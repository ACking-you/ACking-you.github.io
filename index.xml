<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>L_B__</title>
        <link>https://acking-you.gitee.io/</link>
        <description>专注记笔记</description>
        <generator>Hugo -- gohugo.io</generator><language>zh-CN</language><lastBuildDate>Sat, 05 Mar 2022 00:00:00 &#43;0000</lastBuildDate>
            <atom:link href="https://acking-you.gitee.io/index.xml" rel="self" type="application/rss+xml" />
        <item>
    <title>宏和模板的对比——预编译和编译的较量</title>
    <link>https://acking-you.gitee.io/posts/%E5%AE%8F%E5%92%8C%E6%A8%A1%E6%9D%BF%E7%9A%84%E5%AF%B9%E6%AF%94%E9%A2%84%E7%BC%96%E8%AF%91%E5%92%8C%E7%BC%96%E8%AF%91%E7%9A%84%E8%BE%83%E9%87%8F/</link>
    <pubDate>Sat, 05 Mar 2022 00:00:00 &#43;0000</pubDate><guid>https://acking-you.gitee.io/posts/%E5%AE%8F%E5%92%8C%E6%A8%A1%E6%9D%BF%E7%9A%84%E5%AF%B9%E6%AF%94%E9%A2%84%E7%BC%96%E8%AF%91%E5%92%8C%E7%BC%96%E8%AF%91%E7%9A%84%E8%BE%83%E9%87%8F/</guid>
    <description><![CDATA[<div class="featured-image">
                <img src="https://img-blog.csdnimg.cn/img_convert/f58e3cdfd042ae0db6a192022d83a1ac.png#pic_center" referrerpolicy="no-referrer">
            </div>本文默认你已经拥有基本的gcc编译选项知识，如果没有，可以看看这篇文章 程序的编译过程gcc版。 从预编译的角度对比宏定义和模板 来测测宏定义 大家]]></description>
</item>
<item>
    <title>1.1-创建线程(thread)、线程的汇聚(join)、线程的分离(detach)</title>
    <link>https://acking-you.gitee.io/posts/1.1-%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8Bthread%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%B1%87%E8%81%9Ajoin%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%88%86%E7%A6%BBdetach/</link>
    <pubDate>Wed, 02 Mar 2022 00:00:00 &#43;0000</pubDate><guid>https://acking-you.gitee.io/posts/1.1-%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8Bthread%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%B1%87%E8%81%9Ajoin%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%88%86%E7%A6%BBdetach/</guid>
    <description><![CDATA[<div class="featured-image">
                <img src="https://w.wallhaven.cc/full/3z/wallhaven-3z7ded.jpg" referrerpolicy="no-referrer">
            </div>创建线程(thread)分析程序报错原因 头文件：include&lt;thread&gt; 理解线程的创建运行过程 你可以试着运行下面这段代码，]]></description>
</item>
<item>
    <title>1.2-线程安全的保证——互斥量mutex(锁)和原子变量atomic</title>
    <link>https://acking-you.gitee.io/posts/1.2-%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E4%BF%9D%E8%AF%81%E4%BA%92%E6%96%A5%E9%87%8F%E9%94%81%E5%92%8C%E5%8E%9F%E5%AD%90%E5%8F%98%E9%87%8F/</link>
    <pubDate>Wed, 02 Mar 2022 00:00:00 &#43;0000</pubDate><guid>https://acking-you.gitee.io/posts/1.2-%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E4%BF%9D%E8%AF%81%E4%BA%92%E6%96%A5%E9%87%8F%E9%94%81%E5%92%8C%E5%8E%9F%E5%AD%90%E5%8F%98%E9%87%8F/</guid>
    <description><![CDATA[<div class="featured-image">
                <img src="https://img-blog.csdnimg.cn/img_convert/f58e3cdfd042ae0db6a192022d83a1ac.png#pic_center" referrerpolicy="no-referrer">
            </div>资源竞争引发的线程安全问题 有如下的代码： #include&lt;thread&gt;#include&lt;iostream&gt;int globalVariable = 0; void task(){ for (int i = 0; i &lt; 1000000; ++i) { ++globalVariable; } } int main(){ std::thread th1(task); std::thread th2(task); th1.join(); th2.join(); std::cout&lt;&lt;globalVariable; } 我们开了两个线程，一共执行了两次 task ，按理来]]></description>
</item>
<item>
    <title>增量元素之间的最大差值——前缀dp</title>
    <link>https://acking-you.gitee.io/posts/%E5%A2%9E%E9%87%8F%E5%85%83%E7%B4%A0%E4%B9%8B%E9%97%B4%E7%9A%84%E6%9C%80%E5%A4%A7%E5%B7%AE%E5%80%BC%E5%89%8D%E7%BC%80dp/</link>
    <pubDate>Sat, 26 Feb 2022 00:00:00 &#43;0000</pubDate><guid>https://acking-you.gitee.io/posts/%E5%A2%9E%E9%87%8F%E5%85%83%E7%B4%A0%E4%B9%8B%E9%97%B4%E7%9A%84%E6%9C%80%E5%A4%A7%E5%B7%AE%E5%80%BC%E5%89%8D%E7%BC%80dp/</guid>
    <description><![CDATA[<div class="featured-image">
                <img src="https://img-blog.csdnimg.cn/img_convert/daefa95e021376b822b5938e65b8252b.png#pic_center" referrerpolicy="no-referrer">
            </div>题目 题目链接 题目解析 法一：暴力枚举 此题由于是简单题，所以直接可以暴力枚举。暴力枚举的时候我们也可以考虑优化一下，比如外层枚举 $nums[i]$ 的时候，内层直]]></description>
</item>
<item>
    <title>bitset与埃氏筛</title>
    <link>https://acking-you.gitee.io/posts/bitset%E4%B8%8E%E5%9F%83%E6%B0%8F%E7%AD%9B/</link>
    <pubDate>Tue, 22 Feb 2022 00:00:00 &#43;0000</pubDate><guid>https://acking-you.gitee.io/posts/bitset%E4%B8%8E%E5%9F%83%E6%B0%8F%E7%AD%9B/</guid>
    <description><![CDATA[<div class="featured-image">
                <img src="https://img-blog.csdnimg.cn/img_convert/2319540b52ba53f88ff0afbf5cabb92c.png#pic_center" referrerpolicy="no-referrer">
            </div>bitset 介绍 std::bitset 是标准库中的一个存储 0/1 的大小不可变容器。严格来讲，它并不属于 STL。 bitset 并不属于 STL，而是一种标准库中的 &ldquo;Special Container&rdq]]></description>
</item>
<item>
    <title>k站中转内最便宜的航班--BellmanFord算法和SPFA算法的改造</title>
    <link>https://acking-you.gitee.io/posts/k%E7%AB%99%E4%B8%AD%E8%BD%AC%E5%86%85%E6%9C%80%E4%BE%BF%E5%AE%9C%E7%9A%84%E8%88%AA%E7%8F%AD-bellmanford%E7%AE%97%E6%B3%95%E5%92%8Cspfa%E7%AE%97%E6%B3%95%E7%9A%84%E6%94%B9%E9%80%A0/</link>
    <pubDate>Tue, 22 Feb 2022 00:00:00 &#43;0000</pubDate><guid>https://acking-you.gitee.io/posts/k%E7%AB%99%E4%B8%AD%E8%BD%AC%E5%86%85%E6%9C%80%E4%BE%BF%E5%AE%9C%E7%9A%84%E8%88%AA%E7%8F%AD-bellmanford%E7%AE%97%E6%B3%95%E5%92%8Cspfa%E7%AE%97%E6%B3%95%E7%9A%84%E6%94%B9%E9%80%A0/</guid>
    <description><![CDATA[<div class="featured-image">
                <img src="https://img-blog.csdnimg.cn/img_convert/18d027e6aa9fbe6cb650bbfce5b1ce53.png#pic_center" referrerpolicy="no-referrer">
            </div>题目 oj平台 BellmanFord算法的动态规划解决(效率一般) 看到k站内，肯定会想到 BellmanFord 算法的动态规划解法，本来优化成按边遍历的动态规划可以]]></description>
</item>
<item>
    <title>TCP协议详解</title>
    <link>https://acking-you.gitee.io/posts/tcp%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/</link>
    <pubDate>Mon, 21 Feb 2022 00:00:00 &#43;0000</pubDate><guid>https://acking-you.gitee.io/posts/tcp%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/</guid>
    <description><![CDATA[<div class="featured-image">
                <img src="https://img-blog.csdnimg.cn/img_convert/2729ae8b8d3a403affb81167fb3b1604.png#pic_center" referrerpolicy="no-referrer">
            </div>本文章为《Linux高性能服务器编程》第四章的笔记，该书描述该章的各种内容的时候，几乎都使用了实践的工具来抓包验证并解释的方式来铺开知识点。]]></description>
</item>
<item>
    <title>1bit与2bit字符——简单模拟题</title>
    <link>https://acking-you.gitee.io/posts/1bit%E4%B8%8E2bit%E5%AD%97%E7%AC%A6%E7%AE%80%E5%8D%95%E6%A8%A1%E6%8B%9F%E9%A2%98/</link>
    <pubDate>Sun, 20 Feb 2022 00:00:00 &#43;0000</pubDate><guid>https://acking-you.gitee.io/posts/1bit%E4%B8%8E2bit%E5%AD%97%E7%AC%A6%E7%AE%80%E5%8D%95%E6%A8%A1%E6%8B%9F%E9%A2%98/</guid>
    <description><![CDATA[<div class="featured-image">
                <img src="https://img-blog.csdnimg.cn/img_convert/2729ae8b8d3a403affb81167fb3b1604.png#pic_center" referrerpolicy="no-referrer">
            </div>题目 题目链接 题目详解 读懂题： 此题是为了让最后以一个字符解码，也就是 $0$ ，而含 $1$ 的只能是两个字符进行解码，所以遇到 $1$ 就必须确保后面有 $0$ 或 $1$ 来用于]]></description>
</item>
<item>
    <title>Java动态代理详解</title>
    <link>https://acking-you.gitee.io/posts/java%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E8%AF%A6%E8%A7%A3/</link>
    <pubDate>Sun, 20 Feb 2022 00:00:00 &#43;0000</pubDate><guid>https://acking-you.gitee.io/posts/java%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E8%AF%A6%E8%A7%A3/</guid>
    <description><![CDATA[<div class="featured-image">
                <img src="https://img-blog.csdnimg.cn/img_convert/acea126d07748d6630f37b1b481e5d73.png#pic_center" referrerpolicy="no-referrer">
            </div>在介绍动态代理之前，必须先来聊聊静态代理。 静态代理介绍 假设现在项目经理有一个需求：在项目现有所有类的方法前后打印日志。 你如何在不修改已有代码]]></description>
</item>
<item>
    <title>PAT甲级--Insertion-or-Heap-Sort</title>
    <link>https://acking-you.gitee.io/posts/pat%E7%94%B2%E7%BA%A7-insertion-or-heap-sort/</link>
    <pubDate>Sat, 19 Feb 2022 00:00:00 &#43;0000</pubDate><guid>https://acking-you.gitee.io/posts/pat%E7%94%B2%E7%BA%A7-insertion-or-heap-sort/</guid>
    <description><![CDATA[<div class="featured-image">
                <img src="https://img-blog.csdnimg.cn/d42c44f8494c4416af716bc7156a4c96.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAQ19ZQ0JYIFB5X1lZRFM=,size_20,color_FFFFFF,t_70,g_se,x_16" referrerpolicy="no-referrer">
            </div>题目 OJ平台 题目大意 有很多题目实际不需要看懂题目，只需要看懂输入和输出，比如这题。 此题虽然题目较为学术，且比较长，实际总结下来就是，通过给你]]></description>
</item>
</channel>
</rss>
