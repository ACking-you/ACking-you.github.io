[{"categories":["C++实战"],"content":"”简单学习下基本的类封装“","date":"2022-01-22","objectID":"/posts/%E5%A4%A7%E6%95%B4%E6%95%B0%E5%8A%A0%E5%87%8F/","tags":["C++类的封装"],"title":"大数加减类的实现(C++实现)✨","uri":"/posts/%E5%A4%A7%E6%95%B4%E6%95%B0%E5%8A%A0%E5%87%8F/"},{"categories":["C++实战"],"content":"为什么需要大数加减类？ 对于计算机而言，基本的数据类型一般最多为64位数据表示范围，这个范围是有限的，没法无限的表示所有的数据，那么有没有一种方式能够表示所有的大数，并完成加减乘除呢？ 答案肯定是有的，由于数据都是由一位一位的数字所组成，我们只需要用数组中的每一位表示一位数字，便可完成对大数的模拟了。 那么我们说明时候需要用到大数模拟呢？对竞赛人而言，有很多题目实际上就是高精度大数模拟类型，而对于普通的程序员而言，大数模拟也仅是在做某个逻辑运算而保证不会溢出的最佳策略，那么大家难道不好奇如何实现一个大数模拟类吗？ 现在就从封装一个简单的加减类开始了解这样一个大数模拟是怎么实现的👀 ","date":"2022-01-22","objectID":"/posts/%E5%A4%A7%E6%95%B4%E6%95%B0%E5%8A%A0%E5%87%8F/:1:0","tags":["C++类的封装"],"title":"大数加减类的实现(C++实现)✨","uri":"/posts/%E5%A4%A7%E6%95%B4%E6%95%B0%E5%8A%A0%E5%87%8F/"},{"categories":["C++实战"],"content":"大数加减类实现详解 ","date":"2022-01-22","objectID":"/posts/%E5%A4%A7%E6%95%B4%E6%95%B0%E5%8A%A0%E5%87%8F/:2:0","tags":["C++类的封装"],"title":"大数加减类的实现(C++实现)✨","uri":"/posts/%E5%A4%A7%E6%95%B4%E6%95%B0%E5%8A%A0%E5%87%8F/"},{"categories":["C++实战"],"content":"一、流程图总览 如图总体来说分为五部分： 静态成员函数：属于类的公共接口(核心) 构造和析构函数：构造对象以及析构对象 成员数据：用于运算的数据以及表示对象的数据 运算符重载：用于自定义运算方式(核心) 内部成员函数：属于对象的公共接口 ","date":"2022-01-22","objectID":"/posts/%E5%A4%A7%E6%95%B4%E6%95%B0%E5%8A%A0%E5%87%8F/:2:1","tags":["C++类的封装"],"title":"大数加减类的实现(C++实现)✨","uri":"/posts/%E5%A4%A7%E6%95%B4%E6%95%B0%E5%8A%A0%E5%87%8F/"},{"categories":["C++实战"],"content":"二、成员数据和构造函数详解 成员数据 bool f; //是否是负数的标记 char *nums; //存储非符号的大数各个位 int length; //nums的数据长度 int capacity; //nums的可用容量 构造和析构 //缺省构造函数 BigInteger() : length(0), capacity(1), f(false) { nums = new char[capacity]; } //用于转化普通字符串的构造函数 BigInteger(const char *n) : length(strlen(n)), f(false) { int start = 0; if (n[0] == '-') { f = true; start++; } while (start\u003clength\u0026\u0026n[start] == '0')start++; capacity = length * 10; nums = new char[capacity]; std::copy(n + start, n + length, nums); length = length - start; } //拷贝构造函数 BigInteger(BigInteger \u0026a) { capacity = a.capacity; length = a.length; f = a.f; nums = new char[capacity]; std::copy(a.nums, a.nums + length, nums); } //移动构造函数：这里调用了等于号，根据a的类型来决定用哪个等于号 BigInteger(BigInteger \u0026\u0026a) :length(0){ *this = a; } //析构函数 ~BigInteger() { delete[] nums; } ","date":"2022-01-22","objectID":"/posts/%E5%A4%A7%E6%95%B4%E6%95%B0%E5%8A%A0%E5%87%8F/:2:2","tags":["C++类的封装"],"title":"大数加减类的实现(C++实现)✨","uri":"/posts/%E5%A4%A7%E6%95%B4%E6%95%B0%E5%8A%A0%E5%87%8F/"},{"categories":["C++实战"],"content":"三、(算法核心)静态成员函数和运算符重载详解 static Swap() //调用std的swap实现对基本数据的交换 static void Swap(BigInteger \u0026a, BigInteger \u0026b) { std::swap(a.length, b.length); std::swap(a.capacity, b.capacity); std::swap(a.f, b.f); std::swap(a.nums, b.nums); } static compare() //不看符号比较nums的大小：表示a是否比b大 static bool compare(const BigInteger \u0026a,const BigInteger \u0026b) { //比较纯nums大小(不看符号 int n1 = a.length; int n2 = b.length; if (n1 != n2)return n1 \u003e n2; //返回a和b哪个大，true则位a大 int i = 0; while (i \u003c n1 \u0026\u0026 a.nums[i] == b.nums[i])i++; //a b一样长的情况下，比较两个的值 if (i == n1) return false; return a.nums[i] \u003e b.nums[i]; } static isEqual() //表示a和b是否相等 bool isEqual(BigInteger \u0026a, BigInteger \u0026b) { if (a.f != b.f || (a.length != b.length))return false; int i = 0; while (i \u003c a.length \u0026\u0026 a.nums[i] == b.nums[i])i++; return i == a.length \u0026\u0026 a.f == b.f; } (*核心算法)static add() 不看符号的加法，符号这方面由重载加法运算符控制。 static BigInteger add(BigInteger \u0026a, BigInteger \u0026b) { //不看符号的加法 a.reverse();//尾端对齐 b.reverse(); BigInteger t; int up = 0; int len = a.length \u003e b.length ? a.length : b.length; for (int i = 0; i \u003c len; i++) { int ta = i \u003c a.length ? a[i] - '0' : 0; int tb = i \u003c b.length ? b[i] - '0' : 0; int base = ta + tb + up; t.push_back(base % 10 + '0'); up = base / 10; } if (up) t.push_back(up + '0'); t.reverse();//返回原位 a.reverse(); b.reverse(); return t; } (*核心算法)static minus() 不看符号的减法,默认了a的nums大小(不看符号)是比b大的。 static BigInteger minus(BigInteger \u0026a, BigInteger \u0026b) { a.reverse(); b.reverse(); BigInteger t; int len = a.length \u003e b.length ? a.length : b.length; for (int i = 0; i \u003c len; i++) { int ta = i \u003c a.length ? a[i] - '0' : 0; int tb = i \u003c b.length ? b[i] - '0' : 0; int base = ta - tb; if (base \u003c 0) { base += 10; a[i + 1]--; } t.push_back(base + '0'); } t.reverse(); a.reverse(); b.reverse(); return t; } char \u0026operator[] char \u0026operator[](int i) { return nums[i]; } BigInteger \u0026operator= 用了两个版本–右值引用和左值引用版本 右值引用延长寿命，用交换的方式实现(毕竟是将亡值 BigInteger \u0026operator=(BigInteger\u0026\u0026 a) { //Swap\u0026Copy方式实现右值赋值重载 Swap(*this, a); return *this; } 左值引用深拷贝 BigInteger \u0026operator=(const BigInteger \u0026a) {//深拷贝 if (length != 0)//如果不是初始化调用的 = ，则肯定需要先把原来的内存delete掉 delete[]nums; capacity = a.capacity; length = a.length; f = a.f; nums = new char[capacity]; std::copy(a.nums, a.nums + length, nums); return *this; } bool operator\u003c 重载了小于号，好处在于可以直接利用stl进行各种排序操作了。 注意：一定要写成const版本的成员函数，不然STL库无法调用，因为STL库中的所有比较都是基于const对象。 bool operator\u003c(const BigInteger \u0026a) const { if (f \u0026\u0026 !a.f) { //其中一个为负数，则那个是更小的 return true; } else if (!f \u0026\u0026 a.f) return false; if (f) { //两者都为负数的情况，左边的值要更大则为true return compare(*this, a); }//两者均为正数，则值更小的在左边为true return compare(a, *this); } (*核心算法)BigInteger operator+ 利用静态成员函数完成无符号的加减，然后在这里进行判断各种符号情况，根据不同的符号情况进行不同的加法处理。 注意在调用minus之前需要比较两个数的nums谁更大，更大的放在第一个参数上！ BigInteger operator+(BigInteger \u0026a) { BigInteger res; bool flag; if (a.f \u0026\u0026 f) { //同为负数情况，直接相加，再改符号 res = add(*this, a); flag = true; } else if (a.f \u0026\u0026 !f) {//左正右负 if (compare(a, *this)) { //看负数对应的nums是否比正数大 flag = true; res = minus(a, *this); } else { flag = false; res = minus(*this, a); } } else if (!a.f \u0026\u0026 f) { if (compare(*this, a)) { //与上一个相同 flag = true; res = minus(*this, a); } else { flag = false; res = minus(a, *this); } } else { //同时为正数就是最简单的加法 flag = false; res = add(*this, a); } res.f = flag; return res; } (*核心算法)BigInteger operator- 同样是分类讨论，同样是根据不同的类型调用minus和add函数。 与正数不同的处理在于对符号的处理，如果同为负数，则需要判断两者是否相等，防止两数相等相减后减为 0，而被处理为 -0 。 BigInteger operator-(BigInteger \u0026a) { BigInteger res; bool flag; if (a.f \u0026\u0026 f) { //同为负数情况--左边-右边==(不看符号)右边-(不看符号)左边 if (compare(a, *this)) { flag = false; res = minus(a, *this); } else { if (isEqual(*this, a)) flag = false; else flag = true; res = minus(*this, a); } } else if (a.f \u0026\u0026 !f) { //左边为正，右边为负--左边-右边==左边+右边 flag = false; res = add(a, *this); } else if (!a.f \u0026\u0026 f) { //右边为正，左边为负--左边-右边==两边为负的加法 flag = true; res = add(a, *this); } else { //同时为正数--左边-右边==左边-右边(分类讨论正负 if (compare(a, *this)) { //右边\u003e左边,符号为负 res = minus(a, *this); flag = true; } else { //右边\u003c左边，符号为正 res = minus(*this, a); flag = false; } } res.f = flag; return res; } ","date":"2022-01-22","objectID":"/posts/%E5%A4%A7%E6%95%B4%E6%95%B0%E5%8A%A0%E5%87%8F/:2:3","tags":["C++类的封装"],"title":"大数加减类的实现(C++实现)✨","uri":"/posts/%E5%A4%A7%E6%95%B4%E6%95%B0%E5%8A%A0%E5%87%8F/"},{"categories":["C++实战"],"content":"四、其他内部成员函数详解 向外提供的get接口 int getCap() { return capacity; } int getLength() { return length; } bool isNegative() { return f; } bool isEmpty() { return length == 0; } 进行赋值操作所必备的push_back和reverse函数 void push_back(char x) { if (length \u003e= capacity) {//扩容操作 capacity *= 2; char *t = nums; nums = new char[capacity]; std::copy(t, t + length, nums); delete[]t; } nums[length++] = x; } void reverse() {//反转操作 int l = 0, r = length - 1; while (l \u003c r) { std::swap(nums[l], nums[r]); l++; r--; } } 无关紧要的 read() 输入接口 和 print() 输出测试接口 void print() { if (f) printf(\"-\"); nums[length] = '\\0'; int i = 0; while (nums[i] == '0')i++; printf(\"%s\", nums + i); } void read() {//利用getchar()给对象赋上数据 char c = getchar(); if (c == '-') { f = true; c = getchar(); } while (c == '0') c = getchar();//将前导0消耗掉 while (c != '\\n') { push_back(c);//不断的调用push_back即可 c = getchar(); } } ","date":"2022-01-22","objectID":"/posts/%E5%A4%A7%E6%95%B4%E6%95%B0%E5%8A%A0%E5%87%8F/:2:4","tags":["C++类的封装"],"title":"大数加减类的实现(C++实现)✨","uri":"/posts/%E5%A4%A7%E6%95%B4%E6%95%B0%E5%8A%A0%E5%87%8F/"},{"categories":["C++实战"],"content":"整理代码 ","date":"2022-01-22","objectID":"/posts/%E5%A4%A7%E6%95%B4%E6%95%B0%E5%8A%A0%E5%87%8F/:3:0","tags":["C++类的封装"],"title":"大数加减类的实现(C++实现)✨","uri":"/posts/%E5%A4%A7%E6%95%B4%E6%95%B0%E5%8A%A0%E5%87%8F/"},{"categories":["C++实战"],"content":".h声明文件 如果在声明类的同时进行定义，则内部的成员函数默认就是内联的。所以我们一般把短小的代码进行内联，以下的实现均是以该规律进行。 // // Created by Alone on 2021/10/7. // #ifndef MY_TINY_STL_BIGINTEGER_H #define MY_TINY_STL_BIGINTEGER_H #include \u003calgorithm\u003e#include \u003ciostream\u003e#include \u003ccstring\u003e class BigInteger { bool f; char *nums; int length; int capacity; public: //构造函数 BigInteger() : length(0), capacity(1), f(false) { //缺省构造函数 nums = new char[capacity]; } BigInteger(const char *n); BigInteger(const BigInteger \u0026a); BigInteger(BigInteger \u0026\u0026a); ~BigInteger() { //析构函数 delete[] nums; } public: //静态函数 static void Swap(BigInteger \u0026a, BigInteger \u0026b); static bool compare(const BigInteger \u0026a, const BigInteger \u0026b); bool isEqual(BigInteger \u0026a, BigInteger \u0026b); static BigInteger add(BigInteger \u0026a, BigInteger \u0026b); static BigInteger minus(BigInteger \u0026a, BigInteger \u0026b); public: //运算符重载 char \u0026operator[](int i) { return nums[i]; } BigInteger \u0026operator=(BigInteger \u0026\u0026a) { //Swap\u0026Copy方式实现右值赋值重载 Swap(*this, a); return *this; } BigInteger \u0026operator=(const BigInteger \u0026a); bool operator\u003c(const BigInteger \u0026a) const; BigInteger operator+(BigInteger \u0026a); BigInteger operator-(BigInteger \u0026a); public: //对象的基本成员函数 int getCap() { return capacity; } int getLength() { return length; } bool isNegative() { return f; } bool isEmpty() { return length == 0; } void reverse(); void push_back(char x); void print(); void read(); }; #endif //MY_TINY_STL_BIGINTEGER_H ","date":"2022-01-22","objectID":"/posts/%E5%A4%A7%E6%95%B4%E6%95%B0%E5%8A%A0%E5%87%8F/:3:1","tags":["C++类的封装"],"title":"大数加减类的实现(C++实现)✨","uri":"/posts/%E5%A4%A7%E6%95%B4%E6%95%B0%E5%8A%A0%E5%87%8F/"},{"categories":["C++实战"],"content":".cpp定义并实现 // // Created by Alone on 2021/10/7. // #include \"BigInteger.h\" //@构造函数实现 BigInteger::BigInteger(const char *n) : length(strlen(n)), f(false) { //用于初始值的构造函数 int start = 0; if (n[0] == '-') { f = true; start++; } while (start \u003c length \u0026\u0026 n[start] == '0')start++; capacity = length * 10; nums = new char[capacity]; std::copy(n + start, n + length, nums); length = length - start; } BigInteger::BigInteger(const BigInteger \u0026a) { //拷贝构造函数 capacity = a.capacity; length = a.length; f = a.f; nums = new char[capacity]; std::copy(a.nums, a.nums + length, nums); } BigInteger::BigInteger(BigInteger \u0026\u0026a) : length(0) { //移动构造函数 *this = a; } //@静态函数实现 void BigInteger::Swap(BigInteger \u0026a, BigInteger \u0026b) { std::swap(a.length, b.length); std::swap(a.capacity, b.capacity); std::swap(a.f, b.f); std::swap(a.nums, b.nums); } bool BigInteger::compare(const BigInteger \u0026a, const BigInteger \u0026b) { int n1 = a.length; int n2 = b.length; if (n1 != n2)return n1 \u003e n2; //返回a和b哪个大，true则位a大 int i = 0; while (i \u003c n1 \u0026\u0026 a.nums[i] == b.nums[i])i++; //a b一样长的情况下，比较两个的值 if (i == n1) return false; return a.nums[i] \u003e b.nums[i]; } bool BigInteger::isEqual(BigInteger \u0026a, BigInteger \u0026b) { if (a.f != b.f || (a.length != b.length))return false; int i = 0; while (i \u003c a.length \u0026\u0026 a.nums[i] == b.nums[i])i++; return i == a.length \u0026\u0026 a.f == b.f; } BigInteger BigInteger::add(BigInteger \u0026a, BigInteger \u0026b) { a.reverse();//尾端对齐 b.reverse(); BigInteger t; int up = 0; int len = a.length \u003e b.length ? a.length : b.length; for (int i = 0; i \u003c len; i++) { int ta = i \u003c a.length ? a[i] - '0' : 0; int tb = i \u003c b.length ? b[i] - '0' : 0; int base = ta + tb + up; t.push_back(base % 10 + '0'); up = base / 10; } if (up) t.push_back(up + '0'); t.reverse();//返回原位 a.reverse(); b.reverse(); return t; } BigInteger BigInteger::minus(BigInteger \u0026a, BigInteger \u0026b) { a.reverse(); b.reverse(); BigInteger t; int len = a.length \u003e b.length ? a.length : b.length; for (int i = 0; i \u003c len; i++) { int ta = i \u003c a.length ? a[i] - '0' : 0; int tb = i \u003c b.length ? b[i] - '0' : 0; int base = ta - tb; if (base \u003c 0) { base += 10; a[i + 1]--; } t.push_back(base + '0'); } t.reverse(); a.reverse(); b.reverse(); return t; } //@运算符重载实现 BigInteger \u0026BigInteger::operator=(const BigInteger \u0026a) { if (length != 0)//如果不是初始化调用的 = ，则肯定需要先把原来的内存delete掉 delete[]nums; capacity = a.capacity; length = a.length; f = a.f; nums = new char[capacity]; std::copy(a.nums, a.nums + length, nums); return *this; } BigInteger BigInteger::operator+(BigInteger \u0026a) { BigInteger res; bool flag; if (a.f \u0026\u0026 f) { //同为负数情况，直接相加，再改符号 res = add(*this, a); flag = true; } else if (a.f \u0026\u0026 !f) {//左正右负 if (compare(a, *this)) { //看负数对应的nums是否比正数大 flag = true; res = minus(a, *this); } else { flag = false; res = minus(*this, a); } } else if (!a.f \u0026\u0026 f) { if (compare(*this, a)) { //与上一个相同 flag = true; res = minus(*this, a); } else { flag = false; res = minus(a, *this); } } else { //同时为正数就是最简单的加法 flag = false; res = add(*this, a); } res.f = flag; return res; } BigInteger BigInteger::operator-(BigInteger \u0026a) { BigInteger res; bool flag; if (a.f \u0026\u0026 f) { //同为负数情况--左边-右边==(不看符号)右边-(不看符号)左边 if (compare(a, *this)) { flag = false; res = minus(a, *this); } else { if (isEqual(*this, a)) flag = false; else flag = true; res = minus(*this, a); } } else if (a.f \u0026\u0026 !f) { //左边为正，右边为负--左边-右边==左边+右边 flag = false; res = add(a, *this); } else if (!a.f \u0026\u0026 f) { //右边为正，左边为负--左边-右边==两边为负的加法 flag = true; res = add(a, *this); } else { //同时为正数--左边-右边==左边-右边(分类讨论正负 if (compare(a, *this)) { //右边\u003e左边,符号为负 res = minus(a, *this); flag = true; } else { //右边\u003c左边，符号为正 res = minus(*this, a); flag = false; } } res.f = flag; return res; } bool BigInteger::operator\u003c(const BigInteger \u0026a) const { if (f \u0026\u0026 !a.f) { //其中一个为负数，则那个是更小的 return true; } else if (!f \u0026\u0026 a.f) return false; if (f) { //两者都为负数的情况，左边的值要更大则为true return compare(*this, a); }//两者均为正数，则值更小的在左边为true return compare(a, *this); } //@基本成员函数 void BigInteger::reverse() { int l = 0, r = length - 1; while (l \u003c r) { std::swap(nums[l], nums[r]); l++","date":"2022-01-22","objectID":"/posts/%E5%A4%A7%E6%95%B4%E6%95%B0%E5%8A%A0%E5%87%8F/:3:2","tags":["C++类的封装"],"title":"大数加减类的实现(C++实现)✨","uri":"/posts/%E5%A4%A7%E6%95%B4%E6%95%B0%E5%8A%A0%E5%87%8F/"},{"categories":["C++实战"],"content":"功能测试 ","date":"2022-01-22","objectID":"/posts/%E5%A4%A7%E6%95%B4%E6%95%B0%E5%8A%A0%E5%87%8F/:4:0","tags":["C++类的封装"],"title":"大数加减类的实现(C++实现)✨","uri":"/posts/%E5%A4%A7%E6%95%B4%E6%95%B0%E5%8A%A0%E5%87%8F/"},{"categories":["C++实战"],"content":"一、基本的加减测试 运行的测试代码： 打印输出 python输出 总结 与python输出无异，故通过测试。但碍于测试数据太过少，不是很有说服力，还有后面的解题测试。 ","date":"2022-01-22","objectID":"/posts/%E5%A4%A7%E6%95%B4%E6%95%B0%E5%8A%A0%E5%87%8F/:4:1","tags":["C++类的封装"],"title":"大数加减类的实现(C++实现)✨","uri":"/posts/%E5%A4%A7%E6%95%B4%E6%95%B0%E5%8A%A0%E5%87%8F/"},{"categories":["C++实战"],"content":"二、存储个人输入的数据+排序测试 测试代码(方便测试只输入了10个数据)： 排序输出： ","date":"2022-01-22","objectID":"/posts/%E5%A4%A7%E6%95%B4%E6%95%B0%E5%8A%A0%E5%87%8F/:4:2","tags":["C++类的封装"],"title":"大数加减类的实现(C++实现)✨","uri":"/posts/%E5%A4%A7%E6%95%B4%E6%95%B0%E5%8A%A0%E5%87%8F/"},{"categories":["C++实战"],"content":"三、解题测试 正好最近刷的PAT甲级就涉及到大数的加减hhh！ 题目描述 OJ平台 解题代码 #include \"bits/stdc++.h\" class BigInteger { bool f; char *nums; int length; int capacity; public://构造函数 BigInteger() : length(0), capacity(1), f(false) { //缺省构造函数 nums = new char[capacity]; } BigInteger(const char *n) : length(strlen(n)), f(false) { //用于初始值的构造函数 int start = 0; if (n[0] == '-') { f = true; start++; } while (start \u003c length \u0026\u0026 n[start] == '0')start++; capacity = length * 10; nums = new char[capacity]; std::copy(n + start, n + length, nums); length = length - start; } BigInteger(const BigInteger \u0026a) { //拷贝构造函数 capacity = a.capacity; length = a.length; f = a.f; nums = new char[capacity]; std::copy(a.nums, a.nums + length, nums); } BigInteger(BigInteger \u0026\u0026a) : length(0) { //移动构造函数 *this = a; } ~BigInteger() { //析构函数 delete[] nums; } public://静态成员函数 static void Swap(BigInteger \u0026a, BigInteger \u0026b) { std::swap(a.length, b.length); std::swap(a.capacity, b.capacity); std::swap(a.f, b.f); std::swap(a.nums, b.nums); } static bool compare(const BigInteger \u0026a, const BigInteger \u0026b) { //比较纯nums大小(不看符号 int n1 = a.length; int n2 = b.length; if (n1 != n2)return n1 \u003e n2; //返回a和b哪个大，true则位a大 int i = 0; while (i \u003c n1 \u0026\u0026 a.nums[i] == b.nums[i])i++; //a b一样长的情况下，比较两个的值 if (i == n1) return false; return a.nums[i] \u003e b.nums[i]; } bool isEqual(BigInteger \u0026a, BigInteger \u0026b) { if (a.f != b.f || (a.length != b.length))return false; int i = 0; while (i \u003c a.length \u0026\u0026 a.nums[i] == b.nums[i])i++; return i == a.length \u0026\u0026 a.f == b.f; } static BigInteger add(BigInteger \u0026a, BigInteger \u0026b) { //不看符号的加法 a.reverse();//尾端对齐 b.reverse(); BigInteger t; int up = 0; int len = a.length \u003e b.length ? a.length : b.length; for (int i = 0; i \u003c len; i++) { int ta = i \u003c a.length ? a[i] - '0' : 0; int tb = i \u003c b.length ? b[i] - '0' : 0; int base = ta + tb + up; t.push_back(base % 10 + '0'); up = base / 10; } if (up) t.push_back(up + '0'); t.reverse();//返回原位 a.reverse(); b.reverse(); return t; } static BigInteger minus(BigInteger \u0026a, BigInteger \u0026b) { //不看符号的减法,默认了a的长度或者大小是比b要大的(所以外界不要乱调用 a.reverse(); b.reverse(); BigInteger t; int len = a.length \u003e b.length ? a.length : b.length; for (int i = 0; i \u003c len; i++) { int ta = i \u003c a.length ? a[i] - '0' : 0; int tb = i \u003c b.length ? b[i] - '0' : 0; int base = ta - tb; if (base \u003c 0) { base += 10; a[i + 1]--; } t.push_back(base + '0'); } t.reverse(); a.reverse(); b.reverse(); return t; } public://成员函数和重载运算符 char \u0026operator[](int i) { return nums[i]; } BigInteger \u0026operator=(BigInteger \u0026\u0026a) { //Swap\u0026Copy方式实现右值赋值重载 Swap(*this, a); return *this; } BigInteger \u0026operator=(const BigInteger \u0026a) {//深拷贝 if (length != 0)//如果不是初始化调用的 = ，则肯定需要先把原来的内存delete掉 delete[]nums; capacity = a.capacity; length = a.length; f = a.f; nums = new char[capacity]; std::copy(a.nums, a.nums + length, nums); return *this; } int getCap() { return capacity; } int getLength() { return length; } bool isNegative() { return f; } bool isEmpty() { return length == 0; } void reverse() { int l = 0, r = length - 1; while (l \u003c r) { std::swap(nums[l], nums[r]); l++; r--; } } void push_back(char x) { if (length \u003e= capacity) { capacity *= 2; char *t = nums; nums = new char[capacity]; std::copy(t, t + length, nums); delete[]t; } nums[length++] = x; } bool operator\u003c(const BigInteger \u0026a) const { if (f \u0026\u0026 !a.f) { //其中一个为负数，则那个是更小的 return true; } else if (!f \u0026\u0026 a.f) return false; if (f) { //两者都为负数的情况，左边的值要更大则为true return compare(*this, a); }//两者均为正数，则值更小的在左边为true return compare(a, *this); } BigInteger operator+(BigInteger \u0026a) { BigInteger res; bool flag; if (a.f \u0026\u0026 f) { //同为负数情况，直接相加，再改符号 res = add(*this, a); flag = true; } else if (a.f \u0026\u0026 !f) {//左正右负 if (compare(a, *this)) { //看负数对应的nums是否比正数大 flag = true; res = minus(a, *this); } else { flag = false; res = minus(*this, a); } } else if (!a.f \u0026\u0026 f) { if (compare(*this, a)) { //与上一个相同 flag = true; res = minus(*this, a); } else { flag = false; res = minus(a, *this); } } else { //同时为正数就是最简单的加法 flag = false; res = add(*this, a); } res.f = flag; return res; } BigInteger operator-(BigInteger \u0026a","date":"2022-01-22","objectID":"/posts/%E5%A4%A7%E6%95%B4%E6%95%B0%E5%8A%A0%E5%87%8F/:4:3","tags":["C++类的封装"],"title":"大数加减类的实现(C++实现)✨","uri":"/posts/%E5%A4%A7%E6%95%B4%E6%95%B0%E5%8A%A0%E5%87%8F/"},{"categories":["C++实战"],"content":"总结 很多人，可能觉得做项目一定得是那种高大上，又或者是那种贪吃蛇小游戏、扫雷小游戏类型，实际上只要你有兴趣，任何一个东西都能成为你的练手项目，并且收获收获也许比你跟风去弄几个小游戏更大。 做这个小项目，我的收获是，对C++的语法更加的了解了，关于移动构造器、拷贝构造器、赋值重载这块弄得更清楚了，最大的收获在于强化了一个类的设计思路，这个是最重要的。 多写一些类的实现，不仅有利于对算法和语言语法的理解，更大的收获在于对各个功能的设计思路，作为程序员，我们最需要的就是这样的逻辑思维，从接到需求开始，我们应该能迅速的抽象出各种实现方案，然后进行不断的优化，得出属于自己的代码！ ","date":"2022-01-22","objectID":"/posts/%E5%A4%A7%E6%95%B4%E6%95%B0%E5%8A%A0%E5%87%8F/:5:0","tags":["C++类的封装"],"title":"大数加减类的实现(C++实现)✨","uri":"/posts/%E5%A4%A7%E6%95%B4%E6%95%B0%E5%8A%A0%E5%87%8F/"},{"categories":["C++实战"],"content":"”Socket基本操作的C++封装“","date":"2022-01-22","objectID":"/posts/socket%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9Cc++%E5%B0%81%E8%A3%85/","tags":["socket通信"],"title":"Socket基本操作的C++封装","uri":"/posts/socket%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9Cc++%E5%B0%81%E8%A3%85/"},{"categories":["C++实战"],"content":"封装过程 ","date":"2022-01-22","objectID":"/posts/socket%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9Cc++%E5%B0%81%E8%A3%85/:1:0","tags":["socket通信"],"title":"Socket基本操作的C++封装","uri":"/posts/socket%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9Cc++%E5%B0%81%E8%A3%85/"},{"categories":["C++实战"],"content":"接口类的实现(抽象类) _public_socket.h 该头文件用于包含所有该系统平台socket所需要依赖的库。 windows平台 #ifndef MY_TINY_STL__PUBLIC_SOCKET_H #define MY_TINY_STL__PUBLIC_SOCKET_H #include \u003cwinsock2.h\u003e#pragma comment (lib, \"ws2_32.lib\") //加载 ws2_32.dll #endif //MY_TINY_STL__PUBLIC_SOCKET_H Linux平台 #include \u003cunistd.h\u003e#include \u003carpa/inet.h\u003e#include \u003csys/socket.h\u003e#include \u003cnetinet/in.h\u003eTCP_INTERFACE.h(作用于win平台) 由于该接口由服务器端和客户端继承，而两者同样的函数成员也就是这些了，设计客户端和服务器端时就只需要考虑各自的套接字以及其余操作的成员函数，也不需要管理DLL的开关。 还有一个erro_die()成员函数用于阻断错误并打印对应情况。 // // Created by Alone on 2021/8/17. // #ifndef MY_TINY_STL_TCP_INTERFACE_H #define MY_TINY_STL_TCP_INTERFACE_H #include \u003ccstdio\u003e#include \"_public_socket.h\" class TCP_INTERFACE { public: TCP_INTERFACE() { //初始化 DLL WSADATA wsaData; WSAStartup(MAKEWORD(2, 2), \u0026wsaData); } //返回值小于等于0时发生错误 virtual int Send(SOCKET clnt, const void *buf, const int buflen) = 0; virtual int Recv(SOCKET clnt, void *buf, const int buflen) = 0; //closesocket返回值不为0则发生错误 virtual void Close(SOCKET clnt) = 0; virtual void error_die(const char *str) = 0; ~TCP_INTERFACE() { WSACleanup(); } }; #endif //MY_TINY_STL_TCP_INTERFACE_H ","date":"2022-01-22","objectID":"/posts/socket%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9Cc++%E5%B0%81%E8%A3%85/:1:1","tags":["socket通信"],"title":"Socket基本操作的C++封装","uri":"/posts/socket%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9Cc++%E5%B0%81%E8%A3%85/"},{"categories":["C++实战"],"content":"服务器端封装 这次修改了下逻辑，还是用accept返回一个套接字进行发送和接收操作比较好。类的底层没有再保留用于和某个客户端通信的套接字了，自己控制各个客户端套接字的关闭和使用。 TCP_SOCKET_SERVER.h // // Created by Alone on 2021/8/16. // #ifndef MY_TINY_STL_TCP_SOCKET_SERVER_H #define MY_TINY_STL_TCP_SOCKET_SERVER_H #include \"TCP_INTERFACE.h\" class TCP_SOCKET_SERVER : public TCP_INTERFACE { public: TCP_SOCKET_SERVER(); ~TCP_SOCKET_SERVER(); void Bind(int port); void Listen(); SOCKET Accept(); int Send(SOCKET clnt, const void *buf, const int buflen); int Recv(SOCKET clnt, void *buf, const int buflen); void Close(SOCKET clnt); void error_die(const char *str); private: SOCKET servSock; sockaddr_in sockAddr; }; #endif //MY_TINY_STL_TCP_SOCKET_SERVER_H TCP_SOCKET_SERVER.cpp // // Created by Alone on 2021/8/16. // #include \"TCP_SOCKET_SERVER.h\" //初始化操作 TCP_SOCKET_SERVER::TCP_SOCKET_SERVER() : servSock(0) { memset(\u0026sockAddr, 0, sizeof(sockAddr)); //每个字节都用0填充 } //绑定操作 void TCP_SOCKET_SERVER::Bind(int port) { servSock = socket(PF_INET, SOCK_STREAM, IPPROTO_TCP); sockAddr.sin_family = PF_INET; //使用IPv4地址 sockAddr.sin_addr.s_addr = htonl(INADDR_ANY); //具体的IP地址 sockAddr.sin_port = htons(port); //端口 if (bind(servSock, (SOCKADDR *) \u0026sockAddr, sizeof(SOCKADDR)) != 0) { error_die(\"bind\"); } } //置于监听状态 void TCP_SOCKET_SERVER::Listen() { if (servSock == 0) error_die(\"listen\"); if (listen(servSock, SOMAXCONN) != 0) { error_die(\"listen\"); } } //利用套接字的监听串口，接收客户端的请求，建立新的套接字进行存储信息 SOCKET TCP_SOCKET_SERVER::Accept() { SOCKADDR t; int nSize = sizeof(SOCKADDR); //后面两个参数为可选 SOCKET clnt = accept(servSock, \u0026t, \u0026nSize); if (clnt \u003c= 0)error_die(\"accept\"); return clnt; } //返回的是发送到缓冲区的字节长度 int TCP_SOCKET_SERVER::Send(SOCKET clnt, const void *buf, const int buflen) { return send(clnt, (const char *) buf, buflen, 0); } //返回已经接收的字节长度 int TCP_SOCKET_SERVER::Recv(SOCKET clnt, void *buf, const int buflen) { return recv(clnt, (char *) buf, buflen, 0); } //析构函数关闭socket TCP_SOCKET_SERVER::~TCP_SOCKET_SERVER() { if (servSock != 0)closesocket(servSock); } void TCP_SOCKET_SERVER::Close(SOCKET clnt) { if (closesocket(clnt) != 0) { error_die(\"closesocket\"); } } void TCP_SOCKET_SERVER::error_die(const char *str) { printf(\"[hint]%s failed:%d\", str, WSAGetLastError()); exit(-1); } ","date":"2022-01-22","objectID":"/posts/socket%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9Cc++%E5%B0%81%E8%A3%85/:1:2","tags":["socket通信"],"title":"Socket基本操作的C++封装","uri":"/posts/socket%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9Cc++%E5%B0%81%E8%A3%85/"},{"categories":["C++实战"],"content":"客户端的封装 TCP_SOCKET_CLIENT.h 增加了利用域名查询ip地址的成员函数gethostbyname(),挺好玩的！此次增加了erro_die函数，且发送和接收都操作套接字。在类的内部还是保留了套接字的备份，用于忘记关闭套接字时，析构函数进行关闭。 // // Created by Alone on 2021/8/18. // #ifndef MY_TINY_STL_TCP_SOCKET_CLIENT_H #define MY_TINY_STL_TCP_SOCKET_CLIENT_H #include \"TCP_INTERFACE.h\"#include \u003ciostream\u003e class TCP_SOCKET_CLIENT : public TCP_INTERFACE { public: TCP_SOCKET_CLIENT(); ~TCP_SOCKET_CLIENT(); SOCKET Connect(const char *IPAdrr, u_short port); //用于利用URL(域名)查询IP地址 void Gethostbyname(const char *URL); //接口必须实现的函数 int Send(SOCKET clnt,const void *buf, const int bufSize); int Recv(SOCKET clnt,void *buf, const int bufSize); void Close(SOCKET clnt); void error_die(const char *str); private: //由于一般客户端只需要一个套接字实现连接,然后还需要一个socketadrr_in用于连接内容的赋值 SOCKET clntSock; sockaddr_in sockAddr; }; #endif //MY_TINY_STL_TCP_SOCKET_CLIENT_H TCP_SOCKET_CLIENT.cpp // // Created by Alone on 2021/8/17. // #include \"TCP_SOCKET_CLIENT.h\" //初始化 TCP_SOCKET_CLIENT::TCP_SOCKET_CLIENT() : clntSock(0) {} //关闭套接字操作 void TCP_SOCKET_CLIENT::Close(SOCKET clnt) { if (closesocket(clnt) != 0) error_die(\"close\"); clntSock = 0; } //连接服务器操作 SOCKET TCP_SOCKET_CLIENT::Connect(const char *IPAdrr, u_short port) { memset(\u0026sockAddr, 0, sizeof sockAddr); clntSock = socket(PF_INET, SOCK_STREAM, IPPROTO_TCP); sockAddr.sin_family = PF_INET; sockAddr.sin_addr.s_addr = inet_addr(IPAdrr); sockAddr.sin_port = htons(port); if (connect(clntSock, (SOCKADDR *) \u0026sockAddr, sizeof(sockAddr)) != 0) { error_die(\"connect\"); } return clntSock; } //发送信息操作 int TCP_SOCKET_CLIENT::Send(SOCKET clnt,const void *buf, const int bufSize) { return send(clnt, (const char *) buf, bufSize, 0); } //接收信息操作 int TCP_SOCKET_CLIENT::Recv(SOCKET clnt,void *buf, const int bufSize) { return recv(clnt, (char *) buf, bufSize, 0); } //根据域名获取ip地址等信息 void TCP_SOCKET_CLIENT::Gethostbyname(const char *URL) { hostent *host = gethostbyname(URL); if (!host) { std::cout \u003c\u003c \"Get IP address error!\\n\"; return; } //打印本命 std::cout \u003c\u003c URL \u003c\u003c std::endl; //别名 for (int i = 0; host-\u003eh_aliases[i]; i++) { printf(\"Aliases %d: %s\\n\", i + 1, host-\u003eh_aliases[i]); } //地址类型 printf(\"Address type: %s\\n\", (host-\u003eh_addrtype == AF_INET) ? \"AF_INET\" : \"AF_INET6\"); //IP地址,其中inet_ntoa()函数是将网络字节序转为本地的字节序，方便打印看懂 for (int i = 0; host-\u003eh_addr_list[i]; i++) { printf(\"IP addr %d: %s\\n\", i + 1, inet_ntoa(*(struct in_addr *) host-\u003eh_addr_list[i])); } } //析构时需要确保所有东西已经关闭 TCP_SOCKET_CLIENT::~TCP_SOCKET_CLIENT() { if (clntSock != 0) closesocket(clntSock); } void TCP_SOCKET_CLIENT::error_die(const char *str) { printf(\"[hint]%s failed:%d\", str, WSAGetLastError()); exit(-1); } ","date":"2022-01-22","objectID":"/posts/socket%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9Cc++%E5%B0%81%E8%A3%85/:1:3","tags":["socket通信"],"title":"Socket基本操作的C++封装","uri":"/posts/socket%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9Cc++%E5%B0%81%E8%A3%85/"},{"categories":["C++实战"],"content":"实例讲解 ","date":"2022-01-22","objectID":"/posts/socket%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9Cc++%E5%B0%81%E8%A3%85/:2:0","tags":["socket通信"],"title":"Socket基本操作的C++封装","uri":"/posts/socket%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9Cc++%E5%B0%81%E8%A3%85/"},{"categories":["C++实战"],"content":"实例一：回声程序通信 服务器回声程序 绑定本地1234端口，进入监听状态等待请求，如果通信对象关闭了通信，也不慌，重新goto到等待请求得到新的通信套接字 #include \u003ciostream\u003e#include \"TCP_SOCKET_SERVER.h\" #define BUF_SIZE 1000 using namespace std; int main() { TCP_SOCKET_SERVER a; a.Bind(1234); a.Listen(); restart: SOCKET clnt = a.Accept(); while (1) { char *x = new char[BUF_SIZE]; memset(x, 0, BUF_SIZE); int size = a.Recv(clnt,x, BUF_SIZE); if (size \u003c= 0) break; if (a.Send(clnt,x, size) \u003c= 0) break; } a.Close(clnt); cout \u003c\u003c \"connect is over.Waiting for a new connection!\\n\"; goto restart; } 客户端通信程序 为保持持续通信，一旦客户端拒绝了请求，那么弹出循环重新连接，并设置连接超时操作。 #include \"TCP_SOCKET_CLIENT.h\"#define BUF_SIZE 100 int main(){ TCP_SOCKET_CLIENT t; const char* to = \"127.0.0.1\"; restart: SOCKET clnt = t.Connect(to,1234); while(1){ std::cout\u003c\u003c\"\\nInput your message:\\n\"; char buf[BUF_SIZE] = {0}; std::cin.getline(buf,99); int size = t.Send(clnt,buf,BUF_SIZE); if(size\u003c=0) break; memset(buf,0,sizeof buf); if(t.Recv(clnt,buf,size)\u003c=0) break; printf(\"received from %s is:\\n\",to); std::cout\u003c\u003cbuf; } t.Close(clnt); std::cout\u003c\u003c\"The Server is disconnected,and socket has been cleaned up,socket connection has been re-established\\n\"; goto restart; return 0; } 回声效果 客户端收到的结果 服务器端一直运行着，只要不关闭，但每次只能和一个客户端进行通信，通信完后重新等待连接。 ","date":"2022-01-22","objectID":"/posts/socket%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9Cc++%E5%B0%81%E8%A3%85/:2:1","tags":["socket通信"],"title":"Socket基本操作的C++封装","uri":"/posts/socket%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9Cc++%E5%B0%81%E8%A3%85/"},{"categories":["C++实战"],"content":"实例二：文件操作，传送图片(掌握重复传包) 分析待传图片 看看这百万大小的字节，一次肯定是传不完的，所以我们需要发送端不断的续传，直到传送完毕。 发送端程序 #include \"TCP_SOCKET_CLIENT.h\"#include \u003cfstream\u003eint main(){ TCP_SOCKET_CLIENT t; const char* to = \"127.0.0.1\"; restart: SOCKET clnt = t.Connect(to,1234); //图片写入buf(这几百万字节大小，得亏是new动态分配 std::ifstream img(\"D:/DesktopBackground/L-69.png\",std::ios::in|std::ios::binary); //设置文件指针用于求文件内容长度 img.seekg(0,std::ios::end); int len = img.tellg(); img.seekg(0,std::ios::beg); if(len\u003e0){printf(\"read OK\\n\");} else {printf(\"file is empty!\");return 0;} //填补buf char * buf = new char[len]; img.read(buf,len); //发送数据到服务器,一次肯定发送不完，所以多次 int sum = 0; while(sum\u003clen){ int sendlen = t.Send(clnt,buf,len); if(sendlen\u003c=0){ printf(\"Send Erro!\"); return 0; } sum += sendlen; } t.Close(clnt); printf(\"Send OK!\"); return 0; } 接收端程序 #include \u003ciostream\u003e#include \"TCP_SOCKET_SERVER.h\"#include \u003cfstream\u003e#define BUF_SIZE 100 using namespace std; int main() { TCP_SOCKET_SERVER a; a.Bind(1234); a.Listen(); //等待连接，连接成功便可建立通讯 SOCKET clnt = a.Accept(); //创建文件用于写入图片数据 ofstream t(\"test.png\",ios::binary|ios::out); //由于要接收的图片文件较大，需要分多次包进行传输数据，所以需要不断循环接收 while(1){ char buf[BUF_SIZE]; int sz = a.Recv(clnt,buf,BUF_SIZE); //直到发送端发送数据完毕断开连接后，便可判断为接收完毕 if(sz\u003c=0){ cout\u003c\u003c\"Finish !\"; return 0; } //每次调整文件指针位置到最后续写 t.seekp(0,ios::end); t.write(buf,sz); } a.Close(clnt); } 接收结果 一模一样毫无偏差 ","date":"2022-01-22","objectID":"/posts/socket%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9Cc++%E5%B0%81%E8%A3%85/:2:2","tags":["socket通信"],"title":"Socket基本操作的C++封装","uri":"/posts/socket%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9Cc++%E5%B0%81%E8%A3%85/"},{"categories":["C++实战"],"content":"实例三：Web通信(浏览器访问服务器) ","date":"2022-01-22","objectID":"/posts/socket%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9Cc++%E5%B0%81%E8%A3%85/:3:0","tags":["socket通信"],"title":"Socket基本操作的C++封装","uri":"/posts/socket%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9Cc++%E5%B0%81%E8%A3%85/"},{"categories":["C++实战"],"content":"Web服务器程序 我这个web服务器也算是及其简单了。。并没有对客户端的http请求进行解析然后发送对应的文件给客户端，而是单纯的我客户端想怎么发就怎么发。。另外这个程序虽然是对图片进行了判断，但并未写出对应的图片发送程序(二进制文件读写是不一样的)，所以实际只能发送文本文件，如html代码。所以后面看到的课程表都无法显示图片的原因是客户端程序压根就没在乎过客户端的请求🤣 #include \u003ciostream\u003e#include \u003cfstream\u003e#include \"TCP_SOCKET_SERVER.h\" void sendfileToWeb(SOCKET clnt, TCP_SOCKET_SERVER \u0026a, const char *filename); int main() { TCP_SOCKET_SERVER a; a.Bind(8086); a.Listen(); SOCKET clnt = a.Accept(); while (1) { sendfileToWeb(clnt, a, \"D:/Html/schedule/schedule.html\"); a.Close(clnt); clnt = a.Accept(); } } //反馈请求，发送文件代码或者图片等二进制信息。 void sendfileToWeb(SOCKET clnt, TCP_SOCKET_SERVER \u0026a, const char *filename) { //写入返回头信息：包括状态和内容类型 char *type = nullptr; if (strstr(filename, \".html\")) type = \"text/html\"; else if (strstr(filename, \".jpg\")) type = \"image/jpg\"; else if (strstr(filename, \".png\")) type = \"image/png\"; char x[100] = {0}; sprintf(x, \"HTTP/1.1 200 ok\\r\\nContent-Type: %s\\r\\n\\r\\n\", type); //发送返回头信息,每次发送间隔需要一定时间，否则浏览器可能接收没这么快 int sz1 = a.Send(clnt, x, strlen(x)); if (sz1 \u003c= 0)return; //发送文件内容到客户端 std::ifstream ss(filename, std::ios::in); char html[1024] = {0}; while (ss.getline(html, 1024)) { int szz = a.Send(clnt, html, strlen(html)); if (szz \u003c= 0) return; Sleep(1); } ss.close(); } ","date":"2022-01-22","objectID":"/posts/socket%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9Cc++%E5%B0%81%E8%A3%85/:3:1","tags":["socket通信"],"title":"Socket基本操作的C++封装","uri":"/posts/socket%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9Cc++%E5%B0%81%E8%A3%85/"},{"categories":["C++实战"],"content":"接收结果 ","date":"2022-01-22","objectID":"/posts/socket%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9Cc++%E5%B0%81%E8%A3%85/:3:2","tags":["socket通信"],"title":"Socket基本操作的C++封装","uri":"/posts/socket%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9Cc++%E5%B0%81%E8%A3%85/"},{"categories":["C++实战"],"content":"总结 收获： 了解到网络通讯过程到底是怎么样的。 了解到底层socket通信是如何进行的。 封装了socket操作，增强了代码的复用性。 对基本的http请求过程有所了解： 基本上就是浏览器(客户端)对相应的IP地址发起请求，其对应的服务器返回给你这个网页的主页，然后根据你鼠标的点击，又会触发http请求，其对应的服务器对你的请求进行解析，得出你想要的文件，然后发送给你，循环往复一直如此。。。 ","date":"2022-01-22","objectID":"/posts/socket%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9Cc++%E5%B0%81%E8%A3%85/:4:0","tags":["socket通信"],"title":"Socket基本操作的C++封装","uri":"/posts/socket%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9Cc++%E5%B0%81%E8%A3%85/"},{"categories":["C++实战"],"content":"”一起来领略C++模板的奥义“","date":"2022-01-20","objectID":"/posts/c++%E7%9A%84%E6%A8%A1%E6%9D%BF%E5%86%99println/","tags":["C++模板"],"title":"C++变参模板运用实战——实现PrintLn","uri":"/posts/c++%E7%9A%84%E6%A8%A1%E6%9D%BF%E5%86%99println/"},{"categories":["C++实战"],"content":"想要实现PrintLn，关键在于支持无限个参数的打印函数，所以我大致总结下C++能够如何去实现它！ ","date":"2022-01-20","objectID":"/posts/c++%E7%9A%84%E6%A8%A1%E6%9D%BF%E5%86%99println/:0:0","tags":["C++模板"],"title":"C++变参模板运用实战——实现PrintLn","uri":"/posts/c++%E7%9A%84%E6%A8%A1%E6%9D%BF%E5%86%99println/"},{"categories":["C++实战"],"content":"方式一：用初始化列表实现PrintLn() 【C++11】 ","date":"2022-01-20","objectID":"/posts/c++%E7%9A%84%E6%A8%A1%E6%9D%BF%E5%86%99println/:1:0","tags":["C++模板"],"title":"C++变参模板运用实战——实现PrintLn","uri":"/posts/c++%E7%9A%84%E6%A8%A1%E6%9D%BF%E5%86%99println/"},{"categories":["C++实战"],"content":"版本一：朴素初始化列表版本版本 函数版本： #include\u003ciostream\u003eusing namespace std; void PrintLn(std::initializer_list\u003cint\u003e args){ for(auto arg:args){ cout\u003c\u003carg\u003c\u003c\", \"; } cout\u003c\u003cstd::endl; } int main() { PrintLn({3,23,2,12}); return 0; } 类的构造器版本(可去掉小括号)： #include\u003ciostream\u003eusing namespace std; class PrintLn { public: PrintLn(std::initializer_list\u003cint\u003e args) { for (auto arg:args) { cout \u003c\u003c arg \u003c\u003c \", \"; } cout \u003c\u003c std::endl; } }; int main() { auto t = PrintLn{3, 23, 2, 12}; return 0; } ","date":"2022-01-20","objectID":"/posts/c++%E7%9A%84%E6%A8%A1%E6%9D%BF%E5%86%99println/:1:1","tags":["C++模板"],"title":"C++变参模板运用实战——实现PrintLn","uri":"/posts/c++%E7%9A%84%E6%A8%A1%E6%9D%BF%E5%86%99println/"},{"categories":["C++实战"],"content":"版本二：加模板参数版本 实际上和上面的基本没太大区别，除了上面确定为了int类型，二加了模板后，可以为任意类型，但是实际上传入的还是只能是同一个类型。所以初始化列表实现是非常的不好用的。 #incldue\u003ciostream\u003e using namespace std; template\u003ctypename T\u003e class PrintLn { public: PrintLn(std::initializer_list\u003cT\u003e args) { for (auto arg:args) { cout \u003c\u003c arg \u003c\u003c \", \"; }# PrintLn函数实现 想要实现PrintLn，关键在于支持无限个参数的打印函数，所以我大致总结下C++能够如何去实现它！ ## 方式一：用初始化列表实现PrintLn() 【C++11】 ### 版本一：朴素初始化列表版本版本 \u003e 函数版本： ```cpp #include\u003ciostream\u003eusing namespace std; void PrintLn(std::initializer_list\u003cint\u003e args){ for(auto arg:args){ cout\u003c\u003carg\u003c\u003c\", \"; } cout\u003c\u003cstd::endl; } int main() { PrintLn({3,23,2,12}); return 0; } 类的构造器版本(可去掉小括号)： #include\u003ciostream\u003eusing namespace std; class PrintLn { public: PrintLn(std::initializer_list\u003cint\u003e args) { for (auto arg:args) { cout \u003c\u003c arg \u003c\u003c \", \"; } cout \u003c\u003c std::endl; } }; int main() { auto t = PrintLn{3, 23, 2, 12}; return 0; } ","date":"2022-01-20","objectID":"/posts/c++%E7%9A%84%E6%A8%A1%E6%9D%BF%E5%86%99println/:1:2","tags":["C++模板"],"title":"C++变参模板运用实战——实现PrintLn","uri":"/posts/c++%E7%9A%84%E6%A8%A1%E6%9D%BF%E5%86%99println/"},{"categories":["C++实战"],"content":"版本二：加模板参数版本 实际上和上面的基本没太大区别，除了上面确定为了int类型，而加了模板后，可以为任意类型，但是实际上传入的还是只能是同一个类型。所以初始化列表的方式实现Println只能说形似而神不似。 #incldue\u003ciostream\u003e using namespace std; template\u003ctypename T\u003e class PrintLn { public: PrintLn(std::initializer_list\u003cT\u003e args) { for (auto arg:args) { cout \u003c\u003c arg \u003c\u003c \", \"; } cout \u003c\u003c std::endl; } }; int main() { auto t = PrintLn\u003cint\u003e{3, 23, 2, 12}; return 0; } ","date":"2022-01-20","objectID":"/posts/c++%E7%9A%84%E6%A8%A1%E6%9D%BF%E5%86%99println/:1:3","tags":["C++模板"],"title":"C++变参模板运用实战——实现PrintLn","uri":"/posts/c++%E7%9A%84%E6%A8%A1%E6%9D%BF%E5%86%99println/"},{"categories":["C++实战"],"content":"方式二：用可变参模板实现 【C++11/17】 如果有了解过C的可变参函数和可变参的宏，那么这个可变参模板与它有些类型，只不过C里面的va_start,va_list,va_arg,va_end这一系列实现可变参数的宏用起来非常麻烦，而且无法确定每个参数的类型，而可变参的模板则带有模板的泛型性质，所以是能确定类型的，甚至由于模板可以传值，后面还可直接传值使用。 以下简单描述可变参模板的使用方式： typenam... 算C++的一个新的关键字，它可以用来定义一个可变参的模板类型，而这个类型在其他地方定义使用的时候也要在后面带上 ... 表示拆包，否则会报错。 例如： template\u003ctypename... T\u003e void f(T... t){//TODO 这种类型或变量在任何地方作为参数定义或者传递的时候都需要加上...表示拆包 f(t...) } 在C++17出现fold expression之前，这个拆包过程只能借助另一个模板参数来得到模板参数包里面的内容。 注意以上两点，那么可以开始编写泛型模板，实现可变参数的完全打印过程了。 ","date":"2022-01-20","objectID":"/posts/c++%E7%9A%84%E6%A8%A1%E6%9D%BF%E5%86%99println/:2:0","tags":["C++模板"],"title":"C++变参模板运用实战——实现PrintLn","uri":"/posts/c++%E7%9A%84%E6%A8%A1%E6%9D%BF%E5%86%99println/"},{"categories":["C++实战"],"content":"C++11版本实现 错误实现版本：如果你直接像下面这样进行拆包，那么编译是会报错的，因为拆包过程相当于一个递归的过程，而你这个递归的过程没有一个跳出的条件，比如args如果为0个参数时，继续在往下就无法展开了，所以需要实现一个没有参数的版本让拆包过程停止。 template\u003ctypename T,typename... Args\u003e void PrintLn(T firstArg,Args... args){ cout\u003c\u003cfirstArg\u003c\u003c\", \"; PrintLn(args...); } //拆包过程：PrintLn(3,1,3,4)-\u003e // PrintLn(firstArg:3,args(1,3,4)); // PrintLn(firstArg:1,args(3,4)); // PrintLn(firstArg:3,args(4)); // PrintLn(firstArg:4,args(null)) // 由于到了上面的第四行还要继续往下拆包 // 而此时只有0个参数，没有对应的PrintLn版本可以调用，故报错！ 以下为正确修改版本： #include\u003ciostream\u003eusing namespace std; void PrintLn(){ } template\u003ctypename T,typename... Args\u003e void PrintLn(T firstArg,Args... args){ cout\u003c\u003cfirstArg\u003c\u003c\", \"; PrintLn(args...); } int main() { PrintLn(3, 23, 2, 12); return 0; 当然也可以控制只剩一个参数时就停止拆包。 #include\u003ciostream\u003eusing namespace std; template\u003ctypename T\u003e void PrintLn(T arg){ cout\u003c\u003carg\u003c\u003cendl; } template\u003ctypename T,typename... Args\u003e void PrintLn(T firstArg,Args... args){ cout\u003c\u003cfirstArg\u003c\u003c\", \"; PrintLn(args...); } int main() { PrintLn(3, 23, 2, 12); return 0; } ","date":"2022-01-20","objectID":"/posts/c++%E7%9A%84%E6%A8%A1%E6%9D%BF%E5%86%99println/:2:1","tags":["C++模板"],"title":"C++变参模板运用实战——实现PrintLn","uri":"/posts/c++%E7%9A%84%E6%A8%A1%E6%9D%BF%E5%86%99println/"},{"categories":["C++实战"],"content":"C++17版本实现 上面的实现流程实际上在C++17中可以用 if constexpr()+sizeof… 在编译期间来进行流程控制。 首先来讲一讲为什么普通的 if + sizeof… 来实现可变参数的长度控制流程会报错呢？ 因为整个模板推断和拆包解包过程是在编译期完成的，而if的控制流程在编译期是完全不清楚的，所以会报错，但是有了if constexpr之后，就能控制编译期的模板拆包过程了！ 如上面实现PrintLn，可以直接简化成下面这样： #include\u003ciostream\u003eusing namespace std; template\u003ctypename T,typename... Args\u003e void PrintLn(T firstArg,Args... args){ if constexpr(sizeof...(args)==0){//当参数个数为0个的时候就不继续拆包了 cout\u003c\u003cfirstArg\u003c\u003cendl; }else{ cout\u003c\u003cfirstArg\u003c\u003c\", \"; PrintLn(args...);//往下继续拆包 } } int main() { PrintLn(3, 23, 2, 12); return 0; } ","date":"2022-01-20","objectID":"/posts/c++%E7%9A%84%E6%A8%A1%E6%9D%BF%E5%86%99println/:2:2","tags":["C++模板"],"title":"C++变参模板运用实战——实现PrintLn","uri":"/posts/c++%E7%9A%84%E6%A8%A1%E6%9D%BF%E5%86%99println/"},{"categories":["C++实战"],"content":"方式三：可变参模板的fold expression展开 【C++17】 在C++17中，加入了一个fold expression的语法，让可变参数模板可以不通过递归的方式来解包，直接把每个包解开放入一个表达式，然后剩余的包都以该表达式解开，基本的语法如下： ((expression)op...); expression : 表示希望每个解开的参数所执行的表达式。 op : 你指定的操作符。 ... : 一直不断的解包，由于此处放的位置是右边，所以往右边解包，如果放左边则往左边解包。 示例代码： #include \u003cbits/stdc++.h\u003eusing namespace std; template\u003ctypename... Args\u003e double sum(Args... args){ return (args+...);//等价于3+23+1+3.32 } template\u003cauto... val\u003e//可变的传值的模板参数 constexpr int sum(){ return (val+...); } int main() { cout\u003c\u003csum\u003c3,23,1,32\u003e()\u003c\u003cendl;//传值模板参数不支持浮点类型，所以全用的int类型 cout\u003c\u003csum(3,23,1,3.32); return 0; } ","date":"2022-01-20","objectID":"/posts/c++%E7%9A%84%E6%A8%A1%E6%9D%BF%E5%86%99println/:3:0","tags":["C++模板"],"title":"C++变参模板运用实战——实现PrintLn","uri":"/posts/c++%E7%9A%84%E6%A8%A1%E6%9D%BF%E5%86%99println/"},{"categories":["C++实战"],"content":"简单的利用fold expr实现 基于以上对fold expr的使用，我们来正式实现PrintLn，值得一提的是，这个fold expr的性能肯定是比之前递归解包的性能要好的，因为只是迭代的拓宽而已。 我们可以将拆开的包用 ',' 展开 #include\u003ciostream\u003eusing namespace std; template\u003ctypename... Args\u003e void PrintLn(Args... args){ ((cout\u003c\u003cargs\u003c\u003c\", \"),...)\u003c\u003cendl; } int main() { PrintLn(1,2.3,\"LB\",\"hhh\"); return 0; } ","date":"2022-01-20","objectID":"/posts/c++%E7%9A%84%E6%A8%A1%E6%9D%BF%E5%86%99println/:3:1","tags":["C++模板"],"title":"C++变参模板运用实战——实现PrintLn","uri":"/posts/c++%E7%9A%84%E6%A8%A1%E6%9D%BF%E5%86%99println/"},{"categories":["C++实战"],"content":"加上流程控制实现 通过更复杂的流程控制把最后一个打印出来的逗号去掉。 通过延申三元运算符，使得运行时能够正确的打印最后一次。 反正我这里编译期只负责文本替换，所以被fold expr展开的表达式并不会有什么要是编译期常量的要求。 这一切都看作简单宏替换即可。 #include\u003ciostream\u003eusing namespace std; template\u003ctypename... Args\u003e void PrintLn(Args... args){ int lastIndex = sizeof...(args)-1;//得到传入的参数长度 int i = 0; ((i++==lastIndex?cout\u003c\u003cargs\u003c\u003cendl:cout\u003c\u003cargs\u003c\u003c\", \"),...); } int main() { PrintLn(1,2.3,\"LB\",\"hhh\"); return 0; } ","date":"2022-01-20","objectID":"/posts/c++%E7%9A%84%E6%A8%A1%E6%9D%BF%E5%86%99println/:3:2","tags":["C++模板"],"title":"C++变参模板运用实战——实现PrintLn","uri":"/posts/c++%E7%9A%84%E6%A8%A1%E6%9D%BF%E5%86%99println/"},{"categories":["C++实战"],"content":"更多fold expr运用… 利用与或表达式展开，然后利用它们的短路性质，实现得到拆包元素的精准打击（获得包里的第几个元素）。 #include\u003ciostream\u003eusing namespace std; template\u003ctypename... Args\u003e auto GetNth(int n, Args... args) { int i = 0; using CommonType = common_type_t\u003cArgs...\u003e; CommonType ret; ((i++ == n \u0026\u0026 (ret = args, true))||...); return ret; } int main() { cout \u003c\u003c GetNth(3, 2, 1, 2.3, 32.2); return 0; } 上面为了存储不确定的类型用了common_type_t，这个可以帮助你得到一个公共可用的类型，而这个类型必须是公共可用，比如int了float型可以进行相互转化所以有公共类型，而 char* 和int类型则没有，所以这个GetNth中的元素不能传递 char* 类型的同时传递int类型。 ","date":"2022-01-20","objectID":"/posts/c++%E7%9A%84%E6%A8%A1%E6%9D%BF%E5%86%99println/:3:3","tags":["C++模板"],"title":"C++变参模板运用实战——实现PrintLn","uri":"/posts/c++%E7%9A%84%E6%A8%A1%E6%9D%BF%E5%86%99println/"},{"categories":["C++实战"],"content":"矩阵快速幂的C++封装","date":"2022-01-20","objectID":"/posts/%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82%E7%9A%84c++%E5%B0%81%E8%A3%85/","tags":["矩阵快速幂"],"title":"矩阵快速幂的C++封装","uri":"/posts/%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82%E7%9A%84c++%E5%B0%81%E8%A3%85/"},{"categories":["C++实战"],"content":"实现源码在线查看 如果对于类的设计已经非常清楚，只是进来想看看我的这个泛型模板源代码，那么直接点到下面这个链接进行查看： 源码链接 ","date":"2022-01-20","objectID":"/posts/%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82%E7%9A%84c++%E5%B0%81%E8%A3%85/:0:0","tags":["矩阵快速幂"],"title":"矩阵快速幂的C++封装","uri":"/posts/%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82%E7%9A%84c++%E5%B0%81%E8%A3%85/"},{"categories":["C++实战"],"content":"什么是矩阵快速幂？ 关于快速幂，就是利用二进制进行求解某个数的幂的快速方法。 后面会对快速幂的原理进行简单讲解，如果还是不懂，请自行百度。 相信有很多小伙伴是初入大学的世界，可能还没学过线性代数（比如我），于是乎不知道矩阵是什么，我推荐一个网站去看看矩阵的乘法是怎么运算的，下面是网站链接：（话说how to这个网站还真是牛批，什么东西都有教程，而且质量还贼高！😂） 矩阵乘法的计算方式 那么如何用代码表示矩阵以及他的乘法呢？ 其实很简单，就是三层循环进行控制即可。 如：我这里是C++的重载运算符 Matrix 是我定义的一个类。 Matrix\u0026 operator*(Matrix\u0026 b){ assert(b.date!=NULL \u0026\u0026 date!=NULL \u0026\u0026 m==b.n); ll tmp[n][b.m]; for(int i=0;i\u003cn;i++){ for(int j=0;j\u003cb.m;j++){ ll sum = 0; for(int k=0;k\u003cm;k++){ sum = (sum + date[i][k]*b.date[k][j])%MOD; } tmp[i][j] = sum; } } this-\u003em = b.m; for(int i=0;i\u003cn;i++){ for (int j = 0; j \u003c m; ++j) { date[i][j] = tmp[i][j]; } } return *this; } ","date":"2022-01-20","objectID":"/posts/%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82%E7%9A%84c++%E5%B0%81%E8%A3%85/:1:0","tags":["矩阵快速幂"],"title":"矩阵快速幂的C++封装","uri":"/posts/%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82%E7%9A%84c++%E5%B0%81%E8%A3%85/"},{"categories":["C++实战"],"content":"怎么进行矩阵快速幂的运算？ 关于如何矩阵快速幂，我们先了解一下简单的快速幂。 说是快速幂就是通过位运算实现快速的同数累乘。 简述一下快速幂的原理： 原理就是，如果要求x的3次幂，那么可以转化为求 x*x 的 2 次幂，而求一个数的 2^n 幂是很简单的，比如进行一次 x *= x 便得到 x 的二次方。而再进行一次 x *= x 就得到了 4 次方，继续便可得到 8/16... 总之是 log2N 的时间。 代码如下： int QuickPow(int x,int n){ int c = n; int res = 1; while(c!=0){ if(c\u00261!=0){ res *= x; } c \u003e\u003e= 1; x *= x; } return res; } 那么矩阵的快速幂如何进行？ 把上述的 int 类型换成自己定义的矩阵就是矩阵的快速幂了。 我直接贴上C++实现的重载运算符后的类的快速幂写法： 这里的quickPow表示的是一个类的成员函数，所以可以直接用到这个矩阵里的数据进行运算。this表示指向这个对象的指针。init() 成员函数表示初始化为单位矩阵。 void quickPow(ll c){ if(c==1||c\u003c0)return; if(c==0){ init(); return; } Matrix tmp(*this); init(); while (c){ if(c\u00261){ *this = *this * tmp; } c \u003e\u003e= 1; tmp = tmp*tmp; } } ","date":"2022-01-20","objectID":"/posts/%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82%E7%9A%84c++%E5%B0%81%E8%A3%85/:1:1","tags":["矩阵快速幂"],"title":"矩阵快速幂的C++封装","uri":"/posts/%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82%E7%9A%84c++%E5%B0%81%E8%A3%85/"},{"categories":["C++实战"],"content":"为什么突然想写这个模板？ 主要是因为最近做了几道快速幂的题目，被坑的很惨，然后就突然想设计一个模板了，主要是 my_tiny_stl 这个仓库也好久没更新了😂 ","date":"2022-01-20","objectID":"/posts/%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82%E7%9A%84c++%E5%B0%81%E8%A3%85/:2:0","tags":["矩阵快速幂"],"title":"矩阵快速幂的C++封装","uri":"/posts/%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82%E7%9A%84c++%E5%B0%81%E8%A3%85/"},{"categories":["C++实战"],"content":"题目 OJ网站 ","date":"2022-01-20","objectID":"/posts/%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82%E7%9A%84c++%E5%B0%81%E8%A3%85/:2:1","tags":["矩阵快速幂"],"title":"矩阵快速幂的C++封装","uri":"/posts/%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82%E7%9A%84c++%E5%B0%81%E8%A3%85/"},{"categories":["C++实战"],"content":"我是如何被坑的 首先拿到这道题，我便马上开始简单的O(n)递推法实现，然后提交，然后。。超时。。 定眼一看，数据量原来这么大！ 后面一想，肯定是矩阵快速幂了，先想出以下矩阵的递推式子： 进而题目便可得到求解。 然后我就利用 C++ 的类简单的封装了一个矩阵类，里面重载了乘法和 quickpow 方法，然后比较悠闲的准备提交，还没提交前就遇到C++的语法陷阱、、 语法陷阱（建议非C++党绕道） 由于类用的都是堆内存，所以我写了析构函数，我遇到的问题出在重载乘法时我返回的是左值，而且我也没有对 ‘=’ 进行重载，所以 ‘=’ 就是直接的成员变量拷贝，这导致一个结果就是两个对象的 date 指向同一片内存空间，而之前的那片内存空间泄露了，且最后这两个对象肯定都会调用析构函数，这又导致了析构函数调用了两次！ 如何解决这个问题？如果是 C++98 ，那么这个问题很大，基本上就是两种方法解决： 逃避问题，乘法的左操作数必须是当前赋值对象，这样就避免了最后赋值语句将原本对象内的指针直接改变。 解决问题，解决这类问题无论是 C++11 还是 C++98 最直接的方式就是重载 ‘=’ 号，重载 '=' 号的实现根据具体的情况进行，而具体实现赋值的重载，我们需要考虑两件事：第一，需尽可能的减少内存的申请和使用（具体而言就是判断两个对象的指针所指向的是否为同一片空间，即便不是同一片空间，为了增加空间利用率还可以判断两个空间是否大小一致，然后进行拷贝即可）。第二，如果是临时对象则需要把它的指针置空（防止编译器未优化临时变量的析构函数，从而调用了析构函数多次析构同一内存）。 由于 C++11 开始有了右值引用和它配套的移动赋值构造器，所以可以把临时变量直接调用移动构造器变成具名对象，然后进行操作，一般就是把它的指针所有权进行转移，然后把它的指针置空防止析构错误，在我的理解下，右值引用的出现就是为了捕捉到匿名对象然后给程序员进行适当的性能优化操作，没有右值引用前，匿名对象的内存根本就没法去使用，只能用来简单的赋值拷贝操作后才能使用，这样就很消耗内存了，右值引用出现后，我们可以通过右值引用对匿名对象进行捕捉，然后操作它的底层内存。还有一个很大的内存相关的更新就是有了一个 nullptr 关键字，这个关键字使得空指针不再会有歧义，所以 delete nullptr 是安全的。所以防止多次 delete 同一片空间产生错误可以将它赋值为 nullptr 即可。 那么基于 C++11 这个问题该如何解决呢？解决方法和C++98没差，就是能够更加得心应手的进行内存的管理了，如果等号右边是一个右值，那么它肯定是一个临时对象，所以我们可以在 ‘=’ 号的重载中直接了当的用它的内存，并把它的指针置空。如果没有右值类型进行捕获，编译器默认也是会对临时对象进行优化的，也能防止产生多个对象的赋值拷贝，但只能在对象初始化的时候进行优化！而在其他时候则还是会调用析构函数，这个时候如果还是用编译器默认产生的 ‘=’ 重载，则会发生被析构的空间的指针被赋值的情况，而我们的右值引用版本的赋值重载便是针对此现象的。这样便于内存管理，将右值和左值进行分开处理。右值是临时变量只需要用一会儿，所以可以直接把它的内存拿过来继续用，也不会对程序逻辑造成影响，而左值则不一样，它还需要存活很长一段时间，所以我们需要另创空间进行拷贝。 特别提醒：如果是做算法题，则完全不用去考虑内存的管理，析构函数也不要去写，毕竟只需要单次调用使用，对象最多也就存在一会儿。 做题陷阱 在必要的时候千万不要舍不得开long long！！！！ 这道题的数据量无论是幂的次方还是整个记录过程的数据都要开long long！！！ 我被这个陷阱坑了无数回了，这一次也不另外😅 开始写完这种之后过了前5个，然后后面5个报错，我还以为我设计的这个类有问题，还特意去写了好几个普通C语言版本😂最后发现原来的没开long long。以下为更改long long后的代码通过版本，我用宏定义写了几个版本。。。 这个Matrix类的设计还是很多地方没有考虑到位，比如上一个陷阱的问题只是通过方法一得到解决，并未去重载赋值操作符。。。所以后面痛定思痛，设计一个较为可用的Matrix类！ 效率时快时慢的，这主要取决于编译器是否进行优化。 // // Created by Alone on 2021/11/19. // #include \u003cbits/stdc++.h\u003eusing namespace std; //#define ELSE_MAIN #define MY_MAIN #define MAT #ifdef MAT typedef long long ll; class Matrix{ ll** date; int m; int n; public: static const int MOD; public: Matrix(ll** rec,int n,int m):date(rec),n(n),m(m){}//C风格的初始化 Matrix():date(NULL),m(0),n(0){} //缺省 Matrix(Matrix\u0026 b):n(b.n),m(b.m){//拷贝构造 assert(b.date!=NULL \u0026\u0026 b.n\u003e0 \u0026\u0026 b.m\u003e0); date = new ll*[n]; copy(b.date,b.date+n,date); for(int i=0;i\u003cn;i++){ date[i] = new ll[m]; copy(b.date[i],b.date[i]+m,date[i]); } } ~Matrix(){//析构函数实现 assert(date!=NULL \u0026\u0026 n\u003e0 \u0026\u0026 m\u003e0); for (int i = n-1; i \u003e=0 ; --i) { delete [] date[i]; } delete[] date; } Matrix\u0026 operator*(Matrix\u0026 b){ assert(b.date!=NULL \u0026\u0026 date!=NULL \u0026\u0026 m==b.n); ll tmp[n][b.m]; for(int i=0;i\u003cn;i++){ for(int j=0;j\u003cb.m;j++){ ll sum = 0; for(int k=0;k\u003cm;k++){ sum = (sum + date[i][k]*b.date[k][j])%MOD; } tmp[i][j] = sum; } } this-\u003em = b.m; for(int i=0;i\u003cn;i++){ for (int j = 0; j \u003c m; ++j) { date[i][j] = tmp[i][j]; } } return *this; } void init(){//重新初始化为单位矩阵 assert(date!=NULL \u0026\u0026 n\u003e0 \u0026\u0026 m\u003e0); for (int i = 0; i \u003c n; ++i) { for (int j = 0; j \u003c m; ++j) { if(i==j)date[i][j] = 1; else date[i][j] = 0; } } } void quickPow(ll c){ if(c==1||c\u003c0)return; if(c==0){ init(); return; } Matrix tmp(*this); init(); while (c){ if(c\u00261){ *this = *this * tmp; } c \u003e\u003e= 1; tmp = tmp*tmp; } } void print(){ for(int i=0;i\u003cn;i++){ for(int j=0;j\u003cm;j++){ cout\u003c\u003cdate[i][j]\u003c\u003c' '; } cout\u003c\u003cendl; } } int get(int x,int y){ assert(date!=NULL \u0026\u0026 x\u003cn \u0026\u0026 y\u003cm); return date[x][y]; } }; const int Matrix::MOD = 1e9+7; #endif #ifdef MY_MAIN int main(){ ll c; cin\u003e\u003ec; ll** matrix = new ll*[2]; matrix[0] = new ll[2]{1,1}; matrix[1] = new ll[2]{1,0}; Matrix mat(matrix,2,2); mat.quickPow(c-1); //mat.print(); ll** res = new ll*[2]; res[0] = new ll[1]; res[1] = new ll[1]; res[0][0] = res[1][0] = 1; Matrix fib(res,2,1); //这里有个内存分配错误，mat*fib返回的是左值，而=没有重载默认直接赋值成员变量。 //直接导致了fib失去了之前的变量所有权，和mat共同有一个内存空间，这样导致同一片空间被free两次 //通过重载 = 号解决，防止直接的内存没有被释放就重新绑定同一片内存 Matrix ret(mat*fib); cout\u003c\u003cret.get(0,0); return 0; } #endif #ifdef TEST_MAIN typedef long long ll ; const int MOD = 1e9+7; ll a[2][2]{{1,1},{1,0}};ll b[2]{1,1}; void selfMut(){ ll tmp[2][2]; for(int i=0;i\u003c2;i","date":"2022-01-20","objectID":"/posts/%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82%E7%9A%84c++%E5%B0%81%E8%A3%85/:2:2","tags":["矩阵快速幂"],"title":"矩阵快速幂的C++封装","uri":"/posts/%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82%E7%9A%84c++%E5%B0%81%E8%A3%85/"},{"categories":["C++实战"],"content":"教你设计Matrix类 ","date":"2022-01-20","objectID":"/posts/%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82%E7%9A%84c++%E5%B0%81%E8%A3%85/:3:0","tags":["矩阵快速幂"],"title":"矩阵快速幂的C++封装","uri":"/posts/%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82%E7%9A%84c++%E5%B0%81%E8%A3%85/"},{"categories":["C++实战"],"content":"如何设计一个类？ 结构： 内部数据抽象：对象的运算数据存储 用二级指针 date 进行矩阵的二维空间的内存管理，以及n和m表示矩阵的行高和列宽。 行为抽象：对对象的行为描述 构造函数（缺省、自定义、拷贝、移动） 和 析构函数（调用destory成员函数）。 setter 和 getter。提供函数接口去设置和得到数据。 功能函数：比如重载的乘法运算符和快速幂函数这些都算功能函数。 对象的属性抽象： 数据和行为是否对外，对外封装数据的意义在于防止对对象行为描述的破坏，而对外开放的某个行为通常需要内部多个函数进行重复调用来实现。这个时候需要用到 public 和 private 关键字进行修饰。 数据和行为是否可继承，对于某些行为（函数），我们不想被外部调用，但是对子类又很有用，这个时候我们可以采取 protect 关键字进行修饰。 数据和行为是否能重复利用，为了节省不必要的内存开销，可以设计不需要产生具体对象的通用型函数，可以使用 static 关键字进行修饰，这样可以避免我想使用某个函数前还得去申请一片毫不相关的内存空间，而对于某个对象的数据也可以采用 static 进行修饰，这样一来，这个数据在对象的创建过程中就不需要再进行申请和赋值了。 那么接下来就来确定行为（函数）的属性了，数据肯定是不对外开放的（private），否则面向对象将毫无意义。 构造函数 和 析构函数，这两个是对象的创建和销毁的关键，所以如果不是希望对象不被创建或者是不被销毁，都应该使用 public 修饰。 setter 和 getter。很明显是对外开放的接口函数，所以肯定也是 public 修饰。 功能函数：矩阵快速幂的函数，很明显我们希望设置一个对外通用的情况，那么这个时候就应该不需要创建对象便可进行调用，所以最好用 static 进行修饰（这个一般为外部通用接口，内部还需实现一个方便类调用的版本，这也很简单，直接传参调用该函数即可），重载的乘法肯定也是对外的所以需要 public 修饰，destroy 函数用于处理内存的回收，很明显这是一个内部通用的函数，但是外界完全是不需要它的！所以把它设置为 private 属性即可。 以上便是对整个类的设计思路，当然真正动手设计的时候，还需要具体到函数的参数和返回值类型，因为这牵扯到 C++ 的具体语法了，比如我应该在重载乘法的时候返回一个什么样的类型？最好是返回一个右值！而重载赋值运算符则最好是返回一个左值。一般需要考虑返回值类型的取舍时，最难的就是如果返回一个对象，我该返回左值还是右值。 写了这么久C++，我感觉用C++写的Java屏蔽重载运算符的特性主要就是重载运算符时需要考虑的过程太多了，C++菜鸡（我就是这个菜鸟😂）写出及其低效且不安全的代码，而只有老鸟才能写出优雅高效的代码。 ","date":"2022-01-20","objectID":"/posts/%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82%E7%9A%84c++%E5%B0%81%E8%A3%85/:3:1","tags":["矩阵快速幂"],"title":"矩阵快速幂的C++封装","uri":"/posts/%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82%E7%9A%84c++%E5%B0%81%E8%A3%85/"},{"categories":["C++实战"],"content":"类的具体抽象结构（代码的具体规划图） 按照属性对类的各个部分进行分类的，毕竟属性也基本就代表了这个方法的使用场景了。 最后可以利用基本的断言或者异常，让代码变得更为健壮，使得更容易定位错误发生的位置和原因。 ","date":"2022-01-20","objectID":"/posts/%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82%E7%9A%84c++%E5%B0%81%E8%A3%85/:3:2","tags":["矩阵快速幂"],"title":"矩阵快速幂的C++封装","uri":"/posts/%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82%E7%9A%84c++%E5%B0%81%E8%A3%85/"},{"categories":["C++实战"],"content":"实现矩阵泛型模板类 源代码实现 我先是画出规划图进行实现，然后在实现的过程中，发现可以新增一些特性，比如重载下标运算符，比如用print函数打印出来方便验证。 具体实现过程，为了方便简单的定位可能发生的错误，使用了大量的assert进行断言检查。如果想代码的健壮性更强，可以使用抛出异常的方式。 源代码对应的GitHub仓库地址：仓库链接，还有更多模板的实现，包括少量STL 更好的源码阅读体验：源码在线阅读 直接阅读下面的代码有点不太好查看，推荐去上面的GitHub1s里面查看源码。 // // Created by L_B__ on 2021/11/20. // #ifndef LQTEST_MATRIX_H #define LQTEST_MATRIX_H #include \u003ccassert\u003e#include \u003calgorithm\u003e#include \u003ciostream\u003e #define _MOD template\u003ctypename T\u003e class Matrix { /*Type define*/ typedef T data_t; typedef int ssize_t; /*data source*/ data_t **data; ssize_t n; ssize_t m; public: static const data_t MOD; public: /*default construct*/ Matrix() : m(0), n(0), data(nullptr) {} /*custom construct*/ Matrix(data_t **mat, ssize_t n, ssize_t m) : data(mat), n(n), m(m) {}//外部申请内存传入内部 Matrix(ssize_t n, ssize_t m) : data(nullptr), n(n), m(m) {//外部指定矩阵的行和列即可，内存初始化在内部进行 assert(n \u003e 0 \u0026\u0026 m \u003e 0); data = new data_t *[n]; for (int i = 0; i \u003c n; i++) { data[i] = new data_t[m]; } init(data, n, m); } /*copy construct*/ Matrix(Matrix \u0026src) : data(nullptr), n(src.n), m(src.m)//也可用const \u0026引用类型，但这样很多右值的情况都不会调用移动构造了 { assert(n \u003e 0 \u0026\u0026 m \u003e 0); data = new data_t *[n]; for (int i = 0; i \u003c n; ++i) { data[i] = new data_t[m]; std::copy(src.data[i], src.data[i] + m, data[i]); } } /*move construct*/ Matrix(Matrix\u003cdata_t\u003e \u0026\u0026src) : n(src.n), m(src.m), data(nullptr) { assert(src.data != nullptr \u0026\u0026 n \u003e 0 \u0026\u0026 m \u003e 0); data = src.data; src.data = nullptr; src.n = src.m = 0; } /*destruct*/ ~Matrix() { destroy(); } /*overload*/ //加上MOD的特殊版本 #ifdef _MOD Matrix operator*(const Matrix\u003cdata_t\u003e \u0026src)//建议返回右值，返回左值的后续坑比较多，参数const \u0026既可以接受左值也可接受右值 { assert(data != nullptr \u0026\u0026 src.data != nullptr \u0026\u0026 m == src.n \u0026\u0026 m \u003e 0 \u0026\u0026 n \u003e 0 \u0026\u0026 src.m \u003e 0);//进行矩阵乘法的必要条件 data_t **tmp = new data_t *[n]; //为tmp申请动态内存，因为是传出参数 for (int i = 0; i \u003c n; ++i) { tmp[i] = new data_t[m]; } for (int i = 0; i \u003c n; ++i)//开始更新tmp { for (int j = 0; j \u003c src.m; ++j) { data_t sum = 0; for (int k = 0; k \u003c m; ++k) { sum = (sum + data[i][k] * src.data[k][j]) % MOD; } tmp[i][j] = sum; } } //直接构造匿名对象返回 return Matrix(tmp, n, src.m);; } Matrix \u0026operator*=(const Matrix\u003cdata_t\u003e \u0026src)//*= 想一想我们平时的使用，就是返回一个左值 { assert(data != nullptr \u0026\u0026 src.data != nullptr \u0026\u0026 m == src.n \u0026\u0026 m \u003e 0 \u0026\u0026 n \u003e 0 \u0026\u0026 src.m \u003e 0);//进行矩阵乘法的必要条件 data_t tmp[n][src.m];//静态内存就行，毕竟只是临时存数据的 for (int i = 0; i \u003c n; ++i)//开始更新tmp { for (int j = 0; j \u003c src.m; ++j) { data_t sum = 0; for (int k = 0; k \u003c m; ++k) { sum = (sum + data[i][k] * src.data[k][j]) % MOD; } tmp[i][j] = sum; } } //由于此时的date内存可能不够容下tmp数据，所以可能需要重新进行内存申请 //注意重新申请列内存的时候，需要把之前的内存释放 if (m != src.m) { for (int i = 0; i \u003c n; ++i) { delete[]data[i]; data[i] = nullptr; data[i] = new data_t[src.m]; } } for (int i = 0; i \u003c n; ++i) { assert(data[i] != nullptr); std::copy(tmp[i], tmp[i] + src.m, data[i]); } return *this; } #endif #ifndef _MOD Matrix operator*(const Matrix\u003cdata_t\u003e\u0026src)//建议返回右值，返回左值的后续坑比较多，参数const \u0026既可以接受左值也可接受右值 { assert(data!= nullptr\u0026\u0026src.data!= nullptr\u0026\u0026m==src.n\u0026\u0026m\u003e0\u0026\u0026n\u003e0\u0026\u0026src.m\u003e0);//进行矩阵乘法的必要条件 data_t** tmp = new data_t *[n]; //为tmp申请动态内存，因为是传出参数 for (int i = 0; i \u003c n; ++i) { tmp[i] = new data_t [m]; } for(int i=0;i\u003cn;++i)//开始更新tmp { for (int j = 0; j \u003c src.m; ++j) { data_t sum = 0; for (int k = 0; k \u003c m; ++k) { sum = sum + data[i][k]*src.data[k][j]; } tmp[i][j] = sum; } } //直接构造匿名对象返回 return Matrix (tmp,n,src.m); } /*与乘法的唯一区别在于乘法是构造一个新的对象，而*=返回的是this*/ Matrix \u0026operator*=(const Matrix\u003cdata_t\u003e \u0026src)//*= 想一想我们平时的使用，就是返回一个左值 { assert(data!= nullptr\u0026\u0026src.data!= nullptr\u0026\u0026m==src.n\u0026\u0026m\u003e0\u0026\u0026n\u003e0\u0026\u0026src.m\u003e0);//进行矩阵乘法的必要条件 data_t tmp[n][src.m];//静态内存就行，毕竟只是临时存数据的 for(int i=0;i\u003cn;++i)//开始更新tmp { for (int j = 0; j \u003c src.m; ++j) { data_t sum = 0; for (int k = 0; k \u003c m; ++k) { sum = sum + data[i][k]*src.data[k][j]; } tmp[i][j] = sum; } } //由于此时的date内存可能不够容下tmp数据，所以可能需要重新进行内存申请 //注意重新申请列内存的时候，需要把之前的内存释放 if(m!=src.m){ for (int i = 0; i \u003c n; ++i) { delete []data[i]; data[i] = nullptr; data[i] = new data_t [src.m]; } } for (int i = 0; i \u003c n; ++i) { assert(data[i] != nullptr); std::copy(tmp[i],tmp[i]+src.m,data[i]); } return *this; } #endif //赋值号的重载","date":"2022-01-20","objectID":"/posts/%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82%E7%9A%84c++%E5%B0%81%E8%A3%85/:3:3","tags":["矩阵快速幂"],"title":"矩阵快速幂的C++封装","uri":"/posts/%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82%E7%9A%84c++%E5%B0%81%E8%A3%85/"},{"categories":["C++实战"],"content":"总结 由于用的是 C++11 的语法进行实现的模板类，所以低于这个版本的编译器都无法正常使用。我查阅了相关资料，实际上蓝桥杯比赛的时候可以用 C++11，而acm更是不用说，早就能用C++11了。 简单复盘： 实现一个这样的类，主要能学到以下几点： 类的设计技巧。 对C++的左右值有了更深入的理解。 各种构造器的设计和实现已经达到炉火纯青的地步了。 ","date":"2022-01-20","objectID":"/posts/%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82%E7%9A%84c++%E5%B0%81%E8%A3%85/:4:0","tags":["矩阵快速幂"],"title":"矩阵快速幂的C++封装","uri":"/posts/%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82%E7%9A%84c++%E5%B0%81%E8%A3%85/"}]