[{"categories":["算法——模拟题"],"content":"1bit与2bit字符——简单模拟题","date":"2022-02-20","objectID":"/posts/1bit%E4%B8%8E2bit%E5%AD%97%E7%AC%A6%E7%AE%80%E5%8D%95%E6%A8%A1%E6%8B%9F%E9%A2%98/","tags":["1bit与2bit字符——简单模拟题"],"title":"1bit与2bit字符——简单模拟题","uri":"/posts/1bit%E4%B8%8E2bit%E5%AD%97%E7%AC%A6%E7%AE%80%E5%8D%95%E6%A8%A1%E6%8B%9F%E9%A2%98/"},{"categories":["算法——模拟题"],"content":"题目 题目链接 ","date":"2022-02-20","objectID":"/posts/1bit%E4%B8%8E2bit%E5%AD%97%E7%AC%A6%E7%AE%80%E5%8D%95%E6%A8%A1%E6%8B%9F%E9%A2%98/:1:0","tags":["1bit与2bit字符——简单模拟题"],"title":"1bit与2bit字符——简单模拟题","uri":"/posts/1bit%E4%B8%8E2bit%E5%AD%97%E7%AC%A6%E7%AE%80%E5%8D%95%E6%A8%A1%E6%8B%9F%E9%A2%98/"},{"categories":["算法——模拟题"],"content":"题目详解 读懂题： 此题是为了让最后以一个字符解码，也就是 $0$ ，而含 $1$ 的只能是两个字符进行解码，所以遇到 $1$ 就必须确保后面有 $0$ 或 $1$ 来用于抵消。 解题法： 法一：正向遍历法 直接通过遇到 $0$ 走一步，遇到 $1$ 走两步，再看最后是否能恰好走到最后一个 $0$ 的位置，如果能则 $true$ 否则 $false$ 。 法二：反向遍历法 由于遇到 $0$ 能直接跳过，而遇到 $1$ 则后面必须含有一个字符被抵消，所以为了让最后一个 $0$ 不被抵消，它前面的连续 $1$ 应该要为偶数个，否则 $0$ 将会被抵消。故具体做法直接记录最后一个 $0$ 前面的 $1$ 的个数即可得出答案。 ","date":"2022-02-20","objectID":"/posts/1bit%E4%B8%8E2bit%E5%AD%97%E7%AC%A6%E7%AE%80%E5%8D%95%E6%A8%A1%E6%8B%9F%E9%A2%98/:2:0","tags":["1bit与2bit字符——简单模拟题"],"title":"1bit与2bit字符——简单模拟题","uri":"/posts/1bit%E4%B8%8E2bit%E5%AD%97%E7%AC%A6%E7%AE%80%E5%8D%95%E6%A8%A1%E6%8B%9F%E9%A2%98/"},{"categories":["算法——模拟题"],"content":"解题代码 法一： class Solution { public: bool isOneBitCharacter(vector\u003cint\u003e\u0026 bits) { int sz = bits.size(); if(sz\u003c2) return true; int start = 0; while(start\u003csz-1){ if(bits[start]==0) start++; else{ start += 2; } } return start==sz-1; } }; 法二： class Solution { public: bool isOneBitCharacter(vector\u003cint\u003e\u0026 bits) { return find(rbegin(bits)+1, rend(bits), 0) - rbegin(bits) \u0026 1; } }; ","date":"2022-02-20","objectID":"/posts/1bit%E4%B8%8E2bit%E5%AD%97%E7%AC%A6%E7%AE%80%E5%8D%95%E6%A8%A1%E6%8B%9F%E9%A2%98/:3:0","tags":["1bit与2bit字符——简单模拟题"],"title":"1bit与2bit字符——简单模拟题","uri":"/posts/1bit%E4%B8%8E2bit%E5%AD%97%E7%AC%A6%E7%AE%80%E5%8D%95%E6%A8%A1%E6%8B%9F%E9%A2%98/"},{"categories":["Java底层原理"],"content":"Java动态代理详解","date":"2022-02-20","objectID":"/posts/java%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E8%AF%A6%E8%A7%A3/","tags":["Java动态代理详解"],"title":"Java动态代理详解","uri":"/posts/java%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E8%AF%A6%E8%A7%A3/"},{"categories":["Java底层原理"],"content":" 在介绍动态代理之前，必须先来聊聊静态代理。 ","date":"2022-02-20","objectID":"/posts/java%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E8%AF%A6%E8%A7%A3/:0:0","tags":["Java动态代理详解"],"title":"Java动态代理详解","uri":"/posts/java%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E8%AF%A6%E8%A7%A3/"},{"categories":["Java底层原理"],"content":"静态代理介绍 假设现在项目经理有一个需求：在项目现有所有类的方法前后打印日志。 你如何在不修改已有代码的前提下，完成这个需求？ 我首先想到的是静态代理。具体做法是： 一、为现有的每一个类都编写一个对应的代理类，并且让它实现和目标类相同的接口（假设都有） 二、在创建代理对象时，通过构造器塞入一个目标对象，然后在代理对象的方法内部调用目标对象同名方法，并在调用前后打印日志。也就是说，代理对象 = 增强代码 + 目标对象（原对象）。有了代理对象后，就不用原对象了 静态代理的缺陷 程序员要手动为每一个目标类编写对应的代理类。如果当前系统已经有成百上千个类，工作量太大了。所以，现在我们的努力方向是：如何少写或者不写代理类，却能完成代理功能？ 复习对象的创建 很多初学Java的朋友眼中创建对象的过程 实际上可以换个角度，也说得通 所谓的Class对象，是Class类的实例，而Class类是描述所有类的，比如Person类，Student类 可以看出，要创建一个实例，最关键的就是得到对应的Class对象。只不过对于初学者来说，new这个关键字配合构造方法，实在太好用了，底层隐藏了太多细节，一句 Person p = new Person();直接把对象返回给你了。我自己刚开始学Java时，也没意识到Class对象的存在。 分析到这里，貌似有了思路： 能否不写代理类，而直接得到代理Class对象，然后根据它创建代理实例（反射）。 Class对象包含了一个类的所有信息，比如构造器、方法、字段等。如果我们不写代理类，这些信息从哪获取呢？苦思冥想，突然灵光一现：代理类和目标类理应实现同一组接口。之所以实现相同接口，是为了尽可能保证代理对象的内部结构和目标对象一致，这样我们对代理对象的操作最终都可以转移到目标对象身上，代理对象只需专注于增强代码的编写。还是上面这幅图： 所以，可以这样说：接口拥有代理对象和目标对象共同的类信息。所以，我们可以从接口那得到理应由代理类提供的信息。但是别忘了，接口是无法创建对象的，怎么办？ ","date":"2022-02-20","objectID":"/posts/java%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E8%AF%A6%E8%A7%A3/:1:0","tags":["Java动态代理详解"],"title":"Java动态代理详解","uri":"/posts/java%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E8%AF%A6%E8%A7%A3/"},{"categories":["Java底层原理"],"content":"走进动态代理 JDK提供了java.lang.reflect.InvocationHandler接口和 java.lang.reflect.Proxy类，这两个类相互配合，入口是Proxy，所以我们先聊它。 Proxy有个静态方法：getProxyClass(ClassLoader, interfaces)，只要你给它传入类加载器和一组接口，它就给你返回代理Class对象。 用通俗的话说，getProxyClass() 这个方法，会从你传入的接口Class中，“拷贝”类结构信息到一个新的Class对象中，但新的Class对象带有构造器，是可以创建对象的。打个比方，一个大内太监（接口Class），空有一身武艺（类信息），但是无法传给后人。现在江湖上有个妙手神医（Proxy类），发明了克隆大法（getProxyClass），不仅能克隆太监的一身武艺，还保留了小DD（构造器）…（这到底是道德の沦丧，还是人性的扭曲，欢迎走进动态代理） 所以，一旦我们明确接口，完全可以通过接口的Class对象，创建一个代理Class，通过代理Class即可创建代理对象。 所以，按我理解，Proxy.getProxyClass()这个方法的本质就是：以Class造Class。 有了Class对象，就很好办了，具体看代码： 根据代理Class的构造器创建对象时，需要传入InvocationHandler。每次调用代理对象的方法，最终都会调用InvocationHandler的invoke()方法： 怎么做到的呢？ 上面不是说了吗，根据代理Class的构造器创建对象时，需要传入InvocationHandler。通过构造器传入一个引用，那么必然有个成员变量去接收。没错，代理对象的内部确实有个成员变量invocationHandler，而且代理对象的每个方法内部都会调用handler.invoke()！ InvocationHandler对象成了代理对象和目标对象的桥梁，不像静态代理这么直接。 大家仔细看上图右侧的动态代理，我在invocationHandler的invoke()方法中并没有写目标对象。因为一开始invocationHandler的invoke()里确实没有目标对象，需要我们手动new。 但这种写法不够优雅，属于硬编码。我这次代理A对象，下次想代理B对象还要进来改invoke()方法，太差劲了。改进一下，让调用者把目标对象作为参数传进来： public class ProxyTest { public static void main(String[] args) throws Throwable { CalculatorImpl target = new CalculatorImpl(); //传入目标对象 //目的：1.根据它实现的接口生成代理对象 2.代理对象调用目标对象方法 Calculator calculatorProxy = (Calculator) getProxy(target); calculatorProxy.add(1, 2); calculatorProxy.subtract(2, 1); } private static Object getProxy(final Object target) throws Exception { //参数1：随便找个类加载器给它， 参数2：目标对象实现的接口，让代理对象实现相同接口 Class proxyClazz = Proxy.getProxyClass(target.getClass().getClassLoader(), target.getClass().getInterfaces()); Constructor constructor = proxyClazz.getConstructor(InvocationHandler.class); Object proxy = constructor.newInstance(new InvocationHandler() { @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { System.out.println(method.getName() + \"方法开始执行...\"); Object result = method.invoke(target, args); System.out.println(result); System.out.println(method.getName() + \"方法执行结束...\"); return result; } }); return proxy; } } 这样就非常灵活，非常优雅了。无论现在系统有多少类，只要你把实例传进来，getProxy()都能给你返回对应的代理对象。就这样，我们完美地跳过了代理类，直接创建了代理对象！ 不过实际编程中，一般不用getProxyClass()，而是使用Proxy类的另一个静态方法：Proxy.newProxyInstance()，直接返回代理实例，连中间得到代理Class对象的过程都帮你隐藏： public class ProxyTest { public static void main(String[] args) throws Throwable { CalculatorImpl target = new CalculatorImpl(); Calculator calculatorProxy = (Calculator) getProxy(target); calculatorProxy.add(1, 2); calculatorProxy.subtract(2, 1); } private static Object getProxy(final Object target) throws Exception { Object proxy = Proxy.newProxyInstance( target.getClass().getClassLoader(),/*类加载器*/ target.getClass().getInterfaces(),/*让代理对象和目标对象实现相同接口*/ new InvocationHandler(){/*代理对象的方法最终都会被JVM导向它的invoke方法*/ public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { System.out.println(method.getName() + \"方法开始执行...\"); Object result = method.invoke(target, args); System.out.println(result); System.out.println(method.getName() + \"方法执行结束...\"); return result; } } ); return proxy; } } 现在，我想大家应该能看懂动态代理了。 那么来张小图做总结： ","date":"2022-02-20","objectID":"/posts/java%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E8%AF%A6%E8%A7%A3/:2:0","tags":["Java动态代理详解"],"title":"Java动态代理详解","uri":"/posts/java%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E8%AF%A6%E8%A7%A3/"},{"categories":["Java底层原理"],"content":"代理的真正作用（实践） ","date":"2022-02-20","objectID":"/posts/java%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E8%AF%A6%E8%A7%A3/:3:0","tags":["Java动态代理详解"],"title":"Java动态代理详解","uri":"/posts/java%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E8%AF%A6%E8%A7%A3/"},{"categories":["Java底层原理"],"content":"静态代理的作用 假如我们有一个字体提供类，有多种实现（从磁盘，从网络，从系统） public interface FontProvider { Font getFont(String name); } public abstract class ProviderFactory { public static FontProvider getFontProvider() { return new FontProviderFromDisk(); } } public class Main() { public static void main(String[] args) { FontProvider fontProvider = ProviderFactory.getFontProvider(); Font font = fontProvider.getFont(\"微软雅黑\"); ...... } } 现在我们希望给他加上一个缓存功能，我们可以用静态代理来完成。 public class CachedFontProvider implements FontProvider { private FontProvider fontProvider; private Map\u003cString, Font\u003e cached; public CachedFontProvider(FontProvider fontProvider) { this.fontProvider = fontProvider; } public Font getFont(String name) { Font font = cached.get(name); if (font == null) { font = fontProvider.getFont(name); cached.put(name, font); } return font; } } /* 对工厂类进行相应修改，代码使用处不必进行任何修改。 这也是面向接口编程以及工厂模式的一个好处 */ public abstract class ProviderFactory { public static FontProvider getFontProvider() { return new CachedFontProvider(new FontProviderFromDisk()); } } 当然，我们直接修改FontProviderFromDisk类也可以实现目的，但是我们还有FontProviderFromNet, FontProviderFromSystem等多种实现类，一一修改太过繁琐且易出错。 况且将来还可能添加日志，权限检查，异常处理等功能显然用代理类更好一点。 ","date":"2022-02-20","objectID":"/posts/java%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E8%AF%A6%E8%A7%A3/:3:1","tags":["Java动态代理详解"],"title":"Java动态代理详解","uri":"/posts/java%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E8%AF%A6%E8%A7%A3/"},{"categories":["Java底层原理"],"content":"动态代理的运用场景（减少重复劳作） 比如：考虑以下各种情况，有多个提供类，每个类都有getXxx(String name)方法，每个类都要加入缓存功能，使用静态代理虽然也能实现，但是也是略显繁琐，需要手动一一创建代理类。 public abstract class ProviderFactory { public static FontProvider getFontProvider() {...} public static ImageProvider getImageProvider() {...} public static MusicProvider getMusicProvider() {...} ...... } 使用动态代理怎么完成呢？(只需一份缓存版本实现即可) public class CachedProviderHandler implements InvocationHandler { private Map\u003cString, Object\u003e cached = new HashMap\u003c\u003e(); private Object target; public CachedProviderHandler(Object target) { this.target = target; } public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { Type[] types = method.getParameterTypes(); //关键逻辑：当调用的是get方法时，我们就来发挥缓冲区的作用 if (method.getName().matches(\"get.+\") \u0026\u0026 (types.length == 1) \u0026\u0026 (types[0] == String.class)) { String key = (String) args[0]; Object value = cached.get(key); if (value == null) { value = method.invoke(target, args); cached.put(key, value); } return value; } return method.invoke(target, args); } } public abstract class ProviderFactory { public static FontProvider getFontProvider() { Class\u003cFontProvider\u003e targetClass = FontProvider.class; return (FontProvider) Proxy.newProxyInstance(targetClass.getClassLoader(), new Class[] { targetClass }, new CachedProviderHandler(new FontProviderFromDisk())); } } ","date":"2022-02-20","objectID":"/posts/java%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E8%AF%A6%E8%A7%A3/:3:2","tags":["Java动态代理详解"],"title":"Java动态代理详解","uri":"/posts/java%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E8%AF%A6%E8%A7%A3/"},{"categories":["Java底层原理"],"content":"总结 很明显，动态代理在需要大量静态代理的情况下，大大减少了重复劳作，动态代理yyds！(不知道C++如何去实现动态代理。。) ","date":"2022-02-20","objectID":"/posts/java%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E8%AF%A6%E8%A7%A3/:3:3","tags":["Java动态代理详解"],"title":"Java动态代理详解","uri":"/posts/java%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E8%AF%A6%E8%A7%A3/"},{"categories":["算法——排序原理运用"],"content":"PAT甲级--Insertion-or-Heap-Sort","date":"2022-02-19","objectID":"/posts/pat%E7%94%B2%E7%BA%A7-insertion-or-heap-sort/","tags":["PAT甲级--Insertion-or-Heap-Sort"],"title":"PAT甲级--Insertion-or-Heap-Sort","uri":"/posts/pat%E7%94%B2%E7%BA%A7-insertion-or-heap-sort/"},{"categories":["算法——排序原理运用"],"content":"题目 OJ平台 ","date":"2022-02-19","objectID":"/posts/pat%E7%94%B2%E7%BA%A7-insertion-or-heap-sort/:1:0","tags":["PAT甲级--Insertion-or-Heap-Sort"],"title":"PAT甲级--Insertion-or-Heap-Sort","uri":"/posts/pat%E7%94%B2%E7%BA%A7-insertion-or-heap-sort/"},{"categories":["算法——排序原理运用"],"content":"题目大意 有很多题目实际不需要看懂题目，只需要看懂输入和输出，比如这题。 此题虽然题目较为学术，且比较长，实际总结下来就是，通过给你一个原数组序列，还有一个用插入排序或者是堆排序排了几轮的数组序列，你要根据这个序列判断所使用的排序方式，并且再以该排序方式往下排一轮。 ","date":"2022-02-19","objectID":"/posts/pat%E7%94%B2%E7%BA%A7-insertion-or-heap-sort/:2:0","tags":["PAT甲级--Insertion-or-Heap-Sort"],"title":"PAT甲级--Insertion-or-Heap-Sort","uri":"/posts/pat%E7%94%B2%E7%BA%A7-insertion-or-heap-sort/"},{"categories":["算法——排序原理运用"],"content":"解题代码拆解 这次由于我使用的接口化函数设计，也就是传入指针进行操作，没有采用全局变量，所以直接input操作写在main函数里面，省空间。 ","date":"2022-02-19","objectID":"/posts/pat%E7%94%B2%E7%BA%A7-insertion-or-heap-sort/:3:0","tags":["PAT甲级--Insertion-or-Heap-Sort"],"title":"PAT甲级--Insertion-or-Heap-Sort","uri":"/posts/pat%E7%94%B2%E7%BA%A7-insertion-or-heap-sort/"},{"categories":["算法——排序原理运用"],"content":"关键的判断函数 isInsert() 设计思路：假设为插入排序后的序列，通过一次循环，找到下一个要被排序的元素位置，按理来说，没有被排序的位置应该和原数组的序列情况一致，如果不一致，则不是插入排序。 //用于确定是否为插入排序，顺便返回此时待插入处理的位置 int isInsert(int* nums, int len) { int i = 1; for (; i \u003c len; i++) { if (nums[i - 1] \u003e nums[i]) break; } for (int j = i; j \u003c len; j++) { if (original[j] != nums[j]) return -1; } return i; } ","date":"2022-02-19","objectID":"/posts/pat%E7%94%B2%E7%BA%A7-insertion-or-heap-sort/:3:1","tags":["PAT甲级--Insertion-or-Heap-Sort"],"title":"PAT甲级--Insertion-or-Heap-Sort","uri":"/posts/pat%E7%94%B2%E7%BA%A7-insertion-or-heap-sort/"},{"categories":["算法——排序原理运用"],"content":"堆排序和插入排序 插入排序 插入排序很简单，我这里直接写插入排序的每一轮处理函数来代替。 //插入排序的单步处理 void InsertSort(int* nums, int numSize, int i) { int j = i; int temp = nums[i]; for (; j \u003e 0 \u0026\u0026 nums[j - 1] \u003e temp; j--) { nums[j] = nums[j - 1]; } nums[j] = temp; } 堆排序 堆排序的原理： 对于一个完整的堆排序，分为两个过程：堆化+维持堆化。 建立大根堆，每次堆化找到最大值，为了维持堆的结构和排序，将堆顶与最后一个元素交换，然后更新堆的范围到 0~i-1 再次堆化，又能找到这个堆中的最大值，长此以往，便完成了排序。 对于堆排序中的每一轮：堆排中的每一轮都是缩小堆的范围，并继续维持大根堆，在堆范围以外的元素就是被排好的元素。所以重点在于从后往前找到已经排到了哪个位置，再进行一次交换和堆化便可完成一轮排序。 堆排的过程： 向下堆化的函数：sift_down() //堆化，得到大根堆 //对于从0开始编号的二叉堆: /* iparent = (i-1)/2, ilchild = i*2+1, irchild = i*2+2 */ void sift_down(int arr[], int start, int end) { // 计算父结点和子结点的下标 int parent = start; int child = parent * 2 + 1; while (child \u003c= end) { // 子结点下标在范围内才做比较 // 先比较两个子结点大小，选择最大的 if (child + 1 \u003c= end \u0026\u0026 arr[child] \u003c arr[child + 1]) child++; // 如果父结点比子结点大，代表调整完毕，直接跳出函数 if (arr[parent] \u003e= arr[child]) return; else { // 否则交换父子内容，子结点再和孙结点比较 swap(arr[parent], arr[child]); parent = child; child = parent * 2 + 1; } } } 先完全堆化，再利用它挑选最大值维持堆化的过程：heap_sort() void heap_sort(int arr[], int len) { // 从最后一个节点的父节点开始 sift down 以完成堆化 (heapify) for (int i = (len - 1 - 1) / 2; i \u003e= 0; i--) sift_down(arr, i, len - 1); // 先将第一个元素和已经排好的元素前一位做交换，再重新调整（刚调整的元素之前的元素），直到排序完毕 for (int i = len - 1; i \u003e 0; i--) { swap(arr[0], arr[i]); sift_down(arr, 0, i - 1); } } 方便更新下一轮堆排的工具： 确定堆排序到哪个位置的函数：findP //由于堆排是从后往前先得出最大值，所以直接从后往前判断最大值位置即可得出堆排排到了哪一轮 int findP(int* nums, int len) { int i = 0; for (; i \u003c len; i++) { int val = *max_element(nums, nums + len - i); if (nums[len - 1 - i] != val) break; } return len - 1 - i; } ","date":"2022-02-19","objectID":"/posts/pat%E7%94%B2%E7%BA%A7-insertion-or-heap-sort/:3:2","tags":["PAT甲级--Insertion-or-Heap-Sort"],"title":"PAT甲级--Insertion-or-Heap-Sort","uri":"/posts/pat%E7%94%B2%E7%BA%A7-insertion-or-heap-sort/"},{"categories":["算法——排序原理运用"],"content":"整合代码进行提交 效率还行！ #include \u003cbits/stdc++.h\u003eusing namespace std; int* original = nullptr; //插入排序的单步处理 void InsertSort(int* nums, int numSize, int i) { int j = i; int temp = nums[i]; for (; j \u003e 0 \u0026\u0026 nums[j - 1] \u003e temp; j--) { nums[j] = nums[j - 1]; } nums[j] = temp; } //堆排序 void sift_down(int arr[], int start, int end) { // 计算父结点和子结点的下标 int parent = start; int child = parent * 2 + 1; while (child \u003c= end) { // 子结点下标在范围内才做比较 // 先比较两个子结点大小，选择最大的 if (child + 1 \u003c= end \u0026\u0026 arr[child] \u003c arr[child + 1]) child++; // 如果父结点比子结点大，代表调整完毕，直接跳出函数 if (arr[parent] \u003e= arr[child]) return; else { // 否则交换父子内容，子结点再和孙结点比较 swap(arr[parent], arr[child]); parent = child; child = parent * 2 + 1; } } } //用于找出堆排已经拍到了哪个位置的最大值。 int findP(int* nums, int len) { int i = 0; for (; i \u003c len; i++) { int val = *max_element(nums, nums + len - i); if (nums[len - 1 - i] != val) break; } return len - 1 - i; } //用于确定是否为插入排序，顺便返回此时待插入处理的位置 int isInsert(int* nums, int len) { int i = 1; for (; i \u003c len; i++) { if (nums[i - 1] \u003e nums[i]) break; } for (int j = i; j \u003c len; j++) { if (original[j] != nums[j]) return -1; } return i; } //统一打印结果函数 void print(int* nums, int len) { cout \u003c\u003c nums[0]; for (int i = 1; i \u003c len; i++) { cout \u003c\u003c ' ' \u003c\u003c nums[i]; } } int main() { //@输入处理 ios::sync_with_stdio(false); int N; cin \u003e\u003e N; int org[N], nums[N]; for (int i = 0; i \u003c N; ++i) { cin \u003e\u003e org[i]; } for (int i = 0; i \u003c N; ++i) { cin \u003e\u003e nums[i]; } //@根据不同的排序方式进行答案的打印 original = org; int flag = isInsert(nums, N); if (flag != -1) { cout \u003c\u003c \"Insertion Sort\" \u003c\u003c endl; InsertSort(nums, N, flag); print(nums, N); } else { cout \u003c\u003c \"Heap Sort\" \u003c\u003c endl; int pos = findP(nums, N); swap(nums[0], nums[pos]); sift_down(nums, 0, pos - 1); print(nums, N); } return 0; } ","date":"2022-02-19","objectID":"/posts/pat%E7%94%B2%E7%BA%A7-insertion-or-heap-sort/:3:3","tags":["PAT甲级--Insertion-or-Heap-Sort"],"title":"PAT甲级--Insertion-or-Heap-Sort","uri":"/posts/pat%E7%94%B2%E7%BA%A7-insertion-or-heap-sort/"},{"categories":["算法——贪心"],"content":"堆的运用——有序元素的多路归并topk问题","date":"2022-02-19","objectID":"/posts/%E5%A0%86%E7%9A%84%E8%BF%90%E7%94%A8%E6%9C%89%E5%BA%8F%E5%85%83%E7%B4%A0%E7%9A%84%E5%A4%9A%E8%B7%AF%E5%BD%92%E5%B9%B6topk%E9%97%AE%E9%A2%98/","tags":["堆的运用——有序元素的多路归并topk问题"],"title":"堆的运用——有序元素的多路归并topk问题","uri":"/posts/%E5%A0%86%E7%9A%84%E8%BF%90%E7%94%A8%E6%9C%89%E5%BA%8F%E5%85%83%E7%B4%A0%E7%9A%84%E5%A4%9A%E8%B7%AF%E5%BD%92%E5%B9%B6topk%E9%97%AE%E9%A2%98/"},{"categories":["算法——贪心"],"content":"题目一：有序矩阵第k小的元素(提炼出做题方法) 题目链接 ","date":"2022-02-19","objectID":"/posts/%E5%A0%86%E7%9A%84%E8%BF%90%E7%94%A8%E6%9C%89%E5%BA%8F%E5%85%83%E7%B4%A0%E7%9A%84%E5%A4%9A%E8%B7%AF%E5%BD%92%E5%B9%B6topk%E9%97%AE%E9%A2%98/:1:0","tags":["堆的运用——有序元素的多路归并topk问题"],"title":"堆的运用——有序元素的多路归并topk问题","uri":"/posts/%E5%A0%86%E7%9A%84%E8%BF%90%E7%94%A8%E6%9C%89%E5%BA%8F%E5%85%83%E7%B4%A0%E7%9A%84%E5%A4%9A%E8%B7%AF%E5%BD%92%E5%B9%B6topk%E9%97%AE%E9%A2%98/"},{"categories":["算法——贪心"],"content":"解题技法 感觉这张图基本就清楚了这题目如何解。 具体详解过程请看lc大神：题目详解 ","date":"2022-02-19","objectID":"/posts/%E5%A0%86%E7%9A%84%E8%BF%90%E7%94%A8%E6%9C%89%E5%BA%8F%E5%85%83%E7%B4%A0%E7%9A%84%E5%A4%9A%E8%B7%AF%E5%BD%92%E5%B9%B6topk%E9%97%AE%E9%A2%98/:2:0","tags":["堆的运用——有序元素的多路归并topk问题"],"title":"堆的运用——有序元素的多路归并topk问题","uri":"/posts/%E5%A0%86%E7%9A%84%E8%BF%90%E7%94%A8%E6%9C%89%E5%BA%8F%E5%85%83%E7%B4%A0%E7%9A%84%E5%A4%9A%E8%B7%AF%E5%BD%92%E5%B9%B6topk%E9%97%AE%E9%A2%98/"},{"categories":["算法——贪心"],"content":"解题代码 class Solution { public: //TODO 多路归并 int kthSmallest(vector\u003cvector\u003cint\u003e\u003e\u0026 matrix, int k) { auto cmp = [\u0026](pair\u003cint,int\u003e\u0026a,pair\u003cint,int\u003e\u0026b){ return matrix[a.first][a.second]\u003ematrix[b.first][b.second]; }; priority_queue\u003cpair\u003cint,int\u003e,vector\u003cpair\u003cint,int\u003e\u003e,decltype(cmp)\u003epq(cmp); int n = matrix.size(); for(int i=0;i\u003cmin(k,n);i++){ pq.push({i,0});//TODO 得到第一次的行首元素 } int ret = INT_MAX; while(k--\u0026\u0026!pq.empty()){ auto [x,y] = pq.top();pq.pop(); if(y+1\u003cn)//TODO 更新这一行的下一个元素到堆中 pq.push({x,y+1}); ret = matrix[x][y]; } return ret; } }; ","date":"2022-02-19","objectID":"/posts/%E5%A0%86%E7%9A%84%E8%BF%90%E7%94%A8%E6%9C%89%E5%BA%8F%E5%85%83%E7%B4%A0%E7%9A%84%E5%A4%9A%E8%B7%AF%E5%BD%92%E5%B9%B6topk%E9%97%AE%E9%A2%98/:3:0","tags":["堆的运用——有序元素的多路归并topk问题"],"title":"堆的运用——有序元素的多路归并topk问题","uri":"/posts/%E5%A0%86%E7%9A%84%E8%BF%90%E7%94%A8%E6%9C%89%E5%BA%8F%E5%85%83%E7%B4%A0%E7%9A%84%E5%A4%9A%E8%B7%AF%E5%BD%92%E5%B9%B6topk%E9%97%AE%E9%A2%98/"},{"categories":["算法——贪心"],"content":"(进阶运用)题目二：查找和最小的K对数字 题目链接 ","date":"2022-02-19","objectID":"/posts/%E5%A0%86%E7%9A%84%E8%BF%90%E7%94%A8%E6%9C%89%E5%BA%8F%E5%85%83%E7%B4%A0%E7%9A%84%E5%A4%9A%E8%B7%AF%E5%BD%92%E5%B9%B6topk%E9%97%AE%E9%A2%98/:4:0","tags":["堆的运用——有序元素的多路归并topk问题"],"title":"堆的运用——有序元素的多路归并topk问题","uri":"/posts/%E5%A0%86%E7%9A%84%E8%BF%90%E7%94%A8%E6%9C%89%E5%BA%8F%E5%85%83%E7%B4%A0%E7%9A%84%E5%A4%9A%E8%B7%AF%E5%BD%92%E5%B9%B6topk%E9%97%AE%E9%A2%98/"},{"categories":["算法——贪心"],"content":"题目解析 和前面那道题的做法一样，这道题是由于者均有序，所以如果是直接进行两层循环的枚举的话，得到的数字可以看作是一个和上题一模一样的矩阵，也就是把 nums1[0...]+nums2[0] 看作是一行的首元素即可，然后处理过程就和前面的处理过程是完全一致。和前面一题的区别仅仅在于未有确定矩阵的内容而已，而我们需要做的就是确定这个矩阵的内容！ 细节优化：由于矩阵的内容由我们来确定，为了防止初始化矩阵首行元素过多，我们可以采取把长度小的 nums 作为行的标准，那么为了让每次的答案顺序不变，所以需要一个标记。 ","date":"2022-02-19","objectID":"/posts/%E5%A0%86%E7%9A%84%E8%BF%90%E7%94%A8%E6%9C%89%E5%BA%8F%E5%85%83%E7%B4%A0%E7%9A%84%E5%A4%9A%E8%B7%AF%E5%BD%92%E5%B9%B6topk%E9%97%AE%E9%A2%98/:5:0","tags":["堆的运用——有序元素的多路归并topk问题"],"title":"堆的运用——有序元素的多路归并topk问题","uri":"/posts/%E5%A0%86%E7%9A%84%E8%BF%90%E7%94%A8%E6%9C%89%E5%BA%8F%E5%85%83%E7%B4%A0%E7%9A%84%E5%A4%9A%E8%B7%AF%E5%BD%92%E5%B9%B6topk%E9%97%AE%E9%A2%98/"},{"categories":["算法——贪心"],"content":"解题代码 class Solution { public: bool flag = true; vector\u003cvector\u003cint\u003e\u003e kSmallestPairs(vector\u003cint\u003e\u0026 nums1, vector\u003cint\u003e\u0026 nums2, int k) { vector\u003cvector\u003cint\u003e\u003e ans; int n = nums1.size(), m = nums2.size(); if(n \u003e m) { //始终确保nums1为两数组中长度较少的那个(这样做可以适当的减少堆的初始大小)，这个不处理也可以，只是简单的优化 swap(nums1, nums2); swap(m,n); flag = false;//确保原本的第一个取数的数字时nums1原本的数字 } //定义比较规则 auto cmp = [\u0026](const auto\u0026 a, const auto\u0026 b){ return nums1[a.first] + nums2[a.second] \u003e nums1[b.first] + nums2[b.second]; }; priority_queue\u003c pair\u003cint,int\u003e, vector\u003cpair\u003cint,int\u003e\u003e, decltype(cmp) \u003e q(cmp); for(int i = 0; i \u003c min(n,k); i++){ q.push( {i, 0} ); } while(k-- and !q.empty()){ auto [a,b] = q.top(); q.pop(); flag ? ans.push_back( {nums1[a], nums2[b]}) : ans.push_back( {nums2[b], nums1[a]}); //TODO 得到这一行的下一个元素，如果超过则不入 if(b + 1 \u003c m) q.push( {a, b + 1} ); } return ans; } }; ","date":"2022-02-19","objectID":"/posts/%E5%A0%86%E7%9A%84%E8%BF%90%E7%94%A8%E6%9C%89%E5%BA%8F%E5%85%83%E7%B4%A0%E7%9A%84%E5%A4%9A%E8%B7%AF%E5%BD%92%E5%B9%B6topk%E9%97%AE%E9%A2%98/:6:0","tags":["堆的运用——有序元素的多路归并topk问题"],"title":"堆的运用——有序元素的多路归并topk问题","uri":"/posts/%E5%A0%86%E7%9A%84%E8%BF%90%E7%94%A8%E6%9C%89%E5%BA%8F%E5%85%83%E7%B4%A0%E7%9A%84%E5%A4%9A%E8%B7%AF%E5%BD%92%E5%B9%B6topk%E9%97%AE%E9%A2%98/"},{"categories":["算法——排序原理运用"],"content":"归并的运用——计算逆序对","date":"2022-02-19","objectID":"/posts/%E5%BD%92%E5%B9%B6%E7%9A%84%E8%BF%90%E7%94%A8%E8%AE%A1%E7%AE%97%E9%80%86%E5%BA%8F%E5%AF%B9/","tags":["归并的运用——计算逆序数"],"title":"归并的运用——计算逆序数","uri":"/posts/%E5%BD%92%E5%B9%B6%E7%9A%84%E8%BF%90%E7%94%A8%E8%AE%A1%E7%AE%97%E9%80%86%E5%BA%8F%E5%AF%B9/"},{"categories":["算法——排序原理运用"],"content":"题目 题目链接 ","date":"2022-02-19","objectID":"/posts/%E5%BD%92%E5%B9%B6%E7%9A%84%E8%BF%90%E7%94%A8%E8%AE%A1%E7%AE%97%E9%80%86%E5%BA%8F%E5%AF%B9/:1:0","tags":["归并的运用——计算逆序数"],"title":"归并的运用——计算逆序数","uri":"/posts/%E5%BD%92%E5%B9%B6%E7%9A%84%E8%BF%90%E7%94%A8%E8%AE%A1%E7%AE%97%E9%80%86%E5%BA%8F%E5%AF%B9/"},{"categories":["算法——排序原理运用"],"content":"题目解析 很明显此题的问题规模来到了 1e5 的级别，显然不是 O(n^2) 的暴力方式能够解决的。 具体的详细解析，这里有力扣大神在：题目解析 我这里把最关键的图解过程扣了下来： ","date":"2022-02-19","objectID":"/posts/%E5%BD%92%E5%B9%B6%E7%9A%84%E8%BF%90%E7%94%A8%E8%AE%A1%E7%AE%97%E9%80%86%E5%BA%8F%E5%AF%B9/:2:0","tags":["归并的运用——计算逆序数"],"title":"归并的运用——计算逆序数","uri":"/posts/%E5%BD%92%E5%B9%B6%E7%9A%84%E8%BF%90%E7%94%A8%E8%AE%A1%E7%AE%97%E9%80%86%E5%BA%8F%E5%AF%B9/"},{"categories":["算法——排序原理运用"],"content":"解题代码 配上这简洁清晰的解题代码： class Solution { public: int reversePairs(vector\u003cint\u003e\u0026 nums) { vector\u003cint\u003e tmp(nums.size()); return mergeSort(0, nums.size() - 1, nums, tmp); } private: int mergeSort(int l, int r, vector\u003cint\u003e\u0026 nums, vector\u003cint\u003e\u0026 tmp) { // 终止条件 if (l \u003e= r) return 0; // 递归划分 int m = (l + r) / 2; int res = mergeSort(l, m, nums, tmp) + mergeSort(m + 1, r, nums, tmp); // 合并阶段 int i = l, j = m + 1; for (int k = l; k \u003c= r; k++) tmp[k] = nums[k]; for (int k = l; k \u003c= r; k++) { if (i == m + 1) nums[k] = tmp[j++]; else if (j == r + 1 || tmp[i] \u003c= tmp[j]) nums[k] = tmp[i++]; else { nums[k] = tmp[j++]; res += m - i + 1; // 统计逆序对 } } return res; } }; ","date":"2022-02-19","objectID":"/posts/%E5%BD%92%E5%B9%B6%E7%9A%84%E8%BF%90%E7%94%A8%E8%AE%A1%E7%AE%97%E9%80%86%E5%BA%8F%E5%AF%B9/:3:0","tags":["归并的运用——计算逆序数"],"title":"归并的运用——计算逆序数","uri":"/posts/%E5%BD%92%E5%B9%B6%E7%9A%84%E8%BF%90%E7%94%A8%E8%AE%A1%E7%AE%97%E9%80%86%E5%BA%8F%E5%AF%B9/"},{"categories":["算法——排序原理运用"],"content":"煎饼排序——选择排序的运用","date":"2022-02-19","objectID":"/posts/%E7%85%8E%E9%A5%BC%E6%8E%92%E5%BA%8F%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%E7%9A%84%E8%BF%90%E7%94%A8/","tags":["煎饼排序——选择排序的运用"],"title":"煎饼排序——选择排序的运用","uri":"/posts/%E7%85%8E%E9%A5%BC%E6%8E%92%E5%BA%8F%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%E7%9A%84%E8%BF%90%E7%94%A8/"},{"categories":["算法——排序原理运用"],"content":"题目 题目链接 ","date":"2022-02-19","objectID":"/posts/%E7%85%8E%E9%A5%BC%E6%8E%92%E5%BA%8F%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%E7%9A%84%E8%BF%90%E7%94%A8/:1:0","tags":["煎饼排序——选择排序的运用"],"title":"煎饼排序——选择排序的运用","uri":"/posts/%E7%85%8E%E9%A5%BC%E6%8E%92%E5%BA%8F%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%E7%9A%84%E8%BF%90%E7%94%A8/"},{"categories":["算法——排序原理运用"],"content":"解题思路 读懂题目： 此题并不是要我们求出类似于示例所给的最优情况的方式得出答案。 他只要能够翻转成有序的操作序列即可。 故我们可以按照选择排序的思路，利用翻转能够将首尾交换，来进行两次翻转把最大值移动到最后的位置，第一次翻转到首位，第二次翻转到后面的位置即可。 具体例子： 例如:[3,2,4,1]—-\u003e[?,?,?,4] 我们可以先找到数字4的位置,将数字4前进行翻转变成[4,2,3,1],接下来我们在整体翻转[1,3,2,4],这样我们把数字4移动列表底. 然后,我们[1,3,2,4]—\u003e[?,?,3,4],还是用刚才方法,首先找到数字3,翻转数字3前面的,再翻转已经排好数字(这里指数字4)前就可以了. ","date":"2022-02-19","objectID":"/posts/%E7%85%8E%E9%A5%BC%E6%8E%92%E5%BA%8F%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%E7%9A%84%E8%BF%90%E7%94%A8/:2:0","tags":["煎饼排序——选择排序的运用"],"title":"煎饼排序——选择排序的运用","uri":"/posts/%E7%85%8E%E9%A5%BC%E6%8E%92%E5%BA%8F%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%E7%9A%84%E8%BF%90%E7%94%A8/"},{"categories":["算法——排序原理运用"],"content":"解题代码 class Solution { public: vector\u003cint\u003e pancakeSort(vector\u003cint\u003e \u0026arr) { int n = arr.size(); vector\u003cint\u003e ret; while (n \u003e 1) { if (arr[n - 1] != n) { int index = find_if(arr.begin(), arr.end(), [n](auto \u0026num) { if (num == n) return true; return false; }) - arr.begin(); ret.push_back(index + 1); ret.push_back(n); reverse(arr.begin(), arr.begin() + index + 1); reverse(arr.begin(), arr.begin() + n); } --n; } return ret; } }; ","date":"2022-02-19","objectID":"/posts/%E7%85%8E%E9%A5%BC%E6%8E%92%E5%BA%8F%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%E7%9A%84%E8%BF%90%E7%94%A8/:3:0","tags":["煎饼排序——选择排序的运用"],"title":"煎饼排序——选择排序的运用","uri":"/posts/%E7%85%8E%E9%A5%BC%E6%8E%92%E5%BA%8F%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%E7%9A%84%E8%BF%90%E7%94%A8/"},{"categories":["算法——排序原理运用"],"content":"高频面试考点(考察分治思想)：合并k个排序链表","date":"2022-02-19","objectID":"/posts/%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E8%80%83%E7%82%B9%E8%80%83%E5%AF%9F%E5%88%86%E6%B2%BB%E6%80%9D%E6%83%B3%E5%90%88%E5%B9%B6k%E4%B8%AA%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8/","tags":["高频面试考点(考察分治思想)：合并k个排序链表"],"title":"高频面试考点(考察分治思想)：合并k个排序链表","uri":"/posts/%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E8%80%83%E7%82%B9%E8%80%83%E5%AF%9F%E5%88%86%E6%B2%BB%E6%80%9D%E6%83%B3%E5%90%88%E5%B9%B6k%E4%B8%AA%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8/"},{"categories":["算法——排序原理运用"],"content":"题目 题目解析 很明显，这种多个有序链表的排序可以分解为，两个过程： 合并两个有序链表的函数。 实现多次调用合并两个有序链表。 关于分治法如何优化该过程的？很明显如果直接从左往右调用多次合并两个有序链表来实现需要调用n-1次，而分治法通过先把数组分割成两个数组元素为一个基本的操作对象，那么很明显可以优化为调用logn次。 以下是两种方式的时间差距： 解题代码 朴素解法 class Solution { public: ListNode* mergeKLists(vector\u003cListNode*\u003e\u0026 lists) { int size = lists.size(); if(size==0) return nullptr; ListNode* res = lists[0]; for(int i=1;i\u003csize;i++){ res = mergeTwo(res,lists[i]); } return res; } private: ListNode* mergeTwo(ListNode* a,ListNode* b){ ListNode h; ListNode * head = \u0026h; ListNode* res = head; while(a\u0026\u0026b){ if(a-\u003eval\u003eb-\u003eval){ head-\u003enext = b; b = b-\u003enext; head = head-\u003enext; }else{ head-\u003enext = a; a = a-\u003enext; head = head-\u003enext; } } if(b){ head-\u003enext = b; }else{ head-\u003enext = a; } return res-\u003enext; } }; 分治法 class Solution { public: ListNode* mergeKLists(vector\u003cListNode*\u003e\u0026 lists) { return merge(lists,0,lists.size()-1); } private: ListNode* merge(vector \u003cListNode*\u003e \u0026lists, int l, int r) { if (l == r) return lists[l]; if (l \u003e r) return nullptr; int mid = (l + r) \u003e\u003e 1; //开始分治 return mergeTwo(merge(lists, l, mid), merge(lists, mid + 1, r)); } ListNode* mergeTwo(ListNode* a,ListNode* b){ ListNode h; ListNode * head = \u0026h; ListNode* res = head; while(a\u0026\u0026b){ if(a-\u003eval\u003eb-\u003eval){ head-\u003enext = b; b = b-\u003enext; head = head-\u003enext; }else{ head-\u003enext = a; a = a-\u003enext; head = head-\u003enext; } } if(b){ head-\u003enext = b; }else{ head-\u003enext = a; } return res-\u003enext; } }; ","date":"2022-02-19","objectID":"/posts/%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E8%80%83%E7%82%B9%E8%80%83%E5%AF%9F%E5%88%86%E6%B2%BB%E6%80%9D%E6%83%B3%E5%90%88%E5%B9%B6k%E4%B8%AA%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8/:0:0","tags":["高频面试考点(考察分治思想)：合并k个排序链表"],"title":"高频面试考点(考察分治思想)：合并k个排序链表","uri":"/posts/%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E8%80%83%E7%82%B9%E8%80%83%E5%AF%9F%E5%88%86%E6%B2%BB%E6%80%9D%E6%83%B3%E5%90%88%E5%B9%B6k%E4%B8%AA%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8/"},{"categories":["算法——动态规划"],"content":"骑士在棋盘上的概率——dp棋盘概率题","date":"2022-02-18","objectID":"/posts/%E9%AA%91%E5%A3%AB%E5%9C%A8%E6%A3%8B%E7%9B%98%E4%B8%8A%E7%9A%84%E6%A6%82%E7%8E%87dp%E6%A3%8B%E7%9B%98%E6%A6%82%E7%8E%87%E9%A2%98/","tags":["骑士在棋盘上的概率——dp棋盘概率题"],"title":"骑士在棋盘上的概率——dp棋盘概率题","uri":"/posts/%E9%AA%91%E5%A3%AB%E5%9C%A8%E6%A3%8B%E7%9B%98%E4%B8%8A%E7%9A%84%E6%A6%82%E7%8E%87dp%E6%A3%8B%E7%9B%98%E6%A6%82%E7%8E%87%E9%A2%98/"},{"categories":["算法——动态规划"],"content":"题目 题目链接 ","date":"2022-02-18","objectID":"/posts/%E9%AA%91%E5%A3%AB%E5%9C%A8%E6%A3%8B%E7%9B%98%E4%B8%8A%E7%9A%84%E6%A6%82%E7%8E%87dp%E6%A3%8B%E7%9B%98%E6%A6%82%E7%8E%87%E9%A2%98/:1:0","tags":["骑士在棋盘上的概率——dp棋盘概率题"],"title":"骑士在棋盘上的概率——dp棋盘概率题","uri":"/posts/%E9%AA%91%E5%A3%AB%E5%9C%A8%E6%A3%8B%E7%9B%98%E4%B8%8A%E7%9A%84%E6%A6%82%E7%8E%87dp%E6%A3%8B%E7%9B%98%E6%A6%82%E7%8E%87%E9%A2%98/"},{"categories":["算法——动态规划"],"content":"题目详解 一个骑士有 $8$ 种可能的走法，骑士会从中以等概率随机选择一种。部分走法可能会让骑士离开棋盘，另外的走法则会让骑士移动到棋盘的其他位置，并且剩余的移动次数会减少 1。 定义 $dp[step][i][j]$ 表示其实从棋盘商店的点 $(i,j)$ 出发，走了 $step$ 步时仍然留在棋盘上的概率。 当点 $(i,j)$ 不在棋盘上的时候，$dp[step][i][j] = 0;$ 当点 $(i,j)$ 在棋盘上且 $step = 0$ 时，$dp[step][i][j]=1$ 。 对于其他情况，$dp[step][i][j]=1/8×∑dp[step-1][i+di][j+dj]$。 其中$(di,dj)$ 表示走法对坐标的偏移量，具体为 $(−2,−1),(−2,1),(2,−1),(2,1),(−1,−2),(−1,2),(1,−2),(1,2)$ 共 $8$ 种。 ","date":"2022-02-18","objectID":"/posts/%E9%AA%91%E5%A3%AB%E5%9C%A8%E6%A3%8B%E7%9B%98%E4%B8%8A%E7%9A%84%E6%A6%82%E7%8E%87dp%E6%A3%8B%E7%9B%98%E6%A6%82%E7%8E%87%E9%A2%98/:2:0","tags":["骑士在棋盘上的概率——dp棋盘概率题"],"title":"骑士在棋盘上的概率——dp棋盘概率题","uri":"/posts/%E9%AA%91%E5%A3%AB%E5%9C%A8%E6%A3%8B%E7%9B%98%E4%B8%8A%E7%9A%84%E6%A6%82%E7%8E%87dp%E6%A3%8B%E7%9B%98%E6%A6%82%E7%8E%87%E9%A2%98/"},{"categories":["算法——动态规划"],"content":"解题代码 class Solution { public: vector\u003cvector\u003cint\u003e\u003e dirs = {{-2, -1}, {-2, 1}, {2, -1}, {2, 1}, {-1, -2}, {-1, 2}, {1, -2}, {1, 2}}; double knightProbability(int n, int k, int row, int column) { vector\u003cvector\u003cvector\u003cdouble\u003e\u003e\u003e dp(k + 1, vector\u003cvector\u003cdouble\u003e\u003e(n, vector\u003cdouble\u003e(n))); for (int step = 0; step \u003c= k; step++) { for (int i = 0; i \u003c n; i++) { for (int j = 0; j \u003c n; j++) { if (step == 0) { dp[step][i][j] = 1; } else { for (auto \u0026 dir : dirs) { int ni = i + dir[0], nj = j + dir[1]; if (ni \u003e= 0 \u0026\u0026 ni \u003c n \u0026\u0026 nj \u003e= 0 \u0026\u0026 nj \u003c n) { dp[step][i][j] += dp[step - 1][ni][nj] / 8; } } } } } } return dp[k][row][column]; } }; ","date":"2022-02-18","objectID":"/posts/%E9%AA%91%E5%A3%AB%E5%9C%A8%E6%A3%8B%E7%9B%98%E4%B8%8A%E7%9A%84%E6%A6%82%E7%8E%87dp%E6%A3%8B%E7%9B%98%E6%A6%82%E7%8E%87%E9%A2%98/:3:0","tags":["骑士在棋盘上的概率——dp棋盘概率题"],"title":"骑士在棋盘上的概率——dp棋盘概率题","uri":"/posts/%E9%AA%91%E5%A3%AB%E5%9C%A8%E6%A3%8B%E7%9B%98%E4%B8%8A%E7%9A%84%E6%A6%82%E7%8E%87dp%E6%A3%8B%E7%9B%98%E6%A6%82%E7%8E%87%E9%A2%98/"},{"categories":["手写数据结构"],"content":"C++手撕哈希表详解","date":"2022-02-16","objectID":"/posts/c++%E6%89%8B%E6%92%95%E5%93%88%E5%B8%8C%E8%A1%A8%E8%AF%A6%E8%A7%A3/","tags":["C/C++手撕哈希表详解"],"title":"C/C++手撕哈希表详解","uri":"/posts/c++%E6%89%8B%E6%92%95%E5%93%88%E5%B8%8C%E8%A1%A8%E8%AF%A6%E8%A7%A3/"},{"categories":["手写数据结构"],"content":"关于实现源码 实现源码仓库在线查看链接： C语言实现 C++实现 ","date":"2022-02-16","objectID":"/posts/c++%E6%89%8B%E6%92%95%E5%93%88%E5%B8%8C%E8%A1%A8%E8%AF%A6%E8%A7%A3/:0:0","tags":["C/C++手撕哈希表详解"],"title":"C/C++手撕哈希表详解","uri":"/posts/c++%E6%89%8B%E6%92%95%E5%93%88%E5%B8%8C%E8%A1%A8%E8%AF%A6%E8%A7%A3/"},{"categories":["手写数据结构"],"content":"哈希表的理论知识 ","date":"2022-02-16","objectID":"/posts/c++%E6%89%8B%E6%92%95%E5%93%88%E5%B8%8C%E8%A1%A8%E8%AF%A6%E8%A7%A3/:1:0","tags":["C/C++手撕哈希表详解"],"title":"C/C++手撕哈希表详解","uri":"/posts/c++%E6%89%8B%E6%92%95%E5%93%88%E5%B8%8C%E8%A1%A8%E8%AF%A6%E8%A7%A3/"},{"categories":["手写数据结构"],"content":"哈希表的定义 哈希表也叫散列表，我们先来看看哈希表的定义： 哈希表是保存键值映射关系的查找表，通过关键字可以很快找到对应的值。 简单说来说，哈希表由两个要素构成：桶数组 和 散列函数（哈希函数）。 桶数组：用于存储键值对的空间。 散列函数：用于给键值对在桶数组中的位置指路。 ","date":"2022-02-16","objectID":"/posts/c++%E6%89%8B%E6%92%95%E5%93%88%E5%B8%8C%E8%A1%A8%E8%AF%A6%E8%A7%A3/:1:1","tags":["C/C++手撕哈希表详解"],"title":"C/C++手撕哈希表详解","uri":"/posts/c++%E6%89%8B%E6%92%95%E5%93%88%E5%B8%8C%E8%A1%A8%E8%AF%A6%E8%A7%A3/"},{"categories":["手写数据结构"],"content":"桶数组 我们可能知道，有一类基础的数据结构 线性表，而线性表又分两种，数组 和 链表。 哈希表数据结构里，存储元素的数据结构就是数组，数组里的每个单元都可以想象成一个 桶（Bucket）。 而我们每次都是把我们需要存入的键值对加入到这样的桶子中。 ","date":"2022-02-16","objectID":"/posts/c++%E6%89%8B%E6%92%95%E5%93%88%E5%B8%8C%E8%A1%A8%E8%AF%A6%E8%A7%A3/:1:2","tags":["C/C++手撕哈希表详解"],"title":"C/C++手撕哈希表详解","uri":"/posts/c++%E6%89%8B%E6%92%95%E5%93%88%E5%B8%8C%E8%A1%A8%E8%AF%A6%E8%A7%A3/"},{"categories":["手写数据结构"],"content":"散列函数 我们需要在元素和 桶数组 对应位置建立一种映射映射关系，这种映射关系就是 散列函数 ，也可以叫哈希函数。 比如我们平时生活中，碰到排队型的时候，都需要根据高矮来进行一定的队形调整，这个调整过程也可以看做是散列函数的一种体现。 散列函数的构造 散列函数有很多类，这其中的奥妙来自于数学，而不是我们程序员需要过于操心的事情。 在Java语言中只要是继承自Object类的所有类都有默认的一个 hashcode() 方法，而对于具体过程我们不需要多想，我们来看看最常用的字符串的哈希过程： static inline size_t strHashcode(char *key) { size_t hash = 0; size_t index = 0; while (key[index] != '\\0') { hash = hash * 31 + key[index++]; } return hash; } 很明显得出的 hashcode 是一个以31为底的次方数，关于为什么以31为底，我这里简单的描述一下： 以31为底能很快得出比较散且比较大的二进制码（底层的01串），这样结合子掩码的与运算有利于减少哈希冲突的产生。 31 * i == (i \u003c\u003c 5) - i 因为这个等式的成立使得运算性能也有很大的提升。（编译器一般会对 31*i 进行优化的） 更多细节看看这篇文章：关于为什么选31 扰动函数 和 按位与 我们通过散列函数得到一堆 01 串后，我们该怎么做？ 接下来一般就是通过和桶数组的长度取余然后得到对应的位置进行插入。这样虽然也可以，但我们有更好的方式进行替代，那就是位运算。 既然要讲位运算，那么我先讲讲一个二进制串。 在只有一个 1 的二进制串里面，我们对它再减去 1 的时候，我们很快得到它的低位掩码。 比如： 0001000 - 1 = 0000111，得到的 0000111 有什么用处呢？ 如果我们把一个 hashcode 和这个数进行按位与，则得到的结果肯定是介于 000~111 之间，也就是 0~7 之间，这个时候我们思考一下，如果把这个 0001000 看做是桶数组的长度，那么这个按位与的结果就可以当做需要存入的桶的具体位置了。 基于这个理论，我们只要桶数组长度是 2的倍数 则 hashcode%size 可用 hashcode\u0026(size-1) 来替代。 这样做有以下好处： 位运算的性能更好。 便于控制 hashcode 最终得出的结果，有些时候我们得到的 hashcode不够均匀 高位的1比较多，而低位的1比较少，这个时候可以利用 hashcode^(hashcode\u003e\u003e16) 进行一定程度的打散，而这个打散的过程我们一般把它叫做 扰动函数 。 哈希冲突 当出现键值运算结果得到的桶子位置是同一个的时候便产生了哈希冲突。 而解决哈希冲突的方案一般有以下三种： 链地址法 一旦发生哈希冲突，直接生成链表往后继续延伸。 开放地址法 简单来说就是给冲突的元素再在桶数组里找到一个空闲的位置。 而常用采用的方法有： 线性探查法: 从冲突的位置开始，依次判断下一个位置是否空闲，直至找到空闲位置。 平方探查法: 从冲突的位置x开始，第一次增加 1^2 个位置，第二次增加 2^2…，直至找到空闲的位置。 双散列函数探查法 …… 再哈希法 再哈希法完全可以配备以上两类方法进行使用。 当然也可单独使用，单独使用的话就行配备多个哈希函数，一个不行的话换另一个哈希函数，直到不产生哈希冲突为止。 最终的选择： 而我们常用的是 链地址法 + 再哈希 ，为了能够尽量减少内存空间的使用，我们默认从容量为 16 的桶数组开始，一旦装入的键值对超过 capacity * factor 个时，我们进行一次两倍的（左移1位）扩容，而由于扩容会导致 capacity 改变，所以通过 哈希函数 + 与运算 得出的位置也会出错，故需要经过 再哈希 。 我们其实可以继续细想，我们左移一位后，得出的结果再减一，它也仅仅多出一位掩码，而我们的 hashcode 只要在这一位上为 0 则最后得到的桶位置不会有任何改变，只有在这一位上为 1 的才会发生改变，所以根据这个特点，Java 8 进行了一些优化，更厉害的优化方式在于，只要链比较长，它还会转红黑树（这就在我的能力范围之外了）。 以上内容参考的文章为：一个HashMap和面试官扯了半小时 ","date":"2022-02-16","objectID":"/posts/c++%E6%89%8B%E6%92%95%E5%93%88%E5%B8%8C%E8%A1%A8%E8%AF%A6%E8%A7%A3/:1:3","tags":["C/C++手撕哈希表详解"],"title":"C/C++手撕哈希表详解","uri":"/posts/c++%E6%89%8B%E6%92%95%E5%93%88%E5%B8%8C%E8%A1%A8%E8%AF%A6%E8%A7%A3/"},{"categories":["手写数据结构"],"content":"HashMap实现 ","date":"2022-02-16","objectID":"/posts/c++%E6%89%8B%E6%92%95%E5%93%88%E5%B8%8C%E8%A1%A8%E8%AF%A6%E8%A7%A3/:2:0","tags":["C/C++手撕哈希表详解"],"title":"C/C++手撕哈希表详解","uri":"/posts/c++%E6%89%8B%E6%92%95%E5%93%88%E5%B8%8C%E8%A1%A8%E8%AF%A6%E8%A7%A3/"},{"categories":["手写数据结构"],"content":"类型定义（键值对以及对应节点） C #define DEFAULT_CAPACITY 16 //初始的表长 #define DEFAULT_FACTOR 0.75f //初始的装载因子 /*类型定义 和 装载因子初始化*/ typedef int key_t; typedef int val_t; static const float factor = DEFAULT_FACTOR; //装载因子 typedef struct node {//每个哈希表的键值对 key_t key; val_t val; struct node *next; } Node; C++ 全程用的泛型模板 ","date":"2022-02-16","objectID":"/posts/c++%E6%89%8B%E6%92%95%E5%93%88%E5%B8%8C%E8%A1%A8%E8%AF%A6%E8%A7%A3/:2:1","tags":["C/C++手撕哈希表详解"],"title":"C/C++手撕哈希表详解","uri":"/posts/c++%E6%89%8B%E6%92%95%E5%93%88%E5%B8%8C%E8%A1%A8%E8%AF%A6%E8%A7%A3/"},{"categories":["手写数据结构"],"content":"哈希表的数据 C typedef struct { size_t size; //记录已经存下的键值对数目 size_t capacity; //记录表长 Node **buckets; //桶子：用于记录的哈希桶，桶子中每个元素是Node* } HashMap; C++ ","date":"2022-02-16","objectID":"/posts/c++%E6%89%8B%E6%92%95%E5%93%88%E5%B8%8C%E8%A1%A8%E8%AF%A6%E8%A7%A3/:2:2","tags":["C/C++手撕哈希表详解"],"title":"C/C++手撕哈希表详解","uri":"/posts/c++%E6%89%8B%E6%92%95%E5%93%88%E5%B8%8C%E8%A1%A8%E8%AF%A6%E8%A7%A3/"},{"categories":["手写数据结构"],"content":"初始化方法（构造方法） C HashMap *init() { //初始化得到一个哈希表 HashMap *ret = (HashMap *) malloc(sizeof(HashMap)); assert(ret != NULL); ret-\u003esize = 0; ret-\u003ecapacity = DEFAULT_CAPACITY; ret-\u003ebuckets = (Node **) calloc(DEFAULT_CAPACITY, sizeof(Node *)); assert(ret-\u003ebuckets != NULL); return ret; } C++ ","date":"2022-02-16","objectID":"/posts/c++%E6%89%8B%E6%92%95%E5%93%88%E5%B8%8C%E8%A1%A8%E8%AF%A6%E8%A7%A3/:2:3","tags":["C/C++手撕哈希表详解"],"title":"C/C++手撕哈希表详解","uri":"/posts/c++%E6%89%8B%E6%92%95%E5%93%88%E5%B8%8C%E8%A1%A8%E8%AF%A6%E8%A7%A3/"},{"categories":["手写数据结构"],"content":"根据散列函数得到位置 C static inline size_t getHashcode(key_t key) { return key ^ (key \u003e\u003e 16);//这是32位数的扰动函数 } static inline size_t getIndex(key_t key, size_t bucket_size) {//由于bucketsize一定是2的次方，所以size-1和key相与得到的就是下标 return getHashcode(key) \u0026 (bucket_size - 1); } C++ ","date":"2022-02-16","objectID":"/posts/c++%E6%89%8B%E6%92%95%E5%93%88%E5%B8%8C%E8%A1%A8%E8%AF%A6%E8%A7%A3/:2:4","tags":["C/C++手撕哈希表详解"],"title":"C/C++手撕哈希表详解","uri":"/posts/c++%E6%89%8B%E6%92%95%E5%93%88%E5%B8%8C%E8%A1%A8%E8%AF%A6%E8%A7%A3/"},{"categories":["手写数据结构"],"content":"put方法 C void put(HashMap *map, key_t key, val_t val) { assert(map != NULL); //判断是否需要扩容 if (map-\u003esize \u003e= map-\u003ecapacity * factor) resize(map); putVal(key, val, map-\u003ebuckets, \u0026map-\u003esize, map-\u003ecapacity); } static void putVal(key_t key, val_t val, Node **buckets, size_t *returnSize, size_t bucketSize) { //获取位置 size_t index = getIndex(key, bucketSize); Node *node = buckets[index]; if (node == NULL) {//插入位置为空 node = (Node *) malloc(sizeof(Node)); assert(node != NULL); node-\u003eval = val; node-\u003ekey = key; node-\u003enext = NULL; buckets[index] = node; (*returnSize)++; //哈希表内的元素增加 return; } //插入位置不为空，说明发生冲突，使用链地址法，遍历链表 while (node != NULL) { //如果key相同就覆盖 if (node-\u003ekey == key) { node-\u003eval = val; return; } node = node-\u003enext; } //当前的key不在链表中，则插入链表头部 Node *newNode = (Node *) malloc(sizeof(Node)); assert(newNode != NULL); newNode-\u003enext = buckets[index]; buckets[index] = newNode; (*returnSize)++; //哈希表内元素增加 } C++ ","date":"2022-02-16","objectID":"/posts/c++%E6%89%8B%E6%92%95%E5%93%88%E5%B8%8C%E8%A1%A8%E8%AF%A6%E8%A7%A3/:2:5","tags":["C/C++手撕哈希表详解"],"title":"C/C++手撕哈希表详解","uri":"/posts/c++%E6%89%8B%E6%92%95%E5%93%88%E5%B8%8C%E8%A1%A8%E8%AF%A6%E8%A7%A3/"},{"categories":["手写数据结构"],"content":"扩容方法 C static void resize(HashMap *map) { map-\u003ecapacity \u003c\u003c= 1; //扩大两倍容量，相当于左移一位 Node **tmp = map-\u003ebuckets; //存下之前的内存地址 map-\u003ebuckets = (Node **) calloc(map-\u003ecapacity, sizeof(Node *)); //重新分配 assert(map-\u003ebuckets != NULL); rehash(map, tmp);//重新哈希处理 free(tmp); //释放之前的内存 } static void rehash(HashMap *map, Node **preTable) {//采取java1.7的方式进行rehash也就是最简单直接的直接重新哈希插入 size_t preCap = map-\u003ecapacity / 2; //改变前的有效区域 for (size_t i = 0; i \u003c preCap; i++) { if (preTable[i] != NULL) {//判断对应的key是否需要重新换位置,如果对最新掩码多出来的1敏感则需要rehash Node *preNode; Node *curNode = preTable[i]; while (curNode != NULL) { preNode = curNode; curNode = curNode-\u003enext; insert(map, preNode); } } } } C++ ","date":"2022-02-16","objectID":"/posts/c++%E6%89%8B%E6%92%95%E5%93%88%E5%B8%8C%E8%A1%A8%E8%AF%A6%E8%A7%A3/:2:6","tags":["C/C++手撕哈希表详解"],"title":"C/C++手撕哈希表详解","uri":"/posts/c++%E6%89%8B%E6%92%95%E5%93%88%E5%B8%8C%E8%A1%A8%E8%AF%A6%E8%A7%A3/"},{"categories":["手写数据结构"],"content":"get方法 C val_t *get(HashMap *map, key_t key) {//前面的写好后，那么get就很好写了 int index = getIndex(key, map-\u003ecapacity); Node *node = map-\u003ebuckets[index]; while (node != NULL) { if (node-\u003ekey == key) { return \u0026(node-\u003eval); } node = node-\u003enext; } return NULL;//没找到返回NULL指针 } C++ C++标准中主要采用重载下标运算符的方式进行get。 ","date":"2022-02-16","objectID":"/posts/c++%E6%89%8B%E6%92%95%E5%93%88%E5%B8%8C%E8%A1%A8%E8%AF%A6%E8%A7%A3/:2:7","tags":["C/C++手撕哈希表详解"],"title":"C/C++手撕哈希表详解","uri":"/posts/c++%E6%89%8B%E6%92%95%E5%93%88%E5%B8%8C%E8%A1%A8%E8%AF%A6%E8%A7%A3/"},{"categories":["手写数据结构"],"content":"完整代码 C完整代码 C++完整代码 ","date":"2022-02-16","objectID":"/posts/c++%E6%89%8B%E6%92%95%E5%93%88%E5%B8%8C%E8%A1%A8%E8%AF%A6%E8%A7%A3/:2:8","tags":["C/C++手撕哈希表详解"],"title":"C/C++手撕哈希表详解","uri":"/posts/c++%E6%89%8B%E6%92%95%E5%93%88%E5%B8%8C%E8%A1%A8%E8%AF%A6%E8%A7%A3/"},{"categories":["手写数据结构"],"content":"测试：LeetCode 1.两数之和 这效率在用C语言哈希表的方法里面应该是无敌的存在了。。。试了下比UT_HASH还要快一些☺ 再看看之前写的比较烂的哈希表的效率😂 测试源码： // // Created by L_B__ on 2021/11/24. // //底层的表长都用2的次方，然后-1后可以得到低位掩码 //该设计理念急于java1.7的源代码，本来是想基于1.8的实现， // 因为1.8巧妙太多，比如对rehash尽量能不动的就不动，再比如对于链比较长的结构直接转红黑树。可惜能力不能及 /** * 简单说明：static修饰的函数为单文件的中间委托功能函数，不对外公开 * 简单的功能函数介绍： * init()得到一个默认表长的哈希表 * put()插入键值，内部自动进行内存的申请 * get()得到key对应的val的地址，若不存在该键值对返回NULL * insert()外界已经分配好node的内存和key\u0026val对，进行哈希运算后直接插入即可 * destroy()把整个哈希表牵扯的所有内存释放 * **/ #include \u003cassert.h\u003e#include \u003cstdlib.h\u003e#ifndef MY_TINY_STL_HASHMAP_C_H #define MY_TINY_STL_HASHMAP_C_H #define DEFAULT_CAPACITY 128 //初始的表长 #define DEFAULT_FACTOR 0.75f //初始的装载因子 /*类型定义 和 装载因子初始化*/ typedef int key_t; typedef int val_t ; static const float factor = DEFAULT_FACTOR; //装载因子 typedef struct node{//每个哈希表的键值对 key_t key; val_t val; struct node* next; }Node; typedef struct { size_t size; //记录已经存下的键值对数目 size_t capacity; //记录表长 Node** buckets; //桶子：用于记录的哈希桶，桶子中每个元素是Node* }HashMap; /*函数的声明*/ HashMap* init(); void put(HashMap*,key_t,val_t); void insert(HashMap*,Node*); //直接把已经分配好的内存插入哈希表 static void putVal(key_t,val_t,Node**,size_t*,size_t); //这个是put的委托函数,用于直接更新桶子，并更新HashMap的size static inline size_t getHashcode(key_t ); //得到key对应的hashcode static inline size_t getIndex(key_t,size_t); //通过桶的大小和key映射位置，算是包含了关键的哈希函数：由于C不支持泛型也就无法针对不同类型作出不同的哈希了，我这里默认key为int static void resize(HashMap*); //如果插入的元素过多，*2进行重新哈希分配 static void rehash(HashMap*,Node**); //重新设置长度则需要重新哈希一些key的位置 val_t* get(HashMap*,key_t); //得到key对应的val static void del_nodes(Node*); //把单个链表销毁 void destroy(HashMap*); //把哈希表的内存销毁 /*函数实现*/ HashMap* init(){ //初始化得到一个哈希表 HashMap * ret = (HashMap*)malloc(sizeof(HashMap)); assert(ret!=NULL); ret-\u003esize = 0; ret-\u003ecapacity = DEFAULT_CAPACITY; ret-\u003ebuckets = (Node**)calloc(DEFAULT_CAPACITY,sizeof(Node*)); assert(ret-\u003ebuckets!=NULL); return ret; } void insert(HashMap* map,Node* node){ assert(map!=NULL\u0026\u0026node!=NULL); size_t index = getIndex(node-\u003ekey,map-\u003ecapacity); if(map-\u003ebuckets[index]==NULL){ node-\u003enext = NULL; map-\u003ebuckets[index] = node; }else{ node-\u003enext = map-\u003ebuckets[index]; map-\u003ebuckets[index] = node; } } void put(HashMap* map,key_t key,val_t val){ assert(map != NULL); //判断是否需要扩容 if(map-\u003esize \u003e= map-\u003ecapacity*factor) resize(map); putVal(key,val,map-\u003ebuckets,\u0026map-\u003esize,map-\u003ecapacity); } static inline size_t getHashcode(key_t key){ return key ^ (key\u003e\u003e16);//这是32位数的扰动函数 } static inline size_t getIndex(key_t key,size_t bucket_size){//由于bucketsize一定是2的次方，所以size-1和key相与得到的就是下标 return getHashcode(key)\u0026(bucket_size-1); } static void putVal(key_t key,val_t val,Node** buckets,size_t* returnSize,size_t bucketSize){ //获取位置 size_t index = getIndex(key,bucketSize); Node * node = buckets[index]; if(node==NULL){//插入位置为空 node = (Node*)malloc(sizeof(Node)); assert(node!=NULL); node-\u003eval = val; node-\u003ekey = key; node-\u003enext = NULL; buckets[index] = node; (*returnSize)++; //哈希表内的元素增加 return; } //插入位置不为空，说明发生冲突，使用链地址法，遍历链表 while (node!=NULL){ //如果key相同就覆盖 if(node-\u003ekey==key){ node-\u003eval = val; return; } node = node-\u003enext; } //当前的key不在链表中，则插入链表头部 Node* newNode = (Node*)malloc(sizeof(Node)); assert(newNode != NULL); newNode-\u003enext = buckets[index]; buckets[index] = newNode; (*returnSize)++; //哈希表内元素增加 } static void resize(HashMap* map){ map-\u003ecapacity \u003c\u003c= 1; //扩大两倍容量，相当于左移一位 Node ** tmp = map-\u003ebuckets; //存下之前的内存地址 map-\u003ebuckets = (Node**)calloc(map-\u003ecapacity,sizeof(Node*)); //重新分配 assert(map-\u003ebuckets!=NULL); rehash(map,tmp);//重新哈希处理 free(tmp); //释放之前的内存 } static void rehash(HashMap* map,Node** preTable){//采取java1.7的方式进行rehash也就是最简单直接的直接重新哈希插入 size_t preCap = map-\u003ecapacity / 2; //改变前的有效区域 for(size_t i=0;i\u003cpreCap;i++){ if(preTable[i] != NULL){//判断对应的key是否需要重新换位置,如果对最新掩码多出来的1敏感则需要rehash Node *preNode; Node *curNode = preTable[i]; while (curNode!=NULL){ preNode = curNode; curNode = curNode-\u003enext; insert(map,preNode); } } } } val_t* get(HashMap* map,key_t key){//前面的写好后，那么get就很好写了 int index = getIndex(key,map-\u003ecapacity); Node * node = map-\u003ebuckets[index]; while (node != NULL){ if(node-\u003ekey==key){ retur","date":"2022-02-16","objectID":"/posts/c++%E6%89%8B%E6%92%95%E5%93%88%E5%B8%8C%E8%A1%A8%E8%AF%A6%E8%A7%A3/:2:9","tags":["C/C++手撕哈希表详解"],"title":"C/C++手撕哈希表详解","uri":"/posts/c++%E6%89%8B%E6%92%95%E5%93%88%E5%B8%8C%E8%A1%A8%E8%AF%A6%E8%A7%A3/"},{"categories":["手写数据结构"],"content":"总结 通过这次手撕比较规范的哈希表的收获： 更加深入的理解了哈希表的基本实现思想。 从LeetCode刷题无用的感觉到有用，比如时刻需要的链表增删操作。 有点遗憾，没能按照java1.8的思路再进一步优化哈希表。 看了很多大厂的面试题，现在对哈希表这块数据结构的考量是越来越严苛了，比如你如果走的 java 后端岗位，面试可能需要你回答 java HashMap 源码的相关实现部分，深挖原理，而不是死记硬背了，所以最好的学习方式就是学习源码，然后根据学到的思想自己实现一些功能。 参考： [1]. 《数据结构与算法》 [2]. HashMap跟面试官扯了半个小时 [3]. hashCode 为什么乘以 31？ ","date":"2022-02-16","objectID":"/posts/c++%E6%89%8B%E6%92%95%E5%93%88%E5%B8%8C%E8%A1%A8%E8%AF%A6%E8%A7%A3/:3:0","tags":["C/C++手撕哈希表详解"],"title":"C/C++手撕哈希表详解","uri":"/posts/c++%E6%89%8B%E6%92%95%E5%93%88%E5%B8%8C%E8%A1%A8%E8%AF%A6%E8%A7%A3/"},{"categories":["JavaWeb笔记"],"content":"Java连接数据库","date":"2022-02-16","objectID":"/posts/java%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93/","tags":["Java连接数据库"],"title":"Java连接数据库","uri":"/posts/java%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"categories":["JavaWeb笔记"],"content":"Java与数据库 通过Java如何去使用数据库来帮助我们存储数据呢，这将是本章节讨论的重点。 ","date":"2022-02-16","objectID":"/posts/java%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93/:0:0","tags":["Java连接数据库"],"title":"Java连接数据库","uri":"/posts/java%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"categories":["JavaWeb笔记"],"content":"初识JDBC JDBC是什么？JDBC英文名为：Java Data Base Connectivity(Java数据库连接)，官方解释它是Java编程语言和广泛的数据库之间独立于数据库的连接标准的Java API，根本上说JDBC是一种规范，它提供的接口，一套完整的，允许便捷式访问底层数据库。可以用JAVA来写不同类型的可执行文件：JAVA应用程序、JAVA Applets、Java Servlet、JSP等，不同的可执行文件都能通过JDBC访问数据库，又兼备存储的优势。简单说它就是Java与数据库的连接的桥梁或者插件，用Java代码就能操作数据库的增删改查、存储过程、事务等。 我们可以发现，JDK自带了一个java.sql包，而这里面就定义了大量的接口，不同类型的数据库，都可以通过实现此接口，编写适用于自己数据库的实现类。而不同的数据库厂商实现的这套标准，我们称为数据库驱动。 ","date":"2022-02-16","objectID":"/posts/java%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93/:1:0","tags":["Java连接数据库"],"title":"Java连接数据库","uri":"/posts/java%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"categories":["JavaWeb笔记"],"content":"准备工作 那么我们首先来进行一些准备工作，以便开始JDBC的学习： 将idea连接到我们的数据库，以便以后调试。 将mysql驱动jar依赖导入到项目中（推荐6.0版本以上，这里用到是8.0） 向Jetbrians申请一个学生/教师授权，用于激活idea终极版（进行JavaWeb开发需要用到，一般申请需要3-7天时间审核）不是大学生的话…emmm…懂的都懂。 教育授权申请地址：https://www.jetbrains.com/shop/eform/students 一个Java程序并不是一个人的战斗，我们可以在别人开发的基础上继续向上开发，其他的开发者可以将自己编写的Java代码打包为jar，我们只需要导入这个jar作为依赖，即可直接使用别人的代码，就像我们直接去使用JDK提供的类一样。 ","date":"2022-02-16","objectID":"/posts/java%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93/:1:1","tags":["Java连接数据库"],"title":"Java连接数据库","uri":"/posts/java%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"categories":["JavaWeb笔记"],"content":"使用JDBC连接数据库 **注意：**6.0版本以上，不用手动加载驱动，我们直接使用即可！ //1. 通过DriverManager来获得数据库连接 try (Connection connection = DriverManager.getConnection(\"连接URL\",\"用户名\",\"密码\"); //2. 创建一个用于执行SQL的Statement对象 Statement statement = connection.createStatement()){ //注意前两步都放在try()中，因为在最后需要释放资源！ //3. 执行SQL语句，并得到结果集 ResultSet set = statement.executeQuery(\"select * from 表名\"); //4. 查看结果 while (set.next()){ ... } }catch (SQLException e){ e.printStackTrace(); } //5. 释放资源，try-with-resource语法会自动帮助我们close 其中，连接的URL如果记不住格式，我们可以打开idea的数据库连接配置，复制一份即可。（其实idea本质也是使用的JDBC，整个idea程序都是由Java编写的，实际上idea就是一个Java程序） ","date":"2022-02-16","objectID":"/posts/java%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93/:1:2","tags":["Java连接数据库"],"title":"Java连接数据库","uri":"/posts/java%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"categories":["JavaWeb笔记"],"content":"了解DriverManager 我们首先来了解一下DriverManager是什么东西，它其实就是管理我们的数据库驱动的： public static synchronized void registerDriver(java.sql.Driver driver, DriverAction da) throws SQLException { /* Register the driver if it has not already been added to our list */ if(driver != null) { registeredDrivers.addIfAbsent(new DriverInfo(driver, da)); //在刚启动时，mysql实现的驱动会被加载，我们可以断点调试一下。 } else { // This is for compatibility with the original DriverManager throw new NullPointerException(); } println(\"registerDriver: \" + driver); } 我们可以通过调用getConnection()来进行数据库的链接： @CallerSensitive public static Connection getConnection(String url, String user, String password) throws SQLException { java.util.Properties info = new java.util.Properties(); if (user != null) { info.put(\"user\", user); } if (password != null) { info.put(\"password\", password); } return (getConnection(url, info, Reflection.getCallerClass())); //内部有实现 } 我们可以手动为驱动管理器添加一个日志打印： static { DriverManager.setLogWriter(new PrintWriter(System.out)); //这里直接设定为控制台输出 } 现在我们执行的数据库操作日志会在控制台实时打印。 ","date":"2022-02-16","objectID":"/posts/java%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93/:1:3","tags":["Java连接数据库"],"title":"Java连接数据库","uri":"/posts/java%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"categories":["JavaWeb笔记"],"content":"了解Connection Connection是数据库的连接对象，可以通过连接对象来创建一个Statement用于执行SQL语句： Statement createStatement() throws SQLException; 我们发现除了普通的Statement，还存在PreparedStatement： PreparedStatement prepareStatement(String sql) throws SQLException; 在后面我们会详细介绍PreparedStatement的使用，它能够有效地预防SQL注入式攻击。 它还支持事务的处理，也放到后面来详细进行讲解。 ","date":"2022-02-16","objectID":"/posts/java%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93/:1:4","tags":["Java连接数据库"],"title":"Java连接数据库","uri":"/posts/java%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"categories":["JavaWeb笔记"],"content":"了解Statement 我们发现，我们之前使用了executeQuery()方法来执行select语句，此方法返回给我们一个ResultSet对象，查询得到的数据，就存放在ResultSet中！ Statement除了执行这样的DQL语句外，我们还可以使用executeUpdate()方法来执行一个DML或是DDL语句，它会返回一个int类型，表示执行后受影响的行数，可以通过它来判断DML语句是否执行成功。 也可以通过excute()来执行任意的SQL语句，它会返回一个boolean来表示执行结果是一个ResultSet还是一个int，我们可以通过使用getResultSet()或是getUpdateCount()来获取。 ","date":"2022-02-16","objectID":"/posts/java%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93/:1:5","tags":["Java连接数据库"],"title":"Java连接数据库","uri":"/posts/java%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"categories":["JavaWeb笔记"],"content":"执行DML操作 我们通过几个例子来向数据库中插入数据。 ","date":"2022-02-16","objectID":"/posts/java%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93/:1:6","tags":["Java连接数据库"],"title":"Java连接数据库","uri":"/posts/java%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"categories":["JavaWeb笔记"],"content":"执行DQL操作 执行DQL操作会返回一个ResultSet对象，我们来看看如何从ResultSet中去获取数据： //首先要明确，select返回的数据类似于一个excel表格 while (set.next()){ //每调用一次next()就会向下移动一行，首次调用会移动到第一行 } 我们在移动行数后，就可以通过set中提供的方法，来获取每一列的数据。 ","date":"2022-02-16","objectID":"/posts/java%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93/:1:7","tags":["Java连接数据库"],"title":"Java连接数据库","uri":"/posts/java%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"categories":["JavaWeb笔记"],"content":"执行批处理操作 当我们要执行很多条语句时，可以不用一次一次地提交，而是一口气全部交给数据库处理，这样会节省很多的时间。 public static void main(String[] args) throws ClassNotFoundException { try (Connection connection = DriverManager.getConnection(); Statement statement = connection.createStatement()){ statement.addBatch(\"insert into user values ('f', 1234)\"); statement.addBatch(\"insert into user values ('e', 1234)\"); //添加每一条批处理语句 statement.executeBatch(); //一起执行 }catch (SQLException e){ e.printStackTrace(); } } ","date":"2022-02-16","objectID":"/posts/java%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93/:1:8","tags":["Java连接数据库"],"title":"Java连接数据库","uri":"/posts/java%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"categories":["JavaWeb笔记"],"content":"将查询结果映射为对象 既然我们现在可以从数据库中获取数据了，那么现在就可以将这些数据转换为一个类来进行操作，首先定义我们的实体类： public class Student { Integer sid; String name; String sex; public Student(Integer sid, String name, String sex) { this.sid = sid; this.name = name; this.sex = sex; } public void say(){ System.out.println(\"我叫：\"+name+\"，学号为：\"+sid+\"，我的性别是：\"+sex); } } 现在我们来进行一个转换： while (set.next()){ Student student = new Student(set.getInt(1), set.getString(2), set.getString(3)); student.say(); } **注意：**列的下标是从1开始的。 我们也可以利用反射机制来将查询结果映射为对象，使用反射的好处是，无论什么类型都可以通过我们的方法来进行实体类型映射： private static \u003cT\u003e T convert(ResultSet set, Class\u003cT\u003e clazz){ try { Constructor\u003cT\u003e constructor = clazz.getConstructor(clazz.getConstructors()[0].getParameterTypes()); //默认获取第一个构造方法 Class\u003c?\u003e[] param = constructor.getParameterTypes(); //获取参数列表 Object[] object = new Object[param.length]; //存放参数 for (int i = 0; i \u003c param.length; i++) { //是从1开始的 object[i] = set.getObject(i+1); if(object[i].getClass() != param[i]) throw new SQLException(\"错误的类型转换：\"+object[i].getClass()+\" -\u003e \"+param[i]); } return constructor.newInstance(object); } catch (ReflectiveOperationException | SQLException e) { e.printStackTrace(); return null; } } 现在我们就可以通过我们的方法来将查询结果转换为一个对象了： while (set.next()){ Student student = convert(set, Student.class); if(student != null) student.say(); } 实际上，在后面我们会学习Mybatis框架，它对JDBC进行了深层次的封装，而它就进行类似上面反射的操作来便于我们对数据库数据与实体类的转换。 ","date":"2022-02-16","objectID":"/posts/java%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93/:1:9","tags":["Java连接数据库"],"title":"Java连接数据库","uri":"/posts/java%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"categories":["JavaWeb笔记"],"content":"实现登陆与SQL注入攻击 在使用之前，我们先来看看如果我们想模拟登陆一个用户，我们该怎么去写： try (Connection connection = DriverManager.getConnection(\"URL\",\"用户名\",\"密码\"); Statement statement = connection.createStatement(); Scanner scanner = new Scanner(System.in)){ ResultSet res = statement.executeQuery(\"select * from user where username='\"+scanner.nextLine()+\"'and pwd='\"+scanner.nextLine()+\"';\"); while (res.next()){ String username = res.getString(1); System.out.println(username+\" 登陆成功！\"); } }catch (SQLException e){ e.printStackTrace(); } 用户可以通过自己输入用户名和密码来登陆，乍一看好像没啥问题，那如果我输入的是以下内容呢： Test1111' or 1=1; -- # Test 登陆成功！ 1=1一定是true，那么我们原本的SQL语句会变为： select*fromuserwhereusername='Test'andpwd='1111'or1=1;-- ' 我们发现，如果允许这样的数据插入，那么我们原有的SQL语句结构就遭到了破坏，使得用户能够随意登陆别人的账号。因此我们可能需要限制用户的输入来防止用户输入一些SQL语句关键字，但是关键字非常多，这并不是解决问题的最好办法。 ","date":"2022-02-16","objectID":"/posts/java%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93/:1:10","tags":["Java连接数据库"],"title":"Java连接数据库","uri":"/posts/java%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"categories":["JavaWeb笔记"],"content":"使用PreparedStatement 我们发现，如果单纯地使用Statement来执行SQL命令，会存在严重的SQL注入攻击漏洞！而这种问题，我们可以使用PreparedStatement来解决： public static void main(String[] args) throws ClassNotFoundException { try (Connection connection = DriverManager.getConnection(\"URL\",\"用户名\",\"密码\"); PreparedStatement statement = connection.prepareStatement(\"select * from user where username= ? and pwd=?;\"); Scanner scanner = new Scanner(System.in)){ statement.setString(1, scanner.nextLine()); statement.setString(2, scanner.nextLine()); System.out.println(statement); //打印查看一下最终执行的 ResultSet res = statement.executeQuery(); while (res.next()){ String username = res.getString(1); System.out.println(username+\" 登陆成功！\"); } }catch (SQLException e){ e.printStackTrace(); } } 我们发现，我们需要提前给到PreparedStatement一个SQL语句，并且使用?作为占位符，它会预编译一个SQL语句，通过直接将我们的内容进行替换的方式来填写数据。使用这种方式，我们之前的例子就失效了！我们来看看实际执行的SQL语句是什么： com.mysql.cj.jdbc.ClientPreparedStatement: select * from user where username= 'Test' and pwd='123456'' or 1=1; -- ';\r我们发现，我们输入的参数一旦出现'时，会被变为转义形式\\'，而最外层有一个真正的'来将我们输入的内容进行包裹，因此它能够有效地防止SQL注入攻击！ ","date":"2022-02-16","objectID":"/posts/java%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93/:1:11","tags":["Java连接数据库"],"title":"Java连接数据库","uri":"/posts/java%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"categories":["JavaWeb笔记"],"content":"管理事务 JDBC默认的事务处理行为是自动提交，所以前面我们执行一个SQL语句就会被直接提交（相当于没有启动事务），所以JDBC需要进行事务管理时，首先要通过Connection对象调用setAutoCommit(false) 方法, 将SQL语句的提交（commit）由驱动程序转交给应用程序负责。 con.setAutoCommit(); //关闭自动提交后相当于开启事务。 // SQL语句 // SQL语句 // SQL语句 con.commit();或 con.rollback(); 一旦关闭自动提交，那么现在执行所有的操作如果在最后不进行commit()来提交事务的话，那么所有的操作都会丢失，只有提交之后，所有的操作才会被保存！也可以使用rollback()来手动回滚之前的全部操作！ public static void main(String[] args) throws ClassNotFoundException { try (Connection connection = DriverManager.getConnection(\"URL\",\"用户名\",\"密码\"); Statement statement = connection.createStatement()){ connection.setAutoCommit(false); //关闭自动提交，现在将变为我们手动提交 statement.executeUpdate(\"insert into user values ('a', 1234)\"); statement.executeUpdate(\"insert into user values ('b', 1234)\"); statement.executeUpdate(\"insert into user values ('c', 1234)\"); connection.commit(); //如果前面任何操作出现异常，将不会执行commit()，之前的操作也就不会生效 }catch (SQLException e){ e.printStackTrace(); } } 我们来接着尝试一下使用回滚操作： public static void main(String[] args) throws ClassNotFoundException { try (Connection connection = DriverManager.getConnection(\"URL\",\"用户名\",\"密码\"); Statement statement = connection.createStatement()){ connection.setAutoCommit(false); //关闭自动提交，现在将变为我们手动提交 statement.executeUpdate(\"insert into user values ('a', 1234)\"); statement.executeUpdate(\"insert into user values ('b', 1234)\"); connection.rollback(); //回滚，撤销前面全部操作 statement.executeUpdate(\"insert into user values ('c', 1234)\"); connection.commit(); //提交事务（注意，回滚之前的内容都没了） }catch (SQLException e){ e.printStackTrace(); } } 同样的，我们也可以去创建一个回滚点来实现定点回滚： public static void main(String[] args) throws ClassNotFoundException { try (Connection connection = DriverManager.getConnection(\"URL\",\"用户名\",\"密码\"); Statement statement = connection.createStatement()){ connection.setAutoCommit(false); //关闭自动提交，现在将变为我们手动提交 statement.executeUpdate(\"insert into user values ('a', 1234)\"); Savepoint savepoint = connection.setSavepoint(); //创建回滚点 statement.executeUpdate(\"insert into user values ('b', 1234)\"); connection.rollback(savepoint); //回滚到回滚点，撤销前面全部操作 statement.executeUpdate(\"insert into user values ('c', 1234)\"); connection.commit(); //提交事务（注意，回滚之前的内容都没了） }catch (SQLException e){ e.printStackTrace(); } } 通过开启事务，我们就可以更加谨慎地进行一些操作了，如果我们想从事务模式切换为原有的自动提交模式，我们可以直接将其设置回去： public static void main(String[] args) throws ClassNotFoundException { try (Connection connection = DriverManager.getConnection(\"URL\",\"用户名\",\"密码\"); Statement statement = connection.createStatement()){ connection.setAutoCommit(false); //关闭自动提交，现在将变为我们手动提交 statement.executeUpdate(\"insert into user values ('a', 1234)\"); connection.setAutoCommit(true); //重新开启自动提交，开启时把之前的事务模式下的内容给提交了 statement.executeUpdate(\"insert into user values ('d', 1234)\"); //没有commit也成功了！ }catch (SQLException e){ e.printStackTrace(); } 通过学习JDBC，我们现在就可以通过Java来访问和操作我们的数据库了！为了更好地衔接，我们还会接着讲解主流持久层框架——Mybatis，加深JDBC的记忆。 ","date":"2022-02-16","objectID":"/posts/java%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93/:1:12","tags":["Java连接数据库"],"title":"Java连接数据库","uri":"/posts/java%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"categories":["JavaWeb笔记"],"content":"使用Lombok 我们发现，在以往编写项目时，尤其是在类进行类内部成员字段封装时，需要编写大量的get/set方法，这不仅使得我们类定义中充满了get和set方法，同时如果字段名称发生改变，又要挨个进行修改，甚至当字段变得很多时，构造方法的编写会非常麻烦！ 通过使用Lombok（小辣椒）就可以解决这样的问题！ 我们来看看，使用原生方式和小辣椒方式编写类的区别，首先是传统方式： public class Student { private Integer sid; private String name; private String sex; public Student(Integer sid, String name, String sex) { this.sid = sid; this.name = name; this.sex = sex; } public Integer getSid() { //长！ return sid; } public void setSid(Integer sid) { //到！ this.sid = sid; } public String getName() { //爆！ return name; } public void setName(String name) { //炸！ this.name = name; } public String getSex() { return sex; } public void setSex(String sex) { this.sex = sex; } } 而使用Lombok之后： @Getter @Setter @AllArgsConstructor public class Student { private Integer sid; private String name; private String sex; } 我们发现，使用Lombok之后，只需要添加几个注解，就能够解决掉我们之前长长的一串代码！ ","date":"2022-02-16","objectID":"/posts/java%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93/:2:0","tags":["Java连接数据库"],"title":"Java连接数据库","uri":"/posts/java%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"categories":["JavaWeb笔记"],"content":"配置Lombok 首先我们需要导入Lombok的jar依赖，和jdbc依赖是一样的，放在项目目录下直接导入就行了。可以在这里进行下载：https://projectlombok.org/download 然后我们要安装一下Lombok插件，由于IDEA默认都安装了Lombok的插件，因此直接导入依赖后就可以使用了。 重启IDEA Lombok是一种插件化注解API，是通过添加注解来实现的，然后在javac进行编译的时候，进行处理。 Java的编译过程可以分成三个阶段： 所有源文件会被解析成语法树。 调用注解处理器。如果注解处理器产生了新的源文件，新文件也要进行编译。 最后，语法树会被分析并转化成类文件。 实际上在上述的第二阶段，会执行*lombok.core.AnnotationProcessor*，它所做的工作就是我们上面所说的，修改语法树。 ","date":"2022-02-16","objectID":"/posts/java%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93/:2:1","tags":["Java连接数据库"],"title":"Java连接数据库","uri":"/posts/java%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"categories":["JavaWeb笔记"],"content":"使用Lombok 我们通过实战来演示一下Lombok的实用注解： 我们通过添加@Getter和@Setter来为当前类的所有字段生成get/set方法，他们可以添加到类或是字段上，注意静态字段不会生成，final字段无法生成set方法。 我们还可以使用@Accessors来控制生成Getter和Setter的样式。 我们通过添加@ToString来为当前类生成预设的toString方法。 我们可以通过添加@EqualsAndHashCode来快速生成比较和哈希值方法。 我们可以通过添加@AllArgsConstructor和@NoArgsConstructor来快速生成全参构造和无参构造。 我们可以添加@RequiredArgsConstructor来快速生成参数只包含final或被标记为@NonNull的成员字段。 使用@Data能代表@Setter、@Getter、@RequiredArgsConstructor、@ToString、@EqualsAndHashCode全部注解。 一旦使用@Data就不建议此类有继承关系，因为equal方法可能不符合预期结果（尤其是仅比较子类属性）。 使用@Value与@Data类似，但是并不会生成setter并且成员属性都是final的。 使用@SneakyThrows来自动生成try-catch代码块。 使用@Cleanup作用与局部变量，在最后自动调用其close()方法（可以自由更换） 使用@Builder来快速生成建造者模式。 通过使用@Builder.Default来指定默认值。 通过使用@Builder.ObtainVia来指定默认值的获取方式。 ","date":"2022-02-16","objectID":"/posts/java%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93/:2:2","tags":["Java连接数据库"],"title":"Java连接数据库","uri":"/posts/java%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"categories":["JavaWeb笔记"],"content":"认识Mybatis 在前面JDBC的学习中，虽然我们能够通过JDBC来连接和操作数据库，但是哪怕只是完成一个SQL语句的执行，都需要编写大量的代码，更不用说如果我还需要进行实体类映射，将数据转换为我们可以直接操作的实体类型，JDBC很方便，但是还不够方便，我们需要一种更加简洁高效的方式来和数据库进行交互。 **再次强调：**学习厉害的框架或是厉害的技术，并不是为了一定要去使用它，而是它们能够使得我们在不同的开发场景下，合理地使用这些技术，以灵活地应对需要解决的问题。 MyBatis 是一款优秀的持久层框架，它支持定制化 SQL、存储过程以及高级映射。MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。MyBatis 可以使用简单的 XML 或注解来配置和映射原生信息，将接口和 Java 的 POJOs(Plain Ordinary Java Object,普通的 Java对象)映射成数据库中的记录。 我们依然使用传统的jar依赖方式，从最原始开始讲起，不使用Maven，有关Maven内容我们会在后面统一讲解！全程围绕官方文档讲解！ 这一块内容很多很杂，再次强调要多实践！ ","date":"2022-02-16","objectID":"/posts/java%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93/:3:0","tags":["Java连接数据库"],"title":"Java连接数据库","uri":"/posts/java%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"categories":["JavaWeb笔记"],"content":"XML语言概述 在开始介绍Mybatis之前，XML语言发明最初是用于数据的存储和传输，它可以长这样： \u003c?xml version=\"1.0\" encoding=\"UTF-8\" ?\u003e \u003couter\u003e \u003cname\u003e阿伟\u003c/name\u003e \u003cdesc\u003e怎么又在玩电动啊\u003c/desc\u003e \u003cinner type=\"1\"\u003e \u003cage\u003e10\u003c/age\u003e \u003csex\u003e男\u003c/sex\u003e \u003c/inner\u003e \u003c/outer\u003e 如果你学习过前端知识，你会发现它和HTML几乎长得一模一样！但是请注意，虽然它们长得差不多，但是他们的意义却不同，HTML主要用于通过编排来展示数据，而XML主要是存放数据，它更像是一个配置文件！当然，浏览器也是可以直接打开XML文件的。 一个XML文件存在以下的格式规范： 必须存在一个根节点，将所有的子标签全部包含。 可以但不必须包含一个头部声明（主要是可以设定编码格式） 所有的标签必须成对出现，可以嵌套但不能交叉嵌套 区分大小写。 标签中可以存在属性，比如上面的type=\"1\"就是inner标签的一个属性，属性的值由单引号或双引号包括。 XML文件也可以使用注释： \u003c?xml version=\"1.0\" encoding=\"UTF-8\" ?\u003e \u003c!-- 注释内容 --\u003e 通过IDEA我们可以使用Ctrl+/来快速添加注释文本（不仅仅适用于XML，还支持很多种类型的文件） 那如果我们的内容中出现了\u003c或是\u003e字符，那该怎么办呢？我们就可以使用XML的转义字符来代替： 如果嫌一个一个改太麻烦，也可以使用CD来快速创建不解析区域： \u003ctest\u003e \u003cname\u003e\u003c![CDATA[我看你\u003c\u003e\u003c\u003e\u003c\u003e是一点都不懂哦\u003e\u003e\u003e]]\u003e\u003c/name\u003e \u003c/test\u003e 那么，我们现在了解了XML文件的定义，现在该如何去解析一个XML文件呢？比如我们希望将定义好的XML文件读取到Java程序中，这时该怎么做呢？ JDK为我们内置了一个叫做org.w3c的XML解析库，我们来看看如何使用它来进行XML文件内容解析： // 创建DocumentBuilderFactory对象 DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance(); // 创建DocumentBuilder对象 try { DocumentBuilder builder = factory.newDocumentBuilder(); Document d = builder.parse(\"file:mappers/test.xml\"); // 每一个标签都作为一个节点 NodeList nodeList = d.getElementsByTagName(\"test\"); // 可能有很多个名字为test的标签 Node rootNode = nodeList.item(0); // 获取首个 NodeList childNodes = rootNode.getChildNodes(); // 一个节点下可能会有很多个节点，比如根节点下就囊括了所有的节点 //节点可以是一个带有内容的标签（它内部就还有子节点），也可以是一段文本内容 for (int i = 0; i \u003c childNodes.getLength(); i++) { Node child = childNodes.item(i); if(child.getNodeType() == Node.ELEMENT_NODE) //过滤换行符之类的内容，因为它们都被认为是一个文本节点 System.out.println(child.getNodeName() + \"：\" +child.getFirstChild().getNodeValue()); // 输出节点名称，也就是标签名称，以及标签内部的文本（内部的内容都是子节点，所以要获取内部的节点） } } catch (Exception e) { e.printStackTrace(); } 当然，学习和使用XML只是为了更好地去认识Mybatis的工作原理，以及如何使用XML来作为Mybatis的配置文件，这是在开始之前必须要掌握的内容（使用Java读取XML内容不要求掌握，但是需要知道Mybatis就是通过这种方式来读取配置文件的） 不仅仅是Mybatis，包括后面的Spring等众多框架都会用到XML来作为框架的配置文件！ ","date":"2022-02-16","objectID":"/posts/java%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93/:3:1","tags":["Java连接数据库"],"title":"Java连接数据库","uri":"/posts/java%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"categories":["JavaWeb笔记"],"content":"初次使用Mybatis 那么我们首先来感受一下Mybatis给我们带来的便捷，就从搭建环境开始，中文文档网站：https://mybatis.org/mybatis-3/zh/configuration.html 我们需要导入Mybatis的依赖，Jar包需要在github上下载，如果卡得一匹，连不上可以在视频简介处从分享的文件中获取。同样地放入到项目的根目录下，右键作为依赖即可！（依赖变多之后，我们可以将其放到一个单独的文件夹，不然会很繁杂） 依赖导入完成后，我们就可以编写Mybatis的配置文件了（现在不是在Java代码中配置了，而是通过一个XML文件去配置，这样就使得硬编码的部分大大减少，项目后期打包成Jar运行不方便修复，但是通过配置文件，我们随时都可以去修改，就变得很方便了，同时代码量也大幅度减少，配置文件填写完成后，我们只需要关心项目的业务逻辑而不是如何去读取配置文件）我们按照官方文档给定的提示，在项目根目录下新建名为mybatis-config.xml的文件，并填写以下内容： \u003c?xml version=\"1.0\" encoding=\"UTF-8\" ?\u003e \u003c!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\"\u003e \u003cconfiguration\u003e \u003cenvironments default=\"development\"\u003e \u003cenvironment id=\"development\"\u003e \u003ctransactionManager type=\"JDBC\"/\u003e \u003cdataSource type=\"POOLED\"\u003e \u003cproperty name=\"driver\" value=\"${驱动类（含包名）}\"/\u003e \u003cproperty name=\"url\" value=\"${数据库连接URL}\"/\u003e \u003cproperty name=\"username\" value=\"${用户名}\"/\u003e \u003cproperty name=\"password\" value=\"${密码}\"/\u003e \u003c/dataSource\u003e \u003c/environment\u003e \u003c/environments\u003e \u003c/configuration\u003e 我们发现，在最上方还引入了一个叫做DTD（文档类型定义）的东西，它提前帮助我们规定了一些标签，我们就需要使用Mybatis提前帮助我们规定好的标签来进行配置（因为只有这样Mybatis才能正确识别我们配置的内容） 通过进行配置，我们就告诉了Mybatis我们链接数据库的一些信息，包括URL、用户名、密码等，这样Mybatis就知道该链接哪个数据库、使用哪个账号进行登陆了（也可以不使用配置文件，这里不做讲解，还请各位小伙伴自行阅读官方文档） 配置文件完成后，我们需要在Java程序启动时，让Mybatis对配置文件进行读取并得到一个SqlSessionFactory对象： public static void main(String[] args) throws FileNotFoundException { SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(new FileInputStream(\"mybatis-config.xml\")); try (SqlSession sqlSession = sqlSessionFactory.openSession(true)){ //暂时还没有业务 } } 直接运行即可，虽然没有干什么事情，但是不会出现错误，如果之前的配置文件编写错误，直接运行会产生报错！那么现在我们来看看，SqlSessionFactory对象是什么东西： 每个基于 MyBatis 的应用都是以一个 SqlSessionFactory 的实例为核心的，我们可以通过SqlSessionFactory来创建多个新的会话，SqlSession对象，每个会话就相当于我不同的地方登陆一个账号去访问数据库，你也可以认为这就是之前JDBC中的Statement对象，会话之间相互隔离，没有任何关联。 而通过SqlSession就可以完成几乎所有的数据库操作，我们发现这个接口中定义了大量数据库操作的方法，因此，现在我们只需要通过一个对象就能完成数据库交互了，极大简化了之前的流程。 我们来尝试一下直接读取实体类，读取实体类肯定需要一个映射规则，比如类中的哪个字段对应数据库中的哪个字段，在查询语句返回结果后，Mybatis就会自动将对应的结果填入到对象的对应字段上。首先编写实体类，，直接使用Lombok是不是就很方便了： import lombok.Data; @Data public class Student { int sid; //名称最好和数据库字段名称保持一致，不然可能会映射失败导致查询结果丢失 String name; String sex; } 在根目录下重新创建一个mapper文件夹，新建名为TestMapper.xml的文件作为我们的映射器，并填写以下内容： \u003c?xml version=\"1.0\" encoding=\"UTF-8\" ?\u003e \u003c!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"\u003e \u003cmapper namespace=\"TestMapper\"\u003e \u003cselect id=\"selectStudent\" resultType=\"com.test.entity.Student\"\u003e select * from student \u003c/select\u003e \u003c/mapper\u003e 其中namespace就是命名空间，每个Mapper都是唯一的，因此需要用一个命名空间来区分，它还可以用来绑定一个接口。我们在里面写入了一个select标签，表示添加一个select操作，同时id作为操作的名称，resultType指定为我们刚刚定义的实体类，表示将数据库结果映射为Student类，然后就在标签中写入我们的查询语句即可。 编写好后，我们在配置文件中添加这个Mapper映射器： \u003cmappers\u003e \u003cmapper url=\"file:mappers/TestMapper.xml\"/\u003e \u003c!-- 这里用的是url，也可以使用其他类型，我们会在后面讲解 --\u003e \u003c/mappers\u003e 最后在程序中使用我们定义好的Mapper即可： public static void main(String[] args) throws FileNotFoundException { SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(new FileInputStream(\"mybatis-config.xml\")); try (SqlSession sqlSession = sqlSessionFactory.openSession(true)){ List\u003cStudent\u003e student = sqlSession.selectList(\"selectStudent\"); student.forEach(System.out::println); } } 我们会发现，Mybatis非常智能，我们只需要告诉一个映射关系，就能够直接将查询结果转化为一个实体类！ ","date":"2022-02-16","objectID":"/posts/java%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93/:3:2","tags":["Java连接数据库"],"title":"Java连接数据库","uri":"/posts/java%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"categories":["JavaWeb笔记"],"content":"配置Mybatis 在了解了Mybatis为我们带来的便捷之后，现在我们就可以正式地去学习使用Mybatis了！ 由于SqlSessionFactory一般只需要创建一次，因此我们可以创建一个工具类来集中创建SqlSession，这样会更加方便一些： public class MybatisUtil { //在类加载时就进行创建 private static SqlSessionFactory sqlSessionFactory; static { try { sqlSessionFactory = new SqlSessionFactoryBuilder().build(new FileInputStream(\"mybatis-config.xml\")); } catch (FileNotFoundException e) { e.printStackTrace(); } } /** * 获取一个新的会话 * @param autoCommit 是否开启自动提交（跟JDBC是一样的，如果不自动提交，则会变成事务操作） * @return SqlSession对象 */ public static SqlSession getSession(boolean autoCommit){ return sqlSessionFactory.openSession(autoCommit); } } 现在我们只需要在main方法中这样写即可查询结果了： public static void main(String[] args) { try (SqlSession sqlSession = MybatisUtil.getSession(true)){ List\u003cStudent\u003e student = sqlSession.selectList(\"selectStudent\"); student.forEach(System.out::println); } } 之前我们演示了，如何创建一个映射器来将结果快速转换为实体类，但是这样可能还是不够方便，我们每次都需要去找映射器对应操作的名称，而且还要知道对应的返回类型，再通过SqlSession来执行对应的方法，能不能再方便一点呢？ 现在，我们可以通过namespace来绑定到一个接口上，利用接口的特性，我们可以直接指明方法的行为，而实际实现则是由Mybatis来完成。 public interface TestMapper { List\u003cStudent\u003e selectStudent(); } 将Mapper文件的命名空间修改为我们的接口，建议同时将其放到同名包中，作为内部资源： \u003cmapper namespace=\"com.test.mapper.TestMapper\"\u003e \u003cselect id=\"selectStudent\" resultType=\"com.test.entity.Student\"\u003e select * from student \u003c/select\u003e \u003c/mapper\u003e 作为内部资源后，我们需要修改一下配置文件中的mapper定义，不使用url而是resource表示是Jar内部的文件： \u003cmappers\u003e \u003cmapper resource=\"com/test/mapper/TestMapper.xml\"/\u003e \u003c/mappers\u003e 现在我们就可以直接通过SqlSession获取对应的实现类，通过接口中定义的行为来直接获取结果： public static void main(String[] args) { try (SqlSession sqlSession = MybatisUtil.getSession(true)){ TestMapper testMapper = sqlSession.getMapper(TestMapper.class); List\u003cStudent\u003e student = testMapper.selectStudent(); student.forEach(System.out::println); } } 那么肯定有人好奇，TestMapper明明是一个我们自己定义接口啊，Mybatis也不可能提前帮我们写了实现类啊，那这接口怎么就出现了一个实现类呢？我们可以通过调用getClass()方法来看看实现类是个什么： TestMapper testMapper = sqlSession.getMapper(TestMapper.class); System.out.println(testMapper.getClass()); 我们发现，实现类名称很奇怪，名称为com.sun.proxy.$Proxy4，它是通过动态代理生成的，相当于动态生成了一个实现类，而不是预先定义好的，有关Mybatis这一部分的原理，我们放在最后一节进行讲解。 接下来，我们再来看配置文件，之前我们并没有对配置文件进行一个详细的介绍： \u003cconfiguration\u003e \u003cenvironments default=\"development\"\u003e \u003cenvironment id=\"development\"\u003e \u003ctransactionManager type=\"JDBC\"/\u003e \u003cdataSource type=\"POOLED\"\u003e \u003cproperty name=\"driver\" value=\"com.mysql.cj.jdbc.Driver\"/\u003e \u003cproperty name=\"url\" value=\"jdbc:mysql://localhost:3306/study\"/\u003e \u003cproperty name=\"username\" value=\"test\"/\u003e \u003cproperty name=\"password\" value=\"123456\"/\u003e \u003c/dataSource\u003e \u003c/environment\u003e \u003c/environments\u003e \u003cmappers\u003e \u003cmapper resource=\"com/test/mapper/TestMapper.xml\"/\u003e \u003c/mappers\u003e \u003c/configuration\u003e 首先就从environments标签说起，一般情况下，我们在开发中，都需要指定一个数据库的配置信息，包含连接URL、用户、密码等信息，而environment就是用于进行这些配置的！实际情况下可能会不止有一个数据库连接信息，比如开发过程中我们一般会使用本地的数据库，而如果需要将项目上传到服务器或是防止其他人的电脑上运行时，我们可能就需要配置另一个数据库的信息，因此，我们可以提前定义好所有的数据库信息，该什么时候用什么即可！ 在environments标签上有一个default属性，来指定默认的环境，当然如果我们希望使用其他环境，可以修改这个默认环境，也可以在创建工厂时选择环境： sqlSessionFactory = new SqlSessionFactoryBuilder() .build(new FileInputStream(\"mybatis-config.xml\"), \"环境ID\"); 我们还可以给类型起一个别名，以简化Mapper的编写： \u003c!-- 需要在environments的上方 --\u003e \u003ctypeAliases\u003e \u003ctypeAlias type=\"com.test.entity.Student\" alias=\"Student\"/\u003e \u003c/typeAliases\u003e 现在Mapper就可以直接使用别名了： \u003cmapper namespace=\"com.test.mapper.TestMapper\"\u003e \u003cselect id=\"selectStudent\" resultType=\"Student\"\u003e select * from student \u003c/select\u003e \u003c/mapper\u003e 如果这样还是很麻烦，我们也可以直接让Mybatis去扫描一个包，并将包下的所有类自动起别名（别名为首字母小写的类名） \u003ctypeAliases\u003e \u003cpackage name=\"com.test.entity\"/\u003e \u003c/typeAliases\u003e 也可以为指定实体类添加一个注解，来指定别名： @Data @Alias(\"lbwnb\") public class Student { private int sid; private String name; private String sex; } 当然，Mybatis也包含许多的基础配置，通过使用： \u003csettings\u003e \u003csetting name=\"\" value=\"\"/\u003e \u003c/settings\u003e 所有的配置项可以在中文文档处查询，本文不会进行详细介绍，在后面我们会提出一些比较重要的配置项。 有关配置文件的介绍就暂时到这里为止，我们讨论的重心应该是Mybatis的应用，而不是配置文件，所以省略了一部分内容的讲解。 ","date":"2022-02-16","objectID":"/posts/java%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93/:3:3","tags":["Java连接数据库"],"title":"Java连接数据库","uri":"/posts/java%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"categories":["JavaWeb笔记"],"content":"增删改查 在了解了Mybatis的一些基本配置之后，我们就可以正式来使用Mybatis来进行数据库操作了！ 在前面我们演示了如何快速进行查询，我们只需要编写一个对应的映射器既可以了： \u003cmapper namespace=\"com.test.mapper.TestMapper\"\u003e \u003cselect id=\"studentList\" resultType=\"Student\"\u003e select * from student \u003c/select\u003e \u003c/mapper\u003e 当然，如果你不喜欢使用实体类，那么这些属性还可以被映射到一个Map上： \u003cselect id=\"selectStudent\" resultType=\"Map\"\u003e select * from student \u003c/select\u003e public interface TestMapper { List\u003cMap\u003e selectStudent(); } Map中就会以键值对的形式来存放这些结果了。 通过设定一个resultType属性，让Mybatis知道查询结果需要映射为哪个实体类，要求字段名称保持一致。那么如果我们不希望按照这样的规则来映射呢？我们可以自定义resultMap来设定映射规则： \u003cresultMap id=\"Test\" type=\"Student\"\u003e \u003cresult column=\"sid\" property=\"sid\"/\u003e \u003cresult column=\"sex\" property=\"name\"/\u003e \u003cresult column=\"name\" property=\"sex\"/\u003e \u003c/resultMap\u003e 通过指定映射规则，我们现在名称和性别一栏就发生了交换，因为我们将其映射字段进行了交换。 如果一个类中存在多个构造方法，那么很有可能会出现这样的错误： ### Exception in thread \"main\" org.apache.ibatis.exceptions.PersistenceException: ### Error querying database. Cause: org.apache.ibatis.executor.ExecutorException: No constructor found in com.test.entity.Student matching [java.lang.Integer, java.lang.String, java.lang.String] ### The error may exist in com/test/mapper/TestMapper.xml ### The error may involve com.test.mapper.TestMapper.getStudentBySid ### The error occurred while handling results ### SQL: select * from student where sid = ? ### Cause: org.apache.ibatis.executor.ExecutorException: No constructor found in com.test.entity.Student matching [java.lang.Integer, java.lang.String, java.lang.String] at org.apache.ibatis.exceptions.ExceptionFactory.wrapException(ExceptionFactory.java:30) ... 这时就需要使用constructor标签来指定构造方法： \u003cresultMap id=\"test\" type=\"Student\"\u003e \u003cconstructor\u003e \u003carg column=\"sid\" javaType=\"Integer\"/\u003e \u003carg column=\"name\" javaType=\"String\"/\u003e \u003c/constructor\u003e \u003c/resultMap\u003e 值得注意的是，指定构造方法后，若此字段被填入了构造方法作为参数，将不会通过反射给字段单独赋值，而构造方法中没有传入的字段，依然会被反射赋值，有关resultMap的内容，后面还会继续讲解。 如果数据库中存在一个带下划线的字段，我们可以通过设置让其映射为以驼峰命名的字段，比如my_test映射为myTest \u003csettings\u003e \u003csetting name=\"mapUnderscoreToCamelCase\" value=\"true\"/\u003e \u003c/settings\u003e 如果不设置，默认为不开启，也就是默认需要名称保持一致。 我们接着来看看条件查询，既然是条件查询，那么肯定需要我们传入查询条件，比如现在我们想通过sid字段来通过学号查找信息： Student getStudentBySid(int sid); \u003cselect id=\"getStudentBySid\" parameterType=\"int\" resultType=\"Student\"\u003e select * from student where sid = #{sid} \u003c/select\u003e 我们通过使用#{xxx}或是${xxx}来填入我们给定的属性，实际上Mybatis本质也是通过PreparedStatement首先进行一次预编译，有效地防止SQL注入问题，但是如果使用${xxx}就不再是通过预编译，而是直接传值，因此我们一般都使用#{xxx}来进行操作。 使用parameterType属性来指定参数类型（非必须，可以不用，推荐不用） 接着我们来看插入、更新和删除操作，其实与查询操作差不多，不过需要使用对应的标签，比如插入操作： \u003cinsert id=\"addStudent\" parameterType=\"Student\"\u003e insert into student(name, sex) values(#{name}, #{sex}) \u003c/insert\u003e int addStudent(Student student); 我们这里使用的是一个实体类，我们可以直接使用实体类里面对应属性替换到SQL语句中，只需要填写属性名称即可，和条件查询是一样的。 ","date":"2022-02-16","objectID":"/posts/java%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93/:3:4","tags":["Java连接数据库"],"title":"Java连接数据库","uri":"/posts/java%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"categories":["JavaWeb笔记"],"content":"复杂查询 一个老师可以教授多个学生，那么能否一次性将老师的学生全部映射给此老师的对象呢，比如： @Data public class Teacher { int tid; String name; List\u003cStudent\u003e studentList; } 映射为Teacher对象时，同时将其教授的所有学生一并映射为List列表，显然这是一种一对多的查询，那么这时就需要进行复杂查询了。而我们之前编写的都非常简单，直接就能完成映射，因此我们现在需要使用resultMap来自定义映射规则： \u003cselect id=\"getTeacherByTid\" resultMap=\"asTeacher\"\u003e select *, teacher.name as tname from student inner join teach on student.sid = teach.sid inner join teacher on teach.tid = teacher.tid where teach.tid = #{tid} \u003c/select\u003e \u003cresultMap id=\"asTeacher\" type=\"Teacher\"\u003e \u003cid column=\"tid\" property=\"tid\"/\u003e \u003cresult column=\"tname\" property=\"name\"/\u003e \u003ccollection property=\"studentList\" ofType=\"Student\"\u003e \u003cid property=\"sid\" column=\"sid\"/\u003e \u003cresult column=\"name\" property=\"name\"/\u003e \u003cresult column=\"sex\" property=\"sex\"/\u003e \u003c/collection\u003e \u003c/resultMap\u003e 可以看到，我们的查询结果是一个多表联查的结果，而联查的数据就是我们需要映射的数据（比如这里是一个老师有N个学生，联查的结果也是这一个老师对应N个学生的N条记录），其中id标签用于在多条记录中辨别是否为同一个对象的数据，比如上面的查询语句得到的结果中，tid这一行始终为1，因此所有的记录都应该是tid=1的教师的数据，而不应该变为多个教师的数据，如果不加id进行约束，那么会被识别成多个教师的数据！ 通过使用collection来表示将得到的所有结果合并为一个集合，比如上面的数据中每个学生都有单独的一条记录，因此tid相同的全部学生的记录就可以最后合并为一个List，得到最终的映射结果，当然，为了区分，最好也设置一个id，只不过这个例子中可以当做普通的result使用。 了解了一对多，那么多对一又该如何查询呢，比如每个学生都有一个对应的老师，现在Student新增了一个Teacher对象，那么现在又该如何去处理呢？ @Data @Accessors(chain = true) public class Student { private int sid; private String name; private String sex; private Teacher teacher; } @Data public class Teacher { int tid; String name; } 现在我们希望的是，每次查询到一个Student对象时都带上它的老师，同样的，我们也可以使用resultMap来实现（先修改一下老师的类定义，不然会很麻烦）： \u003cresultMap id=\"test2\" type=\"Student\"\u003e \u003cid column=\"sid\" property=\"sid\"/\u003e \u003cresult column=\"name\" property=\"name\"/\u003e \u003cresult column=\"sex\" property=\"sex\"/\u003e \u003cassociation property=\"teacher\" javaType=\"Teacher\"\u003e \u003cid column=\"tid\" property=\"tid\"/\u003e \u003cresult column=\"tname\" property=\"name\"/\u003e \u003c/association\u003e \u003c/resultMap\u003e \u003cselect id=\"selectStudent\" resultMap=\"test2\"\u003e select *, teacher.name as tname from student left join teach on student.sid = teach.sid left join teacher on teach.tid = teacher.tid \u003c/select\u003e 通过使用association进行关联，形成多对一的关系，实际上和一对多是同理的，都是对查询结果的一种处理方式罢了。 ","date":"2022-02-16","objectID":"/posts/java%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93/:3:5","tags":["Java连接数据库"],"title":"Java连接数据库","uri":"/posts/java%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"categories":["JavaWeb笔记"],"content":"事务操作 我们可以在获取SqlSession关闭自动提交来开启事务模式，和JDBC其实都差不多： public static void main(String[] args) { try (SqlSession sqlSession = MybatisUtil.getSession(false)){ TestMapper testMapper = sqlSession.getMapper(TestMapper.class); testMapper.addStudent(new Student().setSex(\"男\").setName(\"小王\")); testMapper.selectStudent().forEach(System.out::println); } } 我们发现，在关闭自动提交后，我们的内容是没有进入到数据库的，现在我们来试一下在最后提交事务： sqlSession.commit(); 在事务提交后，我们的内容才会被写入到数据库中。现在我们来试试看回滚操作： try (SqlSession sqlSession = MybatisUtil.getSession(false)){ TestMapper testMapper = sqlSession.getMapper(TestMapper.class); testMapper.addStudent(new Student().setSex(\"男\").setName(\"小王\")); testMapper.selectStudent().forEach(System.out::println); sqlSession.rollback(); sqlSession.commit(); } 回滚操作也印证成功。 ","date":"2022-02-16","objectID":"/posts/java%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93/:3:6","tags":["Java连接数据库"],"title":"Java连接数据库","uri":"/posts/java%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"categories":["JavaWeb笔记"],"content":"动态SQL 动态 SQL 是 MyBatis 的强大特性之一。如果你使用过 JDBC 或其它类似的框架，你应该能理解根据不同条件拼接 SQL 语句有多痛苦，例如拼接时要确保不能忘记添加必要的空格，还要注意去掉列表最后一个列名的逗号。利用动态 SQL，可以彻底摆脱这种痛苦。 我们直接使用官网的例子进行讲解。 ","date":"2022-02-16","objectID":"/posts/java%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93/:3:7","tags":["Java连接数据库"],"title":"Java连接数据库","uri":"/posts/java%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"categories":["JavaWeb笔记"],"content":"缓存机制 MyBatis 内置了一个强大的事务性查询缓存机制，它可以非常方便地配置和定制。 其实缓存机制我们在之前学习IO流的时候已经提及过了，我们可以提前将一部分内容放入缓存，下次需要获取数据时，我们就可以直接从缓存中读取，这样的话相当于直接从内存中获取而不是再去向数据库索要数据，效率会更高。 因此Mybatis内置了一个缓存机制，我们查询时，如果缓存中存在数据，那么我们就可以直接从缓存中获取，而不是再去向数据库进行请求。 Mybatis存在一级缓存和二级缓存，我们首先来看一下一级缓存，默认情况下，只启用了本地的会话缓存，它仅仅对一个会话中的数据进行缓存（一级缓存无法关闭，只能调整），我们来看看下面这段代码： public static void main(String[] args) throws InterruptedException { try (SqlSession sqlSession = MybatisUtil.getSession(true)){ TestMapper testMapper = sqlSession.getMapper(TestMapper.class); Student student1 = testMapper.getStudentBySid(1); Student student2 = testMapper.getStudentBySid(1); System.out.println(student1 == student2); } } 我们发现，两次得到的是同一个Student对象，也就是说我们第二次查询并没有重新去构造对象，而是直接得到之前创建好的对象。如果还不是很明显，我们可以修改一下实体类： @Data @Accessors(chain = true) public class Student { public Student(){ System.out.println(\"我被构造了\"); } private int sid; private String name; private String sex; } 我们通过前面的学习得知Mybatis在映射为对象时，在只有一个构造方法的情况下，无论你构造方法写成什么样子，都会去调用一次构造方法，如果存在多个构造方法，那么就会去找匹配的构造方法。我们可以通过查看构造方法来验证对象被创建了几次。 结果显而易见，只创建了一次，也就是说当第二次进行同样的查询时，会直接使用第一次的结果，因为第一次的结果已经被缓存了。 那么如果我修改了数据库中的内容，缓存还会生效吗： public static void main(String[] args) throws InterruptedException { try (SqlSession sqlSession = MybatisUtil.getSession(true)){ TestMapper testMapper = sqlSession.getMapper(TestMapper.class); Student student1 = testMapper.getStudentBySid(1); testMapper.addStudent(new Student().setName(\"小李\").setSex(\"男\")); Student student2 = testMapper.getStudentBySid(1); System.out.println(student1 == student2); } } 我们发现，当我们进行了插入操作后，缓存就没有生效了，我们再次进行查询得到的是一个新创建的对象。 也就是说，一级缓存，在进行DML操作后，会使得缓存失效，也就是说Mybatis知道我们对数据库里面的数据进行了修改，所以之前缓存的内容可能就不是当前数据库里面最新的内容了。还有一种情况就是，当前会话结束后，也会清理全部的缓存，因为已经不会再用到了。但是一定注意，一级缓存只针对于单个会话，多个会话之间不相通。 public static void main(String[] args) { try (SqlSession sqlSession = MybatisUtil.getSession(true)){ TestMapper testMapper = sqlSession.getMapper(TestMapper.class); Student student2; try(SqlSession sqlSession2 = MybatisUtil.getSession(true)){ TestMapper testMapper2 = sqlSession2.getMapper(TestMapper.class); student2 = testMapper2.getStudentBySid(1); } Student student1 = testMapper.getStudentBySid(1); System.out.println(student1 == student2); } } **注意：**一个会话DML操作只会重置当前会话的缓存，不会重置其他会话的缓存，也就是说，其他会话缓存是不会更新的！ 一级缓存给我们提供了很高速的访问效率，但是它的作用范围实在是有限，如果一个会话结束，那么之前的缓存就全部失效了，但是我们希望缓存能够扩展到所有会话都能使用，因此我们可以通过二级缓存来实现，二级缓存默认是关闭状态，要开启二级缓存，我们需要在映射器XML文件中添加： \u003ccache/\u003e 可见二级缓存是Mapper级别的，也就是说，当一个会话失效时，它的缓存依然会存在于二级缓存中，因此如果我们再次创建一个新的会话会直接使用之前的缓存，我们首先根据官方文档进行一些配置： \u003ccache eviction=\"FIFO\" flushInterval=\"60000\" size=\"512\" readOnly=\"true\"/\u003e 我们来编写一个代码： public static void main(String[] args) { Student student; try (SqlSession sqlSession = MybatisUtil.getSession(true)){ TestMapper testMapper = sqlSession.getMapper(TestMapper.class); student = testMapper.getStudentBySid(1); } try (SqlSession sqlSession2 = MybatisUtil.getSession(true)){ TestMapper testMapper2 = sqlSession2.getMapper(TestMapper.class); Student student2 = testMapper2.getStudentBySid(1); System.out.println(student2 == student); } } 我们可以看到，上面的代码中首先是第一个会话在进行读操作，完成后会结束会话，而第二个操作重新创建了一个新的会话，再次执行了同样的查询，我们发现得到的依然是缓存的结果。 那么如果我不希望某个方法开启缓存呢？我们可以添加useCache属性来关闭缓存： \u003cselect id=\"getStudentBySid\" resultType=\"Student\" useCache=\"false\"\u003e select * from student where sid = #{sid} \u003c/select\u003e 我们也可以使用flushCache=“false\"在每次执行后都清空缓存，通过这这个我们还可以控制DML操作完成之后不清空缓存。 \u003cselect id=\"getStudentBySid\" resultType=\"Student\" flushCache=\"true\"\u003e select * from student where sid = #{sid} \u003c/select\u003e 添加了二级缓存之后，会先从二级缓存中查找数据，当二级缓存中没有时，才会从一级缓存中获取，当一级缓存中都还没有数据时，才会请求数据库，因此我们再来执行上面的代码： public static void main(String[] args) { try (SqlSession sqlSession = MybatisUtil.getSession(true)){ TestMapper testMapper = sqlSession.getMapper(TestMapper.class); Student student2; try(SqlSession sqlSession2 = MybatisUtil.getSession(true)){ TestMapper testMapper2 = sqlSession2.getMapper(TestMapper.class); student2 = testMapper2.getStudentBySid(1); } Student student1 = testMapper.getStudentBySid(1); System.out.println(student1 == student2); } } 得到的结果就会是同一个对象了，因为现在是优先从二级缓存中获取。 读取顺序：二级缓存 =\u003e 一级缓存 =\u003e 数据库 虽然缓存机制给我","date":"2022-02-16","objectID":"/posts/java%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93/:3:8","tags":["Java连接数据库"],"title":"Java连接数据库","uri":"/posts/java%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"categories":["JavaWeb笔记"],"content":"使用注解开发 在之前的开发中，我们已经体验到Mybatis为我们带来的便捷了，我们只需要编写对应的映射器，并将其绑定到一个接口上，即可直接通过该接口执行我们的SQL语句，极大的简化了我们之前JDBC那样的代码编写模式。那么，能否实现无需xml映射器配置，而是直接使用注解在接口上进行配置呢？答案是可以的，也是现在推荐的一种方式（也不是说XML就不要去用了，由于Java 注解的表达能力和灵活性十分有限，可能相对于XML配置某些功能实现起来会不太好办，但是在大部分场景下，直接使用注解开发已经绰绰有余了） 首先我们来看一下，使用XML进行映射器编写时，我们需要现在XML中定义映射规则和SQL语句，然后再将其绑定到一个接口的方法定义上，然后再使用接口来执行： \u003cinsert id=\"addStudent\"\u003e insert into student(name, sex) values(#{name}, #{sex}) \u003c/insert\u003e int addStudent(Student student); 而现在，我们可以直接使用注解来实现，每个操作都有一个对应的注解： @Insert(\"insert into student(name, sex) values(#{name}, #{sex})\") int addStudent(Student student); 当然，我们还需要修改一下配置文件中的映射器注册： \u003cmappers\u003e \u003cmapper class=\"com.test.mapper.MyMapper\"/\u003e \u003c!-- 也可以直接注册整个包下的 \u003cpackage name=\"com.test.mapper\"/\u003e --\u003e \u003c/mappers\u003e 通过直接指定Class，来让Mybatis知道我们这里有一个通过注解实现的映射器。 我们接着来看一下，如何使用注解进行自定义映射规则： @Results({ @Result(id = true, column = \"sid\", property = \"sid\"), @Result(column = \"sex\", property = \"name\"), @Result(column = \"name\", property = \"sex\") }) @Select(\"select * from student\") List\u003cStudent\u003e getAllStudent(); 直接通过@Results注解，就可以直接进行配置了，此注解的value是一个@Result注解数组，每个@Result注解都都一个单独的字段配置，其实就是我们之前在XML映射器中写的： \u003cresultMap id=\"test\" type=\"Student\"\u003e \u003cid property=\"sid\" column=\"sid\"/\u003e \u003cresult column=\"name\" property=\"sex\"/\u003e \u003cresult column=\"sex\" property=\"name\"/\u003e \u003c/resultMap\u003e 现在我们就可以通过注解来自定义映射规则了。那么如何使用注解来完成复杂查询呢？我们还是使用一个老师多个学生的例子： @Results({ @Result(id = true, column = \"tid\", property = \"tid\"), @Result(column = \"name\", property = \"name\"), @Result(column = \"tid\", property = \"studentList\", many = @Many(select = \"getStudentByTid\") ) }) @Select(\"select * from teacher where tid = #{tid}\") Teacher getTeacherBySid(int tid); @Select(\"select * from student inner join teach on student.sid = teach.sid where tid = #{tid}\") List\u003cStudent\u003e getStudentByTid(int tid); 我们发现，多出了一个子查询，而这个子查询是单独查询该老师所属学生的信息，而子查询结果作为@Result注解的一个many结果，代表子查询的所有结果都归入此集合中（也就是之前的collection标签） \u003cresultMap id=\"asTeacher\" type=\"Teacher\"\u003e \u003cid column=\"tid\" property=\"tid\"/\u003e \u003cresult column=\"tname\" property=\"name\"/\u003e \u003ccollection property=\"studentList\" ofType=\"Student\"\u003e \u003cid property=\"sid\" column=\"sid\"/\u003e \u003cresult column=\"name\" property=\"name\"/\u003e \u003cresult column=\"sex\" property=\"sex\"/\u003e \u003c/collection\u003e \u003c/resultMap\u003e 同理，@Result也提供了@One子注解来实现一对一的关系表示，类似于之前的assocation标签： @Results({ @Result(id = true, column = \"sid\", property = \"sid\"), @Result(column = \"sex\", property = \"name\"), @Result(column = \"name\", property = \"sex\"), @Result(column = \"sid\", property = \"teacher\", one = @One(select = \"getTeacherBySid\") ) }) @Select(\"select * from student\") List\u003cStudent\u003e getAllStudent(); 如果现在我希望直接使用注解编写SQL语句但是我希望映射规则依然使用XML来实现，这时该怎么办呢？ @ResultMap(\"test\") @Select(\"select * from student\") List\u003cStudent\u003e getAllStudent(); 提供了@ResultMap注解，直接指定ID即可，这样我们就可以使用XML中编写的映射规则了，这里就不再演示了。 那么如果出现之前的两个构造方法的情况，且没有任何一个构造方法匹配的话，该怎么处理呢？ @Data @Accessors(chain = true) public class Student { public Student(int sid){ System.out.println(\"我是一号构造方法\"+sid); } public Student(int sid, String name){ System.out.println(\"我是二号构造方法\"+sid+name); } private int sid; private String name; private String sex; } 我们可以通过@ConstructorArgs注解来指定构造方法： @ConstructorArgs({ @Arg(column = \"sid\", javaType = int.class), @Arg(column = \"name\", javaType = String.class) }) @Select(\"select * from student where sid = #{sid} and sex = #{sex}\") Student getStudentBySidAndSex(@Param(\"sid\") int sid, @Param(\"sex\") String sex); 得到的结果和使用constructor标签效果一致，这里就不多做讲解了。 我们发现，当参数列表中出现两个以上的参数时，会出现错误： @Select(\"select * from student where sid = #{sid} and sex = #{sex}\") Student getStudentBySidAndSex(int sid, String sex); Exception in thread \"main\" org.apache.ibatis.exceptions.PersistenceException: ### Error querying database. Cause: org.apache.ibatis.binding.BindingException: Parameter 'sid' not found. Available parameters are [arg1, arg0, param1, param2] ### Cause: org.apache.ibatis.binding.BindingException: Parameter 'sid' not found. Available parameters are [arg1, arg0, param1, param2] at org.apache.ibatis.exceptions.ExceptionFactory.wrapException(ExceptionFactory.java:30) at org.apache.ibatis.session.defaults.","date":"2022-02-16","objectID":"/posts/java%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93/:3:9","tags":["Java连接数据库"],"title":"Java连接数据库","uri":"/posts/java%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"categories":["JavaWeb笔记"],"content":"探究Mybatis的动态代理机制 在探究动态代理机制之前，我们要先聊聊什么是代理：其实顾名思义，就好比我开了个大棚，里面栽种的西瓜，那么西瓜成熟了是不是得去卖掉赚钱，而我们的西瓜非常多，一个人肯定卖不过来，肯定就要去多找几个开水果摊的帮我们卖，这就是一种代理。实际上是由水果摊老板在帮我们卖瓜，我们只告诉老板卖多少钱，而至于怎么卖的是由水果摊老板决定的。 那么现在我们来尝试实现一下这样的类结构，首先定义一个接口用于规范行为： public interface Shopper { //卖瓜行为 void saleWatermelon(String customer); } 然后需要实现一下卖瓜行为，也就是我们要告诉老板卖多少钱，这里就直接写成成功出售： public class ShopperImpl implements Shopper{ //卖瓜行为的实现 @Override public void saleWatermelon(String customer) { System.out.println(\"成功出售西瓜给 ===\u003e \"+customer); } } 最后老板代理后肯定要用自己的方式去出售这些西瓜，成交之后再按照我们告诉老板的价格进行出售： public class ShopperProxy implements Shopper{ private final Shopper impl; public ShopperProxy(Shopper impl){ this.impl = impl; } //代理卖瓜行为 @Override public void saleWatermelon(String customer) { //首先进行 代理商讨价还价行为 System.out.println(customer + \"：哥们，这瓜多少钱一斤啊？\"); System.out.println(\"老板：两块钱一斤。\"); System.out.println(customer + \"：你这瓜皮子是金子做的，还是瓜粒子是金子做的？\"); System.out.println(\"老板：你瞅瞅现在哪有瓜啊，这都是大棚的瓜，你嫌贵我还嫌贵呢。\"); System.out.println(customer + \"：给我挑一个。\"); impl.saleWatermelon(customer); //讨价还价成功，进行我们告诉代理商的卖瓜行为 } } 现在我们来试试看： public class Main { public static void main(String[] args) { Shopper shopper = new ShopperProxy(new ShopperImpl()); shopper.saleWatermelon(\"小强\"); } } 这样的操作称为静态代理，也就是说我们需要提前知道接口的定义并进行实现才可以完成代理，而Mybatis这样的是无法预知代理接口的，我们就需要用到动态代理。 JDK提供的反射框架就为我们很好地解决了动态代理的问题，在这里相当于对JavaSE阶段反射的内容进行一个补充。 public class ShopperProxy implements InvocationHandler { Object target; public ShopperProxy(Object target){ this.target = target; } @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { String customer = (String) args[0]; System.out.println(customer + \"：哥们，这瓜多少钱一斤啊？\"); System.out.println(\"老板：两块钱一斤。\"); System.out.println(customer + \"：你这瓜皮子是金子做的，还是瓜粒子是金子做的？\"); System.out.println(\"老板：你瞅瞅现在哪有瓜啊，这都是大棚的瓜，你嫌贵我还嫌贵呢。\"); System.out.println(customer + \"：行，给我挑一个。\"); return method.invoke(target, args); } } 通过实现InvocationHandler来成为一个动态代理，我们发现它提供了一个invoke方法，用于调用被代理对象的方法并完成我们的代理工作。现在就可以通过 Proxy.newProxyInstance来生成一个动态代理类： public static void main(String[] args) { Shopper impl = new ShopperImpl(); Shopper shopper = (Shopper) Proxy.newProxyInstance(impl.getClass().getClassLoader(), impl.getClass().getInterfaces(), new ShopperProxy(impl)); shopper.saleWatermelon(\"小强\"); System.out.println(shopper.getClass()); } 通过打印类型我们发现，就是我们之前看到的那种奇怪的类：class com.sun.proxy.$Proxy0，因此Mybatis其实也是这样的来实现的（肯定有人问了：Mybatis是直接代理接口啊，你这个不还是要把接口实现了吗？）那我们来改改，现在我们不代理任何类了，直接做接口实现： public class ShopperProxy implements InvocationHandler { @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { String customer = (String) args[0]; System.out.println(customer + \"：哥们，这瓜多少钱一斤啊？\"); System.out.println(\"老板：两块钱一斤。\"); System.out.println(customer + \"：你这瓜皮子是金子做的，还是瓜粒子是金子做的？\"); System.out.println(\"老板：你瞅瞅现在哪有瓜啊，这都是大棚的瓜，你嫌贵我还嫌贵呢。\"); System.out.println(customer + \"：行，给我挑一个。\"); return null; } } public static void main(String[] args) { Shopper shopper = (Shopper) Proxy.newProxyInstance(Shopper.class.getClassLoader(), new Class[]{ Shopper.class }, //因为本身就是接口，所以直接用就行 new ShopperProxy()); shopper.saleWatermelon(\"小强\"); System.out.println(shopper.getClass()); } 我们可以去看看Mybatis的源码。 Mybatis的学习差不多就到这里为止了，不过，同样类型的框架还有很多，Mybatis属于半自动框架，SQL语句依然需要我们自己编写，虽然存在一定的麻烦，但是会更加灵活，而后面我们还会学习JPA，它是全自动的框架，你几乎见不到SQL的影子！ ","date":"2022-02-16","objectID":"/posts/java%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93/:3:10","tags":["Java连接数据库"],"title":"Java连接数据库","uri":"/posts/java%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"categories":["JavaWeb笔记"],"content":"使用JUnit进行单元测试 首先一问：我们为什么需要单元测试？ 随着我们的项目逐渐变大，比如我们之前编写的图书管理系统，我们都是边在写边在测试，而我们当时使用的测试方法，就是直接在主方法中运行测试，但是，在很多情况下，我们的项目可能会很庞大，不可能每次都去完整地启动一个项目来测试某一个功能，这样显然会降低我们的开发效率，因此，我们需要使用单元测试来帮助我们针对于某个功能或是某个模块单独运行代码进行测试，而不是启动整个项目。 同时，在我们项目的维护过程中，难免会涉及到一些原有代码的修改，很有可能出现改了代码导致之前的功能出现问题（牵一发而动全身），而我们又不一定能立即察觉到，因此，我们可以提前保存一些测试用例，每次完成代码后都可以跑一遍测试用例，来确保之前的功能没有因为后续的修改而出现问题。 我们还可以利用单元测试来评估某个模块或是功能的耗时和性能，快速排查导致程序运行缓慢的问题，这些都可以通过单元测试来完成，可见单元测试对于开发的重要性。 ","date":"2022-02-16","objectID":"/posts/java%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93/:4:0","tags":["Java连接数据库"],"title":"Java连接数据库","uri":"/posts/java%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"categories":["JavaWeb笔记"],"content":"尝试JUnit 首先需要导入JUnit依赖，我们在这里使用Junit4进行介绍，最新的Junit5放到Maven板块一起讲解，Jar包已经放在视频下方简介中，直接去下载即可。同时IDEA需要安装JUnit插件（默认是已经捆绑安装的，因此无需多余配置） 现在我们创建一个新的类，来编写我们的单元测试用例： public class TestMain { @Test public void method(){ System.out.println(\"我是测试用例1\"); } @Test public void method2(){ System.out.println(\"我是测试用例2\"); } } 我们可以点击类前面的测试按钮，或是单个方法前的测试按钮，如果点击类前面的测试按钮，会执行所有的测试用例。 运行测试后，我们发现控制台得到了一个测试结果，显示为绿色表示测试通过。 只需要通过打上@Test注解，即可将一个方法标记为测试案例，我们可以直接运行此测试案例，但是我们编写的测试方法有以下要求： 方法必须是public的 不能是静态方法 返回值必须是void 必须是没有任何参数的方法 对于一个测试案例来说，我们肯定希望测试的结果是我们所期望的一个值，因此，如果测试的结果并不是我们所期望的结果，那么这个测试就应该没有成功通过！ 我们可以通过断言工具类来进行判定： public class TestMain { @Test public void method(){ System.out.println(\"我是测试案例！\"); Assert.assertEquals(1, 2); //参数1是期盼值，参数2是实际测试结果值 } } 通过运行代码后，我们发现测试过程中抛出了一个错误，并且IDEA给我们显示了期盼结果和测试结果，那么现在我们来测试一个案例，比如我们想查看冒泡排序的编写是否正确： @Test public void method(){ int[] arr = {0, 4, 5, 2, 6, 9, 3, 1, 7, 8}; //错误的冒泡排序 for (int i = 0; i \u003c arr.length - 1; i++) { for (int j = 0; j \u003c arr.length - 1 - i; j++) { if(arr[j] \u003e arr[j + 1]){ int tmp = arr[j]; arr[j] = arr[j+1]; // arr[j+1] = tmp; } } } Assert.assertArrayEquals(new int[]{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}, arr); } 通过测试，我们发现得到的结果并不是我们想要的结果，因此现在我们需要去修改为正确的冒泡排序，修改后，测试就能正确通过了。我们还可以再通过一个案例来更加深入地了解测试，现在我们想测试从数据库中取数据是否为我们预期的数据： @Test public void method(){ try (SqlSession sqlSession = MybatisUtil.getSession(true)){ TestMapper mapper = sqlSession.getMapper(TestMapper.class); Student student = mapper.getStudentBySidAndSex(1, \"男\"); Assert.assertEquals(new Student().setName(\"小明\").setSex(\"男\").setSid(1), student); } } 那么如果我们在进行所有的测试之前需要做一些前置操作该怎么办呢，一种办法是在所有的测试用例前面都加上前置操作，但是这样显然是很冗余的，因为一旦发生修改就需要挨个进行修改，因此我们需要更加智能的方法，我们可以通过@Before注解来添加测试用例开始之前的前置操作： public class TestMain { private SqlSessionFactory sqlSessionFactory; @Before public void before(){ System.out.println(\"测试前置正在初始化...\"); try { sqlSessionFactory = new SqlSessionFactoryBuilder() .build(new FileInputStream(\"mybatis-config.xml\")); } catch (FileNotFoundException e) { e.printStackTrace(); } System.out.println(\"测试初始化完成，正在开始测试案例...\"); } @Test public void method1(){ try (SqlSession sqlSession = sqlSessionFactory.openSession(true)){ TestMapper mapper = sqlSession.getMapper(TestMapper.class); Student student = mapper.getStudentBySidAndSex(1, \"男\"); Assert.assertEquals(new Student().setName(\"小明\").setSex(\"男\").setSid(1), student); System.out.println(\"测试用例1通过！\"); } } @Test public void method2(){ try (SqlSession sqlSession = sqlSessionFactory.openSession(true)){ TestMapper mapper = sqlSession.getMapper(TestMapper.class); Student student = mapper.getStudentBySidAndSex(2, \"女\"); Assert.assertEquals(new Student().setName(\"小红\").setSex(\"女\").setSid(2), student); System.out.println(\"测试用例2通过！\"); } } } 同理，在所有的测试完成之后，我们还想添加一个收尾的动作，那么只需要使用@After注解即可添加结束动作： @After public void after(){ System.out.println(\"测试结束，收尾工作正在进行...\"); } 有关JUnit的使用我们就暂时只介绍这么多。 ","date":"2022-02-16","objectID":"/posts/java%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93/:4:1","tags":["Java连接数据库"],"title":"Java连接数据库","uri":"/posts/java%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"categories":["JavaWeb笔记"],"content":"JUL日志系统 首先一问：我们为什么需要日志系统？ 我们之前一直都在使用System.out.println来打印信息，但是，如果项目中存在大量的控制台输出语句，会显得很凌乱，而且日志的粒度是不够细的，假如我们现在希望，项目只在debug的情况下打印某些日志，而在实际运行时不打印日志，采用直接输出的方式就很难实现了，因此我们需要使用日志框架来规范化日志输出。 而JDK为我们提供了一个自带的日志框架，位于java.util.logging包下，我们可以使用此框架来实现日志的规范化打印，使用起来非常简单： public class Main { public static void main(String[] args) { // 首先获取日志打印器 Logger logger = Logger.getLogger(Main.class.getName()); // 调用info来输出一个普通的信息，直接填写字符串即可 logger.info(\"我是普通的日志\"); } } 我们可以在主类中使用日志打印，得到日志的打印结果： 十一月 15, 2021 12:55:37 下午 com.test.Main main 信息: 我是普通的日志 我们发现，通过日志输出的结果会更加规范。 ","date":"2022-02-16","objectID":"/posts/java%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93/:5:0","tags":["Java连接数据库"],"title":"Java连接数据库","uri":"/posts/java%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"categories":["JavaWeb笔记"],"content":"JUL日志讲解 日志分为7个级别，详细信息我们可以在Level类中查看： SEVERE（最高值）- 一般用于代表严重错误 WARNING - 一般用于表示某些警告，但是不足以判断为错误 INFO （默认级别） - 常规消息 CONFIG FINE FINER FINEST（最低值） 我们之前通过info方法直接输出的结果就是使用的默认级别的日志，我们可以通过log方法来设定该条日志的输出级别： public static void main(String[] args) { Logger logger = Logger.getLogger(Main.class.getName()); logger.log(Level.SEVERE, \"严重的错误\", new IOException(\"我就是错误\")); logger.log(Level.WARNING, \"警告的内容\"); logger.log(Level.INFO, \"普通的信息\"); logger.log(Level.CONFIG, \"级别低于普通信息\"); } 我们发现，级别低于默认级别的日志信息，无法输出到控制台，我们可以通过设置来修改日志的打印级别： public static void main(String[] args) { Logger logger = Logger.getLogger(Main.class.getName()); //修改日志级别 logger.setLevel(Level.CONFIG); //不使用父日志处理器 logger.setUseParentHandlers(false); //使用自定义日志处理器 ConsoleHandler handler = new ConsoleHandler(); handler.setLevel(Level.CONFIG); logger.addHandler(handler); logger.log(Level.SEVERE, \"严重的错误\", new IOException(\"我就是错误\")); logger.log(Level.WARNING, \"警告的内容\"); logger.log(Level.INFO, \"普通的信息\"); logger.log(Level.CONFIG, \"级别低于普通信息\"); } 每个Logger都有一个父日志打印器，我们可以通过getParent()来获取： public static void main(String[] args) throws IOException { Logger logger = Logger.getLogger(Main.class.getName()); System.out.println(logger.getParent().getClass()); } 我们发现，得到的是java.util.logging.LogManager$RootLogger这个类，它默认使用的是ConsoleHandler，且日志级别为INFO，由于每一个日志打印器都会直接使用父类的处理器，因此我们之前需要关闭父类然后使用我们自己的处理器。 我们通过使用自己日志处理器来自定义级别的信息打印到控制台，当然，日志处理器不仅仅只有控制台打印，我们也可以使用文件处理器来处理日志信息，我们继续添加一个处理器： //添加输出到本地文件 FileHandler fileHandler = new FileHandler(\"test.log\"); fileHandler.setLevel(Level.WARNING); logger.addHandler(fileHandler); 注意，这个时候就有两个日志处理器了，因此控制台和文件的都会生效。如果日志的打印格式我们不喜欢，我们还可以自定义打印格式，比如我们控制台处理器就默认使用的是SimpleFormatter，而文件处理器则是使用的XMLFormatter，我们可以自定义： //使用自定义日志处理器(控制台) ConsoleHandler handler = new ConsoleHandler(); handler.setLevel(Level.CONFIG); handler.setFormatter(new XMLFormatter()); logger.addHandler(handler); 我们可以直接配置为想要的打印格式，如果这些格式还不能满足你，那么我们也可以自行实现： public static void main(String[] args) throws IOException { Logger logger = Logger.getLogger(Main.class.getName()); logger.setUseParentHandlers(false); //为了让颜色变回普通的颜色，通过代码块在初始化时将输出流设定为System.out ConsoleHandler handler = new ConsoleHandler(){{ setOutputStream(System.out); }}; //创建匿名内部类实现自定义的格式 handler.setFormatter(new Formatter() { @Override public String format(LogRecord record) { SimpleDateFormat format = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss.SSS\"); String time = format.format(new Date(record.getMillis())); //格式化日志时间 String level = record.getLevel().getName(); // 获取日志级别名称 // String level = record.getLevel().getLocalizedName(); // 获取本地化名称（语言跟随系统） String thread = String.format(\"%10s\", Thread.currentThread().getName()); //线程名称（做了格式化处理，留出10格空间） long threadID = record.getThreadID(); //线程ID String className = String.format(\"%-20s\", record.getSourceClassName()); //发送日志的类名 String msg = record.getMessage(); //日志消息 //\\033[33m作为颜色代码，30~37都有对应的颜色，38是没有颜色，IDEA能显示，但是某些地方可能不支持 return \"\\033[38m\" + time + \" \\033[33m\" + level + \" \\033[35m\" + threadID + \"\\033[38m --- [\" + thread + \"] \\033[36m\" + className + \"\\033[38m : \" + msg + \"\\n\"; } }); logger.addHandler(handler); logger.info(\"我是测试消息1...\"); logger.log(Level.INFO, \"我是测试消息2...\"); logger.log(Level.WARNING, \"我是测试消息3...\"); } 日志可以设置过滤器，如果我们不希望某些日志信息被输出，我们可以配置过滤规则： public static void main(String[] args) throws IOException { Logger logger = Logger.getLogger(Main.class.getName()); //自定义过滤规则 logger.setFilter(record -\u003e !record.getMessage().contains(\"普通\")); logger.log(Level.SEVERE, \"严重的错误\", new IOException(\"我就是错误\")); logger.log(Level.WARNING, \"警告的内容\"); logger.log(Level.INFO, \"普通的信息\"); } 实际上，整个日志的输出流程如下： ","date":"2022-02-16","objectID":"/posts/java%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93/:5:1","tags":["Java连接数据库"],"title":"Java连接数据库","uri":"/posts/java%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"categories":["JavaWeb笔记"],"content":"Properties配置文件 Properties文件是Java的一种配置文件，我们之前学习了XML，但是我们发现XML配置文件读取实在是太麻烦，那么能否有一种简单一点的配置文件呢？我们可以使用Properties文件： name=Test\rdesc=Description\r该文件配置很简单，格式为配置项=配置值，我们可以直接通过Properties类来将其读取为一个类似于Map一样的对象： public static void main(String[] args) throws IOException { Properties properties = new Properties(); properties.load(new FileInputStream(\"test.properties\")); System.out.println(properties); } 我们发现，Properties类是继承自Hashtable，而Hashtable是实现的Map接口，也就是说，Properties本质上就是一个Map一样的结构，它会把所有的配置项映射为一个Map，这样我们就可以快速地读取对应配置的值了。 我们也可以将已经存在的Properties对象放入输出流进行保存，我们这里就不保存文件了，而是直接打印到控制台，我们只需要提供输出流即可： public static void main(String[] args) throws IOException { Properties properties = new Properties(); // properties.setProperty(\"test\", \"lbwnb\"); //和put效果一样 properties.put(\"test\", \"lbwnb\"); properties.store(System.out, \"????\"); //properties.storeToXML(System.out, \"????\"); 保存为XML格式 } 我们可以通过System.getProperties()获取系统的参数，我们来看看： public static void main(String[] args) throws IOException { System.getProperties().store(System.out, \"系统信息：\"); } ","date":"2022-02-16","objectID":"/posts/java%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93/:5:2","tags":["Java连接数据库"],"title":"Java连接数据库","uri":"/posts/java%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"categories":["JavaWeb笔记"],"content":"编写日志配置文件 我们可以通过进行配置文件来规定日志打印器的一些默认值： # RootLogger 的默认处理器为\rhandlers= java.util.logging.ConsoleHandler\r# RootLogger 的默认的日志级别\r.level= CONFIG\r我们来尝试使用配置文件来进行配置： public static void main(String[] args) throws IOException { //获取日志管理器 LogManager manager = LogManager.getLogManager(); //读取我们自己的配置文件 manager.readConfiguration(new FileInputStream(\"logging.properties\")); //再获取日志打印器 Logger logger = Logger.getLogger(Main.class.getName()); logger.log(Level.CONFIG, \"我是一条日志信息\"); //通过自定义配置文件，我们发现默认级别不再是INFO了 } 我们也可以去修改ConsoleHandler的默认配置： # 指定默认日志级别\rjava.util.logging.ConsoleHandler.level = ALL\r# 指定默认日志消息格式\rjava.util.logging.ConsoleHandler.formatter = java.util.logging.SimpleFormatter\r# 指定默认的字符集\rjava.util.logging.ConsoleHandler.encoding = UTF-8\r其实，我们阅读ConsoleHandler的源码就会发现，它就是通过读取配置文件来进行某些参数设置： // Private method to configure a ConsoleHandler from LogManager // properties and/or default values as specified in the class // javadoc. private void configure() { LogManager manager = LogManager.getLogManager(); String cname = getClass().getName(); setLevel(manager.getLevelProperty(cname +\".level\", Level.INFO)); setFilter(manager.getFilterProperty(cname +\".filter\", null)); setFormatter(manager.getFormatterProperty(cname +\".formatter\", new SimpleFormatter())); try { setEncoding(manager.getStringProperty(cname +\".encoding\", null)); } catch (Exception ex) { try { setEncoding(null); } catch (Exception ex2) { // doing a setEncoding with null should always work. // assert false; } } } ","date":"2022-02-16","objectID":"/posts/java%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93/:5:3","tags":["Java连接数据库"],"title":"Java连接数据库","uri":"/posts/java%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"categories":["JavaWeb笔记"],"content":"使用Lombok快速开启日志 我们发现，如果我们现在需要全面使用日志系统，而不是传统的直接打印，那么就需要在每个类都去编写获取Logger的代码，这样显然是很冗余的，能否简化一下这个流程呢？ 前面我们学习了Lombok，我们也体会到Lombok给我们带来的便捷，我们可以通过一个注解快速生成构造方法、Getter和Setter，同样的，Logger也是可以使用Lombok快速生成的。 @Log public class Main { public static void main(String[] args) { System.out.println(\"自动生成的Logger名称：\"+log.getName()); log.info(\"我是日志信息\"); } } 只需要添加一个@Log注解即可，添加后，我们可以直接使用一个静态变量log，而它就是自动生成的Logger。我们也可以手动指定名称： @Log(topic = \"打工是不可能打工的\") public class Main { public static void main(String[] args) { System.out.println(\"自动生成的Logger名称：\"+log.getName()); log.info(\"我是日志信息\"); } } ","date":"2022-02-16","objectID":"/posts/java%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93/:5:4","tags":["Java连接数据库"],"title":"Java连接数据库","uri":"/posts/java%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"categories":["JavaWeb笔记"],"content":"Mybatis日志系统 Mybatis也有日志系统，它详细记录了所有的数据库操作等，但是我们在前面的学习中没有开启它，现在我们学习了日志之后，我们就可以尝试开启Mybatis的日志系统，来监控所有的数据库操作，要开启日志系统，我们需要进行配置： \u003csetting name=\"logImpl\" value=\"STDOUT_LOGGING\" /\u003e logImpl包括很多种配置项，包括 SLF4J | LOG4J | LOG4J2 | JDK_LOGGING | COMMONS_LOGGING | STDOUT_LOGGING | NO_LOGGING，而默认情况下是未配置，也就是说不打印。我们这里将其设定为STDOUT_LOGGING表示直接使用标准输出将日志信息打印到控制台，我们编写一个测试案例来看看效果： public class TestMain { private SqlSessionFactory sqlSessionFactory; @Before public void before(){ try { sqlSessionFactory = new SqlSessionFactoryBuilder() .build(new FileInputStream(\"mybatis-config.xml\")); } catch (FileNotFoundException e) { e.printStackTrace(); } } @Test public void test(){ try(SqlSession sqlSession = sqlSessionFactory.openSession(true)){ TestMapper mapper = sqlSession.getMapper(TestMapper.class); System.out.println(mapper.getStudentBySidAndSex(1, \"男\")); System.out.println(mapper.getStudentBySidAndSex(1, \"男\")); } } } 我们发现，两次获取学生信息，只有第一次打开了数据库连接，而第二次并没有。 现在我们学习了日志系统，那么我们来尝试使用日志系统输出Mybatis的日志信息： \u003csetting name=\"logImpl\" value=\"JDK_LOGGING\" /\u003e 将其配置为JDK_LOGGING表示使用JUL进行日志打印，因为Mybatis的日志级别都比较低，因此我们需要设置一下logging.properties默认的日志级别： handlers= java.util.logging.ConsoleHandler\r.level= ALL\rjava.util.logging.ConsoleHandler.level = ALL\r代码编写如下： @Log public class TestMain { private SqlSessionFactory sqlSessionFactory; @Before public void before(){ try { sqlSessionFactory = new SqlSessionFactoryBuilder() .build(new FileInputStream(\"mybatis-config.xml\")); LogManager manager = LogManager.getLogManager(); manager.readConfiguration(new FileInputStream(\"logging.properties\")); } catch (IOException e) { e.printStackTrace(); } } @Test public void test(){ try(SqlSession sqlSession = sqlSessionFactory.openSession(true)){ TestMapper mapper = sqlSession.getMapper(TestMapper.class); log.info(mapper.getStudentBySidAndSex(1, \"男\").toString()); log.info(mapper.getStudentBySidAndSex(1, \"男\").toString()); } } } 但是我们发现，这样的日志信息根本没法看，因此我们需要修改一下日志的打印格式，我们自己创建一个格式化类： public class TestFormatter extends Formatter { @Override public String format(LogRecord record) { SimpleDateFormat format = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss.SSS\"); String time = format.format(new Date(record.getMillis())); //格式化日志时间 return time + \" : \" + record.getMessage() + \"\\n\"; } } 现在再来修改一下默认的格式化实现： handlers= java.util.logging.ConsoleHandler\r.level= ALL\rjava.util.logging.ConsoleHandler.level = ALL\rjava.util.logging.ConsoleHandler.formatter = com.test.TestFormatter\r现在就好看多了，当然，我们还可以继续为Mybatis添加文件日志，这里就不做演示了。 ","date":"2022-02-16","objectID":"/posts/java%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93/:5:5","tags":["Java连接数据库"],"title":"Java连接数据库","uri":"/posts/java%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"categories":["JavaWeb笔记"],"content":"使用Maven管理项目 **注意：**开始之前，看看你C盘空间够不够，最好预留2GB空间以上！ **吐槽：**很多电脑预装系统C盘都给得巨少，就算不装软件，一些软件的缓存文件也能给你塞满，建议有时间重装一下系统重新分配一下磁盘空间。 Maven 翻译为\"专家”、“内行”，是 Apache 下的一个纯 Java 开发的开源项目。基于项目对象模型（缩写：POM）概念，Maven利用一个中央信息片断能管理一个项目的构建、报告和文档等步骤。Maven 是一个项目管理工具，可以对 Java 项目进行构建、依赖管理。Maven 也可被用于构建和管理各种项目，例如 C#，Ruby，Scala 和其他语言编写的项目。Maven 曾是 Jakarta 项目的子项目，现为由 Apache 软件基金会主持的独立 Apache 项目。 通过Maven，可以帮助我们做： 项目的自动构建，包括代码的编译、测试、打包、安装、部署等操作。 依赖管理，项目使用到哪些依赖，可以快速完成导入。 我们之前并没有讲解如何将我们的项目打包为Jar文件运行，同时，我们导入依赖的时候，每次都要去下载对应的Jar包，这样其实是很麻烦的，并且还有可能一个Jar包依赖于另一个Jar包，就像之前使用JUnit一样，因此我们需要一个更加方便的包管理机制。 Maven也需要安装环境，但是IDEA已经自带了Maven环境，因此我们不需要再去进行额外的环境安装（无IDEA也能使用Maven，但是配置过程很麻烦，并且我们现在使用的都是IDEA的集成开发环境，所以这里就不讲解Maven命令行操作了）我们直接创建一个新的Maven项目即可。 ","date":"2022-02-16","objectID":"/posts/java%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93/:6:0","tags":["Java连接数据库"],"title":"Java连接数据库","uri":"/posts/java%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"categories":["JavaWeb笔记"],"content":"Maven项目结构 我们可以来看一下，一个Maven项目和我们普通的项目有什么区别： 那么首先，我们需要了解一下POM文件，它相当于是我们整个Maven项目的配置文件，它也是使用XML编写的： \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003cproject xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"\u003e \u003cmodelVersion\u003e4.0.0\u003c/modelVersion\u003e \u003cgroupId\u003eorg.example\u003c/groupId\u003e \u003cartifactId\u003eMavenTest\u003c/artifactId\u003e \u003cversion\u003e1.0-SNAPSHOT\u003c/version\u003e \u003cproperties\u003e \u003cmaven.compiler.source\u003e8\u003c/maven.compiler.source\u003e \u003cmaven.compiler.target\u003e8\u003c/maven.compiler.target\u003e \u003c/properties\u003e \u003c/project\u003e 我们可以看到，Maven的配置文件是以project为根节点，而modelVersion定义了当前模型的版本，一般是4.0.0，我们不用去修改。 groupId、artifactId、version这三个元素合在一起，用于唯一区别每个项目，别人如果需要将我们编写的代码作为依赖，那么就必须通过这三个元素来定位我们的项目，我们称为一个项目的基本坐标，所有的项目一般都有自己的Maven坐标，因此我们通过Maven导入其他的依赖只需要填写这三个基本元素就可以了，无需再下载Jar文件，而是Maven自动帮助我们下载依赖并导入。 groupId 一般用于指定组名称，命名规则一般和包名一致，比如我们这里使用的是org.example，一个组下面可以有很多个项目。 artifactId 一般用于指定项目在当前组中的唯一名称，也就是说在组中用于区分于其他项目的标记。 version 代表项目版本，随着我们项目的开发和改进，版本号也会不断更新，就像LOL一样，每次赛季更新都会有一个大版本更新，我们的Maven项目也是这样，我们可以手动指定当前项目的版本号，其他人使用我们的项目作为依赖时，也可以根本版本号进行选择（这里的SNAPSHOT代表快照，一般表示这是一个处于开发中的项目，正式发布项目一般只带版本号） properties中一般都是一些变量和选项的配置，我们这里指定了JDK的源代码和编译版本为1.8，无需进行修改。 ","date":"2022-02-16","objectID":"/posts/java%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93/:6:1","tags":["Java连接数据库"],"title":"Java连接数据库","uri":"/posts/java%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"categories":["JavaWeb笔记"],"content":"Maven依赖导入 现在我们尝试使用Maven来帮助我们快速导入依赖，我们需要导入之前的JDBC驱动依赖、JUnit依赖、Mybatis依赖、Lombok依赖，那么如何使用Maven来管理依赖呢？ 我们可以创建一个dependencies节点： \u003cdependencies\u003e //里面填写的就是所有的依赖 \u003c/dependencies\u003e 那么现在就可以向节点中填写依赖了，那么我们如何知道每个依赖的坐标呢？我们可以在：https://mvnrepository.com/ 进行查询（可能打不开，建议用流量，或是直接百度某个项目的Maven依赖），我们直接搜索lombok即可，打开后可以看到已经给我们写出了依赖的坐标： \u003cdependency\u003e \u003cgroupId\u003eorg.projectlombok\u003c/groupId\u003e \u003cartifactId\u003elombok\u003c/artifactId\u003e \u003cversion\u003e1.18.22\u003c/version\u003e \u003cscope\u003eprovided\u003c/scope\u003e \u003c/dependency\u003e 我们直接将其添加到dependencies节点中即可，现在我们来编写一个测试用例看看依赖导入成功了没有： public class Main { public static void main(String[] args) { Student student = new Student(\"小明\", 18); System.out.println(student); } } @Data @AllArgsConstructor public class Student { String name; int age; } 项目运行成功，表示成功导入了依赖。那么，Maven是如何进行依赖管理呢，以致于如此便捷的导入依赖，我们来看看Maven项目的依赖管理流程： 通过流程图我们得知，一个项目依赖一般是存储在中央仓库中，也有可能存储在一些其他的远程仓库（私服），几乎所有的依赖都被放到了中央仓库中，因此，Maven可以直接从中央仓库中下载大部分的依赖（Maven第一次导入依赖是需要联网的），远程仓库中下载之后 ，会暂时存储在本地仓库，我们会发现我们本地存在一个.m2文件夹，这就是Maven本地仓库文件夹，默认建立在C盘，如果你C盘空间不足，会出现问题！ 在下次导入依赖时，如果Maven发现本地仓库中就已经存在某个依赖，那么就不会再去远程仓库下载了。 可能在导入依赖时，小小伙伴们会出现卡顿的问题，我们建议配置一下IDEA自带的Maven插件远程仓库地址，我们打开IDEA的安装目录，找到安装根目录/plugins/maven/lib/maven3/conf文件夹，找到settings.xml文件，打开编辑： 找到mirros标签，添加以下内容： \u003cmirror\u003e \u003cid\u003enexus-aliyun\u003c/id\u003e \u003cmirrorOf\u003e*\u003c/mirrorOf\u003e \u003cname\u003eNexus aliyun\u003c/name\u003e \u003curl\u003ehttp://maven.aliyun.com/nexus/content/groups/public\u003c/url\u003e \u003c/mirror\u003e 这样，我们就将默认的远程仓库地址（国外），配置为国内的阿里云仓库地址了（依赖的下载速度就会快起来了） ","date":"2022-02-16","objectID":"/posts/java%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93/:6:2","tags":["Java连接数据库"],"title":"Java连接数据库","uri":"/posts/java%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"categories":["JavaWeb笔记"],"content":"Maven依赖作用域 除了三个基本的属性用于定位坐标外，依赖还可以添加以下属性： type：依赖的类型，对于项目坐标定义的packaging。大部分情况下，该元素不必声明，其默认值为jar scope：依赖的范围（作用域，着重讲解） optional：标记依赖是否可选 exclusions：用来排除传递性依赖（一个项目有可能依赖于其他项目，就像我们的项目，如果别人要用我们的项目作为依赖，那么就需要一起下载我们项目的依赖，如Lombok） 我们着重来讲解一下scope属性，它决定了依赖的作用域范围： compile ：为默认的依赖有效范围。如果在定义依赖关系的时候，没有明确指定依赖有效范围的话，则默认采用该依赖有效范围。此种依赖，在编译、运行、测试时均有效。 provided ：在编译、测试时有效，但是在运行时无效，也就是说，项目在运行时，不需要此依赖，比如我们上面的Lombok，我们只需要在编译阶段使用它，编译完成后，实际上已经转换为对应的代码了，因此Lombok不需要在项目运行时也存在。 runtime ：在运行、测试时有效，但是在编译代码时无效。比如我们如果需要自己写一个JDBC实现，那么肯定要用到JDK为我们指定的接口，但是实际上在运行时是不用自带JDK的依赖，因此只保留我们自己写的内容即可。 test ：只在测试时有效，例如：JUnit，我们一般只会在测试阶段使用JUnit，而实际项目运行时，我们就用不到测试了，那么我们来看看，导入JUnit的依赖： 同样的，我们可以在网站上搜索Junit的依赖，我们这里导入最新的JUnit5作为依赖： \u003cdependency\u003e \u003cgroupId\u003eorg.junit.jupiter\u003c/groupId\u003e \u003cartifactId\u003ejunit-jupiter\u003c/artifactId\u003e \u003cversion\u003e5.8.1\u003c/version\u003e \u003cscope\u003etest\u003c/scope\u003e \u003c/dependency\u003e 我们所有的测试用例全部编写到Maven项目给我们划分的test目录下，位于此目录下的内容不会在最后被打包到项目中，只用作开发阶段测试使用： public class MainTest { @Test public void test(){ System.out.println(\"测试\"); //Assert在JUnit5时名称发生了变化Assertions Assertions.assertArrayEquals(new int[]{1, 2, 3}, new int[]{1, 2}); } } 因此，一般仅用作测试的依赖如JUnit只保留在测试中即可，那么现在我们再来添加JDBC和Mybatis的依赖： \u003cdependency\u003e \u003cgroupId\u003emysql\u003c/groupId\u003e \u003cartifactId\u003emysql-connector-java\u003c/artifactId\u003e \u003cversion\u003e8.0.27\u003c/version\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.mybatis\u003c/groupId\u003e \u003cartifactId\u003emybatis\u003c/artifactId\u003e \u003cversion\u003e3.5.7\u003c/version\u003e \u003c/dependency\u003e 我们发现，Maven还给我们提供了一个resource文件夹，我们可以将一些静态资源，比如配置文件，放入到这个文件夹中，项目在打包时会将资源文件夹中文件一起打包的Jar中，比如我们在这里编写一个Mybatis的配置文件： \u003c?xml version=\"1.0\" encoding=\"UTF-8\" ?\u003e \u003c!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\"\u003e \u003cconfiguration\u003e \u003csettings\u003e \u003csetting name=\"mapUnderscoreToCamelCase\" value=\"true\"/\u003e \u003csetting name=\"cacheEnabled\" value=\"true\"/\u003e \u003csetting name=\"logImpl\" value=\"JDK_LOGGING\" /\u003e \u003c/settings\u003e \u003c!-- 需要在environments的上方 --\u003e \u003ctypeAliases\u003e \u003cpackage name=\"com.test.entity\"/\u003e \u003c/typeAliases\u003e \u003cenvironments default=\"development\"\u003e \u003cenvironment id=\"development\"\u003e \u003ctransactionManager type=\"JDBC\"/\u003e \u003cdataSource type=\"POOLED\"\u003e \u003cproperty name=\"driver\" value=\"com.mysql.cj.jdbc.Driver\"/\u003e \u003cproperty name=\"url\" value=\"jdbc:mysql://localhost:3306/study\"/\u003e \u003cproperty name=\"username\" value=\"test\"/\u003e \u003cproperty name=\"password\" value=\"123456\"/\u003e \u003c/dataSource\u003e \u003c/environment\u003e \u003c/environments\u003e \u003cmappers\u003e \u003cmapper class=\"com.test.mapper.TestMapper\"/\u003e \u003c/mappers\u003e \u003c/configuration\u003e 现在我们创建一下测试用例，顺便带大家了解一下Junit5的一些比较方便的地方： public class MainTest { //因为配置文件位于内部，我们需要使用Resources类的getResourceAsStream来获取内部的资源文件 private static SqlSessionFactory factory; //在JUnit5中@Before被废弃，它被细分了： @BeforeAll // 一次性开启所有测试案例只会执行一次 (方法必须是static) // @BeforeEach 一次性开启所有测试案例每个案例开始之前都会执行一次 @SneakyThrows public static void before(){ factory = new SqlSessionFactoryBuilder() .build(Resources.getResourceAsStream(\"mybatis.xml\")); } @DisplayName(\"Mybatis数据库测试\") //自定义测试名称 @RepeatedTest(3) //自动执行多次测试 public void test(){ try (SqlSession sqlSession = factory.openSession(true)){ TestMapper testMapper = sqlSession.getMapper(TestMapper.class); System.out.println(testMapper.getStudentBySid(1)); } } } 那么就有人提问了，如果我需要的依赖没有上传的远程仓库，而是只有一个Jar怎么办呢？我们可以使用第四种作用域： system：作用域和provided是一样的，但是它不是从远程仓库获取，而是直接导入本地Jar包： \u003cdependency\u003e \u003cgroupId\u003ejavax.jntm\u003c/groupId\u003e \u003cartifactId\u003elbwnb\u003c/artifactId\u003e \u003cversion\u003e2.0\u003c/version\u003e \u003cscope\u003esystem\u003c/scope\u003e \u003csystemPath\u003eC://学习资料/4K高清无码/test.jar\u003c/systemPath\u003e \u003c/dependency\u003e 比如上面的例子，如果scope为system，那么我们需要添加一个systemPath来指定jar文件的位置，这里就不再演示了。 ","date":"2022-02-16","objectID":"/posts/java%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93/:6:3","tags":["Java连接数据库"],"title":"Java连接数据库","uri":"/posts/java%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"categories":["JavaWeb笔记"],"content":"Maven可选依赖 当项目中的某些依赖不希望被使用此项目作为依赖的项目使用时，我们可以给依赖添加optional标签表示此依赖是可选的，默认在导入依赖时，不会导入可选的依赖： \u003coptional\u003etrue\u003c/optional\u003e 比如Mybatis的POM文件中，就存在大量的可选依赖： \u003cdependency\u003e \u003cgroupId\u003eorg.slf4j\u003c/groupId\u003e \u003cartifactId\u003eslf4j-api\u003c/artifactId\u003e \u003cversion\u003e1.7.30\u003c/version\u003e \u003coptional\u003etrue\u003c/optional\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.slf4j\u003c/groupId\u003e \u003cartifactId\u003eslf4j-log4j12\u003c/artifactId\u003e \u003cversion\u003e1.7.30\u003c/version\u003e \u003coptional\u003etrue\u003c/optional\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003elog4j\u003c/groupId\u003e \u003cartifactId\u003elog4j\u003c/artifactId\u003e \u003cversion\u003e1.2.17\u003c/version\u003e \u003coptional\u003etrue\u003c/optional\u003e \u003c/dependency\u003e ... 由于Mybatis要支持多种类型的日志，需要用到很多种不同的日志框架，因此需要导入这些依赖来做兼容，但是我们项目中并不一定会使用这些日志框架作为Mybatis的日志打印器，因此这些日志框架仅Mybatis内部做兼容需要导入使用，而我们可以选择不使用这些框架或是选择其中一个即可，也就是说我们导入Mybatis之后想用什么日志框架再自己加就可以了。 ","date":"2022-02-16","objectID":"/posts/java%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93/:6:4","tags":["Java连接数据库"],"title":"Java连接数据库","uri":"/posts/java%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"categories":["JavaWeb笔记"],"content":"Maven排除依赖 我们了解了可选依赖，现在我们可以让使用此项目作为依赖的项目默认不使用可选依赖，但是如果存在那种不是可选依赖，但是我们导入此项目有不希望使用此依赖该怎么办呢，这个时候我们就可以通过排除依赖来防止添加不必要的依赖： \u003cdependency\u003e \u003cgroupId\u003eorg.junit.jupiter\u003c/groupId\u003e \u003cartifactId\u003ejunit-jupiter\u003c/artifactId\u003e \u003cversion\u003e5.8.1\u003c/version\u003e \u003cscope\u003etest\u003c/scope\u003e \u003cexclusions\u003e \u003cexclusion\u003e \u003cgroupId\u003eorg.junit.jupiter\u003c/groupId\u003e \u003cartifactId\u003ejunit-jupiter-engine\u003c/artifactId\u003e \u003c/exclusion\u003e \u003c/exclusions\u003e \u003c/dependency\u003e 我们这里演示了排除JUnit的一些依赖，我们可以在外部库中观察排除依赖之后和之前的效果。 ","date":"2022-02-16","objectID":"/posts/java%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93/:6:5","tags":["Java连接数据库"],"title":"Java连接数据库","uri":"/posts/java%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"categories":["JavaWeb笔记"],"content":"Maven继承关系 一个Maven项目可以继承自另一个Maven项目，比如多个子项目都需要父项目的依赖，我们就可以使用继承关系来快速配置。 我们右键左侧栏，新建一个模块，来创建一个子项目： \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003cproject xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"\u003e \u003cparent\u003e \u003cartifactId\u003eMavenTest\u003c/artifactId\u003e \u003cgroupId\u003eorg.example\u003c/groupId\u003e \u003cversion\u003e1.0-SNAPSHOT\u003c/version\u003e \u003c/parent\u003e \u003cmodelVersion\u003e4.0.0\u003c/modelVersion\u003e \u003cartifactId\u003eChildModel\u003c/artifactId\u003e \u003cproperties\u003e \u003cmaven.compiler.source\u003e8\u003c/maven.compiler.source\u003e \u003cmaven.compiler.target\u003e8\u003c/maven.compiler.target\u003e \u003c/properties\u003e \u003c/project\u003e 我们可以看到，IDEA默认给我们添加了一个parent节点，表示此Maven项目是父Maven项目的子项目，子项目直接继承父项目的groupId，子项目会直接继承父项目的所有依赖，除非依赖添加了optional标签，我们来编写一个测试用例尝试一下: import lombok.extern.java.Log; @Log public class Main { public static void main(String[] args) { log.info(\"我是日志信息\"); } } 可以看到，子项目也成功继承了Lombok依赖。 我们还可以让父Maven项目统一管理所有的依赖，包括版本号等，子项目可以选取需要的作为依赖，而版本全由父项目管理，我们可以将dependencies全部放入dependencyManagement节点，这样父项目就完全作为依赖统一管理。 \u003cdependencyManagement\u003e \u003cdependencies\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.projectlombok\u003c/groupId\u003e \u003cartifactId\u003elombok\u003c/artifactId\u003e \u003cversion\u003e1.18.22\u003c/version\u003e \u003cscope\u003eprovided\u003c/scope\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.junit.jupiter\u003c/groupId\u003e \u003cartifactId\u003ejunit-jupiter\u003c/artifactId\u003e \u003cversion\u003e5.8.1\u003c/version\u003e \u003cscope\u003etest\u003c/scope\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003emysql\u003c/groupId\u003e \u003cartifactId\u003emysql-connector-java\u003c/artifactId\u003e \u003cversion\u003e8.0.27\u003c/version\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.mybatis\u003c/groupId\u003e \u003cartifactId\u003emybatis\u003c/artifactId\u003e \u003cversion\u003e3.5.7\u003c/version\u003e \u003c/dependency\u003e \u003c/dependencies\u003e \u003c/dependencyManagement\u003e 我们发现，子项目的依赖失效了，因为现在父项目没有依赖，而是将所有的依赖进行集中管理，子项目需要什么再拿什么即可，同时子项目无需指定版本，所有的版本全部由父项目决定，子项目只需要使用即可： \u003cdependencies\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.projectlombok\u003c/groupId\u003e \u003cartifactId\u003elombok\u003c/artifactId\u003e \u003cscope\u003eprovided\u003c/scope\u003e \u003c/dependency\u003e \u003c/dependencies\u003e 当然，父项目如果还存在dependencies节点的话，里面的内依赖依然是直接继承： \u003cdependencies\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.junit.jupiter\u003c/groupId\u003e \u003cartifactId\u003ejunit-jupiter\u003c/artifactId\u003e \u003cversion\u003e5.8.1\u003c/version\u003e \u003cscope\u003etest\u003c/scope\u003e \u003c/dependency\u003e \u003c/dependencies\u003e \u003cdependencyManagement\u003e \u003cdependencies\u003e ... ","date":"2022-02-16","objectID":"/posts/java%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93/:6:6","tags":["Java连接数据库"],"title":"Java连接数据库","uri":"/posts/java%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"categories":["JavaWeb笔记"],"content":"Maven常用命令 我们可以看到在IDEA右上角Maven板块中，每个Maven项目都有一个生命周期，实际上这些是Maven的一些插件，每个插件都有各自的功能，比如： clean命令，执行后会清理整个target文件夹，在之后编写Springboot项目时可以解决一些缓存没更新的问题。 validate命令可以验证项目的可用性。 compile命令可以将项目编译为.class文件。 install命令可以将当前项目安装到本地仓库，以供其他项目导入作为依赖使用 verify命令可以按顺序执行每个默认生命周期阶段（validate，compile，package等） ","date":"2022-02-16","objectID":"/posts/java%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93/:6:7","tags":["Java连接数据库"],"title":"Java连接数据库","uri":"/posts/java%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"categories":["JavaWeb笔记"],"content":"Maven测试项目 通过使用test命令，可以一键测试所有位于test目录下的测试案例，请注意有以下要求： 测试类的名称必须是以Test结尾，比如MainTest 测试方法上必须标注@Test注解，实测@RepeatedTest无效 这是由于JUnit5比较新，我们需要重新配置插件升级到高版本，才能完美的兼容Junit5： \u003cbuild\u003e \u003cplugins\u003e \u003cplugin\u003e \u003cgroupId\u003eorg.apache.maven.plugins\u003c/groupId\u003e \u003cartifactId\u003emaven-surefire-plugin\u003c/artifactId\u003e \u003c!-- JUnit 5 requires Surefire version 2.22.0 or higher --\u003e \u003cversion\u003e2.22.0\u003c/version\u003e \u003c/plugin\u003e \u003c/plugins\u003e \u003c/build\u003e 现在@RepeatedTest、@BeforeAll也能使用了。 ","date":"2022-02-16","objectID":"/posts/java%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93/:6:8","tags":["Java连接数据库"],"title":"Java连接数据库","uri":"/posts/java%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"categories":["JavaWeb笔记"],"content":"Maven打包项目 我们的项目在编写完成之后，要么作为Jar依赖，供其他模型使用，要么就作为一个可以执行的程序，在控制台运行，我们只需要直接执行package命令就可以直接对项目的代码进行打包，生成jar文件。 当然，以上方式仅适用于作为Jar依赖的情况，如果我们需要打包一个可执行文件，那么我不仅需要将自己编写的类打包到Jar中，同时还需要将依赖也一并打包到Jar中，因为我们使用了别人为我们通过的框架，自然也需要运行别人的代码，我们需要使用另一个插件来实现一起打包： \u003cplugin\u003e \u003cartifactId\u003emaven-assembly-plugin\u003c/artifactId\u003e \u003cversion\u003e3.1.0\u003c/version\u003e \u003cconfiguration\u003e \u003cdescriptorRefs\u003e \u003cdescriptorRef\u003ejar-with-dependencies\u003c/descriptorRef\u003e \u003c/descriptorRefs\u003e \u003carchive\u003e \u003cmanifest\u003e \u003caddClasspath\u003etrue\u003c/addClasspath\u003e \u003cmainClass\u003ecom.test.Main\u003c/mainClass\u003e \u003c/manifest\u003e \u003c/archive\u003e \u003c/configuration\u003e \u003cexecutions\u003e \u003cexecution\u003e \u003cid\u003emake-assembly\u003c/id\u003e \u003cphase\u003epackage\u003c/phase\u003e \u003cgoals\u003e \u003cgoal\u003esingle\u003c/goal\u003e \u003c/goals\u003e \u003c/execution\u003e \u003c/executions\u003e \u003c/plugin\u003e 在打包之前也会执行一次test命令，来保证项目能够正常运行，当测试出现问题时，打包将无法完成，我们也可以手动跳过，选择执行Maven目标来手动执行Maven命令，输入mvn package -Dmaven.test.skip=true 来以跳过测试的方式进行打包。 最后得到我们的Jar文件，在同级目录下输入java -jar xxxx.jar来运行我们打包好的Jar可执行程序（xxx代表文件名称） deploy命令用于发布项目到本地仓库和远程仓库，一般情况下用不到，这里就不做讲解了。 site命令用于生成当前项目的发布站点，暂时不需要了解。 我们之前还讲解了多模块项目，那么多模块下父项目存在一个packing打包类型标签，所有的父级项目的packing都为pom，packing默认是jar类型，如果不作配置，maven会将该项目打成jar包。作为父级项目，还有一个重要的属性，那就是modules，通过modules标签将项目的所有子项目引用进来，在build父级项目时，会根据子模块的相互依赖关系整理一个build顺序，然后依次build。 ","date":"2022-02-16","objectID":"/posts/java%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93/:6:9","tags":["Java连接数据库"],"title":"Java连接数据库","uri":"/posts/java%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"categories":["JavaWeb笔记"],"content":"实战：基于Mybatis+JUL+Lombok+Maven的图书管理系统（带单元测试） 项目需求： 在线录入学生信息和书籍信息 查询书籍信息列表 查询学生信息列表 查询借阅信息列表 完整的日志系统 ","date":"2022-02-16","objectID":"/posts/java%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93/:7:0","tags":["Java连接数据库"],"title":"Java连接数据库","uri":"/posts/java%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"categories":["手写数据结构"],"content":"徒手写的AVL竟然比STL中的红黑树效率更高？✨","date":"2022-02-16","objectID":"/posts/%E5%BE%92%E6%89%8B%E5%86%99%E7%9A%84avl%E7%AB%9F%E7%84%B6%E6%AF%94stl%E4%B8%AD%E7%9A%84%E7%BA%A2%E9%BB%91%E6%A0%91%E6%95%88%E7%8E%87%E6%9B%B4%E9%AB%98/","tags":["徒手写的AVL竟然比STL中的红黑树效率更高？✨"],"title":"徒手写的AVL竟然比STL中的红黑树效率更高？✨","uri":"/posts/%E5%BE%92%E6%89%8B%E5%86%99%E7%9A%84avl%E7%AB%9F%E7%84%B6%E6%AF%94stl%E4%B8%AD%E7%9A%84%E7%BA%A2%E9%BB%91%E6%A0%91%E6%95%88%E7%8E%87%E6%9B%B4%E9%AB%98/"},{"categories":["手写数据结构"],"content":"AVL树简介 AVL树的名字来源于它的发明作者G.M. Adelson-Velsky 和 E.M. Landis。AVL树是最先发明的自平衡二叉查找树（Self-Balancing Binary Search Tree,简称平衡二叉树）。 一棵AVL树有如下必要条件： 条件一：它必须是二叉查找树。 条件二：每个节点的左子树和右子树的高度差至多为1。 图一中左边二叉树的节点45的左孩子46比45大，不满足二叉搜索树的条件，因此它也不是一棵平衡二叉树。 右边二叉树满足二叉搜索树的条件，同时它满足条件二，因此它是一棵平衡二叉树。 左边二叉树的节点45左子树高度2，右子树高度0，左右子树高度差为2-0=2，不满足条件二；右边二叉树的节点均满足左右子树高度差至多为1，同时它满足二叉搜索树的要求，因此它是一棵平衡二叉树。 AVL树的查找、插入、删除操作在平均和最坏的情况下都是O（logn），这得益于它时刻维护着二叉树的平衡。但由于每次插入都需要不断的调整和维护，所以，实际上如果插入操作次数太多则同样会陷入超时的死局，最具优势的操作在于查找，因为它的底层设计使得它无论插入多少个元素，这颗二叉树总是严格平衡的，所以AVL树适用于插入操作不是很频繁，但查找操作极度频繁的情况，如果需要在插入和查找操作找一个均衡点，那么就只能选择红黑树了。 ","date":"2022-02-16","objectID":"/posts/%E5%BE%92%E6%89%8B%E5%86%99%E7%9A%84avl%E7%AB%9F%E7%84%B6%E6%AF%94stl%E4%B8%AD%E7%9A%84%E7%BA%A2%E9%BB%91%E6%A0%91%E6%95%88%E7%8E%87%E6%9B%B4%E9%AB%98/:1:0","tags":["徒手写的AVL竟然比STL中的红黑树效率更高？✨"],"title":"徒手写的AVL竟然比STL中的红黑树效率更高？✨","uri":"/posts/%E5%BE%92%E6%89%8B%E5%86%99%E7%9A%84avl%E7%AB%9F%E7%84%B6%E6%AF%94stl%E4%B8%AD%E7%9A%84%E7%BA%A2%E9%BB%91%E6%A0%91%E6%95%88%E7%8E%87%E6%9B%B4%E9%AB%98/"},{"categories":["手写数据结构"],"content":"AVL树的相关概念 平衡因子：将二叉树上节点的左子树高度减去右子树高度的值称为该节点的平衡因子BF(Balance Factor)。 在图二右边的AVL树上： 节点50的左子树高度为3，右子树高度为2，BF= 3-2 = 1； 节点45的左子树高度为2，右子树高度为1，BF= 2-1 = 1； 节点46的左子树高度为0，右子树高度为0，BF= 0-0 = 0； 节点65的左子树高度为0，右子树高度为1，BF= 0-1 = -1； 对于平衡二叉树，BF的取值范围为[-1,1]。如果发现某个节点的BF值不在此范围，则需要对树进行调整。 最小不平衡树：距离插入节点最近的，且平衡因子的绝对值大于1的节点为根的子树。 在图三中，左边二叉树的节点45的BF = 1，插入节点43后，节点45的BF = 2。节点45是距离插入点43最近的BF不在[-1,1]范围内的节点，因此以节点45为根的子树为最小不平衡子树。(这正好对应了递归的后序返回操作 中序的前驱和后继：顾名思义，就是中序遍历下的前一个结点和后一个结点，由于时二叉搜索树，所以中序遍历的前一个结点对应比这个结点小的最大结点，而后一个结点对应比这个结点大的最小结点。(这个可以看后面代码再进行理解)这个概念在进行删除结点的操作时很有用，因为删除结点后需要同时保证仍然为二叉搜索树。 关于对前驱和后继的一些寻找方法，请看我的另一篇博客：面试题 04.06. 后继者 ","date":"2022-02-16","objectID":"/posts/%E5%BE%92%E6%89%8B%E5%86%99%E7%9A%84avl%E7%AB%9F%E7%84%B6%E6%AF%94stl%E4%B8%AD%E7%9A%84%E7%BA%A2%E9%BB%91%E6%A0%91%E6%95%88%E7%8E%87%E6%9B%B4%E9%AB%98/:2:0","tags":["徒手写的AVL竟然比STL中的红黑树效率更高？✨"],"title":"徒手写的AVL竟然比STL中的红黑树效率更高？✨","uri":"/posts/%E5%BE%92%E6%89%8B%E5%86%99%E7%9A%84avl%E7%AB%9F%E7%84%B6%E6%AF%94stl%E4%B8%AD%E7%9A%84%E7%BA%A2%E9%BB%91%E6%A0%91%E6%95%88%E7%8E%87%E6%9B%B4%E9%AB%98/"},{"categories":["手写数据结构"],"content":"AVL树的实现详解 总体思维导图实现。 ","date":"2022-02-16","objectID":"/posts/%E5%BE%92%E6%89%8B%E5%86%99%E7%9A%84avl%E7%AB%9F%E7%84%B6%E6%AF%94stl%E4%B8%AD%E7%9A%84%E7%BA%A2%E9%BB%91%E6%A0%91%E6%95%88%E7%8E%87%E6%9B%B4%E9%AB%98/:3:0","tags":["徒手写的AVL竟然比STL中的红黑树效率更高？✨"],"title":"徒手写的AVL竟然比STL中的红黑树效率更高？✨","uri":"/posts/%E5%BE%92%E6%89%8B%E5%86%99%E7%9A%84avl%E7%AB%9F%E7%84%B6%E6%AF%94stl%E4%B8%AD%E7%9A%84%E7%BA%A2%E9%BB%91%E6%A0%91%E6%95%88%E7%8E%87%E6%9B%B4%E9%AB%98/"},{"categories":["手写数据结构"],"content":"1. 结点结构 struct node { int val; int depth; node *lchild; node *rchild; node() : val(0), lchild(nullptr), rchild(nullptr) {} node(int x) : val(x), lchild(nullptr), rchild(nullptr) {} }; val，结点的值。 depth，该结点的高度(它的左右子树中最高的高度+1)。 lchild，左孩子。 rchild，右孩子。 ","date":"2022-02-16","objectID":"/posts/%E5%BE%92%E6%89%8B%E5%86%99%E7%9A%84avl%E7%AB%9F%E7%84%B6%E6%AF%94stl%E4%B8%AD%E7%9A%84%E7%BA%A2%E9%BB%91%E6%A0%91%E6%95%88%E7%8E%87%E6%9B%B4%E9%AB%98/:3:1","tags":["徒手写的AVL竟然比STL中的红黑树效率更高？✨"],"title":"徒手写的AVL竟然比STL中的红黑树效率更高？✨","uri":"/posts/%E5%BE%92%E6%89%8B%E5%86%99%E7%9A%84avl%E7%AB%9F%E7%84%B6%E6%AF%94stl%E4%B8%AD%E7%9A%84%E7%BA%A2%E9%BB%91%E6%A0%91%E6%95%88%E7%8E%87%E6%9B%B4%E9%AB%98/"},{"categories":["手写数据结构"],"content":"2. AVL树的抽象数据结构（ADT） class AVLTree { /*date part*/ node *head; int length; public: /*construct and destruct part*/ AVLTree() : head(nullptr), length(0) {} AVLTree(int x) : head(new node(x)), length(1) {} ~AVLTree() { destroy(head); } public: /*iterator part*/ class iterator {//封装迭代器：内部类--只能调用外部类的静态函数 node *head; node *root; public: iterator(node *head, node *root) : head(head), root(root) {} iterator \u0026operator++(); bool operator==(const iterator \u0026x); bool operator!=(const iterator \u0026x); iterator operator++(int); iterator \u0026operator--(); iterator operator--(int); int operator*(); }; private: /*static member function*/ /*Rotate Part*/ static node *rotateRight(node *root); static node *rotateLeft(node *root); static node *rotateLeftRight(node *root); static node *rotateRightLeft(node *root); /*Destruct*/ static void destroy(node *root); /*Getter*/ static node *getNext(node *root, node *p); static node *getPre(node *root, node *p); static node *getMinNode(node *root); static node *getMaxNode(node *root); static int get_depth(node *root); static void update_depth(node *root); /*Insert\u0026Remove*/ static node *Insert(int x, node *root, int \u0026size); static node *remove(int x, node *root, int \u0026size); /*print_order*/ static void inorder(node *root); public: /*public interface*/ /*clear\u0026empty*/ void clear(); bool isEmpty(); /*find*/ bool find(int x); /*insert\u0026remove*/ void insert(int x); void remove(int x); /*size*/ int size(); /*begin\u0026end*/ iterator begin(); iterator end(); /*print*/ void inorder_print(); }; ","date":"2022-02-16","objectID":"/posts/%E5%BE%92%E6%89%8B%E5%86%99%E7%9A%84avl%E7%AB%9F%E7%84%B6%E6%AF%94stl%E4%B8%AD%E7%9A%84%E7%BA%A2%E9%BB%91%E6%A0%91%E6%95%88%E7%8E%87%E6%9B%B4%E9%AB%98/:3:2","tags":["徒手写的AVL竟然比STL中的红黑树效率更高？✨"],"title":"徒手写的AVL竟然比STL中的红黑树效率更高？✨","uri":"/posts/%E5%BE%92%E6%89%8B%E5%86%99%E7%9A%84avl%E7%AB%9F%E7%84%B6%E6%AF%94stl%E4%B8%AD%E7%9A%84%E7%BA%A2%E9%BB%91%E6%A0%91%E6%95%88%E7%8E%87%E6%9B%B4%E9%AB%98/"},{"categories":["手写数据结构"],"content":"3. AVL树高度相关操作 得到高度 static int get_depth(node *root) {//得到深度 if (root == nullptr) return 0; return root-\u003edepth; } 更新高度 static void update_depth(node *root) { if (root == nullptr) return; root-\u003edepth = std::max(get_depth(root-\u003elchild), get_depth(root-\u003erchild)) + 1; } ","date":"2022-02-16","objectID":"/posts/%E5%BE%92%E6%89%8B%E5%86%99%E7%9A%84avl%E7%AB%9F%E7%84%B6%E6%AF%94stl%E4%B8%AD%E7%9A%84%E7%BA%A2%E9%BB%91%E6%A0%91%E6%95%88%E7%8E%87%E6%9B%B4%E9%AB%98/:3:3","tags":["徒手写的AVL竟然比STL中的红黑树效率更高？✨"],"title":"徒手写的AVL竟然比STL中的红黑树效率更高？✨","uri":"/posts/%E5%BE%92%E6%89%8B%E5%86%99%E7%9A%84avl%E7%AB%9F%E7%84%B6%E6%AF%94stl%E4%B8%AD%E7%9A%84%E7%BA%A2%E9%BB%91%E6%A0%91%E6%95%88%E7%8E%87%E6%9B%B4%E9%AB%98/"},{"categories":["手写数据结构"],"content":"4. 得到子树中最大/最小结点 原理：根据二叉搜索树中结点的左子树一定小于该结点，右子树一定大于该结点。 得到最大：直接遍历得出该结点的最右结点。 static node* getMaxNode(node* root) { if (root == nullptr) return nullptr; while (root-\u003erchild != nullptr) root = root-\u003erchild; return root; } 得到最小：直接遍历得出该结点的最左结点。 static node* getMinNode(node* root) { if (root == nullptr) return nullptr; while (root-\u003elchild != nullptr) root = root-\u003elchild; return root; } ","date":"2022-02-16","objectID":"/posts/%E5%BE%92%E6%89%8B%E5%86%99%E7%9A%84avl%E7%AB%9F%E7%84%B6%E6%AF%94stl%E4%B8%AD%E7%9A%84%E7%BA%A2%E9%BB%91%E6%A0%91%E6%95%88%E7%8E%87%E6%9B%B4%E9%AB%98/:3:4","tags":["徒手写的AVL竟然比STL中的红黑树效率更高？✨"],"title":"徒手写的AVL竟然比STL中的红黑树效率更高？✨","uri":"/posts/%E5%BE%92%E6%89%8B%E5%86%99%E7%9A%84avl%E7%AB%9F%E7%84%B6%E6%AF%94stl%E4%B8%AD%E7%9A%84%E7%BA%A2%E9%BB%91%E6%A0%91%E6%95%88%E7%8E%87%E6%9B%B4%E9%AB%98/"},{"categories":["手写数据结构"],"content":"5. 得到结点的前驱和后继 注意：二叉搜索树的前驱后继一般指的是它中序遍历的前一个和后一个结点，也就是从小到大排的前一个和后一个结点。 具体可以看我之前的博客–后继者 后继结点求解：如果有右子树，就是右子树的最小结点，如果没有，则是距离该节点最近的处于该节点右边的父节点。 static node* getNext(node* root, node* p) { //得到p节点的后继结点 if (root == nullptr || p == nullptr) return nullptr; if (p-\u003eval \u003e= root-\u003eval) { return getNext(root-\u003erchild, p); } else { node* left = getNext(root-\u003elchild, p); return left ? left : root; } } 前驱结点求解：如果有左子树，就是左子树的最大结点，如果没有，则是距离该节点最近的处于该节点左边的父节点。 static node* getPre(node* root, node* p) { //得到p节点的前驱结点 if (root == nullptr || p == nullptr)return nullptr; if (p-\u003eval \u003c= root-\u003eval) { return getPre(root-\u003elchild, p); } else { node* right = getPre(root-\u003erchild, p); return right ? right : root; } } ","date":"2022-02-16","objectID":"/posts/%E5%BE%92%E6%89%8B%E5%86%99%E7%9A%84avl%E7%AB%9F%E7%84%B6%E6%AF%94stl%E4%B8%AD%E7%9A%84%E7%BA%A2%E9%BB%91%E6%A0%91%E6%95%88%E7%8E%87%E6%9B%B4%E9%AB%98/:3:5","tags":["徒手写的AVL竟然比STL中的红黑树效率更高？✨"],"title":"徒手写的AVL竟然比STL中的红黑树效率更高？✨","uri":"/posts/%E5%BE%92%E6%89%8B%E5%86%99%E7%9A%84avl%E7%AB%9F%E7%84%B6%E6%AF%94stl%E4%B8%AD%E7%9A%84%E7%BA%A2%E9%BB%91%E6%A0%91%E6%95%88%E7%8E%87%E6%9B%B4%E9%AB%98/"},{"categories":["手写数据结构"],"content":"6. AVL树失衡的调整 节点的插入或删除都有可能导致AVL树失去平衡，因此，失衡调整是插入与删除操作的基础。 AVL树的失衡调整可以分为四种情况，我们逐一分析。 假设我们要为数组a[]={4，5，6，3，2，8，7，0，1}构建一棵AVL树。 情况一：左旋 首先插入{4，5，6}，在插入元素6后出现不平衡的情况： 当我们在右子树插入右孩子导致AVL失衡时，我们需要进行单左旋调整。旋转围绕最小失衡子树的根节点进行。 在删除新节点时也有可能会出现需要单左旋的情况。 左旋代码如下： static node *rotateLeft(node *root) { node *son = root-\u003erchild; root-\u003erchild = son-\u003elchild; son-\u003elchild = root; update_depth(root); update_depth(son); return son; } 情况二：右旋 我们继续插入元素{3，2}，此时二叉树为： 插入3、2后出现了不平衡的情况。此时的插入情况是“在左子树上插入左孩子导致AVL树失衡”，我们需要进行单右旋调整。 右旋代码： static node *rotateRight(node *root) {//右旋 node *son = root-\u003elchild; root-\u003elchild = son-\u003erchild; son-\u003erchild = root; update_depth(root);//更新深度(右旋只会对这两结点产生影响 update_depth(son); return son; } 情况三：先左旋后右旋 需要进行两次旋转的原因是第一次旋转后，AVL树仍旧处于不平衡的状态，第二次旋转再次进行调整。 我们继续插入元素{8，7} 这种情况，总结起来就是“在右子树上插入左孩子导致AVL树失衡\",此时我们需要进行先右旋后左旋的调整。 调整的代码为： static node *rotateLeftRight(node *root) { root-\u003elchild = rotateLeft(root-\u003elchild); return rotateRight(root); } 结合例子进行分析： 首先对最小不平衡子树的根节点（也就是节点6）的右孩子（也就是8）进行右旋操作 再对节点6进行一次左旋操作 情况四：先右旋再左旋 根据对称性原理，当我们“在左子树上插入右孩子导致AVL树失衡\",此时我们需要进行先左旋后右旋的调整。如果你不理解接着看图。 我们接着插入节点{0，1} 调整的代码: static node *rotateRightLeft(node *root) { root-\u003erchild = rotateRight(root-\u003erchild); return rotateLeft(root); } 结合例子进行分析： 首先对最小不平衡子树的根节点（也就是节点2）的左孩子（也就是0）进行左旋操作 再对节点2进行一次右旋操作 总结：四种失衡调整 ","date":"2022-02-16","objectID":"/posts/%E5%BE%92%E6%89%8B%E5%86%99%E7%9A%84avl%E7%AB%9F%E7%84%B6%E6%AF%94stl%E4%B8%AD%E7%9A%84%E7%BA%A2%E9%BB%91%E6%A0%91%E6%95%88%E7%8E%87%E6%9B%B4%E9%AB%98/:3:6","tags":["徒手写的AVL竟然比STL中的红黑树效率更高？✨"],"title":"徒手写的AVL竟然比STL中的红黑树效率更高？✨","uri":"/posts/%E5%BE%92%E6%89%8B%E5%86%99%E7%9A%84avl%E7%AB%9F%E7%84%B6%E6%AF%94stl%E4%B8%AD%E7%9A%84%E7%BA%A2%E9%BB%91%E6%A0%91%E6%95%88%E7%8E%87%E6%9B%B4%E9%AB%98/"},{"categories":["手写数据结构"],"content":"7. 插入新结点 //需要是否兼容相等的元素，可通过对 x\u003croot-\u003eval 或 x\u003eroot-\u003eval 这两个中的一个取等号即可 static node *Insert(int x, node *root, int\u0026 size) { //所有的deep的更新都在后序遍历后 if (root == nullptr) { root = new node(x); size++;//创建结点后size++ } else if (x \u003c root-\u003eval) { root-\u003elchild = Insert(x, root-\u003elchild, size); //由于在更新该root结点之前，当平衡度未达到该要求之前肯定以及是进行了update_depth操作 if (get_depth(root-\u003elchild) - get_depth(root-\u003erchild) == 2) root = x \u003c root-\u003elchild-\u003eval ? rotateRight(root) : rotateLeftRight(root); } else if (x \u003e root-\u003eval) { root-\u003erchild = Insert(x, root-\u003erchild, size); if (get_depth(root-\u003elchild) - get_depth(root-\u003erchild) == -2) root = x \u003e root-\u003erchild-\u003eval ? rotateLeft(root) : rotateRightLeft(root); } update_depth(root); return root; } ","date":"2022-02-16","objectID":"/posts/%E5%BE%92%E6%89%8B%E5%86%99%E7%9A%84avl%E7%AB%9F%E7%84%B6%E6%AF%94stl%E4%B8%AD%E7%9A%84%E7%BA%A2%E9%BB%91%E6%A0%91%E6%95%88%E7%8E%87%E6%9B%B4%E9%AB%98/:3:7","tags":["徒手写的AVL竟然比STL中的红黑树效率更高？✨"],"title":"徒手写的AVL竟然比STL中的红黑树效率更高？✨","uri":"/posts/%E5%BE%92%E6%89%8B%E5%86%99%E7%9A%84avl%E7%AB%9F%E7%84%B6%E6%AF%94stl%E4%B8%AD%E7%9A%84%E7%BA%A2%E9%BB%91%E6%A0%91%E6%95%88%E7%8E%87%E6%9B%B4%E9%AB%98/"},{"categories":["手写数据结构"],"content":"8. 删除结点 失衡的处理： 删除节点也可能导致AVL树的失衡，实际上删除节点和插入节点是一种互逆的操作： 删除右子树的节点导致AVL树失衡时，相当于在左子树插入节点导致AVL树失衡，即情况情况二或情况四。 删除左子树的节点导致AVL树失衡时，相当于在右子树插入节点导致AVL树失衡，即情况情况一或情况三。 维持排序树的处理： 另外，AVL树也是一棵二叉排序树，因此在删除节点时也要维护二叉排序树的性质。 如果删除结点为叶子结点，则直接删除，并不会改变搜索树的性质。 如果删除结点只有左子树或者右子树，则直接把要删除的结点的数据用下一个结点覆盖，然后删除下一个结点，由于复制了下一层的左右孩子指针，所以不会出现断层的。 如果删除结点左右子树都有，则找出该节点的前驱结点或后继结点的值进行覆盖(不覆盖指针，这样便仍然是排序二叉树了，然后**继续递归寻找对应的前驱或者后继结点进行删除，**因为左右子树都有，所以它们的前驱或者后继只能是叶子结点，找到直接删除即可。 删除处理代码： 我这里对删除操作进行了进一步优化，如果被删除结点的左右子树都存在，则查看左右子树的高度，如果左边高于右边则选择前驱结点进行删除，反之则后继。 static node *remove(int x, node *root, int\u0026 size) { if (root == nullptr) return nullptr; if (x == root-\u003eval) { /*左右子树均不为空---用中序的前驱或者后继来进行替换*/ if (root-\u003elchild != nullptr \u0026\u0026 root-\u003erchild != nullptr) { /*根据左右子树的深度来选择删除替换哪边的*/ if (get_depth(root-\u003elchild) \u003e get_depth(root-\u003erchild)) { node* t = getMaxNode(root-\u003elchild); root-\u003eval = t-\u003eval; root-\u003elchild = remove(t-\u003eval, root-\u003elchild, size); } else { node* t = getMinNode(root-\u003erchild); root-\u003eval = t-\u003eval; root-\u003erchild = remove(t-\u003eval, root-\u003erchild, size); } } /*左右子树至少有一个为空的情况，直接往下走一步即可*/ else { node* tmp = root-\u003elchild == nullptr ? root-\u003erchild : nullptr; if (tmp != nullptr) { *root = *tmp; delete tmp; } else { delete root; root = nullptr; } //删除时size-- size--; } } else if (x \u003c root-\u003eval) { root-\u003elchild = remove(x, root-\u003elchild, size); if (get_depth(root-\u003elchild) - get_depth(root-\u003erchild) == -2) root = get_depth(root-\u003erchild-\u003elchild) \u003e get_depth(root-\u003erchild-\u003erchild) ? rotateRightLeft(root) : rotateLeft(root); } else { root-\u003erchild = remove(x, root-\u003erchild, size); if (get_depth(root-\u003elchild) - get_depth(root-\u003erchild) == 2) root = get_depth(root-\u003elchild-\u003erchild) \u003e get_depth(root-\u003elchild-\u003elchild) ? rotateLeftRight(root) : rotateRight(root); } return root; } ","date":"2022-02-16","objectID":"/posts/%E5%BE%92%E6%89%8B%E5%86%99%E7%9A%84avl%E7%AB%9F%E7%84%B6%E6%AF%94stl%E4%B8%AD%E7%9A%84%E7%BA%A2%E9%BB%91%E6%A0%91%E6%95%88%E7%8E%87%E6%9B%B4%E9%AB%98/:3:8","tags":["徒手写的AVL竟然比STL中的红黑树效率更高？✨"],"title":"徒手写的AVL竟然比STL中的红黑树效率更高？✨","uri":"/posts/%E5%BE%92%E6%89%8B%E5%86%99%E7%9A%84avl%E7%AB%9F%E7%84%B6%E6%AF%94stl%E4%B8%AD%E7%9A%84%E7%BA%A2%E9%BB%91%E6%A0%91%E6%95%88%E7%8E%87%E6%9B%B4%E9%AB%98/"},{"categories":["手写数据结构"],"content":"9. 查找元素 二叉树是一种递归的定义，因此，二叉树的许多操作都可以通过递归简单地实现，例如遍历二叉树、查找指定元素、销毁二叉树等。 这里使用了迭代方式。 bool find(int x) { //查找直接迭代方式即可 node *f = head; while (f != nullptr) { if (x == f-\u003eval) return true; else if (x \u003c f-\u003eval) f = f-\u003elchild; else f = f-\u003erchild; } return false; } ","date":"2022-02-16","objectID":"/posts/%E5%BE%92%E6%89%8B%E5%86%99%E7%9A%84avl%E7%AB%9F%E7%84%B6%E6%AF%94stl%E4%B8%AD%E7%9A%84%E7%BA%A2%E9%BB%91%E6%A0%91%E6%95%88%E7%8E%87%E6%9B%B4%E9%AB%98/:3:9","tags":["徒手写的AVL竟然比STL中的红黑树效率更高？✨"],"title":"徒手写的AVL竟然比STL中的红黑树效率更高？✨","uri":"/posts/%E5%BE%92%E6%89%8B%E5%86%99%E7%9A%84avl%E7%AB%9F%E7%84%B6%E6%AF%94stl%E4%B8%AD%E7%9A%84%E7%BA%A2%E9%BB%91%E6%A0%91%E6%95%88%E7%8E%87%E6%9B%B4%E9%AB%98/"},{"categories":["手写数据结构"],"content":"10. 遍历二叉树 我这里只提供了中序遍历的打印，方便验证二叉搜索树的情况。 static void inorder(node *root) { if (root != nullptr) { inorder(root-\u003elchild); printf(\"%d \", root-\u003eval); inorder(root-\u003erchild); } } ","date":"2022-02-16","objectID":"/posts/%E5%BE%92%E6%89%8B%E5%86%99%E7%9A%84avl%E7%AB%9F%E7%84%B6%E6%AF%94stl%E4%B8%AD%E7%9A%84%E7%BA%A2%E9%BB%91%E6%A0%91%E6%95%88%E7%8E%87%E6%9B%B4%E9%AB%98/:3:10","tags":["徒手写的AVL竟然比STL中的红黑树效率更高？✨"],"title":"徒手写的AVL竟然比STL中的红黑树效率更高？✨","uri":"/posts/%E5%BE%92%E6%89%8B%E5%86%99%E7%9A%84avl%E7%AB%9F%E7%84%B6%E6%AF%94stl%E4%B8%AD%E7%9A%84%E7%BA%A2%E9%BB%91%E6%A0%91%E6%95%88%E7%8E%87%E6%9B%B4%E9%AB%98/"},{"categories":["手写数据结构"],"content":"11. AVL树的销毁 直接利用后序先处理完左右子树再处理根节点。 static void destroy(node *root) { if (root == nullptr) return; destroy(root-\u003elchild); destroy(root-\u003erchild); delete root; root = nullptr; } ","date":"2022-02-16","objectID":"/posts/%E5%BE%92%E6%89%8B%E5%86%99%E7%9A%84avl%E7%AB%9F%E7%84%B6%E6%AF%94stl%E4%B8%AD%E7%9A%84%E7%BA%A2%E9%BB%91%E6%A0%91%E6%95%88%E7%8E%87%E6%9B%B4%E9%AB%98/:3:11","tags":["徒手写的AVL竟然比STL中的红黑树效率更高？✨"],"title":"徒手写的AVL竟然比STL中的红黑树效率更高？✨","uri":"/posts/%E5%BE%92%E6%89%8B%E5%86%99%E7%9A%84avl%E7%AB%9F%E7%84%B6%E6%AF%94stl%E4%B8%AD%E7%9A%84%E7%BA%A2%E9%BB%91%E6%A0%91%E6%95%88%E7%8E%87%E6%9B%B4%E9%AB%98/"},{"categories":["手写数据结构"],"content":"12. 迭代器的设计 关于C++里面的迭代器，其实就是方便遍历容器中的元素，而迭代器需要模拟指针的行为，所以在C++中迭代器其实就是对指针特别包装的类，对其进行一些运算符的重载即可。 内部类充当迭代器 由于需要满足顺序容器的迭代顺序，所以++和–操作对应后继和前驱。 /*iterator part*/ class iterator { //封装迭代器 node* head; node* root; public: iterator(node* head, node* root): head(head), root(root) {} iterator\u0026 operator++() { //直接把root加为当前的后继结点 root = getNext(head, root); return *this; } bool operator==(const iterator\u0026 x) { return this-\u003eroot == x.root; } bool operator!=(const iterator\u0026 x) { return this-\u003eroot != x.root; } iterator operator++(int) { iterator t = *this; root = getNext(head, root); return t; } iterator\u0026 operator--() { //直接把root赋值为前驱结点 root = getPre(head, root); return *this; } iterator operator--(int) { iterator t = *this; root = getPre(head, root); return t; } node\u0026 operator*() { //解引用的重载 return *root; } }; 外部类提供外界begin()和end()接口得到迭代器的始端和末端 iterator begin() { node* min = getMinNode(head); return iterator(head, min); } iterator end() { //end表示结束标记 return iterator(head, nullptr); } ","date":"2022-02-16","objectID":"/posts/%E5%BE%92%E6%89%8B%E5%86%99%E7%9A%84avl%E7%AB%9F%E7%84%B6%E6%AF%94stl%E4%B8%AD%E7%9A%84%E7%BA%A2%E9%BB%91%E6%A0%91%E6%95%88%E7%8E%87%E6%9B%B4%E9%AB%98/:3:12","tags":["徒手写的AVL竟然比STL中的红黑树效率更高？✨"],"title":"徒手写的AVL竟然比STL中的红黑树效率更高？✨","uri":"/posts/%E5%BE%92%E6%89%8B%E5%86%99%E7%9A%84avl%E7%AB%9F%E7%84%B6%E6%AF%94stl%E4%B8%AD%E7%9A%84%E7%BA%A2%E9%BB%91%E6%A0%91%E6%95%88%E7%8E%87%E6%9B%B4%E9%AB%98/"},{"categories":["手写数据结构"],"content":"完整代码 我的GitHub ","date":"2022-02-16","objectID":"/posts/%E5%BE%92%E6%89%8B%E5%86%99%E7%9A%84avl%E7%AB%9F%E7%84%B6%E6%AF%94stl%E4%B8%AD%E7%9A%84%E7%BA%A2%E9%BB%91%E6%A0%91%E6%95%88%E7%8E%87%E6%9B%B4%E9%AB%98/:4:0","tags":["徒手写的AVL竟然比STL中的红黑树效率更高？✨"],"title":"徒手写的AVL竟然比STL中的红黑树效率更高？✨","uri":"/posts/%E5%BE%92%E6%89%8B%E5%86%99%E7%9A%84avl%E7%AB%9F%E7%84%B6%E6%AF%94stl%E4%B8%AD%E7%9A%84%E7%BA%A2%E9%BB%91%E6%A0%91%E6%95%88%E7%8E%87%E6%9B%B4%E9%AB%98/"},{"categories":["手写数据结构"],"content":"AVLTree.h // // Created by Alone on 2021/10/12. // #include \u003calgorithm\u003e#include \u003ccstdio\u003e#include \u003ccassert\u003e #ifndef MY_TINY_STL_AVLTREE_H #define MY_TINY_STL_AVLTREE_H namespace L_B__ { struct node { int val; int depth; node *lchild; node *rchild; node() : val(0), lchild(nullptr), rchild(nullptr) {} node(int x) : val(x), lchild(nullptr), rchild(nullptr) {} }; class AVLTree { /*date part*/ node *head; int length; public: /*construct and destruct part*/ AVLTree() : head(nullptr), length(0) {} AVLTree(int x) : head(new node(x)), length(1) {} ~AVLTree() { destroy(head); } public: /*iterator part*/ class iterator {//封装迭代器：内部类--只能调用外部类的静态函数 node *head; node *root; public: iterator(node *head, node *root) : head(head), root(root) {} iterator \u0026operator++(); bool operator==(const iterator \u0026x); bool operator!=(const iterator \u0026x); iterator operator++(int); iterator \u0026operator--(); iterator operator--(int); int operator*(); }; private: /*static member function*/ /*Rotate Part*/ static node *rotateRight(node *root); static node *rotateLeft(node *root); static node *rotateLeftRight(node *root); static node *rotateRightLeft(node *root); /*Destruct*/ static void destroy(node *root); /*Getter*/ static node *getNext(node *root, node *p); static node *getPre(node *root, node *p); static node *getMinNode(node *root); static node *getMaxNode(node *root); static int get_depth(node *root); static void update_depth(node *root); /*Insert\u0026Remove*/ static node *Insert(int x, node *root, int \u0026size); static node *remove(int x, node *root, int \u0026size); /*print_order*/ static void inorder(node *root); public: /*public interface*/ /*clear\u0026empty*/ void clear(); bool isEmpty(); /*find*/ bool find(int x); /*insert\u0026remove*/ void insert(int x); void remove(int x); /*size*/ int size(); /*begin\u0026end*/ iterator begin(); iterator end(); /*print*/ void inorder_print(); }; } #endif //MY_TINY_STL_AVLTREE_H ","date":"2022-02-16","objectID":"/posts/%E5%BE%92%E6%89%8B%E5%86%99%E7%9A%84avl%E7%AB%9F%E7%84%B6%E6%AF%94stl%E4%B8%AD%E7%9A%84%E7%BA%A2%E9%BB%91%E6%A0%91%E6%95%88%E7%8E%87%E6%9B%B4%E9%AB%98/:4:1","tags":["徒手写的AVL竟然比STL中的红黑树效率更高？✨"],"title":"徒手写的AVL竟然比STL中的红黑树效率更高？✨","uri":"/posts/%E5%BE%92%E6%89%8B%E5%86%99%E7%9A%84avl%E7%AB%9F%E7%84%B6%E6%AF%94stl%E4%B8%AD%E7%9A%84%E7%BA%A2%E9%BB%91%E6%A0%91%E6%95%88%E7%8E%87%E6%9B%B4%E9%AB%98/"},{"categories":["手写数据结构"],"content":"AVLTree.cpp // // Created by Alone on 2021/10/12. // #include \"AVLTree.h\" /*Rotate*/ L_B__::node *L_B__::AVLTree::rotateRight(L_B__::node *root) {//右旋 node *son = root-\u003elchild; root-\u003elchild = son-\u003erchild; son-\u003erchild = root; update_depth(root);//更新深度(右旋只会对这两结点产生影响 update_depth(son); return son; } L_B__::node *L_B__::AVLTree::rotateLeft(L_B__::node *root) { node *son = root-\u003erchild; root-\u003erchild = son-\u003elchild; son-\u003elchild = root; update_depth(root); update_depth(son); return son; } L_B__::node *L_B__::AVLTree::rotateLeftRight(L_B__::node *root) { root-\u003elchild = rotateLeft(root-\u003elchild); return rotateRight(root); } L_B__::node *L_B__::AVLTree::rotateRightLeft(L_B__::node *root) { root-\u003erchild = rotateRight(root-\u003erchild); return rotateLeft(root); } /*Destruct*/ void L_B__::AVLTree::destroy(L_B__::node *root) { if (root == nullptr) return; destroy(root-\u003elchild); destroy(root-\u003erchild); delete root; root = nullptr; } /*Getter*/ L_B__::node *L_B__::AVLTree::getNext(L_B__::node *root, L_B__::node *p) { if (root == nullptr || p == nullptr) return nullptr; if (p-\u003eval \u003e= root-\u003eval) { return getNext(root-\u003erchild, p); } else { node *left = getNext(root-\u003elchild, p); return left ? left : root; } } L_B__::node *L_B__::AVLTree::getPre(L_B__::node *root, L_B__::node *p) { if (root == nullptr || p == nullptr)return nullptr; if (p-\u003eval \u003c= root-\u003eval) { return getPre(root-\u003elchild, p); } else { node *right = getPre(root-\u003erchild, p); return right ? right : root; } } L_B__::node *L_B__::AVLTree::getMinNode(L_B__::node *root) { if (root == nullptr) return nullptr; while (root-\u003elchild != nullptr) root = root-\u003elchild; return root; } L_B__::node *L_B__::AVLTree::getMaxNode(L_B__::node *root) { if (root == nullptr) return nullptr; while (root-\u003erchild != nullptr) root = root-\u003erchild; return root; } int L_B__::AVLTree::get_depth(L_B__::node *root) { if (root == nullptr) return 0; return root-\u003edepth; } void L_B__::AVLTree::update_depth(L_B__::node *root) { if (root == nullptr) return; root-\u003edepth = std::max(get_depth(root-\u003elchild), get_depth(root-\u003erchild)) + 1; } /*Insert\u0026remove*/ L_B__::node *L_B__::AVLTree::Insert(int x, L_B__::node *root, int \u0026size) { if (root == nullptr) { root = new node(x); size++;//创建结点后size++ } else if (x \u003c root-\u003eval) { root-\u003elchild = Insert(x, root-\u003elchild, size); //由于在更新该root结点之前，当平衡度未达到该要求之前肯定以及是进行了update_depth操作 if (get_depth(root-\u003elchild) - get_depth(root-\u003erchild) == 2) root = x \u003c root-\u003elchild-\u003eval ? rotateRight(root) : rotateLeftRight(root); } else if (x \u003e root-\u003eval) { root-\u003erchild = Insert(x, root-\u003erchild, size); if (get_depth(root-\u003elchild) - get_depth(root-\u003erchild) == -2) root = x \u003e root-\u003erchild-\u003eval ? rotateLeft(root) : rotateRightLeft(root); } update_depth(root); return root; } L_B__::node *L_B__::AVLTree::remove(int x, L_B__::node *root, int \u0026size) { if (root == nullptr) return nullptr; if (x == root-\u003eval) { /*左右子树均不为空---用中序的前驱或者后继来进行替换*/ if (root-\u003elchild != nullptr \u0026\u0026 root-\u003erchild != nullptr) { /*根据左右子树的深度来选择删除替换哪边的*/ if (get_depth(root-\u003elchild) \u003e get_depth(root-\u003erchild)) { node *t = getMaxNode(root-\u003elchild); root-\u003eval = t-\u003eval; root-\u003elchild = remove(t-\u003eval, root-\u003elchild, size); } else { node *t = getMinNode(root-\u003erchild); root-\u003eval = t-\u003eval; root-\u003erchild = remove(t-\u003eval, root-\u003erchild, size); } } /*左右子树至少有一个为空的情况，直接往下走一步即可*/ else { node *tmp = root-\u003elchild == nullptr ? root-\u003erchild : nullptr; if (tmp != nullptr) { *root = *tmp; delete tmp; } else { delete root; root = nullptr; } //删除时size-- size--; } } else if (x \u003c root-\u003eval) { root-\u003elchild = remove(x, root-\u003elchild, size); if (get_depth(root-\u003elchild) - get_depth(root-\u003erchild) == -2) root = get_depth(root-\u003erchild-\u003elchild) \u003e get_depth(root-\u003erchild-\u003erchild) ? rotateRightLeft(root) : rotateLeft(root); } else { root-\u003erchild = remove(x, root-\u003erchild, size); if (get_depth(root-\u003elchild) - get_depth(root-\u003erchild) == 2) root = get_depth(root-\u003elchild-\u003erchild) \u003e get_depth(root-\u003elchild-\u003elchild) ? rotateLeftRight(root) : rotateRight(root); } return root; } /*print part*/ void L_B__::AVL","date":"2022-02-16","objectID":"/posts/%E5%BE%92%E6%89%8B%E5%86%99%E7%9A%84avl%E7%AB%9F%E7%84%B6%E6%AF%94stl%E4%B8%AD%E7%9A%84%E7%BA%A2%E9%BB%91%E6%A0%91%E6%95%88%E7%8E%87%E6%9B%B4%E9%AB%98/:4:2","tags":["徒手写的AVL竟然比STL中的红黑树效率更高？✨"],"title":"徒手写的AVL竟然比STL中的红黑树效率更高？✨","uri":"/posts/%E5%BE%92%E6%89%8B%E5%86%99%E7%9A%84avl%E7%AB%9F%E7%84%B6%E6%AF%94stl%E4%B8%AD%E7%9A%84%E7%BA%A2%E9%BB%91%E6%A0%91%E6%95%88%E7%8E%87%E6%9B%B4%E9%AB%98/"},{"categories":["手写数据结构"],"content":"测试 注意：以下数据由于存在大量相同的值，而我写的这个AVLTree并未对相同的值进行存储，所以节省了大量插入时候的调整时间，所以才能达到不错的插入性能，实际上只要实际插入的数据够多，和红黑树的差距就越大，我之前试过十亿不重复数据插入AVL和RB的测试，AVL运行几分钟，而RB一分钟内解决。但查找和删除方面AVL仍然是吊打RB(毕竟严格平衡树 与STL中的set（红黑树）进行对比： ","date":"2022-02-16","objectID":"/posts/%E5%BE%92%E6%89%8B%E5%86%99%E7%9A%84avl%E7%AB%9F%E7%84%B6%E6%AF%94stl%E4%B8%AD%E7%9A%84%E7%BA%A2%E9%BB%91%E6%A0%91%E6%95%88%E7%8E%87%E6%9B%B4%E9%AB%98/:5:0","tags":["徒手写的AVL竟然比STL中的红黑树效率更高？✨"],"title":"徒手写的AVL竟然比STL中的红黑树效率更高？✨","uri":"/posts/%E5%BE%92%E6%89%8B%E5%86%99%E7%9A%84avl%E7%AB%9F%E7%84%B6%E6%AF%94stl%E4%B8%AD%E7%9A%84%E7%BA%A2%E9%BB%91%E6%A0%91%E6%95%88%E7%8E%87%E6%9B%B4%E9%AB%98/"},{"categories":["手写数据结构"],"content":"测试代码 int main() { using namespace std; AVLTree x; set\u003cint\u003eQ; printf(\"插入测试\\n\"); auto start = clock(); for (int i = 0; i \u003c 100000000; ++i) { x.insert(i%10000000); } std::cout\u003c\u003c\"AVLTree\"\u003c\u003cclock()-start\u003c\u003c\"ms\"\u003c\u003cstd::endl; start = clock(); for (int i = 0; i \u003c 100000000; ++i) { Q.insert(i%10000000); } std::cout\u003c\u003c\"RBTree\"\u003c\u003cclock()-start\u003c\u003c\"ms\"\u003c\u003cstd::endl; printf(\"迭代测试\\n\"); start = clock(); for(auto it = x.begin();it!=x.end();++it){ continue; } std::cout\u003c\u003c\"AVLTree\"\u003c\u003cclock()-start\u003c\u003c\"ms\"\u003c\u003cstd::endl; start = clock(); for(auto it = Q.begin();it!=Q.end();++it){ continue; } std::cout\u003c\u003c\"RBTree\"\u003c\u003cclock()-start\u003c\u003c\"ms\"\u003c\u003cstd::endl; printf(\"查找测试\\n\"); start = clock(); for (int i = 0; i \u003c 100000000; ++i) { x.find(i); } std::cout\u003c\u003c\"AVLTree\"\u003c\u003cclock()-start\u003c\u003c\"ms\"\u003c\u003cstd::endl; start = clock(); for(int i = 0;i\u003c100000000;++i){ Q.count(i); } std::cout\u003c\u003c\"RBTree\"\u003c\u003cclock()-start\u003c\u003c\"ms\"\u003c\u003cstd::endl; printf(\"删除测试\\n\"); start = clock(); for(int i=0;i\u003c10000000;i++){ x.remove(i); } std::cout\u003c\u003c\"AVLTree\"\u003c\u003cclock()-start\u003c\u003c\"ms\"\u003c\u003c\"length\"\u003c\u003cx.size()\u003c\u003cstd::endl; start = clock(); for(int i=0;i\u003c10000000;i++){ Q.erase(i); } std::cout\u003c\u003c\"RBTree\"\u003c\u003cclock()-start\u003c\u003c\"ms\"\u003c\u003c\"length\"\u003c\u003cQ.size()\u003c\u003cstd::endl; return 0; } ","date":"2022-02-16","objectID":"/posts/%E5%BE%92%E6%89%8B%E5%86%99%E7%9A%84avl%E7%AB%9F%E7%84%B6%E6%AF%94stl%E4%B8%AD%E7%9A%84%E7%BA%A2%E9%BB%91%E6%A0%91%E6%95%88%E7%8E%87%E6%9B%B4%E9%AB%98/:5:1","tags":["徒手写的AVL竟然比STL中的红黑树效率更高？✨"],"title":"徒手写的AVL竟然比STL中的红黑树效率更高？✨","uri":"/posts/%E5%BE%92%E6%89%8B%E5%86%99%E7%9A%84avl%E7%AB%9F%E7%84%B6%E6%AF%94stl%E4%B8%AD%E7%9A%84%E7%BA%A2%E9%BB%91%E6%A0%91%E6%95%88%E7%8E%87%E6%9B%B4%E9%AB%98/"},{"categories":["手写数据结构"],"content":"测试总结 通过不断对比红黑树(RB)和AVL，得出以下结论： 插入操作红黑树比AVL快很多，数据量越大优势越明显。 查找和删除操作红黑树却是比AVL慢很多，同样也是数据量越大越明显。 总的来说，如果所需要管理的数据量很大，并且需要频繁的插入，那么红黑树更适合你，如果只需要插入一次后，对数据进行查找管理，那么AVL更加的适合你！ ","date":"2022-02-16","objectID":"/posts/%E5%BE%92%E6%89%8B%E5%86%99%E7%9A%84avl%E7%AB%9F%E7%84%B6%E6%AF%94stl%E4%B8%AD%E7%9A%84%E7%BA%A2%E9%BB%91%E6%A0%91%E6%95%88%E7%8E%87%E6%9B%B4%E9%AB%98/:5:2","tags":["徒手写的AVL竟然比STL中的红黑树效率更高？✨"],"title":"徒手写的AVL竟然比STL中的红黑树效率更高？✨","uri":"/posts/%E5%BE%92%E6%89%8B%E5%86%99%E7%9A%84avl%E7%AB%9F%E7%84%B6%E6%AF%94stl%E4%B8%AD%E7%9A%84%E7%BA%A2%E9%BB%91%E6%A0%91%E6%95%88%E7%8E%87%E6%9B%B4%E9%AB%98/"},{"categories":["手写数据结构"],"content":"解题测试 OJ平台 在以上设计的基础上加个get_head方法即可。 #include \u003cbits/stdc++.h\u003e struct node { int val; int depth; node *lchild; node *rchild; node() : val(0), lchild(nullptr), rchild(nullptr) {} node(int x) : val(x), lchild(nullptr), rchild(nullptr) {} }; class AVLTree { /*date part*/ node *head; int size; public: /*construct and destruct part*/ AVLTree() : head(nullptr),size(0) {} AVLTree(int x) : head(new node(x)),size(1) {} ~AVLTree() { destroy(head); } private: /*static function part*/ static node *rotateRight(node *root) {//右旋 node *son = root-\u003elchild; root-\u003elchild = son-\u003erchild; son-\u003erchild = root; update_depth(root);//更新深度(右旋只会对这两结点产生影响 update_depth(son); return son; } static node *rotateLeft(node *root) { node *son = root-\u003erchild; root-\u003erchild = son-\u003elchild; son-\u003elchild = root; update_depth(root); update_depth(son); return son; } static node *rotateLeftRight(node *root) { root-\u003elchild = rotateLeft(root-\u003elchild); return rotateRight(root); } static node *rotateRightLeft(node *root) { root-\u003erchild = rotateRight(root-\u003erchild); return rotateLeft(root); } static void destroy(node *root) { if (root == nullptr) return; destroy(root-\u003elchild); destroy(root-\u003erchild); delete root; root = nullptr; } static node* getMinNode(node* root){ if(root== nullptr) return nullptr; while(root-\u003elchild!= nullptr) root = root-\u003elchild; return root; } static node* getMaxNode(node* root){ if(root== nullptr) return nullptr; while(root-\u003erchild!= nullptr) root = root-\u003erchild; return root; } static int get_depth(node *root) {//得到深度 if (root == nullptr) return 0; return root-\u003edepth; } static void update_depth(node *root) { if (root == nullptr) return; root-\u003edepth = std::max(get_depth(root-\u003elchild), get_depth(root-\u003erchild)) + 1; } static node *Insert(int x, node *root) {//所有的deep的更新都在后序遍历后 if (root == nullptr) { root = new node(x); } else if (x \u003c= root-\u003eval) { root-\u003elchild = Insert(x, root-\u003elchild); //由于在更新该root结点之前，当平衡度未达到该要求之前肯定以及是进行了update_depth操作 if (get_depth(root-\u003elchild) - get_depth(root-\u003erchild) == 2) root = x \u003c= root-\u003elchild-\u003eval ? rotateRight(root) : rotateLeftRight(root); } else if (x \u003e root-\u003eval) { root-\u003erchild = Insert(x, root-\u003erchild); if (get_depth(root-\u003elchild) - get_depth(root-\u003erchild) == -2) root = x \u003e= root-\u003erchild-\u003eval ? rotateLeft(root) : rotateRightLeft(root); } update_depth(root); return root; } static node *remove(int x, node *root) { if (root == nullptr) return nullptr; if (x == root-\u003eval) { /*左右子树均不为空---用中序的前驱或者后继来进行替换*/ if (root-\u003elchild != nullptr \u0026\u0026 root-\u003erchild != nullptr) { /*根据左右子树的深度来选择删除替换哪边的*/ if(get_depth(root-\u003elchild)\u003eget_depth(root-\u003erchild)){ node* t = getMaxNode(root-\u003elchild); root-\u003eval = t-\u003eval; root-\u003elchild = remove(t-\u003eval,root-\u003elchild); }else{ node* t = getMinNode(root-\u003erchild); root-\u003eval = t-\u003eval; root-\u003erchild = remove(t-\u003eval,root-\u003erchild); } } /*左右子树至少有一个为空的情况，直接往下走一步即可*/ else{ node* tmp = root-\u003elchild== nullptr?root-\u003erchild: nullptr; if(tmp!= nullptr){ *root = *tmp; delete tmp; } else{ delete root; root = nullptr; } } } else if (x \u003c root-\u003eval) { root-\u003elchild = remove(x, root-\u003elchild); if(get_depth(root-\u003elchild)-get_depth(root-\u003erchild)==-2) root = get_depth(root-\u003erchild-\u003elchild)\u003eget_depth(root-\u003erchild-\u003erchild)?rotateRightLeft(root): rotateLeft(root); } else { root-\u003erchild = remove(x, root-\u003erchild); if(get_depth(root-\u003elchild)-get_depth(root-\u003erchild)==2) root = get_depth(root-\u003elchild-\u003erchild)\u003eget_depth(root-\u003elchild-\u003elchild)?rotateLeftRight(root): rotateRight(root); } return root; } static void inorder(node *root) { if (root != nullptr) { inorder(root-\u003elchild); printf(\"%d \", root-\u003eval); inorder(root-\u003erchild); } } public: /*public function part*/ void insert(int x) { //递归方式插入，方便后续处理 head = Insert(x, head); size++; } void remove(int x){ assert(size!=0); head = remove(x,head); size--; } void clear() { destroy(head); } bool isEmpty() { return head == nullptr; } bool find(int x) { //查找直接迭代方式即可 node *f = head; while (f != nullptr) { if (x == f-\u003eval) return true; else if (x \u003c f-\u003eval) f = f-\u003elchild; else f = f-\u003erchild; } return false; } void i","date":"2022-02-16","objectID":"/posts/%E5%BE%92%E6%89%8B%E5%86%99%E7%9A%84avl%E7%AB%9F%E7%84%B6%E6%AF%94stl%E4%B8%AD%E7%9A%84%E7%BA%A2%E9%BB%91%E6%A0%91%E6%95%88%E7%8E%87%E6%9B%B4%E9%AB%98/:6:0","tags":["徒手写的AVL竟然比STL中的红黑树效率更高？✨"],"title":"徒手写的AVL竟然比STL中的红黑树效率更高？✨","uri":"/posts/%E5%BE%92%E6%89%8B%E5%86%99%E7%9A%84avl%E7%AB%9F%E7%84%B6%E6%AF%94stl%E4%B8%AD%E7%9A%84%E7%BA%A2%E9%BB%91%E6%A0%91%E6%95%88%E7%8E%87%E6%9B%B4%E9%AB%98/"},{"categories":["手写数据结构"],"content":"新手用C++写了个泛型堆，效率竟比STL的更快？","date":"2022-02-16","objectID":"/posts/%E6%96%B0%E6%89%8B%E7%94%A8c++%E5%86%99%E4%BA%86%E4%B8%AA%E6%B3%9B%E5%9E%8B%E5%A0%86%E6%95%88%E7%8E%87%E7%AB%9F%E6%AF%94stl%E7%9A%84%E6%9B%B4%E5%BF%AB/","tags":["新手用C++写了个泛型堆，效率竟比STL的更快？"],"title":"新手用C++写了个泛型堆，效率竟比STL的更快？","uri":"/posts/%E6%96%B0%E6%89%8B%E7%94%A8c++%E5%86%99%E4%BA%86%E4%B8%AA%E6%B3%9B%E5%9E%8B%E5%A0%86%E6%95%88%E7%8E%87%E7%AB%9F%E6%AF%94stl%E7%9A%84%E6%9B%B4%E5%BF%AB/"},{"categories":["手写数据结构"],"content":"关于为什么突然想写一个模板类？ 嗯。。主要是因为最近在翻看《STL源码剖析》，然后发现原来STL源码是如此的庞大且复杂，而又及其具有条理，而其中最难的就是各个组件的关系，而对外所展现的效果就是泛型编程，对我这个初入门菜鸟来说的话，我之前对模板仅仅停留在知道，但没用过的阶段🤣 由于STL库中对模板的骚操作一个接一个，没个模板的基础，根本就看不懂，所以我痛定思痛，一定要亲手用模板实现一个数据结构(之前用非模板实现过一些)。 好了，目标有了，用模板实现一个数据结构，那数据结构这么多，我到底实现哪个呢？要不就把堆给冲了？我一拍大腿，可行！👍 最后关于它的具体实现，我肯定不会像STL那样考虑的那么周到，组件分工齐全，毕竟STL是包含六大组件的！ 具体如下图： ","date":"2022-02-16","objectID":"/posts/%E6%96%B0%E6%89%8B%E7%94%A8c++%E5%86%99%E4%BA%86%E4%B8%AA%E6%B3%9B%E5%9E%8B%E5%A0%86%E6%95%88%E7%8E%87%E7%AB%9F%E6%AF%94stl%E7%9A%84%E6%9B%B4%E5%BF%AB/:1:0","tags":["新手用C++写了个泛型堆，效率竟比STL的更快？"],"title":"新手用C++写了个泛型堆，效率竟比STL的更快？","uri":"/posts/%E6%96%B0%E6%89%8B%E7%94%A8c++%E5%86%99%E4%BA%86%E4%B8%AA%E6%B3%9B%E5%9E%8B%E5%A0%86%E6%95%88%E7%8E%87%E7%AB%9F%E6%AF%94stl%E7%9A%84%E6%9B%B4%E5%BF%AB/"},{"categories":["手写数据结构"],"content":"对刚用模板的C++新手而言的几大坑点 ","date":"2022-02-16","objectID":"/posts/%E6%96%B0%E6%89%8B%E7%94%A8c++%E5%86%99%E4%BA%86%E4%B8%AA%E6%B3%9B%E5%9E%8B%E5%A0%86%E6%95%88%E7%8E%87%E7%AB%9F%E6%AF%94stl%E7%9A%84%E6%9B%B4%E5%BF%AB/:2:0","tags":["新手用C++写了个泛型堆，效率竟比STL的更快？"],"title":"新手用C++写了个泛型堆，效率竟比STL的更快？","uri":"/posts/%E6%96%B0%E6%89%8B%E7%94%A8c++%E5%86%99%E4%BA%86%E4%B8%AA%E6%B3%9B%E5%9E%8B%E5%A0%86%E6%95%88%E7%8E%87%E7%AB%9F%E6%AF%94stl%E7%9A%84%E6%9B%B4%E5%BF%AB/"},{"categories":["手写数据结构"],"content":"习惯性写.h和.cpp文件 对于对C++有一定掌握，但基本没用过模板的人而言，声明与定义早就烂熟于心的.h和.cpp文件。 然而，当你使用模板的时候，再去吧声明和定义分开，将会产生一个错误！除非在.h文件末尾有包含.cpp文件。然而这样的操作是很多余的！ 所以在用模板实现类的时候，最好只写一个.h文件！ ","date":"2022-02-16","objectID":"/posts/%E6%96%B0%E6%89%8B%E7%94%A8c++%E5%86%99%E4%BA%86%E4%B8%AA%E6%B3%9B%E5%9E%8B%E5%A0%86%E6%95%88%E7%8E%87%E7%AB%9F%E6%AF%94stl%E7%9A%84%E6%9B%B4%E5%BF%AB/:2:1","tags":["新手用C++写了个泛型堆，效率竟比STL的更快？"],"title":"新手用C++写了个泛型堆，效率竟比STL的更快？","uri":"/posts/%E6%96%B0%E6%89%8B%E7%94%A8c++%E5%86%99%E4%BA%86%E4%B8%AA%E6%B3%9B%E5%9E%8B%E5%A0%86%E6%95%88%E7%8E%87%E7%AB%9F%E6%AF%94stl%E7%9A%84%E6%9B%B4%E5%BF%AB/"},{"categories":["手写数据结构"],"content":"对模板特化运用和理解很少 我现在就处于这个状态，说不上来该怎么规范🤣 ","date":"2022-02-16","objectID":"/posts/%E6%96%B0%E6%89%8B%E7%94%A8c++%E5%86%99%E4%BA%86%E4%B8%AA%E6%B3%9B%E5%9E%8B%E5%A0%86%E6%95%88%E7%8E%87%E7%AB%9F%E6%AF%94stl%E7%9A%84%E6%9B%B4%E5%BF%AB/:2:2","tags":["新手用C++写了个泛型堆，效率竟比STL的更快？"],"title":"新手用C++写了个泛型堆，效率竟比STL的更快？","uri":"/posts/%E6%96%B0%E6%89%8B%E7%94%A8c++%E5%86%99%E4%BA%86%E4%B8%AA%E6%B3%9B%E5%9E%8B%E5%A0%86%E6%95%88%E7%8E%87%E7%AB%9F%E6%AF%94stl%E7%9A%84%E6%9B%B4%E5%BF%AB/"},{"categories":["手写数据结构"],"content":"我的Heap实现 ","date":"2022-02-16","objectID":"/posts/%E6%96%B0%E6%89%8B%E7%94%A8c++%E5%86%99%E4%BA%86%E4%B8%AA%E6%B3%9B%E5%9E%8B%E5%A0%86%E6%95%88%E7%8E%87%E7%AB%9F%E6%AF%94stl%E7%9A%84%E6%9B%B4%E5%BF%AB/:3:0","tags":["新手用C++写了个泛型堆，效率竟比STL的更快？"],"title":"新手用C++写了个泛型堆，效率竟比STL的更快？","uri":"/posts/%E6%96%B0%E6%89%8B%E7%94%A8c++%E5%86%99%E4%BA%86%E4%B8%AA%E6%B3%9B%E5%9E%8B%E5%A0%86%E6%95%88%E7%8E%87%E7%AB%9F%E6%AF%94stl%E7%9A%84%E6%9B%B4%E5%BF%AB/"},{"categories":["手写数据结构"],"content":"总览Heap类 这是我画的树状图，我设计的Heap一共分为以下三个部分： 一、 成员变量 这部分没啥好说的，就用一个 nums 指针存储变量数据，length 记录当前的 nums 已经使用的长度，capacity 存储当前 nums 的最大容量。 二、 静态成员函数 我将堆的基本操作封装为静态成员变量的初衷是方便，对外实现堆化的功能，即使使用外部数组也能实现堆。 下面简单的介绍一下这几个函数（后面再详解）： sift_down()：接受四个参数，依次是用于向下堆化的数组，起始的堆化位置，结束的堆化位置，以及一个仿函数(用于设定最大/最小堆)。 static void sift_down(T \u0026nums, size_t start, size_t len, _CMP cmp); sift_up()：向上堆化的操作，与上面的类似，少了结束信息，因为结束信息一般都是0. static void sift_up(T \u0026nums, size_t start, _CMP cmp); heapify()：调用向下堆化函数，实现完全堆化，接收两个参数，待堆化数组和数组长度 static void heapify(T \u0026nums, size_t len); print()：主要实现一个用于测试功能的泛型打印接口，接收的参数肯定就是数组和数组长度了。(略过，不重要) 三、类的内部成员函数(放源代码详解) 构造和析构函数：很简单的，我直接放源代码出来。 Heap() : length(0), capacity(1) {//暂时没有对构造函数拓展的打算 nums = new _T[capacity]; } ~Heap(){ delete []nums; } push()：每次入队后进行一次向上堆化，这个简单，直接调上面的静态接口就行了。注意：我这里采用的是倍增的方式进行延伸内存，一旦出现capacity不够用的情况，就重新分配内存，其中数据拷贝方面用了copy函数。 void push(_T val) { if (length \u003e= capacity) {//两倍两倍的扩容 _T *t = nums; capacity *= 2; nums = new _T[capacity]; std::copy(t, t + length, nums); delete[] t; } nums[length] = val; sift_up(nums, length, _CMP()); length++; } pop()：这个操作是需要一点技巧的–为了不破坏整体堆化的结构，我们直接把根部与尾部元素进行交换，再从根部往下重新堆化一次(注意此时堆化的终点应该要比原来小1)。 还采取了C语言的断言方式，防止pop操作的时候，堆中已经没有元素。 void pop() { if (length == 0) assert(0); length--; std::swap(nums[0], nums[length]);//实际上pop操作就相当于堆排的一次过程 sift_down(nums, 0, length, _CMP()); } top()：直接取根节点的值。 _T top() { if (length == 0) assert(0); return nums[0]; } print()：用于打印内部数据的接口。 void print() {//内部print方便测试 print(nums, length);//调用静态print } ","date":"2022-02-16","objectID":"/posts/%E6%96%B0%E6%89%8B%E7%94%A8c++%E5%86%99%E4%BA%86%E4%B8%AA%E6%B3%9B%E5%9E%8B%E5%A0%86%E6%95%88%E7%8E%87%E7%AB%9F%E6%AF%94stl%E7%9A%84%E6%9B%B4%E5%BF%AB/:3:1","tags":["新手用C++写了个泛型堆，效率竟比STL的更快？"],"title":"新手用C++写了个泛型堆，效率竟比STL的更快？","uri":"/posts/%E6%96%B0%E6%89%8B%E7%94%A8c++%E5%86%99%E4%BA%86%E4%B8%AA%E6%B3%9B%E5%9E%8B%E5%A0%86%E6%95%88%E7%8E%87%E7%AB%9F%E6%AF%94stl%E7%9A%84%E6%9B%B4%E5%BF%AB/"},{"categories":["手写数据结构"],"content":"关于堆化函数的实现 我直接开放代码实现，具体的理解靠大家了。 sift_down() template\u003ctypename T\u003e static void sift_down(T \u0026nums, size_t start, size_t len, _CMP cmp) {//最小堆还是最大堆由cmp决定 int end = len; int parent = start; int child = parent * 2 + 1; while (child \u003c end) { if (child + 1 \u003c end \u0026\u0026 cmp(nums[child], nums[child + 1])) child++; if (!cmp(nums[parent], nums[child])) { break; } else { std::swap(nums[parent], nums[child]); parent = child; child = parent * 2 + 1; } } } sift_up template\u003ctypename T\u003e static void sift_up(T \u0026nums, size_t start, _CMP cmp) {//最小堆还是最大堆由cmp决定 int end = 0; int child = start; int parent = (child - 1) / 2; while (child \u003e end) { if (!cmp(nums[parent], nums[child])) { break; } else { std::swap(nums[parent], nums[child]); child = parent; parent = (child - 1) / 2; } } } heapify() template\u003ctypename T\u003e static void heapify(T \u0026nums, size_t len) {//用于对数组进行堆化 for (int i = len - 1; i \u003e= 0; i--) { sift_down\u003cT\u003e(nums, i, len, _CMP()); } } print() template\u003ctypename T\u003e static void print(T \u0026nums, size_t length) { for (int i = 0; i \u003c length; i++) { std::cout \u003c\u003c nums[i] \u003c\u003c ' '; } } ","date":"2022-02-16","objectID":"/posts/%E6%96%B0%E6%89%8B%E7%94%A8c++%E5%86%99%E4%BA%86%E4%B8%AA%E6%B3%9B%E5%9E%8B%E5%A0%86%E6%95%88%E7%8E%87%E7%AB%9F%E6%AF%94stl%E7%9A%84%E6%9B%B4%E5%BF%AB/:3:2","tags":["新手用C++写了个泛型堆，效率竟比STL的更快？"],"title":"新手用C++写了个泛型堆，效率竟比STL的更快？","uri":"/posts/%E6%96%B0%E6%89%8B%E7%94%A8c++%E5%86%99%E4%BA%86%E4%B8%AA%E6%B3%9B%E5%9E%8B%E5%A0%86%E6%95%88%E7%8E%87%E7%AB%9F%E6%AF%94stl%E7%9A%84%E6%9B%B4%E5%BF%AB/"},{"categories":["手写数据结构"],"content":"关于所用模板的说明 类模板(全局均可用的类型参数)： 其中 _T 用于表示数组元素的类型，默认为int，_CMP 则是一个类(仿函数)的类型，默认为已经提供的cmp仿函数，所以如果为自定义类型构建堆，则一定要自己写好相应的仿函数进行传递。 template\u003ctypename T = int\u003e //用于默认排序的仿函数，默认为大顶堆 class cmp { public: bool operator()(T \u0026a, T \u0026b) { return a \u003c b; } }; template\u003ctypename _T = int, typename _CMP = cmp\u003c_T\u003e\u003e 成员函数模板 为了便于外界使用静态成员函数进行相应的操作，所以每个静态成员函数都提供了对应的类型模板，但比较操作的仿函数用的还是和类模板一样的类型。 如： template\u003ctypename T\u003e static void sift_up(T \u0026nums, size_t start, _CMP cmp) {//最小堆还是最大堆由cmp决定 int end = 0; int child = start; int parent = (child - 1) / 2; while (child \u003e end) { if (!cmp(nums[parent], nums[child])) { break; } else { std::swap(nums[parent], nums[child]); child = parent; parent = (child - 1) / 2; } } } ","date":"2022-02-16","objectID":"/posts/%E6%96%B0%E6%89%8B%E7%94%A8c++%E5%86%99%E4%BA%86%E4%B8%AA%E6%B3%9B%E5%9E%8B%E5%A0%86%E6%95%88%E7%8E%87%E7%AB%9F%E6%AF%94stl%E7%9A%84%E6%9B%B4%E5%BF%AB/:3:3","tags":["新手用C++写了个泛型堆，效率竟比STL的更快？"],"title":"新手用C++写了个泛型堆，效率竟比STL的更快？","uri":"/posts/%E6%96%B0%E6%89%8B%E7%94%A8c++%E5%86%99%E4%BA%86%E4%B8%AA%E6%B3%9B%E5%9E%8B%E5%A0%86%E6%95%88%E7%8E%87%E7%AB%9F%E6%AF%94stl%E7%9A%84%E6%9B%B4%E5%BF%AB/"},{"categories":["手写数据结构"],"content":"整合所有代码，实现Heap类模板 这里用一个命名空间套住是最好，防止命名冲突！我这里用的自己常用的网名hhh // // Created by Alone on 2021/10/2. // #ifndef MY_TINY_STL_HEAP_H #define MY_TINY_STL_HEAP_H #include \u003ciostream\u003e#include \u003ccassert\u003e#include \u003calgorithm\u003e namespace L_B__ { template\u003ctypename T=int\u003e//用于默认排序的仿函数，默认为大顶堆 class cmp { public: bool operator()(T \u0026a, T \u0026b) { return a \u003c b; } }; //@模板类的实现 template\u003ctypename _T=int, typename _CMP = cmp\u003c_T\u003e\u003e class Heap { //私有成员 _T *nums; size_t length; size_t capacity; public://@静态成员函数，对外对内都能实现功能 template\u003ctypename T\u003e static void sift_down(T \u0026nums, size_t start, size_t len, _CMP cmp) {//最小堆还是最大堆由cmp决定 int end = len; int parent = start; int child = parent * 2 + 1; while (child \u003c end) { if (child + 1 \u003c end \u0026\u0026 cmp(nums[child], nums[child + 1])) child++; if (!cmp(nums[parent], nums[child])) { break; } else { std::swap(nums[parent], nums[child]); parent = child; child = parent * 2 + 1; } } } template\u003ctypename T\u003e static void sift_up(T \u0026nums, size_t start, _CMP cmp) {//最小堆还是最大堆由cmp决定 int end = 0; int child = start; int parent = (child - 1) / 2; while (child \u003e end) { if (!cmp(nums[parent], nums[child])) { break; } else { std::swap(nums[parent], nums[child]); child = parent; parent = (child - 1) / 2; } } } template\u003ctypename T\u003e static void heapify(T \u0026nums, size_t len) {//用于对数组进行堆化 for (int i = len - 1; i \u003e= 0; i--) { sift_down\u003cT\u003e(nums, i, len, _CMP()); } } template\u003ctypename T\u003e static void print(T \u0026nums, size_t length) {//专为打印原始数组 for (int i = 0; i \u003c length; i++) { std::cout \u003c\u003c nums[i] \u003c\u003c ' '; } } public://@基本的内部成员函数 Heap() : length(0), capacity(1) {//暂时没有对构造函数拓展的打算 nums = new _T[capacity]; } ~Heap() { delete[]nums; } void push(_T val) { if (length \u003e= capacity) {//两倍两倍的扩容 _T *t = nums; capacity *= 2; nums = new _T[capacity]; std::copy(t, t + length, nums); delete[] t; } nums[length] = val; sift_up(nums, length, _CMP()); length++; } void pop() { if (length == 0) assert(0); length--; std::swap(nums[0], nums[length]);//实际上pop操作就相当于堆排的一次过程 sift_down(nums, 0, length, _CMP()); } _T top() { if (length == 0) assert(0); return nums[0]; } void print() {//内部print方便测试 print(nums, length); } }; } #endif //MY_TINY_STL_HEAP_H ","date":"2022-02-16","objectID":"/posts/%E6%96%B0%E6%89%8B%E7%94%A8c++%E5%86%99%E4%BA%86%E4%B8%AA%E6%B3%9B%E5%9E%8B%E5%A0%86%E6%95%88%E7%8E%87%E7%AB%9F%E6%AF%94stl%E7%9A%84%E6%9B%B4%E5%BF%AB/:3:4","tags":["新手用C++写了个泛型堆，效率竟比STL的更快？"],"title":"新手用C++写了个泛型堆，效率竟比STL的更快？","uri":"/posts/%E6%96%B0%E6%89%8B%E7%94%A8c++%E5%86%99%E4%BA%86%E4%B8%AA%E6%B3%9B%E5%9E%8B%E5%A0%86%E6%95%88%E7%8E%87%E7%AB%9F%E6%AF%94stl%E7%9A%84%E6%9B%B4%E5%BF%AB/"},{"categories":["手写数据结构"],"content":"我的Heap测试 ","date":"2022-02-16","objectID":"/posts/%E6%96%B0%E6%89%8B%E7%94%A8c++%E5%86%99%E4%BA%86%E4%B8%AA%E6%B3%9B%E5%9E%8B%E5%A0%86%E6%95%88%E7%8E%87%E7%AB%9F%E6%AF%94stl%E7%9A%84%E6%9B%B4%E5%BF%AB/:4:0","tags":["新手用C++写了个泛型堆，效率竟比STL的更快？"],"title":"新手用C++写了个泛型堆，效率竟比STL的更快？","uri":"/posts/%E6%96%B0%E6%89%8B%E7%94%A8c++%E5%86%99%E4%BA%86%E4%B8%AA%E6%B3%9B%E5%9E%8B%E5%A0%86%E6%95%88%E7%8E%87%E7%AB%9F%E6%AF%94stl%E7%9A%84%E6%9B%B4%E5%BF%AB/"},{"categories":["手写数据结构"],"content":"正确性测试(与STL priority_queue对比) 经历这数千万数据的测试，仍然和STL的正确性是一样的，说明正确性是有了保障的。 测试代码 #include \"Heap.h\"#include \u003cctime\u003e#include \u003cqueue\u003eusing namespace std; #define MAX_SIZE 10000000 int main() { L_B__::Heap\u003cint\u003e a; priority_queue\u003cint\u003e Q; int step = 1; for(int i=1;i\u003cMAX_SIZE;i++){ a.push(step%i); Q.push(step%i); step += 2; } cout\u003c\u003c\"STL-\u003e\"; for (int i = 0; i \u003c 10; i++) { auto t = move(Q.top()); cout \u003c\u003c t\u003c\u003c' '; Q.pop(); } cout \u003c\u003c endl; cout \u003c\u003c \"My-\u003e\"; for (int i = 0; i \u003c 10; i++) { auto t = move(a.top()); cout \u003c\u003c t\u003c\u003c' '; a.pop(); } } ","date":"2022-02-16","objectID":"/posts/%E6%96%B0%E6%89%8B%E7%94%A8c++%E5%86%99%E4%BA%86%E4%B8%AA%E6%B3%9B%E5%9E%8B%E5%A0%86%E6%95%88%E7%8E%87%E7%AB%9F%E6%AF%94stl%E7%9A%84%E6%9B%B4%E5%BF%AB/:4:1","tags":["新手用C++写了个泛型堆，效率竟比STL的更快？"],"title":"新手用C++写了个泛型堆，效率竟比STL的更快？","uri":"/posts/%E6%96%B0%E6%89%8B%E7%94%A8c++%E5%86%99%E4%BA%86%E4%B8%AA%E6%B3%9B%E5%9E%8B%E5%A0%86%E6%95%88%E7%8E%87%E7%AB%9F%E6%AF%94stl%E7%9A%84%E6%9B%B4%E5%BF%AB/"},{"categories":["手写数据结构"],"content":"效率测试(与STL priority_queue对比) 1000w数据两者的push和pop速度对比 欧耶！比STL快两倍！！🐱‍🏍 其实这样不是很奇怪，STL本来就要实现和考虑很多事情，各种组件的套娃，而我们只是实现了这样一个简单的堆，那当然快很多了。 测试源代码 #include \"Heap.h\"#include \u003cctime\u003e#include \u003cqueue\u003eusing namespace std; #define MAX_SIZE 10000000 int main() { L_B__::Heap\u003cint\u003e a; priority_queue\u003cint\u003e Q; auto start = clock(); //@push测试 int step = 1; for(int i=1;i\u003cMAX_SIZE;i++){ Q.push(step%i); step += 2; } cout\u003c\u003c\"STL Push:\"\u003c\u003cclock()-start\u003c\u003c\"ms\"\u003c\u003cendl; start = clock(); step = 1; for(int i=1;i\u003cMAX_SIZE;i++){ a.push(step%i); step += 2; } cout\u003c\u003c\"My Push:\"\u003c\u003cclock()-start\u003c\u003c\"ms\"\u003c\u003cendl; //@pop测试 start = clock(); for(int i=1;i\u003cMAX_SIZE;i++){ Q.pop(); } cout\u003c\u003c\"STL Pop:\"\u003c\u003cclock()-start\u003c\u003c\"ms\"\u003c\u003cendl; start = clock(); for(int i=1;i\u003cMAX_SIZE;i++){ a.pop(); } cout\u003c\u003c\"My Pop:\"\u003c\u003cclock()-start\u003c\u003c\"ms\"\u003c\u003cendl; } ","date":"2022-02-16","objectID":"/posts/%E6%96%B0%E6%89%8B%E7%94%A8c++%E5%86%99%E4%BA%86%E4%B8%AA%E6%B3%9B%E5%9E%8B%E5%A0%86%E6%95%88%E7%8E%87%E7%AB%9F%E6%AF%94stl%E7%9A%84%E6%9B%B4%E5%BF%AB/:4:2","tags":["新手用C++写了个泛型堆，效率竟比STL的更快？"],"title":"新手用C++写了个泛型堆，效率竟比STL的更快？","uri":"/posts/%E6%96%B0%E6%89%8B%E7%94%A8c++%E5%86%99%E4%BA%86%E4%B8%AA%E6%B3%9B%E5%9E%8B%E5%A0%86%E6%95%88%E7%8E%87%E7%AB%9F%E6%AF%94stl%E7%9A%84%E6%9B%B4%E5%BF%AB/"},{"categories":["手写数据结构"],"content":"解题实测(LeetCode 347. 前 K 个高频元素) 我去，果然比stl的快不少🤣 直接把代码cv放到LC前面，然后测试使用自定义类型的情况。 解题代码： struct S{ int a,b; }; class cmp{ public: bool operator()(S\u0026a,S\u0026b){ return a.b\u003cb.b; } }; namespace L_B__ { template\u003ctypename T=int\u003e//用于默认排序的仿函数，默认为大顶堆 class cmp { public: bool operator()(T \u0026a, T \u0026b) { return a \u003c b; } }; //@模板类的实现 template\u003ctypename _T=int, typename _CMP = cmp\u003c_T\u003e\u003e class Heap { //私有成员 _T *nums; size_t length; size_t capacity; public://@静态成员函数，对外对内都能实现功能 template\u003ctypename T\u003e static void sift_down(T \u0026nums, size_t start, size_t len, _CMP cmp) {//最小堆还是最大堆由cmp决定 int end = len; int parent = start; int child = parent * 2 + 1; while (child \u003c end) { if (child + 1 \u003c end \u0026\u0026 cmp(nums[child], nums[child + 1])) child++; if (!cmp(nums[parent], nums[child])) { break; } else { std::swap(nums[parent], nums[child]); parent = child; child = parent * 2 + 1; } } } template\u003ctypename T\u003e static void sift_up(T \u0026nums, size_t start, _CMP cmp) {//最小堆还是最大堆由cmp决定 int end = 0; int child = start; int parent = (child - 1) / 2; while (child \u003e end) { if (!cmp(nums[parent], nums[child])) { break; } else { std::swap(nums[parent], nums[child]); child = parent; parent = (child - 1) / 2; } } } template\u003ctypename T\u003e static void heapify(T \u0026nums, size_t len) {//用于对数组进行堆化 for (int i = len - 1; i \u003e= 0; i--) { sift_down\u003cT\u003e(nums, i, len, _CMP()); } } template\u003ctypename T\u003e static void print(T \u0026nums, size_t length) {//专为打印原始数组 for (int i = 0; i \u003c length; i++) { std::cout \u003c\u003c nums[i] \u003c\u003c ' '; } } public://@基本的内部成员函数 Heap() : length(0), capacity(1) {//暂时没有对构造函数拓展的打算 nums = new _T[capacity]; } ~Heap() { delete[]nums; } void push(_T val) { if (length \u003e= capacity) {//两倍两倍的扩容 _T *t = nums; capacity *= 2; nums = new _T[capacity]; std::copy(t, t + length, nums); delete[] t; } nums[length] = val; sift_up(nums, length, _CMP()); length++; } void pop() { if (length == 0) assert(0); length--; std::swap(nums[0], nums[length]);//实际上pop操作就相当于堆排的一次过程 sift_down(nums, 0, length, _CMP()); } _T top() { if (length == 0) assert(0); return nums[0]; } void print() {//内部print方便测试 print(nums, length); } }; } class Solution { public: vector\u003cint\u003e topKFrequent(vector\u003cint\u003e\u0026 nums, int k) { unordered_map\u003cint,int\u003et; //开始映射hashmap for(int s:nums){ t[s]++; } L_B__::Heap\u003cS,cmp\u003eQ; for(unordered_map\u003cint,int\u003e::iterator it=t.begin();it!=t.end();it++){ Q.push({it-\u003efirst,it-\u003esecond}); } vector\u003cint\u003eres; //得到前k个最大的元素 for(int i=0;i\u003ck;i++){ auto t = Q.top();Q.pop(); res.push_back(t.a); } return res; } }; ","date":"2022-02-16","objectID":"/posts/%E6%96%B0%E6%89%8B%E7%94%A8c++%E5%86%99%E4%BA%86%E4%B8%AA%E6%B3%9B%E5%9E%8B%E5%A0%86%E6%95%88%E7%8E%87%E7%AB%9F%E6%AF%94stl%E7%9A%84%E6%9B%B4%E5%BF%AB/:4:3","tags":["新手用C++写了个泛型堆，效率竟比STL的更快？"],"title":"新手用C++写了个泛型堆，效率竟比STL的更快？","uri":"/posts/%E6%96%B0%E6%89%8B%E7%94%A8c++%E5%86%99%E4%BA%86%E4%B8%AA%E6%B3%9B%E5%9E%8B%E5%A0%86%E6%95%88%E7%8E%87%E7%AB%9F%E6%AF%94stl%E7%9A%84%E6%9B%B4%E5%BF%AB/"},{"categories":["手写数据结构"],"content":"总结 对于模板的运用，现在才刚开始入门(入门都不到…)，给我的感觉是STL源码的包袱很重，各个组件高度关联，所以能够通过一个容器实现的算法有很多很多！我这个新手还不配高攀，只能仰望了，当然平时随便写写乐色代码也是可以滴，至少可以吹牛说比STL还快了🤣 ","date":"2022-02-16","objectID":"/posts/%E6%96%B0%E6%89%8B%E7%94%A8c++%E5%86%99%E4%BA%86%E4%B8%AA%E6%B3%9B%E5%9E%8B%E5%A0%86%E6%95%88%E7%8E%87%E7%AB%9F%E6%AF%94stl%E7%9A%84%E6%9B%B4%E5%BF%AB/:5:0","tags":["新手用C++写了个泛型堆，效率竟比STL的更快？"],"title":"新手用C++写了个泛型堆，效率竟比STL的更快？","uri":"/posts/%E6%96%B0%E6%89%8B%E7%94%A8c++%E5%86%99%E4%BA%86%E4%B8%AA%E6%B3%9B%E5%9E%8B%E5%A0%86%E6%95%88%E7%8E%87%E7%AB%9F%E6%AF%94stl%E7%9A%84%E6%9B%B4%E5%BF%AB/"},{"categories":["手写数据结构"],"content":"来自上帝的骰子---Treap(树堆)详解","date":"2022-02-16","objectID":"/posts/%E6%9D%A5%E8%87%AA%E4%B8%8A%E5%B8%9D%E7%9A%84%E9%AA%B0%E5%AD%90-treap%E6%A0%91%E5%A0%86%E8%AF%A6%E8%A7%A3/","tags":["来自上帝的骰子---Treap(树堆)详解"],"title":"来自上帝的骰子---Treap(树堆)详解","uri":"/posts/%E6%9D%A5%E8%87%AA%E4%B8%8A%E5%B8%9D%E7%9A%84%E9%AA%B0%E5%AD%90-treap%E6%A0%91%E5%A0%86%E8%AF%A6%E8%A7%A3/"},{"categories":["手写数据结构"],"content":"为什么说是上帝的骰子？ 解释这个问题，首先由这个数据结构的名字开始，Treap = Tree + Heap，即为树堆之意，然而实际上用到堆的地方就是利用了一个随机的值标记每个结点，然后根据这个值对树进行左旋、右旋操作来调整父子树直接的关系，你可以严格让它遵循小根堆也可以遵循大根堆，这都无所谓。 也就是说每个结点的结构需要额外存储一个随机值，来决定它是否旋转调整，这对比普通的BST就要优越很多了，但这个也看运气，如果骰子没摇好，出现极端的情况，则可能即便是旋转了多次还是效率低下，我后面对BST、Treap、AVL进行了各方面的对比。 相对AVL，它不需要记录深度，不需要根据深度来判断是否旋转，旋转这件事就完全交给老天了，而且也不存在复杂的旋转情况，只有左旋和右旋。 注意：我写的这个Treap是以大根堆的方式进行维护的！也就是父节点大于子节点的随机值。 ","date":"2022-02-16","objectID":"/posts/%E6%9D%A5%E8%87%AA%E4%B8%8A%E5%B8%9D%E7%9A%84%E9%AA%B0%E5%AD%90-treap%E6%A0%91%E5%A0%86%E8%AF%A6%E8%A7%A3/:1:0","tags":["来自上帝的骰子---Treap(树堆)详解"],"title":"来自上帝的骰子---Treap(树堆)详解","uri":"/posts/%E6%9D%A5%E8%87%AA%E4%B8%8A%E5%B8%9D%E7%9A%84%E9%AA%B0%E5%AD%90-treap%E6%A0%91%E5%A0%86%E8%AF%A6%E8%A7%A3/"},{"categories":["手写数据结构"],"content":"Treap实现 ","date":"2022-02-16","objectID":"/posts/%E6%9D%A5%E8%87%AA%E4%B8%8A%E5%B8%9D%E7%9A%84%E9%AA%B0%E5%AD%90-treap%E6%A0%91%E5%A0%86%E8%AF%A6%E8%A7%A3/:2:0","tags":["来自上帝的骰子---Treap(树堆)详解"],"title":"来自上帝的骰子---Treap(树堆)详解","uri":"/posts/%E6%9D%A5%E8%87%AA%E4%B8%8A%E5%B8%9D%E7%9A%84%E9%AA%B0%E5%AD%90-treap%E6%A0%91%E5%A0%86%E8%AF%A6%E8%A7%A3/"},{"categories":["手写数据结构"],"content":"1. 结点的结构 struct node { //值、优先级(随机数、该数的总结点数、该结点的val次数 int val, priority, length, cnt; node *lchild; node *rchild; node() : val(0), length(1), cnt(1), lchild(nullptr), rchild(nullptr) { srand((unsigned) time(NULL));//记得重新设定种子 priority = rand(); } node(int val) : val(val), length(1), cnt(1), lchild(nullptr), rchild(nullptr) { srand((unsigned) time(NULL)); priority = rand(); } void update() { length = cnt; if (lchild != nullptr)length += lchild-\u003elength; if (rchild != nullptr)length += rchild-\u003elength; } }; ","date":"2022-02-16","objectID":"/posts/%E6%9D%A5%E8%87%AA%E4%B8%8A%E5%B8%9D%E7%9A%84%E9%AA%B0%E5%AD%90-treap%E6%A0%91%E5%A0%86%E8%AF%A6%E8%A7%A3/:2:1","tags":["来自上帝的骰子---Treap(树堆)详解"],"title":"来自上帝的骰子---Treap(树堆)详解","uri":"/posts/%E6%9D%A5%E8%87%AA%E4%B8%8A%E5%B8%9D%E7%9A%84%E9%AA%B0%E5%AD%90-treap%E6%A0%91%E5%A0%86%E8%AF%A6%E8%A7%A3/"},{"categories":["手写数据结构"],"content":"2. Treap的抽象数据结构 class Treap { node *head; int length; public: /*construct\u0026destruct*/ Treap() : head(nullptr), length(0) {} Treap(int val) : head(new node(val)), length(1) {} public://内部类设计迭代器 class iterator { node *head; node *root; public: /*迭代器部分*/ iterator(node *head, node *root) : head(head), root(root) {} iterator \u0026operator++() { root = queryNext(head, root-\u003eval); return *this; } iterator operator++(int) { iterator t = *this; root = queryNext(head, root-\u003eval); return t; } iterator \u0026operator--() { root = queryPre(head, root-\u003eval); return *this; } iterator operator--(int) { iterator t = *this; root = queryPre(head, root-\u003eval); return t; } int operator*() { return root-\u003eval; } bool operator!=(const iterator \u0026t) { return t.root != root; } }; private: /*static function*/ /*rotate*/ static node *rotateLeft(node *root); static node *rotateRight(node *root); /*insert\u0026remove*/ static node *insert(node *root, int val, int \u0026size); static node *remove(node *root, int val, int \u0026size); /*query rank\u0026value*/ static int getLength(node *root); static int queryRank(node *root, int val);//快速查询val的排名 static int queryValue(node *root, int rank);//快速查询排名为rank的数 /*query pre\u0026next*/ static node *queryPre(node *root, int val); static node *queryNext(node *root, int val); static void inorder_print(node *root); static void destroy(node *root); public: /*public function*/ /*insert\u0026remove*/ void insert(int val) { head = insert(head, val, length); } void remove(int val) { head = remove(head, val, length); } int size() { return length; } bool isEmpty() { return length == 0; } /*query rank\u0026value*/ int queryRank(int val) { return queryRank(head, val); } int queryValue(int rank) { return queryValue(head, rank); } void inorder_print() { inorder_print(head); } /*begin\u0026end*/ iterator begin() { node *t = head; while (t-\u003elchild != nullptr) { t = t-\u003elchild; } return iterator(head, t); } iterator end() { return iterator(head, nullptr); } }; ","date":"2022-02-16","objectID":"/posts/%E6%9D%A5%E8%87%AA%E4%B8%8A%E5%B8%9D%E7%9A%84%E9%AA%B0%E5%AD%90-treap%E6%A0%91%E5%A0%86%E8%AF%A6%E8%A7%A3/:2:2","tags":["来自上帝的骰子---Treap(树堆)详解"],"title":"来自上帝的骰子---Treap(树堆)详解","uri":"/posts/%E6%9D%A5%E8%87%AA%E4%B8%8A%E5%B8%9D%E7%9A%84%E9%AA%B0%E5%AD%90-treap%E6%A0%91%E5%A0%86%E8%AF%A6%E8%A7%A3/"},{"categories":["手写数据结构"],"content":"3. 左旋和右旋 具体可以看我之前AVL树对左旋右旋的描述,这里只开发源码查看，文章链接 左旋： node *Treap::rotateLeft(node *root) { node *son = root-\u003erchild; root-\u003erchild = son-\u003elchild; son-\u003elchild = root; root-\u003eupdate();//记得先更新底下的情况 son-\u003eupdate(); return son; } 右旋： node *Treap::rotateRight(node *root) { node *son = root-\u003elchild; root-\u003elchild = son-\u003erchild; son-\u003erchild = root; root-\u003eupdate(); son-\u003eupdate(); return son; } ","date":"2022-02-16","objectID":"/posts/%E6%9D%A5%E8%87%AA%E4%B8%8A%E5%B8%9D%E7%9A%84%E9%AA%B0%E5%AD%90-treap%E6%A0%91%E5%A0%86%E8%AF%A6%E8%A7%A3/:2:3","tags":["来自上帝的骰子---Treap(树堆)详解"],"title":"来自上帝的骰子---Treap(树堆)详解","uri":"/posts/%E6%9D%A5%E8%87%AA%E4%B8%8A%E5%B8%9D%E7%9A%84%E9%AA%B0%E5%AD%90-treap%E6%A0%91%E5%A0%86%E8%AF%A6%E8%A7%A3/"},{"categories":["手写数据结构"],"content":"4. 插入和删除 插入： node *Treap::insert(node *root, int val, int \u0026size) { if (root == nullptr) { ++size; return new node(val); } if (root-\u003eval == val) { root-\u003ecnt++; size++; } else if (root-\u003eval \u003e val) { root-\u003elchild = insert(root-\u003elchild, val, size); //根据优先级判断是否右旋，因为只可能在左边增加长度，通过维持优先级的大根堆 if (root-\u003epriority \u003c root-\u003elchild-\u003epriority) root = rotateRight(root); } else if (root-\u003eval \u003c val) { root-\u003erchild = insert(root-\u003erchild, val, size); if (root-\u003epriority \u003c root-\u003erchild-\u003epriority) root = rotateLeft(root); } root-\u003eupdate();//注意更新长度信息 return root; } 删除： 删除这里还是详解一下： 找到要删除的目标节点后，我们根据让树旋转使得优先级较大的孩子替换掉父亲（目标节点）。然后继续追杀父亲结点，直到该结点被逼到叶子结点，删除即可。 node *Treap::remove(node *root, int val, int \u0026size) { if (root == nullptr)return nullptr;//没找到 if (root-\u003eval == val) { //含有多个相同值，直接操作cnt即可 if (root-\u003ecnt \u003e 1) { root-\u003ecnt--; --size; } //分为两类情况：叶子结点情况和非叶子结点情况 else if (root-\u003elchild != nullptr || root-\u003erchild != nullptr) { //只有左子树或者左子树优先级大于右子树情况 if (root-\u003erchild == nullptr || root-\u003elchild != nullptr \u0026\u0026 root-\u003elchild-\u003epriority \u003e root-\u003erchild-\u003epriority) { root = rotateRight(root);//右旋后继续追杀 root-\u003erchild = remove(root-\u003erchild, val, size); } else {//只有右子树或者右子树优先级大于左子树的情况 root = rotateLeft(root);//左旋后继续追杀 root-\u003elchild = remove(root-\u003elchild, val, size); } } else {//叶子结点情况，直接删除，然后把 delete root; root = nullptr; --size; } } else if (root-\u003eval \u003e val) { root-\u003elchild = remove(root-\u003elchild, val, size); } else if (root-\u003eval \u003c val) { root-\u003erchild = remove(root-\u003erchild, val, size); } if (root) root-\u003eupdate(); return root; } ","date":"2022-02-16","objectID":"/posts/%E6%9D%A5%E8%87%AA%E4%B8%8A%E5%B8%9D%E7%9A%84%E9%AA%B0%E5%AD%90-treap%E6%A0%91%E5%A0%86%E8%AF%A6%E8%A7%A3/:2:4","tags":["来自上帝的骰子---Treap(树堆)详解"],"title":"来自上帝的骰子---Treap(树堆)详解","uri":"/posts/%E6%9D%A5%E8%87%AA%E4%B8%8A%E5%B8%9D%E7%9A%84%E9%AA%B0%E5%AD%90-treap%E6%A0%91%E5%A0%86%E8%AF%A6%E8%A7%A3/"},{"categories":["手写数据结构"],"content":"5. 查询排名 原理：由于是排序二叉树，而且记录了树的结点个数，所以我们根据左边个数（小于当前结点的个数），如果我们的值小于当前结点的值，则小于它的个数范围肯定是在当前结点的左边，直接迁移到左孩子即可，如果大于当前结点，则当前结点的左边大小+它自身也是无法满足要查询的值的排名，rank加上该值后root继续右移。如果出现找到该元素的情况，则直接返回rank+左边长度。如果其中不存在，则最后得出的rank肯定是需要+1的。 inline int Treap::getLength(node *root) { if (root == nullptr) return 0; return root-\u003elength; } int Treap::queryRank(node *root, int val) {//相当于查询有多少个数小于等于val int rank = 0; while (root != nullptr) { if (root-\u003eval == val)return rank + getLength(root-\u003elchild) + root-\u003ecnt; else if (root-\u003eval \u003e val)root = root-\u003elchild; else rank += getLength(root-\u003elchild) + root-\u003ecnt, root = root-\u003erchild; } return rank + 1;//如果未找到，则在原来的基础上+1 } ","date":"2022-02-16","objectID":"/posts/%E6%9D%A5%E8%87%AA%E4%B8%8A%E5%B8%9D%E7%9A%84%E9%AA%B0%E5%AD%90-treap%E6%A0%91%E5%A0%86%E8%AF%A6%E8%A7%A3/:2:5","tags":["来自上帝的骰子---Treap(树堆)详解"],"title":"来自上帝的骰子---Treap(树堆)详解","uri":"/posts/%E6%9D%A5%E8%87%AA%E4%B8%8A%E5%B8%9D%E7%9A%84%E9%AA%B0%E5%AD%90-treap%E6%A0%91%E5%A0%86%E8%AF%A6%E8%A7%A3/"},{"categories":["手写数据结构"],"content":"6. 按排名查询值 inline int Treap::getLength(node *root) { if (root == nullptr) return 0; return root-\u003elength; } int Treap::queryValue(node *root, int rank) {//相当于得到第k大的数：支持重复元素是最骚的！！！ while (root != nullptr) { if (getLength(root-\u003elchild) + root-\u003ecnt \u003e rank) { if (getLength(root-\u003elchild) + 1 \u003e rank) root = root-\u003elchild; else return root-\u003eval; } else if (getLength(root-\u003elchild) + root-\u003ecnt \u003c rank) { rank -= getLength(root-\u003elchild) + root-\u003ecnt; root = root-\u003erchild; } else {//rank与左子树的大小相等的情况 return root-\u003eval; } } return 0; } ","date":"2022-02-16","objectID":"/posts/%E6%9D%A5%E8%87%AA%E4%B8%8A%E5%B8%9D%E7%9A%84%E9%AA%B0%E5%AD%90-treap%E6%A0%91%E5%A0%86%E8%AF%A6%E8%A7%A3/:2:6","tags":["来自上帝的骰子---Treap(树堆)详解"],"title":"来自上帝的骰子---Treap(树堆)详解","uri":"/posts/%E6%9D%A5%E8%87%AA%E4%B8%8A%E5%B8%9D%E7%9A%84%E9%AA%B0%E5%AD%90-treap%E6%A0%91%E5%A0%86%E8%AF%A6%E8%A7%A3/"},{"categories":["手写数据结构"],"content":"7. 查询前驱后继 前驱： node *Treap::queryPre(node *root, int val) {//一样的道理：如果有左子树，就是左子树中最大的结点，如果没有则是最接近该结点的父节点(应在它的右侧 node *res = nullptr; while (root != nullptr) { if (root-\u003eval \u003c val)res = root, root = root-\u003erchild; else root = root-\u003erchild; } return res; } 后继： node *Treap::queryNext(node *root, int val) {//寻找后继 node *res = nullptr; while (root != nullptr) { if (root-\u003eval \u003e val)res = root, root = root-\u003elchild; else root = root-\u003erchild; } return res; } ","date":"2022-02-16","objectID":"/posts/%E6%9D%A5%E8%87%AA%E4%B8%8A%E5%B8%9D%E7%9A%84%E9%AA%B0%E5%AD%90-treap%E6%A0%91%E5%A0%86%E8%AF%A6%E8%A7%A3/:2:7","tags":["来自上帝的骰子---Treap(树堆)详解"],"title":"来自上帝的骰子---Treap(树堆)详解","uri":"/posts/%E6%9D%A5%E8%87%AA%E4%B8%8A%E5%B8%9D%E7%9A%84%E9%AA%B0%E5%AD%90-treap%E6%A0%91%E5%A0%86%E8%AF%A6%E8%A7%A3/"},{"categories":["手写数据结构"],"content":"8. 销毁Treap void Treap::destroy(node *root) { if (root == nullptr) return; destroy(root-\u003elchild); destroy(root-\u003erchild); delete root; root = nullptr; } ","date":"2022-02-16","objectID":"/posts/%E6%9D%A5%E8%87%AA%E4%B8%8A%E5%B8%9D%E7%9A%84%E9%AA%B0%E5%AD%90-treap%E6%A0%91%E5%A0%86%E8%AF%A6%E8%A7%A3/:2:8","tags":["来自上帝的骰子---Treap(树堆)详解"],"title":"来自上帝的骰子---Treap(树堆)详解","uri":"/posts/%E6%9D%A5%E8%87%AA%E4%B8%8A%E5%B8%9D%E7%9A%84%E9%AA%B0%E5%AD%90-treap%E6%A0%91%E5%A0%86%E8%AF%A6%E8%A7%A3/"},{"categories":["手写数据结构"],"content":"9. 迭代器的设计 public://内部类设计迭代器 class iterator { node *head; node *root; public: /*迭代器部分*/ iterator(node *head, node *root) : head(head), root(root) {} iterator \u0026operator++() { root = queryNext(head, root-\u003eval); return *this; } iterator operator++(int) { iterator t = *this; root = queryNext(head, root-\u003eval); return t; } iterator \u0026operator--() { root = queryPre(head, root-\u003eval); return *this; } iterator operator--(int) { iterator t = *this; root = queryPre(head, root-\u003eval); return t; } int operator*() { return root-\u003eval; } bool operator!=(const iterator \u0026t) { return t.root != root; } }; ","date":"2022-02-16","objectID":"/posts/%E6%9D%A5%E8%87%AA%E4%B8%8A%E5%B8%9D%E7%9A%84%E9%AA%B0%E5%AD%90-treap%E6%A0%91%E5%A0%86%E8%AF%A6%E8%A7%A3/:2:9","tags":["来自上帝的骰子---Treap(树堆)详解"],"title":"来自上帝的骰子---Treap(树堆)详解","uri":"/posts/%E6%9D%A5%E8%87%AA%E4%B8%8A%E5%B8%9D%E7%9A%84%E9%AA%B0%E5%AD%90-treap%E6%A0%91%E5%A0%86%E8%AF%A6%E8%A7%A3/"},{"categories":["手写数据结构"],"content":"完整源代码 ","date":"2022-02-16","objectID":"/posts/%E6%9D%A5%E8%87%AA%E4%B8%8A%E5%B8%9D%E7%9A%84%E9%AA%B0%E5%AD%90-treap%E6%A0%91%E5%A0%86%E8%AF%A6%E8%A7%A3/:3:0","tags":["来自上帝的骰子---Treap(树堆)详解"],"title":"来自上帝的骰子---Treap(树堆)详解","uri":"/posts/%E6%9D%A5%E8%87%AA%E4%B8%8A%E5%B8%9D%E7%9A%84%E9%AA%B0%E5%AD%90-treap%E6%A0%91%E5%A0%86%E8%AF%A6%E8%A7%A3/"},{"categories":["手写数据结构"],"content":"Treap.h // // Created by Alone on 2021/10/14. // #ifndef MY_TINY_STL_TREAP_H #define MY_TINY_STL_TREAP_H #include \u003ccstdio\u003e#include \u003ccstdlib\u003e#include \u003cctime\u003e struct node { int val, priority, length, cnt; node *lchild; node *rchild; node() : val(0), length(1), cnt(1), lchild(nullptr), rchild(nullptr) { srand((unsigned) time(NULL));//记得重新设定种子 priority = rand(); } node(int val) : val(val), length(1), cnt(1), lchild(nullptr), rchild(nullptr) { srand((unsigned) time(NULL)); priority = rand(); } void update() { length = cnt; if (lchild != nullptr)length += lchild-\u003elength; if (rchild != nullptr)length += rchild-\u003elength; } }; class Treap { node *head; int length; public: /*construct\u0026destruct*/ Treap() : head(nullptr), length(0) {} Treap(int val) : head(new node(val)), length(1) {} ~Treap(){ destroy(head); } public://内部类设计迭代器 class iterator { node *head; node *root; public: /*迭代器部分*/ iterator(node *head, node *root) : head(head), root(root) {} iterator \u0026operator++() { root = queryNext(head, root-\u003eval); return *this; } iterator operator++(int) { iterator t = *this; root = queryNext(head, root-\u003eval); return t; } iterator \u0026operator--() { root = queryPre(head, root-\u003eval); return *this; } iterator operator--(int) { iterator t = *this; root = queryPre(head, root-\u003eval); return t; } int operator*() { return root-\u003eval; } bool operator!=(const iterator \u0026t) { return t.root != root; } }; private: /*static function*/ /*rotate*/ static node *rotateLeft(node *root); static node *rotateRight(node *root); /*insert\u0026remove*/ static node *insert(node *root, int val, int \u0026size); static node *remove(node *root, int val, int \u0026size); /*query rank\u0026value*/ static int getLength(node *root); static int queryRank(node *root, int val);//快速查询val的排名 static int queryValue(node *root, int rank);//快速查询排名为rank的数 /*query pre\u0026next*/ static node *queryPre(node *root, int val); static node *queryNext(node *root, int val); static void inorder_print(node *root); static void destroy(node *root); public: /*public function*/ /*insert\u0026remove*/ void insert(int val) { head = insert(head, val, length); } void remove(int val) { head = remove(head, val, length); } int size() { return length; } bool isEmpty() { return length == 0; } /*query rank\u0026value*/ int queryRank(int val) { return queryRank(head, val); } int queryValue(int rank) { return queryValue(head, rank); } void inorder_print() { inorder_print(head); } /*begin\u0026end*/ iterator begin() { node *t = head; while (t-\u003elchild != nullptr) { t = t-\u003elchild; } return iterator(head, t); } iterator end() { return iterator(head, nullptr); } }; #endif //MY_TINY_STL_TREAP_H ","date":"2022-02-16","objectID":"/posts/%E6%9D%A5%E8%87%AA%E4%B8%8A%E5%B8%9D%E7%9A%84%E9%AA%B0%E5%AD%90-treap%E6%A0%91%E5%A0%86%E8%AF%A6%E8%A7%A3/:3:1","tags":["来自上帝的骰子---Treap(树堆)详解"],"title":"来自上帝的骰子---Treap(树堆)详解","uri":"/posts/%E6%9D%A5%E8%87%AA%E4%B8%8A%E5%B8%9D%E7%9A%84%E9%AA%B0%E5%AD%90-treap%E6%A0%91%E5%A0%86%E8%AF%A6%E8%A7%A3/"},{"categories":["手写数据结构"],"content":"Treap.cpp // // Created by Alone on 2021/10/14. // #include \"Treap.h\" node *Treap::rotateLeft(node *root) { node *son = root-\u003erchild; root-\u003erchild = son-\u003elchild; son-\u003elchild = root; root-\u003eupdate();//记得先更新底下的情况 son-\u003eupdate(); return son; } node *Treap::rotateRight(node *root) { node *son = root-\u003elchild; root-\u003elchild = son-\u003erchild; son-\u003erchild = root; root-\u003eupdate(); son-\u003eupdate(); return son; } node *Treap::insert(node *root, int val, int \u0026size) { if (root == nullptr) { ++size; return new node(val); } if (root-\u003eval == val) { root-\u003ecnt++; size++; } else if (root-\u003eval \u003e val) { root-\u003elchild = insert(root-\u003elchild, val, size); //根据优先级判断是否右旋，因为只可能在左边增加长度，通过维持优先级的大根堆 if (root-\u003epriority \u003c root-\u003elchild-\u003epriority) root = rotateRight(root); } else if (root-\u003eval \u003c val) { root-\u003erchild = insert(root-\u003erchild, val, size); if (root-\u003epriority \u003c root-\u003erchild-\u003epriority) root = rotateLeft(root); } root-\u003eupdate(); return root; } node *Treap::remove(node *root, int val, int \u0026size) { if (root == nullptr)return nullptr;//没找到 if (root-\u003eval == val) { //含有多个相同值，直接操作cnt即可 if (root-\u003ecnt \u003e 1) { root-\u003ecnt--; --size; } //分为两类情况：叶子结点情况和非叶子结点情况 else if (root-\u003elchild != nullptr || root-\u003erchild != nullptr) { //只有左子树或者左子树优先级大于右子树情况 if (root-\u003erchild == nullptr || root-\u003elchild != nullptr \u0026\u0026 root-\u003elchild-\u003epriority \u003e root-\u003erchild-\u003epriority) { root = rotateRight(root);//右旋后继续追杀 root-\u003erchild = remove(root-\u003erchild, val, size); } else {//只有右子树或者右子树优先级大于左子树的情况 root = rotateLeft(root);//左旋后继续追杀 root-\u003elchild = remove(root-\u003elchild, val, size); } } else {//叶子结点情况，直接删除，然后把 delete root; root = nullptr; --size; } } else if (root-\u003eval \u003e val) { root-\u003elchild = remove(root-\u003elchild, val, size); } else if (root-\u003eval \u003c val) { root-\u003erchild = remove(root-\u003erchild, val, size); } if (root) root-\u003eupdate(); return root; } int Treap::queryRank(node *root, int val) {//相当于查询有多少个数小于等于val int rank = 0; while (root != nullptr) { if (root-\u003eval == val)return rank + getLength(root-\u003elchild) + root-\u003ecnt; else if (root-\u003eval \u003e val)root = root-\u003elchild; else rank += getLength(root-\u003elchild) + root-\u003ecnt, root = root-\u003erchild; } return rank + 1;//如果未找到，则在原来的基础上+1 } int Treap::queryValue(node *root, int rank) {//相当于得到第k大的数：支持重复元素是最骚的！！！ while (root != nullptr) { if (getLength(root-\u003elchild) + root-\u003ecnt \u003e rank) { if (getLength(root-\u003elchild) + 1 \u003e rank) root = root-\u003elchild; else return root-\u003eval; } else if (getLength(root-\u003elchild) + root-\u003ecnt \u003c rank) { rank -= getLength(root-\u003elchild) + root-\u003ecnt; root = root-\u003erchild; } else {//rank与左子树的大小相等的情况 return root-\u003eval; } } return 0; } node *Treap::queryPre(node *root, int val) {//一样的道理：如果有左子树，就是左子树中最大的结点，如果没有则是最接近该结点的父节点(应在它的右侧 node *res = nullptr; while (root != nullptr) { if (root-\u003eval \u003c val)res = root, root = root-\u003erchild; else root = root-\u003erchild; } return res; } node *Treap::queryNext(node *root, int val) {//寻找后继 node *res = nullptr; while (root != nullptr) { if (root-\u003eval \u003e val)res = root, root = root-\u003elchild; else root = root-\u003erchild; } return res; } void Treap::inorder_print(node *root) { if (root == nullptr) return; inorder_print(root-\u003elchild); printf(\"%d \", root-\u003eval); inorder_print(root-\u003erchild); } void Treap::destroy(node *root) { if (root == nullptr) return; destroy(root-\u003elchild); destroy(root-\u003erchild); delete root; root = nullptr; } inline int Treap::getLength(node *root) { if (root == nullptr) return 0; return root-\u003elength; } ","date":"2022-02-16","objectID":"/posts/%E6%9D%A5%E8%87%AA%E4%B8%8A%E5%B8%9D%E7%9A%84%E9%AA%B0%E5%AD%90-treap%E6%A0%91%E5%A0%86%E8%AF%A6%E8%A7%A3/:3:2","tags":["来自上帝的骰子---Treap(树堆)详解"],"title":"来自上帝的骰子---Treap(树堆)详解","uri":"/posts/%E6%9D%A5%E8%87%AA%E4%B8%8A%E5%B8%9D%E7%9A%84%E9%AA%B0%E5%AD%90-treap%E6%A0%91%E5%A0%86%E8%AF%A6%E8%A7%A3/"},{"categories":["手写数据结构"],"content":"测试 ","date":"2022-02-16","objectID":"/posts/%E6%9D%A5%E8%87%AA%E4%B8%8A%E5%B8%9D%E7%9A%84%E9%AA%B0%E5%AD%90-treap%E6%A0%91%E5%A0%86%E8%AF%A6%E8%A7%A3/:4:0","tags":["来自上帝的骰子---Treap(树堆)详解"],"title":"来自上帝的骰子---Treap(树堆)详解","uri":"/posts/%E6%9D%A5%E8%87%AA%E4%B8%8A%E5%B8%9D%E7%9A%84%E9%AA%B0%E5%AD%90-treap%E6%A0%91%E5%A0%86%E8%AF%A6%E8%A7%A3/"},{"categories":["手写数据结构"],"content":"AVL vs Treap vs 普通BST 测试数据量：1000w 直接来结论： AVL极端情况下(插入的数据有序)，完爆所有平衡树。 Treap随机情况的插入表示不错！大部分时间可以和AVL持平。 BST别想了，这个1000w数据只有随机情况能用几分钟过，如果极端情况直接程序运行出错！ 整体小结： 第一轮：insert操作 随机情况Treap(看运气，毕竟随机事件) \u003e=\u003c AVL\u003e\u003e BST 极端情况AVL \u003e\u003e Treap， BST直接暴毙 第二轮: remove操作–Treap被AVL吊打，BST就别提了 下面就没得继续展开的比较了，总结就是Treap相对好写一点，效率高不高看运气。 还有就是Treap在直接处理第K大的值具有优势，以及按排位查找具有优势。 优势：由于treap每个结点都含有它整个结点个数的记录，所以可以很快的查出值的排名和排名的值。 ","date":"2022-02-16","objectID":"/posts/%E6%9D%A5%E8%87%AA%E4%B8%8A%E5%B8%9D%E7%9A%84%E9%AA%B0%E5%AD%90-treap%E6%A0%91%E5%A0%86%E8%AF%A6%E8%A7%A3/:4:1","tags":["来自上帝的骰子---Treap(树堆)详解"],"title":"来自上帝的骰子---Treap(树堆)详解","uri":"/posts/%E6%9D%A5%E8%87%AA%E4%B8%8A%E5%B8%9D%E7%9A%84%E9%AA%B0%E5%AD%90-treap%E6%A0%91%E5%A0%86%E8%AF%A6%E8%A7%A3/"},{"categories":["算法——二段性相关(二分)"],"content":"leetcode情人节特辑——寻找单身狗","date":"2022-02-14","objectID":"/posts/leetcode%E6%83%85%E4%BA%BA%E8%8A%82%E7%89%B9%E8%BE%91%E5%AF%BB%E6%89%BE%E5%8D%95%E8%BA%AB%E7%8B%97/","tags":["leetcode情人节特辑——寻找单身狗"],"title":"leetcode情人节特辑——寻找单身狗","uri":"/posts/leetcode%E6%83%85%E4%BA%BA%E8%8A%82%E7%89%B9%E8%BE%91%E5%AF%BB%E6%89%BE%E5%8D%95%E8%BA%AB%E7%8B%97/"},{"categories":["算法——二段性相关(二分)"],"content":"题目 题目链接 ","date":"2022-02-14","objectID":"/posts/leetcode%E6%83%85%E4%BA%BA%E8%8A%82%E7%89%B9%E8%BE%91%E5%AF%BB%E6%89%BE%E5%8D%95%E8%BA%AB%E7%8B%97/:1:0","tags":["leetcode情人节特辑——寻找单身狗"],"title":"leetcode情人节特辑——寻找单身狗","uri":"/posts/leetcode%E6%83%85%E4%BA%BA%E8%8A%82%E7%89%B9%E8%BE%91%E5%AF%BB%E6%89%BE%E5%8D%95%E8%BA%AB%E7%8B%97/"},{"categories":["算法——二段性相关(二分)"],"content":"题目详解 这题本应是简单题，就是简单的异或规律，但是题目要求使用 O(logn) 时间复杂度， O(1) 空间复杂度，而如果直接异或，只会是 O(n) 的时间复杂度。 那么该如何去做呢？ 这题有二段性，什么叫二段性呢，就是能有一个分界点把特性一分为二。比如此题由于数据是有序的，所以数量为两个的元素会挨在一起，而且在 单身狗 左边连续的元素下标会有以下规律：两个相邻的相同元素中，第一个元素下标会是偶数，第二个是奇数。右边的连续元素下标会有以下规律：两个相邻的相同元素中，第一个元素下标是奇数，第二个是偶数。 根据以上二段性可很快构建出二分版本的代码！ ","date":"2022-02-14","objectID":"/posts/leetcode%E6%83%85%E4%BA%BA%E8%8A%82%E7%89%B9%E8%BE%91%E5%AF%BB%E6%89%BE%E5%8D%95%E8%BA%AB%E7%8B%97/:2:0","tags":["leetcode情人节特辑——寻找单身狗"],"title":"leetcode情人节特辑——寻找单身狗","uri":"/posts/leetcode%E6%83%85%E4%BA%BA%E8%8A%82%E7%89%B9%E8%BE%91%E5%AF%BB%E6%89%BE%E5%8D%95%E8%BA%AB%E7%8B%97/"},{"categories":["算法——二段性相关(二分)"],"content":"解题代码 未简化二分版本 class Solution { public: int singleNonDuplicate(vector\u003cint\u003e\u0026 nums) { int l=0,r=nums.size()-1; int maxr = r; int mid; while(l\u003cr){ mid = (l+r)/2; if(mid\u003cmaxr\u0026\u0026nums[mid+1]==nums[mid]){ if(mid%2==0){ l = mid+2; }else{ r = mid; } }else if(mid\u003e0\u0026\u0026nums[mid-1]==nums[mid]){ if((mid-1)%2==0){ l = mid+1; }else{ r = mid; } }else{ return nums[mid]; } } return nums[l]; } }; 简化的二分版本 class Solution { public: int singleNonDuplicate(vector\u003cint\u003e\u0026 nums) { int low = 0, high = nums.size() - 1; while (low \u003c high) { int mid = (high - low) / 2 + low; if (nums[mid] == nums[mid ^ 1]) { low = mid + 1; } else { high = mid; } } return nums[low]; } }; ","date":"2022-02-14","objectID":"/posts/leetcode%E6%83%85%E4%BA%BA%E8%8A%82%E7%89%B9%E8%BE%91%E5%AF%BB%E6%89%BE%E5%8D%95%E8%BA%AB%E7%8B%97/:3:0","tags":["leetcode情人节特辑——寻找单身狗"],"title":"leetcode情人节特辑——寻找单身狗","uri":"/posts/leetcode%E6%83%85%E4%BA%BA%E8%8A%82%E7%89%B9%E8%BE%91%E5%AF%BB%E6%89%BE%E5%8D%95%E8%BA%AB%E7%8B%97/"},{"categories":["算法——二段性相关(二分)"],"content":"牛客-wyh的物品——通过验证得出二分的搜索区间","date":"2022-02-14","objectID":"/posts/%E7%89%9B%E5%AE%A2-wyh%E7%9A%84%E7%89%A9%E5%93%81%E9%80%9A%E8%BF%87%E9%AA%8C%E8%AF%81%E5%BE%97%E5%87%BA%E4%BA%8C%E5%88%86%E7%9A%84%E6%90%9C%E7%B4%A2%E5%8C%BA%E9%97%B4/","tags":["牛客-wyh的物品——通过验证得出二分的搜索区间"],"title":"牛客-wyh的物品——通过验证得出二分的搜索区间","uri":"/posts/%E7%89%9B%E5%AE%A2-wyh%E7%9A%84%E7%89%A9%E5%93%81%E9%80%9A%E8%BF%87%E9%AA%8C%E8%AF%81%E5%BE%97%E5%87%BA%E4%BA%8C%E5%88%86%E7%9A%84%E6%90%9C%E7%B4%A2%E5%8C%BA%E9%97%B4/"},{"categories":["算法——二段性相关(二分)"],"content":"题目 题目链接 ","date":"2022-02-14","objectID":"/posts/%E7%89%9B%E5%AE%A2-wyh%E7%9A%84%E7%89%A9%E5%93%81%E9%80%9A%E8%BF%87%E9%AA%8C%E8%AF%81%E5%BE%97%E5%87%BA%E4%BA%8C%E5%88%86%E7%9A%84%E6%90%9C%E7%B4%A2%E5%8C%BA%E9%97%B4/:1:0","tags":["牛客-wyh的物品——通过验证得出二分的搜索区间"],"title":"牛客-wyh的物品——通过验证得出二分的搜索区间","uri":"/posts/%E7%89%9B%E5%AE%A2-wyh%E7%9A%84%E7%89%A9%E5%93%81%E9%80%9A%E8%BF%87%E9%AA%8C%E8%AF%81%E5%BE%97%E5%87%BA%E4%BA%8C%E5%88%86%E7%9A%84%E6%90%9C%E7%B4%A2%E5%8C%BA%E9%97%B4/"},{"categories":["算法——二段性相关(二分)"],"content":"题目详解 以下为手写详解 下面总结这个做题步骤： 二分搜索可能的最大单位价值。 根据这个值得到每个数的单位价值情况s，根据s的值排序，得到前k大的s，相加得出我们枚举的这个最大单位价值是大了还是小了，方便后续二分！ 最后按保留两位小数，输出即可。 ","date":"2022-02-14","objectID":"/posts/%E7%89%9B%E5%AE%A2-wyh%E7%9A%84%E7%89%A9%E5%93%81%E9%80%9A%E8%BF%87%E9%AA%8C%E8%AF%81%E5%BE%97%E5%87%BA%E4%BA%8C%E5%88%86%E7%9A%84%E6%90%9C%E7%B4%A2%E5%8C%BA%E9%97%B4/:2:0","tags":["牛客-wyh的物品——通过验证得出二分的搜索区间"],"title":"牛客-wyh的物品——通过验证得出二分的搜索区间","uri":"/posts/%E7%89%9B%E5%AE%A2-wyh%E7%9A%84%E7%89%A9%E5%93%81%E9%80%9A%E8%BF%87%E9%AA%8C%E8%AF%81%E5%BE%97%E5%87%BA%E4%BA%8C%E5%88%86%E7%9A%84%E6%90%9C%E7%B4%A2%E5%8C%BA%E9%97%B4/"},{"categories":["算法——二段性相关(二分)"],"content":"解题代码 #include\u003cbits/stdc++.h\u003eusing namespace std; const int maxn = 1e5+5; int w[maxn],v[maxn]; double s[maxn]; //TODO 存下用于比对实际单位价值的信息 int n,k; using namespace std; int solve(double mid) { double ss = 0; for(int i = 0;i\u003cn;i++) { s[i] = 1.0*v[i] - w[i]*mid; } sort(s,s+n,greater\u003cdouble\u003e());//TODO 从大到小排序，因为要取前k个最大值 for(int i = 0;i\u003ck;i++) ss += s[i]; //TODO 得到前k个最大的s信息的和， // 如果大于0，则说明取小了，小于0则取大了，等于0则正好满足！ if(ss\u003e0) return 1; else if(ss==0)return -1; else return 0; } int main() { int t; cin\u003e\u003et; while(t--) { scanf(\"%d %d\",\u0026n,\u0026k); double low = 0,high = 100000,mid; for(int i = 0;i\u003cn;i++) { scanf(\"%d %d\",\u0026w[i],\u0026v[i]); } //TODO 二分搜索，由于double类型的二分，故取一个小数形式进行比对 // 注意double类型的二分，千万别+1或者-1！这个跨度太大了，因为我们搜的是个分数！ while(high - low \u003e0.00001) { mid = (low + high)/2.0; int flag = solve(mid); if(flag==1) low = mid;//TODO 收缩左边界 else if(flag == -1)break;//TODO 枚举得到答案 else high = mid;//TODO 收缩右边界 } printf(\"%.2lf\\n\",mid); } return 0; } ","date":"2022-02-14","objectID":"/posts/%E7%89%9B%E5%AE%A2-wyh%E7%9A%84%E7%89%A9%E5%93%81%E9%80%9A%E8%BF%87%E9%AA%8C%E8%AF%81%E5%BE%97%E5%87%BA%E4%BA%8C%E5%88%86%E7%9A%84%E6%90%9C%E7%B4%A2%E5%8C%BA%E9%97%B4/:3:0","tags":["牛客-wyh的物品——通过验证得出二分的搜索区间"],"title":"牛客-wyh的物品——通过验证得出二分的搜索区间","uri":"/posts/%E7%89%9B%E5%AE%A2-wyh%E7%9A%84%E7%89%A9%E5%93%81%E9%80%9A%E8%BF%87%E9%AA%8C%E8%AF%81%E5%BE%97%E5%87%BA%E4%BA%8C%E5%88%86%E7%9A%84%E6%90%9C%E7%B4%A2%E5%8C%BA%E9%97%B4/"},{"categories":["C++实战"],"content":"Hugo博客图形化写作工具","date":"2022-02-12","objectID":"/posts/hugo%E5%8D%9A%E5%AE%A2%E5%9B%BE%E5%BD%A2%E5%8C%96%E5%86%99%E4%BD%9C%E5%B7%A5%E5%85%B7/","tags":["Hugo博客图形化写作工具"],"title":"Hugo博客图形化写作工具","uri":"/posts/hugo%E5%8D%9A%E5%AE%A2%E5%9B%BE%E5%BD%A2%E5%8C%96%E5%86%99%E4%BD%9C%E5%B7%A5%E5%85%B7/"},{"categories":["C++实战"],"content":"软件使用 视频教程 ","date":"2022-02-12","objectID":"/posts/hugo%E5%8D%9A%E5%AE%A2%E5%9B%BE%E5%BD%A2%E5%8C%96%E5%86%99%E4%BD%9C%E5%B7%A5%E5%85%B7/:1:0","tags":["Hugo博客图形化写作工具"],"title":"Hugo博客图形化写作工具","uri":"/posts/hugo%E5%8D%9A%E5%AE%A2%E5%9B%BE%E5%BD%A2%E5%8C%96%E5%86%99%E4%BD%9C%E5%B7%A5%E5%85%B7/"},{"categories":["C++实战"],"content":"项目介绍 项目所在地 温馨提示：如果本地还未搭建 hugo 博客，可以使用我的另一个 hugo 博客自动搭建工具 QtRun： 介绍：一个用纯 C++ 写的命令行工具。 主要作用：根据提供的 hugo 博客本地地址进行命令行式的自动化写作，会把每一篇文章的图片、分类、标题等内容自动化完成。 构建方式：确保生成 exe 文件的目录下含有以下文件，且确保编译器支持 C++17。 BlogPath.txt #提供本地hugo博客路径 categories.txt #提供可供选择的分类(没有也没关系) initImg.txt #提供可选择的图片 mob.txt #提供用于生成的模板 ed_Path.txt #提供打开的编辑器路径(没有也没关系) 使用方式：可查看源码得到更详尽的解答 QtRun [title name] [category name] Qtrun [-op] QtRunBlog： 介绍：使用 Qt+cmake 搭建的图形化 hugo 自动化工具，写作的相关部分都是调用的 QtRun ，所以运行时 QtRun 的配置文件和 QtRun 都必须在它的 exe 目录之下。而其他其他部分调用的 git 命令行，所以需要本地有 git 工具。 主要作用：提供图形化的 hugo 写作体验。 构建方式：本地需要 Qt6 环境，选择本项目目录便可完成构建。 ","date":"2022-02-12","objectID":"/posts/hugo%E5%8D%9A%E5%AE%A2%E5%9B%BE%E5%BD%A2%E5%8C%96%E5%86%99%E4%BD%9C%E5%B7%A5%E5%85%B7/:2:0","tags":["Hugo博客图形化写作工具"],"title":"Hugo博客图形化写作工具","uri":"/posts/hugo%E5%8D%9A%E5%AE%A2%E5%9B%BE%E5%BD%A2%E5%8C%96%E5%86%99%E4%BD%9C%E5%B7%A5%E5%85%B7/"},{"categories":["C++实战"],"content":"QtRun C++ 源代码 实现了自动化命令行写作，QtRunBlog图形化界面调用的就是它的命令行 // // Created by Alone on 2022-1-24. // //TODO aaaaaaa得出感悟：1.数据较为复杂的情况下尽量不要使用全局变量 2.在构造函数初始化的时候千万不要直接new空间给它，记得随时随地nullptr #include \u003cfstream\u003e#include \u003ciostream\u003e#include \u003cstring\u003e#include \u003csys/stat.h\u003e#include \u003cunistd.h\u003e#include \u003cwindows.h\u003e#include \u003cvector\u003e#include \u003cunordered_map\u003e#include \u003cctime\u003e#include \u003cfilesystem\u003e#include \u003crandom\u003e #define IMGS_PATH \"./initImg.txt\" #define MOB_PATH \"./mob.txt\" #define CATEGORIES_PATH \"./categories.txt\" #define BLOG_SRC \"./BlogPath.txt\" std::filesystem::path POSTS_PATH;//用于获取post_path using namespace std; //TODO 建立枚举映射 enum class SHOW_ARGS : int { EMPTY, CATEGORIES, IMG, BLOG_PATH }; //TODO 命令行参数的枚举映射 unordered_map\u003cstring, SHOW_ARGS\u003e MAP{ {\"-sc\", SHOW_ARGS::CATEGORIES}, {\"-si\", SHOW_ARGS::IMG}, {\"-sp\", SHOW_ARGS::BLOG_PATH} }; //TODO 封装文件读取类 class FileReader { stringstream in_buf; ifstream reader; public: FileReader() = default; FileReader(const FileReader \u0026) = delete; FileReader(FileReader \u0026\u0026) = delete; ~FileReader() { if (reader.is_open()) reader.close(); } void open(const string \u0026path) { reader.open(path); if (!reader.is_open()) { perror(\"reader open failed\"); exit(1); } in_buf \u003c\u003c reader.rdbuf(); } bool readAll(string \u0026dst) { if (in_buf.good()) dst = in_buf.str(); else return false; return true; } bool readline(string \u0026dst) { if (in_buf.good()) getline(in_buf, dst); else return false; return true; } }; //TODO 封装文件写入类 class FileWriter { char *out_buf; ofstream writer; size_t cur_buf_size; size_t max_buf_size; private: void _write() { //缓冲区写满，写入文件中 writer.write(out_buf, max_buf_size); cur_buf_size = 0; } public: FileWriter() : cur_buf_size(0), max_buf_size(512), out_buf(nullptr) {}; FileWriter(const FileReader \u0026) = delete; FileWriter(FileReader \u0026\u0026) = delete; FileWriter(const string \u0026path, ios::openmode mode = ios::out) { writer.open(path, mode); if (!writer.is_open()) { perror(\"writer open failed\"); exit(1); } cur_buf_size = 0; max_buf_size = 512; out_buf = new char[max_buf_size + 5]; } ~FileWriter() { if (cur_buf_size \u003e 0) { writer.write(out_buf, cur_buf_size); cur_buf_size = 0; } delete[] out_buf; out_buf = nullptr; writer.flush(); writer.close(); } static bool exist(const string \u0026path) { return (access(path.c_str(), F_OK) != -1); } void open(const string \u0026path, ios::openmode mode = ios::out) { writer.open(path, mode); if (!writer.is_open()) { perror(\"writer open failed\"); exit(1); } out_buf = new char[max_buf_size + 5]; } void write(const string \u0026src) {//TODO 缓冲机制的重要组成 if (writer.is_open()) {//只有在open文件后才能写入 if (src.empty()) return; if (cur_buf_size == max_buf_size) _write(); size_t psize = src.size() + cur_buf_size;//如果全盘写入缓冲区后，缓冲区需要的大小 int startp = 0, maxLen; while (psize \u003e max_buf_size) { //当这次写入缓冲区的数据量大于缓冲区的大小，则进行不断写满更新操作 maxLen = max_buf_size - cur_buf_size; copy(src.begin() + startp, src.begin() + startp + maxLen, out_buf + cur_buf_size);//copy到满状态，再来一次write _write(); startp += maxLen; psize -= max_buf_size; } //如果写入数据不超出缓冲区大小，则直接写入 copy(src.begin() + startp, src.end(), out_buf + cur_buf_size); cur_buf_size += src.size() - startp; } } FileWriter \u0026append(const string \u0026src) {//TODO 和write没区别，只是支持链式调用 write(src); return *this; } }; //TODO 整个项目需要操作的变量（很不推荐用全局变量，我就是因为这玩意就导致了bug） FileReader readImg, readText, readCategories;//用于文件io的变量 FileWriter appendCategories, fileWriter; vector\u003cstring\u003e imgs, categories; //用于存下磁盘到内存的数据，根据名字判断存的啥 time_t now = time(NULL); //TODO 打开typora软件 void open_exe_from_path(const char *path) { WinExec(path, SW_SHOWNORMAL); cout \u003c\u003c \"open your custom editor successfully!\" \u003c\u003c endl; } //TODO 打印内容 void show(vector\u003cstring\u003e \u0026src) { for (int i = 0; i \u003c src.size(); i++) { if (!src[i].empty()) printf(\"%d: %s\\n\", i, src[i].c_str()); } } //TODO 替换string的内容 void to_replace(string \u0026s, const string \u0026target, const string \u0026replacement) { int i = 0; int find_ret; int tar_len = target.size(); while ((find_ret = s.find(target, i)) != -1) { s.replace(find_ret, tar_len, replacement); i = find_ret; } } //TODO 打印出错的信息，并退出程序 void exit_print(","date":"2022-02-12","objectID":"/posts/hugo%E5%8D%9A%E5%AE%A2%E5%9B%BE%E5%BD%A2%E5%8C%96%E5%86%99%E4%BD%9C%E5%B7%A5%E5%85%B7/:3:0","tags":["Hugo博客图形化写作工具"],"title":"Hugo博客图形化写作工具","uri":"/posts/hugo%E5%8D%9A%E5%AE%A2%E5%9B%BE%E5%BD%A2%E5%8C%96%E5%86%99%E4%BD%9C%E5%B7%A5%E5%85%B7/"},{"categories":["算法——搜索类问题"],"content":"leetcode每日一题——1020飞地的数量","date":"2022-02-12","objectID":"/posts/leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%981020%E9%A3%9E%E5%9C%B0%E7%9A%84%E6%95%B0%E9%87%8F/","tags":["leetcode每日一题——1020飞地的数量"],"title":"并查集/dfs解决——leetcode每日一题——1020飞地的数量","uri":"/posts/leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%981020%E9%A3%9E%E5%9C%B0%E7%9A%84%E6%95%B0%E9%87%8F/"},{"categories":["算法——搜索类问题"],"content":"题目描述 题目链接 ","date":"2022-02-12","objectID":"/posts/leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%981020%E9%A3%9E%E5%9C%B0%E7%9A%84%E6%95%B0%E9%87%8F/:1:0","tags":["leetcode每日一题——1020飞地的数量"],"title":"并查集/dfs解决——leetcode每日一题——1020飞地的数量","uri":"/posts/leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%981020%E9%A3%9E%E5%9C%B0%E7%9A%84%E6%95%B0%E9%87%8F/"},{"categories":["算法——搜索类问题"],"content":"题目解析 一、以边界值为对象进行搜索解决 一开始很快就想到用比较暴力的直接dfs深搜，然后就超时了。 注意此题由于以 1 是否能延申到整个边界以外来判断是否为有效的 1 所以我们需要取巧，应该以所有边界的 1 为对象先把所有能超出的 1 搜出来，然后剩余的 1 就是答案了。 二、并查集合并+是否接壤边界属性更新 创建一个并查集，用一维数组存下所有二维数组的元素，同时再增加一个一维数组用于判断是否边界接壤，每次 merge 操作的时候判断需要同时执行合并操作和是否接壤的更新。 先利用并查集 merge 所有的 1，然后再挨个判断是否接壤即可。 ","date":"2022-02-12","objectID":"/posts/leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%981020%E9%A3%9E%E5%9C%B0%E7%9A%84%E6%95%B0%E9%87%8F/:2:0","tags":["leetcode每日一题——1020飞地的数量"],"title":"并查集/dfs解决——leetcode每日一题——1020飞地的数量","uri":"/posts/leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%981020%E9%A3%9E%E5%9C%B0%E7%9A%84%E6%95%B0%E9%87%8F/"},{"categories":["算法——搜索类问题"],"content":"解题代码 dfs方法： class Solution { public: vector\u003cvector\u003cint\u003e\u003e dirs = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}}; int numEnclaves(vector\u003cvector\u003cint\u003e\u003e\u0026 grid) { this-\u003em = grid.size(); this-\u003en = grid[0].size(); this-\u003evisited = vector\u003cvector\u003cbool\u003e\u003e(m, vector\u003cbool\u003e(n, false)); for (int i = 0; i \u003c m; i++) { dfs(grid, i, 0); dfs(grid, i, n - 1); } for (int j = 1; j \u003c n - 1; j++) { dfs(grid, 0, j); dfs(grid, m - 1, j); } int enclaves = 0; for (int i = 1; i \u003c m - 1; i++) { for (int j = 1; j \u003c n - 1; j++) { if (grid[i][j] == 1 \u0026\u0026 !visited[i][j]) { enclaves++; } } } return enclaves; } void dfs(const vector\u003cvector\u003cint\u003e\u003e \u0026 grid, int row, int col) { if (row \u003c 0 || row \u003e= m || col \u003c 0 || col \u003e= n || grid[row][col] == 0 || visited[row][col]) { return; } visited[row][col] = true; for (auto \u0026 dir : dirs) { dfs(grid, row + dir[0], col + dir[1]); } } private: int m, n; vector\u003cvector\u003cbool\u003e\u003e visited; }; 并查集方法： //这个并查集写的好 class UnionFind { public: UnionFind(const vector\u003cvector\u003cint\u003e\u003e \u0026 grid) { int m = grid.size(), n = grid[0].size(); this-\u003eparent = vector\u003cint\u003e(m * n); //存储并查集的联通关系 this-\u003eonEdge = vector\u003cbool\u003e(m * n, false);//查找是否有在边界元素的关键所在 this-\u003erank = vector\u003cint\u003e(m * n); for (int i = 0; i \u003c m; i++) { //根据传过来的二维数组更新并查集，同时更新onEdge边界元素为true for (int j = 0; j \u003c n; j++) { if (grid[i][j] == 1) { int index = i * n + j; parent[index] = index; if (i == 0 || i == m - 1 || j == 0 || j == n - 1) { onEdge[index] = true; } } } } } int find(int i) { if (parent[i] != i) { parent[i] = find(parent[i]); } return parent[i]; } void uni(int x, int y) { int rootx = find(x); int rooty = find(y); if (rootx != rooty) { if (rank[rootx] \u003e rank[rooty]) {//这里时按秩优化处理 parent[rooty] = rootx; onEdge[rootx] = onEdge[rootx] | onEdge[rooty];//每次合并元素的时候同时把这一堆是否与边界接壤的关系更新 } else if (rank[rootx] \u003c rank[rooty]) { parent[rootx] = rooty; onEdge[rooty] = onEdge[rooty] | onEdge[rootx]; } else { parent[rooty] = rootx; onEdge[rootx] = onEdge[rootx] | onEdge[rooty]; rank[rootx]++; } } } bool isOnEdge(int i) { return onEdge[find(i)]; } private: vector\u003cint\u003e parent; //并查集的必备 vector\u003cbool\u003e onEdge; //判断是否接壤边界 vector\u003cint\u003e rank; //按秩 }; class Solution { public: int numEnclaves(vector\u003cvector\u003cint\u003e\u003e\u0026 grid) { int m = grid.size(), n = grid[0].size(); UnionFind uf(grid); //先把所有的1连接起来，然后再判断是否接壤边界即可 //由于循环是从上往下，从左往右，故左和上方向不需要考虑 for (int i = 0; i \u003c m; i++) { for (int j = 0; j \u003c n; j++) { if (grid[i][j] == 1) { int index = i * n + j; if (j + 1 \u003c n \u0026\u0026 grid[i][j + 1] == 1) { uf.uni(index, index + 1); } if (i + 1 \u003c m \u0026\u0026 grid[i + 1][j] == 1) { uf.uni(index, index + n); } } } } //判断这个1是否和边界接壤 int enclaves = 0; for (int i = 1; i \u003c m - 1; i++) { for (int j = 1; j \u003c n - 1; j++) { if (grid[i][j] == 1 \u0026\u0026 !uf.isOnEdge(i * n + j)) { enclaves++; } } } return enclaves; } }; ","date":"2022-02-12","objectID":"/posts/leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%981020%E9%A3%9E%E5%9C%B0%E7%9A%84%E6%95%B0%E9%87%8F/:3:0","tags":["leetcode每日一题——1020飞地的数量"],"title":"并查集/dfs解决——leetcode每日一题——1020飞地的数量","uri":"/posts/leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%981020%E9%A3%9E%E5%9C%B0%E7%9A%84%E6%95%B0%E9%87%8F/"},{"categories":["C++实战"],"content":"自动化搭建博客工具","date":"2022-02-12","objectID":"/posts/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E5%B7%A5%E5%85%B7/","tags":["自动化搭建博客工具"],"title":"自动化搭建博客工具","uri":"/posts/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E5%B7%A5%E5%85%B7/"},{"categories":["C++实战"],"content":"软件使用 使用前请下载好git工具 视频教程 ","date":"2022-02-12","objectID":"/posts/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E5%B7%A5%E5%85%B7/:1:0","tags":["自动化搭建博客工具"],"title":"自动化搭建博客工具","uri":"/posts/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E5%B7%A5%E5%85%B7/"},{"categories":["C++实战"],"content":"项目介绍 项目所在地 温馨提示：本地搭建完网站框架后，每次新建文章的写作体验较差，可以看看我的另一个 hugo 博客自动化写作工具 src目录：存放图形化项目的源代码，使用 Qt6 可直接启动 QHugoInit 项目。 bin目录：存放项目的可执行二进制文件。 exec_code.bat：用于写入代码执行脚本 hugo.exe：构建博客的基石 QHugoInit.exe：软件启动程序 log.txt：整个程序执行的日志 ","date":"2022-02-12","objectID":"/posts/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E5%B7%A5%E5%85%B7/:2:0","tags":["自动化搭建博客工具"],"title":"自动化搭建博客工具","uri":"/posts/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E5%B7%A5%E5%85%B7/"},{"categories":["C++实战"],"content":"项目关键源码 通过多线程防止下载步骤把画面给阻塞 //TODO 简单封装一个用于多线程通信的类 class run_thread:public QThread{ public: run_thread() = delete; run_thread(const std::function\u003cvoid()\u003e\u0026Runnable,QObject* parent = nullptr):m_task(nullptr){ m_task = Runnable; } void run()override{ if(m_task!=nullptr); m_task(); } private: std::function\u003cvoid()\u003em_task; }; 通过文件io控制命令行的代码执行来执行对应的每一步 void MainWindow::on_right_Btn_clicked() { auto path = ui-\u003einput-\u003etext(); if(!QDir(path).exists()||path.isEmpty()){ QMessageBox::warning(nullptr,\"提示\",\"文件夹路径不存在\"); return; } ui-\u003ew2-\u003esetVisible(false); ui-\u003ew4-\u003esetVisible(false); ui-\u003ew3-\u003esetVisible(true); ui-\u003el1-\u003esetText(\"一切即将准备就绪\"); ui-\u003el2-\u003esetText(\"正在初始化您的hugo网站\"); ui-\u003el3-\u003esetOpenExternalLinks(true); ui-\u003el3-\u003esetText(R\"(\u003chtml\u003e \u003cstyle\u003e a { color:#3281b8; } \u003c/style\u003e\u003chead/\u003e\u003cbody\u003e\u003cp\u003e这可能会耗费几分钟，请不要强制关闭应用程序\u003cbr/\u003e\u003cbr/\u003e闲得无聊？\u003ca href=\"https://github.com/ACking-you/AutoHugoSetup\"\u003e给个star\u003c/a\u003e\u003c/p\u003e\u003c/body\u003e\u003c/html\u003e)\"); QProcess qp; std::ofstream writer; m_Path = path; auto std_str = m_Path.toStdString(); //first step writer.open(\"./exec_code.bat\"); if(!writer.is_open()){ QMessageBox::warning(nullptr,\"提示\",\"第一次写入文件打开失败\"); writer.close(); QCoreApplication::exit(1); } ui-\u003einfo_text-\u003esetText(\"正在初始化 hugo 博客\"); std::replace(std_str.begin(),std_str.end(),'/','\\\\'); //这里注意：cmd32命令只支持反斜杠！ writer\u003c\u003cR\"(chcp 65001)\"\u003c\u003c'\\n'; //设置编码为utf-8 writer\u003c\u003cR\"(copy .\\hugo.exe )\"\u003c\u003cstd_str\u003c\u003c'\\n'; //copy一份hugo.exe到目标目录下 writer\u003c\u003c\"cd /d\"\u003c\u003cstd_str\u003c\u003c'\\n'; //切换到创建目录，这里/d代表直接一步到位的切换目录 writer\u003c\u003cR\"(.\\hugo new site myBlog)\"\u003c\u003c'\\n'; //初始化hugo命令 writer.close(); qp.startCommand(R\"(.\\exec_code.bat)\"); if(qp.waitForFinished()){ QString str = qp.readAll(); m_logWriter\u003c\u003c\"-----1st step-----\\n\\r\"\u003c\u003cstr.toStdString()\u003c\u003c'\\n'; ui-\u003einfo_text-\u003esetText(\" hugo 博客初始化完成\"); } //second step：执行此步之前先判断git是否可用，此步执行时间最久，不要让它卡死主线程，故需要用到多线程技术 qp.startCommand(\"git\"); if(!qp.waitForFinished()){ QMessageBox::warning(nullptr,\"提示\",\"未安装git工具或未设置到环境变量\"); QCoreApplication::exit(1); } writer.open(\"./exec_code.bat\"); if(!writer.is_open()){ QMessageBox::warning(nullptr,\"提示\",\"第二次写入文件打开失败\"); writer.close(); QCoreApplication::exit(1); } ui-\u003einfo_text-\u003esetText(\"正在下载 FeelIt 主题\"); std::filesystem::path blog_path = std_str; blog_path /= \"myBlog\"; m_Path = blog_path.string().c_str(); writer\u003c\u003c\"cd /d\"\u003c\u003cblog_path\u003c\u003c\"\\\\themes\"\u003c\u003c'\\n'; //cd到themes文件夹目录下 writer\u003c\u003c\"git clone https://gitee.com/acking-you/FeelIt.git\"\u003c\u003c'\\n';//开始通过git下载主题包 writer.close(); QThread* sub_thread = new run_thread([\u0026]{ //最耗时间的工作别去干扰主线程的正常运行，否则主线程可能看起来会陷入瘫痪 QProcess tqp; //信号槽机制，主线程等待子线程完成任务发送信号后再执行最后的步骤，因为这个过程肯定是要同步进行，故需要信号槽来等待 connect(\u0026tqp,\u0026QProcess::finished,[\u0026](int exitCode, QProcess::ExitStatus exitStatus){ //step third std::ofstream writer; QProcess qp; writer.open(\"./exec_code.bat\"); if(!writer.is_open()){ QMessageBox::warning(nullptr,\"提示\",\"第三次写入文件打开失败\"); writer.close(); QCoreApplication::exit(1); } ui-\u003einfo_text-\u003esetText(\"配置本地主题中...\"); writer\u003c\u003c\"cd /d\"\u003c\u003cm_Path.toStdString()\u003c\u003c'\\n'; //cd到blog_path writer\u003c\u003cR\"(del .\\config.toml)\"\u003c\u003c'\\n'; //删除原本的config文件 writer\u003c\u003cR\"(move .\\themes\\FeelIt\\config.toml .\\)\"\u003c\u003c'\\n'; //将我的配置文件放到顶级目录去 writer\u003c\u003cR\"(move .\\themes\\FeelIt\\exampleSite\\static\\* .\\static\\)\"\u003c\u003c'\\n';//移动static图片资源 writer\u003c\u003cR\"(move ..\\hugo.exe .\\)\"\u003c\u003c'\\n';//将之前的hugo.exe移动到真正的博客目录下 writer\u003c\u003cR\"(mkdir .\\content\\posts)\"\u003c\u003c'\\n'; //创建用于写文章的目录 writer.close(); qp.startCommand(R\"(.\\exec_code.bat)\"); if(qp.waitForFinished(120000)){ ui-\u003einfo_text-\u003esetText(\"配置完成 \"); ending(); m_logWriter\u003c\u003c\"-----3rd step-----\\n\\r\"\u003c\u003cqp.readAll().toStdString(); } }); tqp.startCommand(R\"(.\\exec_code.bat)\"); if(!tqp.waitForFinished(120000)){ QMessageBox::warning(nullptr,\"提示\",\"下载主题响应超时\"); QCoreApplication::exit(1); }else{ m_logWriter\u003c\u003c\"-----2nd step-----\\n\\r\"\u003c\u003ctqp.readAll().toStdString(); } }); sub_thread-\u003estart(); } ","date":"2022-02-12","objectID":"/posts/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E5%B7%A5%E5%85%B7/:3:0","tags":["自动化搭建博客工具"],"title":"自动化搭建博客工具","uri":"/posts/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E5%B7%A5%E5%85%B7/"},{"categories":["JavaWeb笔记"],"content":"数据库基础","date":"2022-02-09","objectID":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/","tags":["数据库基础"],"title":"数据库基础","uri":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/"},{"categories":["JavaWeb笔记"],"content":"数据库基础 数据库是学习JavaWeb的一个前置，只有了解了数据库的操作和使用，我们才能更好地组织和管理网站应用产生的数据。 ","date":"2022-02-09","objectID":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/:0:0","tags":["数据库基础"],"title":"数据库基础","uri":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/"},{"categories":["JavaWeb笔记"],"content":"什么是数据库 数据库是数据管理的有效技术，是由一批数据构成的有序集合，这些数据被存放在结构化的数据表里。数据表之间相互关联，反映客观事物间的本质联系。数据库能有效地帮助一个组织或企业科学地管理各类信息资源。简而言之，我们的数据可以交给数据库来帮助我们进行管理，同时数据库能够为我们提供高效的访问性能。 在JavaSE学习阶段中，我们学习了如何使用文件I/O来将数据保存到本地，这样就可以将一个数据持久地存储在本地，即使程序重新打开，我们也能加载回上一次的数据，但是当我们的数据变得非常多的时候，这样的方式就显得不太方便了。同时我们如果需要查找众多数据的中的某一个，就只能加载到内存再进行查找，这样显然是很难受的！ 而数据库就是专门做这事的，我们可以快速查找想要的数据，便捷地插入、修改和删除数据，并且数据库不仅能做这些事，还能提供更多便于管理数据和操作数据的功能！ ","date":"2022-02-09","objectID":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/:1:0","tags":["数据库基础"],"title":"数据库基础","uri":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/"},{"categories":["JavaWeb笔记"],"content":"常见的数据库 常见的数据库有很多种，包括但不限于： MySQL - 免费，用的最多的，开源数据库，适用于中小型 Microsoft SQL Server - 收钱的，但是提供技术支持，适用于Windows Server Oracle - 收钱的，大型数据库系统 而我们要学习的是MySQL数据，其实无论学习哪种数据库，SQL语句大部分都是通用的，只有少许语法是不通用的，因此我们只需要学习一种数据库其他的也就差不多都会了。 ","date":"2022-02-09","objectID":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/:1:1","tags":["数据库基础"],"title":"数据库基础","uri":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/"},{"categories":["JavaWeb笔记"],"content":"数据模型 数据模型与现实世界中的模型一样，是对现实世界数据特征的一种抽象。实际上，我们之前学习的类就是对现实世界数据的一种抽象，比如一个学生的特征包括姓名，年龄，年级，学号，专业等，这些特征也称为实体的一种属性，属性具有以下特点： 属性不可再分 一个实体的属性可以有很多个 用于唯一区分不同实体的的属性，称为Key，比如每个同学的学号都是不一样的 属性取值可以有一定的约束，比如性别只能是男或是女 实体或是属性之间可以具有一定的联系，比如一个老师可以教很多个学生，而学生相对于老师就是被教授的关系；又比如每个同学都有一个学号与其唯一对应，因此学号和学生之间也有一种联系。而像一个老师教多个学生的联系就是一种一对多的联系（1:n），而学号唯一对应，就是一种一对一的联系（1:1）；每一个老师不仅可以教多个学生，每一个学生也可以有多个教师，这就是一种多对多的联系（n:m） MySQL就是一种关系型数据库，通过使用关系型数据库，我们就可以很好地存储这样带有一定联系的数据。 通过构建一个ER图，我们就能很好地理清不同数据模型之间的关系和特点。 ","date":"2022-02-09","objectID":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/:1:2","tags":["数据库基础"],"title":"数据库基础","uri":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/"},{"categories":["JavaWeb笔记"],"content":"数据库的创建 既然了解了属性和联系，那么我们就来尝试创建一个数据库，并在数据库中添加用于存放数据的表，每一张表都代表一种实体的数据。首先我们要明确，我们需要创建什么样子的表： 学生表：用于存放所有学生的数据，学生（学号，姓名，性别） 教师表：用于存放所有教师的数据，教师（教师号，姓名） 授课表：用于存放教师与学生的授课信息，授课（学号，教师号） 其中，标注下划线的属性，作为Key，用于区别于其他实体数据的唯一标记。 为了理解起来更加轻松，我们从图形界面操作再讲到SQL语句，请不要着急。我们现在通过Navicat或idea自带的数据库客户端来创建一个数据库和上述三个表。 ","date":"2022-02-09","objectID":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/:2:0","tags":["数据库基础"],"title":"数据库基础","uri":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/"},{"categories":["JavaWeb笔记"],"content":"数据库的规范化 要去设计存放一个实体的表，我们就需要了解数据库的关系规范化，尽可能减少“不好”的关系存在，如何设计一个优良的关系模型是最关键的内容！简而言之，我们要学习一下每一个表该如何去设计。 ","date":"2022-02-09","objectID":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/:3:0","tags":["数据库基础"],"title":"数据库基础","uri":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/"},{"categories":["JavaWeb笔记"],"content":"第一范式（1NF） 第一范式是指数据库的每一列都是不可分割的基本数据项，而下面这样的就存在可分割的情况： 学生（姓名，电话号码） 电话号码实际上包括了家用座机电话和移动电话，因此它可以被拆分为： 学生（姓名，座机号码，手机号码） 满足第一范式是关系型数据库最基本的要求！ ","date":"2022-02-09","objectID":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/:3:1","tags":["数据库基础"],"title":"数据库基础","uri":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/"},{"categories":["JavaWeb笔记"],"content":"第二范式（2NF） 第二范式要求表中必须存在主键，且其他的属性必须完全依赖于主键，比如： 学生（学号，姓名，性别） 学号是每个学生的唯一标识，每个学生都有着不同的学号，因此此表中存在一个主键，并且每个学生的所有属性都依赖于学号，学号发生改变就代表学生发生改变，姓名和性别都会因此发生改变，所有此表满足第二范式。 ","date":"2022-02-09","objectID":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/:3:2","tags":["数据库基础"],"title":"数据库基础","uri":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/"},{"categories":["JavaWeb笔记"],"content":"第三范式（3NF） 在满足第二范式的情况下，所有的属性都不传递依赖于主键，满足第三范式。 学生借书情况（借阅编号，学生学号，书籍编号，书籍名称，书籍作者） 实际上书籍编号依赖于借阅编号，而书籍名称和书籍作者依赖于书籍编号，因此存在传递依赖的情况，我们可以将书籍信息进行单独拆分为另一张表： 学生借书情况（借阅编号，学生学号，书籍编号） 书籍（书籍编号，书籍名称，书籍作者） 这样就消除了传递依赖，从而满足第三范式。 ","date":"2022-02-09","objectID":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/:3:3","tags":["数据库基础"],"title":"数据库基础","uri":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/"},{"categories":["JavaWeb笔记"],"content":"BCNF BCNF作为第三范式的补充，假设仓库管理关系表为StorehouseManage(仓库ID, 存储物品ID, 管理员ID, 数量)，且有一个管理员只在一个仓库工作；一个仓库可以存储多种物品。这个数据库表中存在如下决定关系： (仓库ID, 存储物品ID) →(管理员ID, 数量) (管理员ID, 存储物品ID) → (仓库ID, 数量) 所以，(仓库ID, 存储物品ID)和(管理员ID, 存储物品ID)都是StorehouseManage的候选关键字，表中的唯一非关键字段为数量，它是符合第三范式的。但是，由于存在如下决定关系： (仓库ID) → (管理员ID) (管理员ID) → (仓库ID) 即存在关键字段决定关键字段的情况，如果修改管理员ID，那么就必须逐一进行修改，所以其不符合BCNF范式。 ","date":"2022-02-09","objectID":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/:3:4","tags":["数据库基础"],"title":"数据库基础","uri":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/"},{"categories":["JavaWeb笔记"],"content":"认识SQL语句 结构化查询语言（Structured Query Language）简称SQL，这是一种特殊的语言，它专门用于数据库的操作。每一种数据库都支持SQL，但是他们之间会存在一些细微的差异，因此不同的数据库都存在自己的“方言”。 SQL语句不区分大小写（关键字推荐使用大写），它支持多行，并且需要使用;进行结尾！ SQL也支持注释，通过使用--或是#来编写注释内容，也可以使用/*来进行多行注释。 我们要学习的就是以下四种类型的SQL语言： 数据查询语言（Data Query Language, DQL）基本结构是由SELECT子句，FROM子句，WHERE子句组成的查询块。 数据操纵语言（Data Manipulation Language, DML）是SQL语言中，负责对数据库对象运行数据访问工作的指令集，以INSERT、UPDATE、DELETE三种指令为核心，分别代表插入、更新与删除，是开发以数据为中心的应用程序必定会使用到的指令。 数据库定义语言DDL(Data Definition Language)，是用于描述数据库中要存储的现实世界实体的语言。 DCL（Data Control Language）是数据库控制语言。是用来设置或更改数据库用户或角色权限的语句，包括（grant,deny,revoke等）语句。在默认状态下，只有sysadmin,dbcreator,db_owner或db_securityadmin等人员才有权力执行DCL。 我们平时所说的CRUD其实就是增删改查（Create/Retrieve/Update/Delete） ","date":"2022-02-09","objectID":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/:4:0","tags":["数据库基础"],"title":"数据库基础","uri":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/"},{"categories":["JavaWeb笔记"],"content":"数据库定义语言（DDL） ","date":"2022-02-09","objectID":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/:5:0","tags":["数据库基础"],"title":"数据库基础","uri":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/"},{"categories":["JavaWeb笔记"],"content":"数据库操作 我们可以通过create database来创建一个数据库： createdatabase数据库名为了能够支持中文，我们在创建时可以设定编码格式： CREATEDATABASEIFNOTEXISTS数据库名DEFAULTCHARSETutf8COLLATEutf8_general_ci;如果我们创建错误了，我们可以将此数据库删除，通过使用drop database来删除一个数据库： dropdatabase数据库名","date":"2022-02-09","objectID":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/:5:1","tags":["数据库基础"],"title":"数据库基础","uri":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/"},{"categories":["JavaWeb笔记"],"content":"创建表 数据库创建完成后，我们一般通过create table语句来创建一张表： createtable表名(列名数据类型[列级约束条件],列名数据类型[列级约束条件],...[,表级约束条件])","date":"2022-02-09","objectID":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/:5:2","tags":["数据库基础"],"title":"数据库基础","uri":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/"},{"categories":["JavaWeb笔记"],"content":"SQL数据类型 以下的数据类型用于字符串存储： char(n)可以存储任意字符串，但是是固定长度为n，如果插入的长度小于定义长度时，则用空格填充。 varchar(n)也可以存储任意数量字符串，长度不固定，但不能超过n，不会用空格填充。 以下数据类型用于存储数字： smallint用于存储小的整数，范围在 (-32768，32767) int用于存储一般的整数，范围在 (-2147483648，2147483647) bigint用于存储大型整数，范围在 (-9,223,372,036,854,775,808，9,223,372,036,854,775,807) float用于存储单精度小数 double用于存储双精度的小数 以下数据类型用于存储时间： date存储日期 time存储时间 year存储年份 datetime用于混合存储日期+时间 ","date":"2022-02-09","objectID":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/:5:3","tags":["数据库基础"],"title":"数据库基础","uri":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/"},{"categories":["JavaWeb笔记"],"content":"列级约束条件 列级约束有六种：主键Primary key、外键foreign key 、唯一 unique、检查 check （MySQL不支持）、默认default 、非空/空值 not null/ null ","date":"2022-02-09","objectID":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/:5:4","tags":["数据库基础"],"title":"数据库基础","uri":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/"},{"categories":["JavaWeb笔记"],"content":"表级约束条件 表级约束有四种：主键、外键、唯一、检查 现在我们通过SQL语句来创建我们之前提到的三张表。 [CONSTRAINT\u003c外键名\u003e]FOREIGNKEY字段名[，字段名2，…]REFERENCES\u003c主表名\u003e主键列1[，主键列2，…]","date":"2022-02-09","objectID":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/:5:5","tags":["数据库基础"],"title":"数据库基础","uri":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/"},{"categories":["JavaWeb笔记"],"content":"修改表 如果我们想修改表结构，我们可以通过alter table来进行修改： ALTERTABLE表名[ADD新列名数据类型[列级约束条件]][DROPCOLUMN列名[restrict|cascade]][ALTERCOLUMN列名新数据类型]我们可以通过ADD来添加一个新的列，通过DROP来删除一个列，不过我们可以添加restrict或cascade，默认是restrict，表示如果此列作为其他表的约束或视图引用到此列时，将无法删除，而cascade会强制连带引用此列的约束、视图一起删除。还可以通过ALTER来修改此列的属性。 ","date":"2022-02-09","objectID":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/:5:6","tags":["数据库基础"],"title":"数据库基础","uri":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/"},{"categories":["JavaWeb笔记"],"content":"删除表 我们可以通过drop table来删除一个表： DROPTABLE表名[restrict|cascade]其中restrict和cascade上面的效果一致。 ","date":"2022-02-09","objectID":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/:5:7","tags":["数据库基础"],"title":"数据库基础","uri":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/"},{"categories":["JavaWeb笔记"],"content":"数据库操纵语言（DML） 前面我们已经学习了如何使用SQL语句来创建、修改、删除数据库以及表，而如何向数据库中插入、删除、更新数据，将是本版块讨论的重点。 ","date":"2022-02-09","objectID":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/:6:0","tags":["数据库基础"],"title":"数据库基础","uri":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/"},{"categories":["JavaWeb笔记"],"content":"插入数据 通过使用insert into语句来向数据库中插入一条数据（一条记录）： INSERTINTO表名VALUES(值1,值2,值3)如果插入的数据与列一一对应，那么可以省略列名，但是如果希望向指定列上插入数据，就需要给出列名： INSERTINTO表名(列名1,列名2)VALUES(值1,值2)我们也可以一次性向数据库中插入多条数据： INSERTINTO表名(列名1,列名2)VALUES(值1,值2),(值1,值2),(值1,值2)我们来试试看向我们刚刚创建的表中添加三条数据。 ","date":"2022-02-09","objectID":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/:6:1","tags":["数据库基础"],"title":"数据库基础","uri":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/"},{"categories":["JavaWeb笔记"],"content":"修改数据 我们可以通过update语句来更新表中的数据： UPDATE表名SET列名=值,...WHERE条件注意，SQL语句中的等于判断是= **警告：**如果忘记添加WHERE字句来限定条件，将使得整个表中此列的所有数据都被修改！ ","date":"2022-02-09","objectID":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/:6:2","tags":["数据库基础"],"title":"数据库基础","uri":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/"},{"categories":["JavaWeb笔记"],"content":"删除数据 我们可以通过使用delete来删除表中的数据： DELETEFROM表名通过这种方式，将删除表中全部数据，我们也可以使用where来添加条件，只删除指定的数据： DELETEFROM表名WHERE条件 ","date":"2022-02-09","objectID":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/:6:3","tags":["数据库基础"],"title":"数据库基础","uri":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/"},{"categories":["JavaWeb笔记"],"content":"数据库查询语言（DQL） 数据库的查询是我们整个数据库学习中的重点内容，面对数据库中庞大的数据，该如何去寻找我们想要的数据，就是我们主要讨论的问题。 ","date":"2022-02-09","objectID":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/:7:0","tags":["数据库基础"],"title":"数据库基础","uri":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/"},{"categories":["JavaWeb笔记"],"content":"单表查询 单表查询是最简单的一种查询，我们只需要在一张表中去查找数据即可，通过使用select语句来进行单表查询： -- 指定查询某一列数据 SELECT列名[,列名]FROM表名-- 会以别名显示此列 SELECT列名别名FROM表名-- 查询所有的列数据 SELECT*FROM表名-- 只查询不重复的值 SELECTDISTINCT列名FROM表名我们也可以添加where字句来限定查询目标： SELECT*FROM表名WHERE条件","date":"2022-02-09","objectID":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/:7:1","tags":["数据库基础"],"title":"数据库基础","uri":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/"},{"categories":["JavaWeb笔记"],"content":"常用查询条件 一般的比较运算符，包括=、\u003e、\u003c、\u003e=、\u003c=、!=等。 是否在集合中：in、not in 字符模糊匹配：like，not like 多重条件连接查询：and、or、not 我们来尝试使用一下上面这几种条件。 ","date":"2022-02-09","objectID":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/:7:2","tags":["数据库基础"],"title":"数据库基础","uri":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/"},{"categories":["JavaWeb笔记"],"content":"排序查询 我们可以通过order by来将查询结果进行排序： SELECT*FROM表名WHERE条件ORDERBY列名ASC|DESC使用ASC表示升序排序，使用DESC表示降序排序，默认为升序。 我们也可以可以同时添加多个排序： SELECT*FROM表名WHERE条件ORDERBY列名1ASC|DESC,列名2ASC|DESC这样会先按照列名1进行排序，每组列名1相同的数据再按照列名2排序。 ","date":"2022-02-09","objectID":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/:7:3","tags":["数据库基础"],"title":"数据库基础","uri":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/"},{"categories":["JavaWeb笔记"],"content":"聚集函数 聚集函数一般用作统计，包括： count([distinct]*)统计所有的行数（distinct表示去重再统计，下同） count([distinct]列名)统计某列的值总和 sum([distinct]列名)求一列的和（注意必须是数字类型的） avg([distinct]列名)求一列的平均值（注意必须是数字类型） max([distinct]列名)求一列的最大值 min([distinct]列名)求一列的最小值 一般聚集函数是这样使用的： SELECTcount(distinct列名)FROM表名WHERE条件","date":"2022-02-09","objectID":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/:7:4","tags":["数据库基础"],"title":"数据库基础","uri":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/"},{"categories":["JavaWeb笔记"],"content":"分组和分页查询 通过使用group by来对查询结果进行分组，它需要结合聚合函数一起使用： SELECTsum(*)FROM表名WHERE条件GROUPBY列名我们还可以添加having来限制分组条件： SELECTsum(*)FROM表名WHERE条件GROUPBY列名HAVING约束条件我们可以通过limit来限制查询的数量，只取前n个结果： SELECT*FROM表名LIMIT数量我们也可以进行分页： SELECT*FROM表名LIMIT起始位置,数量","date":"2022-02-09","objectID":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/:7:5","tags":["数据库基础"],"title":"数据库基础","uri":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/"},{"categories":["JavaWeb笔记"],"content":"多表查询 多表查询是同时查询的两个或两个以上的表，多表查询会提通过连接转换为单表查询。 SELECT*FROM表1,表2直接这样查询会得到两张表的笛卡尔积，也就是每一项数据和另一张表的每一项数据都结合一次，会产生庞大的数据。 SELECT*FROM表1,表2WHERE条件这样，只会从笛卡尔积的结果中得到满足条件的数据。 **注意：**如果两个表中都带有此属性吗，需要添加表名前缀来指明是哪一个表的数据。 ","date":"2022-02-09","objectID":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/:7:6","tags":["数据库基础"],"title":"数据库基础","uri":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/"},{"categories":["JavaWeb笔记"],"content":"自身连接查询 自身连接，就是将表本身和表进行笛卡尔积计算，得到结果，但是由于表名相同，因此要先起一个别名： SELECT*FROM表名别名1,表名别名2其实自身连接查询和前面的是一样的，只是连接对象变成自己和自己了。 ","date":"2022-02-09","objectID":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/:7:7","tags":["数据库基础"],"title":"数据库基础","uri":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/"},{"categories":["JavaWeb笔记"],"content":"外连接查询 外连接就是专门用于联合查询情景的，比如现在有一个存储所有用户的表，还有一张用户详细信息的表，我希望将这两张表结合到一起来查看完整的数据，我们就可以通过使用外连接来进行查询，外连接有三种方式： 通过使用inner join进行内连接，只会返回两个表满足条件的交集部分： 通过使用left join进行左连接，不仅会返回两个表满足条件的交集部分，也会返回左边表中的全部数据，而在右表中缺失的数据会使用null来代替（右连接right join同理，只是反过来而已，这里就不再介绍了）： ","date":"2022-02-09","objectID":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/:7:8","tags":["数据库基础"],"title":"数据库基础","uri":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/"},{"categories":["JavaWeb笔记"],"content":"嵌套查询 我们可以将查询的结果作为另一个查询的条件，比如： SELECT*FROM表名WHERE列名=(SELECT列名FROM表名WHERE条件)我们来再次尝试编写一下在最开始我们查找某教师所有学生的SQL语句。 ","date":"2022-02-09","objectID":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/:7:9","tags":["数据库基础"],"title":"数据库基础","uri":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/"},{"categories":["JavaWeb笔记"],"content":"数据库控制语言（DCL） 庞大的数据库不可能由一个人来管理，我们需要更多的用户来一起管理整个数据库。 ","date":"2022-02-09","objectID":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/:8:0","tags":["数据库基础"],"title":"数据库基础","uri":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/"},{"categories":["JavaWeb笔记"],"content":"创建用户 我们可以通过create user来创建用户： CREATEUSER用户名identifiedby密码;也可以不带密码： CREATEUSER用户名;我们可以通过@来限制用户登录的登录IP地址，%表示匹配所有的IP地址，默认使用的就是任意IP地址。 ","date":"2022-02-09","objectID":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/:8:1","tags":["数据库基础"],"title":"数据库基础","uri":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/"},{"categories":["JavaWeb笔记"],"content":"登陆用户 首先需要添加一个环境变量，然后我们通过cmd去登陆mysql： login-u用户名-p输入密码后即可登陆此用户，我们输入以下命令来看看能否访问所有数据库： showdatabases;我们发现，虽然此用户能够成功登录，但是并不能查看完整的数据库列表，这是因为此用户还没有权限！ ","date":"2022-02-09","objectID":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/:8:2","tags":["数据库基础"],"title":"数据库基础","uri":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/"},{"categories":["JavaWeb笔记"],"content":"用户授权 我们可以通过使用grant来为一个数据库用户进行授权： grantall|权限1,权限2...(列1,...)on数据库.表to用户[withgrantoption]其中all代表授予所有权限，当数据库和表为*，代表为所有的数据库和表都授权。如果在最后添加了with grant option，那么被授权的用户还能将已获得的授权继续授权给其他用户。 我们可以使用revoke来收回一个权限： revokeall|权限1,权限2...(列1,...)on数据库.表from用户 ","date":"2022-02-09","objectID":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/:8:3","tags":["数据库基础"],"title":"数据库基础","uri":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/"},{"categories":["JavaWeb笔记"],"content":"视图 视图本质就是一个查询的结果，不过我们每次都可以通过打开视图来按照我们想要的样子查看数据。既然视图本质就是一个查询的结果，那么它本身就是一个虚表，并不是真实存在的，数据实际上还是存放在原来的表中。 我们可以通过create view来创建视图; CREATEVIEW视图名称(列名)as子查询语句[WITHCHECKOPTION];WITH CHECK OPTION是指当创建后，如果更新视图中的数据，是否要满足子查询中的条件表达式，不满足将无法插入，创建后，我们就可以使用select语句来直接查询视图上的数据了，因此，还能在视图的基础上，导出其他的视图。 若视图是由两个以上基本表导出的，则此视图不允许更新。 若视图的字段来自字段表达式或常数，则不允许对此视图执行INSERT和UPDATE操作，但允许执行DELETE操作。 若视图的字段来自集函数，则此视图不允许更新。 若视图定义中含有GROUP BY子句，则此视图不允许更新。 若视图定义中含有DISTINCT短语，则此视图不允许更新。 若视图定义中有嵌套查询，并且内层查询的FROM子句中涉及的表也是导出该视图的基本表，则此视图不允许更新。例如将成绩在平均成绩之上的元组定义成一个视图GOOD_SC： CREATE VIEW GOOD_SC AS SELECT Sno, Cno, Grade FROM SC WHERE Grade \u003e (SELECT AVG(Grade) FROM SC); 导出视图GOOD_SC的基本表是SC，内层查询中涉及的表也是SC，所以视图GOOD_SC是不允许更新的。 一个不允许更新的视图上定义的视图也不允许更新 通过drop来删除一个视图： dropviewapptest ","date":"2022-02-09","objectID":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/:9:0","tags":["数据库基础"],"title":"数据库基础","uri":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/"},{"categories":["JavaWeb笔记"],"content":"索引 在数据量变得非常庞大时，通过创建索引，能够大大提高我们的查询效率，就像Hash表一样，它能够快速地定位元素存放的位置，我们可以通过下面的命令创建索引： -- 创建索引 CREATEINDEX索引名称ON表名(列名)-- 查看表中的索引 showINDEXFROMstudent我们也可以通过下面的命令删除一个索引： dropindex索引名称on表名虽然添加索引后会使得查询效率更高，但是我们不能过度使用索引，索引为我们带来高速查询效率的同时，也会在数据更新时产生额外建立索引的开销，同时也会占用磁盘资源。 ","date":"2022-02-09","objectID":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/:10:0","tags":["数据库基础"],"title":"数据库基础","uri":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/"},{"categories":["JavaWeb笔记"],"content":"触发器 触发器就像其名字一样，在某种条件下会自动触发，在select/update/delete时，会自动执行我们预先设定的内容，触发器通常用于检查内容的安全性，相比直接添加约束，触发器显得更加灵活。 触发器所依附的表称为基本表，当触发器表上发生select/update/delete等操作时，会自动生成两个临时的表（new表和old表，只能由触发器使用） 比如在insert操作时，新的内容会被插入到new表中；在delete操作时，旧的内容会被移到old表中，我们仍可在old表中拿到被删除的数据；在update操作时，旧的内容会被移到old表中，新的内容会出现在new表中。 CREATETRIGGER触发器名称[BEFORE|AFTER][INSERT|UPDATE|DELETE]ON表名/视图名FOREACHROWDELETEFROMstudentWHEREstudent.sno=new.snoFOR EACH ROW表示针对每一行都会生效，无论哪行进行指定操作都会执行触发器！ 通过下面的命令来查看触发器： SHOWTRIGGERS如果不需要，我们就可以删除此触发器： DROPTRIGGER触发器名称 ","date":"2022-02-09","objectID":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/:11:0","tags":["数据库基础"],"title":"数据库基础","uri":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/"},{"categories":["JavaWeb笔记"],"content":"事务 当我们要进行的操作非常多时，比如要依次删除很多个表的数据，我们就需要执行大量的SQL语句来完成，这些数据库操作语句就可以构成一个事务！只有Innodb引擎支持事务，我们可以这样来查看支持的引擎： SHOWENGINES;MySQL默认采用的是Innodb引擎，我们也可以去修改为其他的引擎。 事务具有以下特性： **原子性：**一个事务（transaction）中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。 **一致性：**在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设规则，这包含资料的精确度、串联性以及后续数据库可以自发性地完成预定的工作。 **隔离性：**数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括读未提交（Read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（Serializable）。 **持久性：**事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。 我们通过以下例子来探究以下事务： begin;#开始事务...rollback;#回滚事务savepoint回滚点;#添加回滚点rollbackto回滚点;#回滚到指定回滚点...commit;#提交事务-- 一旦提交，就无法再进行回滚了！ ","date":"2022-02-09","objectID":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/:12:0","tags":["数据库基础"],"title":"数据库基础","uri":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/"},{"categories":["JavaWeb笔记"],"content":"选学内容 函数和存储过程并没有包含在我们的教程当中，但是这并不代表它们就不重要，通过学习它们能够让你的数据库管理能力更上一层楼，它们能够捆绑一组SQL语句运行，并且可以反复使用，大大提高工作效率。 ","date":"2022-02-09","objectID":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/:13:0","tags":["数据库基础"],"title":"数据库基础","uri":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/"},{"categories":["算法——最短路问题"],"content":"BellmanFord和SPFA算法详解","date":"2022-02-07","objectID":"/posts/bellmanford%E5%92%8Cspfa%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3/","tags":["BellmanFord和SPFA算法详解"],"title":"BellmanFord和SPFA算法详解","uri":"/posts/bellmanford%E5%92%8Cspfa%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3/"},{"categories":["算法——最短路问题"],"content":"*关于Bellman ford和SPFA算法的详解 我是白嫖的leetcode会员，然后看了关于图单源最短路径的讲解，讲解的非常好(虽然没代码演示，但基本上一看思路就有了)。 为了让大家也白嫖到视频资源，我把视频上传到了YouTube(国内会有版权问题，发不出) 大家有能力上油管的建议去看看，否则这代码肯定是看不懂的。。。 视频链接： Bellman ford算法详解(两种方式及其优化) 由Bellman ford算法的缺陷引出SPFA算法 适用性分析(先看视频) Blellman ford算法 DP方法：以 dp[i][j] 表示选择最多 i 条边，从起点到 j 的最短距离。每次的更新依赖于上一行 dp[i-1][j] 的答案，故可滚动数组优化为一维数组。时间复杂度O(N^3) 多次遍历边的更新方法：提前记录好哪两个结点有边，每进行一次整个边的遍历，就相当于完成了最多选择一条边到达目的地的最短距离的效果。平均时间复杂度 O(N*V)（V是边的个数，极端情况下会掉到 O(N*N*V)的复杂度，因为最多是可以进行 N-1 次循环的) 很明显无论是哪种方式实现，最终都是依赖选择多少条边的结果，所以该算法适用于指定最多经过k条边的最短路径题目。 正好有道例题适合他 K 站中转内最便宜的航班 SPFA算法 这个算法只是Bellman ford算法的再优化，使得每次选择的边的关系达到最优，大大减少了边的遍历次数,时间复杂度较为稳定(相对Bellmanford稳定很多)的在 O(N*V)。 这个原本也是基于Bellmanford算法优化的，除了无法表示最多经过k条边，其余效率比之前的算法更快，所以适用于求存在负权值的单源最短路径问题，而无法精确为最多经过了多少条边。 以题代讲 ","date":"2022-02-07","objectID":"/posts/bellmanford%E5%92%8Cspfa%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3/:0:0","tags":["BellmanFord和SPFA算法详解"],"title":"BellmanFord和SPFA算法详解","uri":"/posts/bellmanford%E5%92%8Cspfa%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3/"},{"categories":["算法——最短路问题"],"content":"蓝桥杯–最短路 ","date":"2022-02-07","objectID":"/posts/bellmanford%E5%92%8Cspfa%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3/:1:0","tags":["BellmanFord和SPFA算法详解"],"title":"BellmanFord和SPFA算法详解","uri":"/posts/bellmanford%E5%92%8Cspfa%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3/"},{"categories":["算法——最短路问题"],"content":"Bellman ford的动态规划解决(超时,过三个) #include\u003cbits/stdc++.h\u003eusing namespace std; #define LL long long int n,m; vector\u003cint\u003edp(20001,INT_MAX/2); map\u003cint,map\u003cint,int\u003e \u003e MAP; LL read() { LL res = 0; bool f = 1; char c; //先耗掉一个getchar来进行判断符号 c = getchar(); if(c == '-')f = 0; else res+= (c-'0'); while (isdigit(c = getchar())) { res = (LL)res * 10 + (c-'0'); } if (f) return res; return res*-1; } int main(){ n = read(); m = read(); for(int i=0;i\u003cm;i++){ int a =read(),c = read(),len = read(); MAP[a][c] = len; if(a == 1) dp[c] = len; } dp[1] = 0; vector\u003cint\u003epre = dp; //外层循环经过最多i条路到达该结点的最短距离，最多经过n-1条 //里面几层都是用于更新没一行的数据 for(int i=2;i\u003c=n-1;i++){ for(int j=2;j\u003c=n;j++){ for(int k = 1;k\u003c=n;k++){ int t = MAP[k][j]; if(t) dp[j] = min(dp[j],pre[k]+t); } } pre = dp; } for(int i=2;i\u003c=n;i++){ cout\u003c\u003cdp[i]\u003c\u003cendl; } } ","date":"2022-02-07","objectID":"/posts/bellmanford%E5%92%8Cspfa%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3/:2:0","tags":["BellmanFord和SPFA算法详解"],"title":"BellmanFord和SPFA算法详解","uri":"/posts/bellmanford%E5%92%8Cspfa%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3/"},{"categories":["算法——最短路问题"],"content":"Bellman ford按边遍历解决(速度竟比SPFA快，我惊了) #include\u003cbits/stdc++.h\u003eusing namespace std; #define LL long long int n,m; //以边为单位遍历更新 struct pos{ int i; int j; int len; }; vector\u003cint\u003edp(20001,INT_MAX/2); LL read() { LL res = 0; bool f = 1; char c; //先耗掉一个getchar来进行判断符号 c = getchar(); if(c == '-')f = 0; else res+= (c-'0'); while (isdigit(c = getchar())) { res = (LL)res * 10 + (c-'0'); } if (f) return res; return res*-1; } int main(){ n = read(); m = read(); //记录m条边的关系 pos MAP[m]; for(int i=0;i\u003cm;i++){ int a =read(),c = read(),len = read(); MAP[i] = {a,c,len}; } dp[1] = 0; //外面一层代表遍历边的次数，最多为n-1次 for(int i=1;i\u003c=n-1;i++){ bool flag = true; for(int k=0;k\u003cm;k++){ if(dp[MAP[k].j]\u003edp[MAP[k].i]+MAP[k].len){ dp[MAP[k].j] = dp[MAP[k].i]+MAP[k].len; flag = false; } } //一旦有一轮遍历未更新一次，则弹出循环，得出答案 if(flag) break; } for(int i=2;i\u003c=n;i++){ cout\u003c\u003cdp[i]\u003c\u003cendl; } } ","date":"2022-02-07","objectID":"/posts/bellmanford%E5%92%8Cspfa%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3/:3:0","tags":["BellmanFord和SPFA算法详解"],"title":"BellmanFord和SPFA算法详解","uri":"/posts/bellmanford%E5%92%8Cspfa%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3/"},{"categories":["算法——最短路问题"],"content":"最终优化–SPFA算法 毕竟SPFA的全称为Shortest Path Faster Algorithm，也得当担得起这个名字啊🤣 主要因为用STL容器存储数据的原因，所以似乎稍慢。 #include\u003cbits/stdc++.h\u003eusing namespace std; #define LL long long int n,m; //以边为单位遍历更新,再进一步优化便得到得到SPFA算法 //我们需要构造一个以任一点为起点的，它所连接的通路的结构，以方便队列进行操作，用哈希表进行映射最好 map\u003cint,vector\u003cpair\u003cint,int\u003e \u003e \u003eMAP; vector\u003cint\u003edp(20001,INT_MAX/2); queue\u003cint\u003eQ; //标记结点是否在队列之中 bool check[20001] = {false}; LL read() { LL res = 0; bool f = 1; char c; //先耗掉一个getchar来进行判断符号 c = getchar(); if(c == '-')f = 0; else res+= (c-'0'); while (isdigit(c = getchar())) { res = (LL)res * 10 + (c-'0'); } if (f) return res; return res*-1; } int main(){ n = read(); m = read(); for(int i=0;i\u003cm;i++){ int a =read(),c = read(),len = read(); MAP[a].push_back(make_pair(c,len)); } dp[1] = 0; Q.push(1); check[1] = true; while(!Q.empty()){ int node = Q.front();Q.pop();check[node] = false; vector\u003cpair\u003cint,int\u003e \u003e\u0026 t = MAP[node]; //以node为起点开始更新，一旦被更新且队中无该结点，则入队。 for(int i=0;i\u003ct.size();i++) { if(dp[t[i].first]\u003edp[node]+t[i].second){ dp[t[i].first] = dp[node]+t[i].second; //入队操作 if(!check[t[i].first]) Q.push(t[i].first); check[t[i].first] = true; } } } for(int i=2;i\u003c=n;i++){ cout\u003c\u003cdp[i]\u003c\u003cendl; } } ","date":"2022-02-07","objectID":"/posts/bellmanford%E5%92%8Cspfa%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3/:4:0","tags":["BellmanFord和SPFA算法详解"],"title":"BellmanFord和SPFA算法详解","uri":"/posts/bellmanford%E5%92%8Cspfa%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3/"},{"categories":["算法——最短路问题"],"content":"Dijkstra算法模板讲解","date":"2022-02-07","objectID":"/posts/dijkstra%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E8%AE%B2%E8%A7%A3/","tags":["Dijkstra算法模板讲解"],"title":"Dijkstra算法模板讲解","uri":"/posts/dijkstra%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E8%AE%B2%E8%A7%A3/"},{"categories":["算法——最短路问题"],"content":"(也就5min)先点开链接把Dijkstra算法过程看一看(否则肯定看不懂代码). 视频详解Dijkstra算法过程 此方法最短路径的适用范围：单源带权图，要是不带权完全可以用bfs。 详解代码实现过程(请结合视频过程分析) ","date":"2022-02-07","objectID":"/posts/dijkstra%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E8%AE%B2%E8%A7%A3/:0:0","tags":["Dijkstra算法模板讲解"],"title":"Dijkstra算法模板讲解","uri":"/posts/dijkstra%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E8%AE%B2%E8%A7%A3/"},{"categories":["算法——最短路问题"],"content":"用到的基本数据表示 根据视频中讲解的实现原理，我们需要通过多个数组来实现该过程。 dist[i]数组(下标表示第几个结点)用于标记起点S到i的最短距离，初始值全为无穷大，这个值只要足够大就行。 visit[i]数组(下标同上)用于标记每个已经得到最短距离的结点，初始值全为false,表示该结点还未找到最短距离。 path[i]数组(下标同上)用于标记每个已经得到最短距离的结点的前驱(最短路径中的上一个结点)，初始值全为-1。 Graph[i][j]这是一个带权矩阵，表示任意i结点到j结点间边的距离,若两者间无边则初始为无穷大。 ","date":"2022-02-07","objectID":"/posts/dijkstra%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E8%AE%B2%E8%A7%A3/:1:0","tags":["Dijkstra算法模板讲解"],"title":"Dijkstra算法模板讲解","uri":"/posts/dijkstra%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E8%AE%B2%E8%A7%A3/"},{"categories":["算法——最短路问题"],"content":"各个函数模块实现(重在Dijkstra函数) init() void init()//在读入数据之前初始化图 {//Graph和dist在读取数据之前都初始化为INF，path初始化为-1 for(int i = 1; i \u003c= N; i++){ path[i] = -1; dist[i] = INF; for(int j = 1; j \u003c= N; j++){ Graph[j][i] = INF;//INF为自定义的较大的值 } } memset(visit,0,sizeof(visit));//起初，没有一个结点被标记 } FIndMin() int FindMin()//找出未被visit标记的结点中最小的距离结点,并返回该结点 { int minV = S;//初始为S，如果未被更新则路径更新过程结束 int minDist = INF; for(int i = 0; i \u003c N; i++){ if(!visit[i] \u0026\u0026 dist[i] \u003c minDist){//没有被标记\u0026\u0026距离最小 minV = i; minDist = dist[i]; } }//返回没有被标记的最小结点 return minV; } Dijkstra() void Dijkstra() {//S表示起点，T表示终点 dist[S] = 0;//起点到自己的距离设为0 visit[S] = true;//将起点标记 for(int i = 1; i \u003c= N; i++){ //更新与起点S相连的结点的距离值 int t = Graph[i][S]; if(t \u003c INF){ dist[i] = t; path[i] = S; } } //要么无法到达，要么就是找到到达终点的最小值，否则一直循环。 while(1){ //得到未被标记的最小结点，将其标记 int v = FindMin(); if(v==S)//如果未被更新，则无需再更新了，要么全被标记，要么就是剩下的无法到达 return; visit[v] = true;//将该结点标记 if(visit[T])return;//一旦T被标记，则说明到达终点的最小值已经找到 for(int i = 1; i \u003c= N; i++){ //这个结合视频的更新过程想想就懂了 if(!visit[i]\u0026\u0026Graph[v][i]!=INF){//没被标记\u0026\u0026两者之间存在边 if(dist[v] + Graph[v][i] \u003c dist[i]){ dist[i] = dist[v] + Graph[v][i]; path[i] = v; } } } } } 以题代讲–具体实现 ","date":"2022-02-07","objectID":"/posts/dijkstra%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E8%AE%B2%E8%A7%A3/:2:0","tags":["Dijkstra算法模板讲解"],"title":"Dijkstra算法模板讲解","uri":"/posts/dijkstra%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E8%AE%B2%E8%A7%A3/"},{"categories":["算法——最短路问题"],"content":"蓝桥杯–文化之旅 看完题目，唯一的区别在于还需要额外判断文化是否排斥，这个在函数中多添加一个判断条件就行。 ","date":"2022-02-07","objectID":"/posts/dijkstra%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E8%AE%B2%E8%A7%A3/:3:0","tags":["Dijkstra算法模板讲解"],"title":"Dijkstra算法模板讲解","uri":"/posts/dijkstra%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E8%AE%B2%E8%A7%A3/"},{"categories":["算法——最短路问题"],"content":"解题过程 我们按照上述的过程三步走试试： 初始化过程(我比较习惯用vector容器所以就没有单独写init函数了) //vector容器的初始化方法--vector\u003c类型\u003e变量名(长度,初始值); const int size = 505;//用于初始化一个size长度的数组 vector\u003cint\u003epath(size,-1); vector\u003cint\u003edist(size,INT_MAX); vector\u003cbool\u003evisit(size,false); vector\u003cvector\u003cint\u003e \u003eGraphics(size,vector\u003cint\u003e(size,INT_MAX)); //下面两个是本题新加的属性，我们建立所属文化以及文化关系数组来存储。 vector\u003cint\u003ecultures(size); bool cultureLinks[size][size] = {false}; 找最小结点的函数FindMin() int FindMin() { int minV = S; int minDist = INT_MAX; for(int i = 1; i \u003c= N; i++){ if(!visit[i] \u0026\u0026 dist[i] \u003c minDist){ minV = i; minDist = dist[i]; } } return minV; } Dijkstra() 函数 void Dijkstra() { dist[S] = 0; visit[S] = true; for(int i = 1; i \u003c= N; i++){ int t = Graphics[S][i]; if(t \u003c INT_MAX\u0026\u0026!cultureLinks[cultures[i]][cultures[S]]){ dist[i] = t; path[i] = S;} } while(1){ int v = FindMin(); if(v==S) return; visit[v] = true;//将此次最小路径结点标记 //一旦T终点被标记则说明答案已经出现 if(visit[T])return; for(int i = 1; i \u003c= N; i++){ if(!visit[i]\u0026\u0026Graphics[v][i]!=INT_MAX\u0026\u0026!cultureLinks[cultures[i]][cultures[v]]){//只有结点未被标记 \u0026\u0026 文化不会排斥 \u0026\u0026 路径长度不是无穷大 if(dist[v] + Graphics[v][i] \u003c dist[i]){ dist[i] = dist[v] + Graphics[v][i]; path[i] = v; } } } } } main函数测试接口 int main(){ cin\u003e\u003eN\u003e\u003eK\u003e\u003eM\u003e\u003eS\u003e\u003eT; for(int i=1;i\u003c=N;i++) cin\u003e\u003ecultures[i]; for(int i=1;i\u003c=K;i++) for(int j=1;j\u003c=K;j++) cin\u003e\u003ecultureLinks[i][j]; for(int i=1;i\u003c=M;i++){ int u,v,d;cin\u003e\u003eu\u003e\u003ev\u003e\u003ed;//无向图 Graphics[u][v] = Graphics[v][u] = d; } Dijkstra(); if(dist[T]!=INT_MAX) cout\u003c\u003cdist[T]; else cout\u003c\u003c-1; return 0; } ","date":"2022-02-07","objectID":"/posts/dijkstra%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E8%AE%B2%E8%A7%A3/:4:0","tags":["Dijkstra算法模板讲解"],"title":"Dijkstra算法模板讲解","uri":"/posts/dijkstra%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E8%AE%B2%E8%A7%A3/"},{"categories":["算法——最短路问题"],"content":"汇总代码提交 #include\u003cbits/stdc++.h\u003eusing namespace std; const int size = 505; vector\u003cint\u003epath(size,-1); vector\u003cint\u003edist(size,INT_MAX); vector\u003cbool\u003evisit(size,false); vector\u003cvector\u003cint\u003e \u003eGraphics(size,vector\u003cint\u003e(size,INT_MAX)); vector\u003cint\u003ecultures(size); bool cultureLinks[size][size] = {false}; int N,K,M,S,T; int FindMin() { int minV = S; int minDist = INT_MAX; for(int i = 1; i \u003c= N; i++){ if(!visit[i] \u0026\u0026 dist[i] \u003c minDist){ minV = i; minDist = dist[i]; } } return minV; } void Dijkstra() { dist[S] = 0; visit[S] = true; for(int i = 1; i \u003c= N; i++){ int t = Graphics[S][i]; if(t \u003c INT_MAX\u0026\u0026!cultureLinks[cultures[i]][cultures[S]]){ dist[i] = t; path[i] = S;} } while(1){ int v = FindMin(); if(v==S) return; visit[v] = true;//将此次最小路径结点标记 //一旦T终点被标记则说明答案已经出现 if(visit[T])return; for(int i = 1; i \u003c= N; i++){ if(!visit[i]\u0026\u0026Graphics[v][i]!=INT_MAX\u0026\u0026!cultureLinks[cultures[i]][cultures[v]]){//只有结点未被标记 \u0026\u0026 文化不会排斥 \u0026\u0026 路径长度不是无穷大 if(dist[v] + Graphics[v][i] \u003c dist[i]){ dist[i] = dist[v] + Graphics[v][i]; path[i] = v; } } } } } int main(){ cin\u003e\u003eN\u003e\u003eK\u003e\u003eM\u003e\u003eS\u003e\u003eT; for(int i=1;i\u003c=N;i++) cin\u003e\u003ecultures[i]; for(int i=1;i\u003c=K;i++) for(int j=1;j\u003c=K;j++) cin\u003e\u003ecultureLinks[i][j]; for(int i=1;i\u003c=M;i++){ int u,v,d;cin\u003e\u003eu\u003e\u003ev\u003e\u003ed;//无向图 Graphics[u][v] = Graphics[v][u] = d; } Dijkstra(); if(dist[T]!=INT_MAX) cout\u003c\u003cdist[T]; else cout\u003c\u003c-1; return 0; } ","date":"2022-02-07","objectID":"/posts/dijkstra%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E8%AE%B2%E8%A7%A3/:5:0","tags":["Dijkstra算法模板讲解"],"title":"Dijkstra算法模板讲解","uri":"/posts/dijkstra%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E8%AE%B2%E8%A7%A3/"},{"categories":["C++实战"],"content":"C++图形化实现学生管理系统","date":"2022-02-05","objectID":"/posts/c++%E5%9B%BE%E5%BD%A2%E5%8C%96%E5%AE%9E%E7%8E%B0%E5%AD%A6%E7%94%9F%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/","tags":["C++图形化实现学生管理系统"],"title":"C++图形化实现学生管理系统","uri":"/posts/c++%E5%9B%BE%E5%BD%A2%E5%8C%96%E5%AE%9E%E7%8E%B0%E5%AD%A6%E7%94%9F%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/"},{"categories":["C++实战"],"content":"Qt学生管理系统 想查看源码或者直接下载软件安装包可以到下面的链接： 软件安装包大概在这个位置 GitHub地址：链接 Gitee地址(方便国内访问)：链接 ","date":"2022-02-05","objectID":"/posts/c++%E5%9B%BE%E5%BD%A2%E5%8C%96%E5%AE%9E%E7%8E%B0%E5%AD%A6%E7%94%9F%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/:0:0","tags":["C++图形化实现学生管理系统"],"title":"C++图形化实现学生管理系统","uri":"/posts/c++%E5%9B%BE%E5%BD%A2%E5%8C%96%E5%AE%9E%E7%8E%B0%E5%AD%A6%E7%94%9F%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/"},{"categories":["C++实战"],"content":"基本源码介绍 本项目基于Qt6+cmake，故直接拿到源码是无法跑起来的，需要Qt6的库。上传源码主要是记录源码里面的一些思路。 以下是源码的解析图：（其中的ui布局界面和qss界面美化是最耗时间的部分！） ui界面布局用到的特殊之处： 重写界面顶部逻辑。 重写一些事件。 增加软件运行效率的特殊之处： 通过开一个线程将数据库中的数据提前载入内存，后续的任何查询等操作都是直接和内存打交道，大大加快了运行效率。 对数据库的增删，不是一次一次的进行，而是开一个缓冲区，当缓冲满了，再一次性增或者删。减少了磁盘io次数，大大增加了软件运行效率。 使用的数据库为Qt自带的sqlite数据库。 ","date":"2022-02-05","objectID":"/posts/c++%E5%9B%BE%E5%BD%A2%E5%8C%96%E5%AE%9E%E7%8E%B0%E5%AD%A6%E7%94%9F%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/:1:0","tags":["C++图形化实现学生管理系统"],"title":"C++图形化实现学生管理系统","uri":"/posts/c++%E5%9B%BE%E5%BD%A2%E5%8C%96%E5%AE%9E%E7%8E%B0%E5%AD%A6%E7%94%9F%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/"},{"categories":["C++实战"],"content":"实现效果 基本学生/用户数据的增删改查。 数据存储的持久化。 较为优美的图形化界面。 还有很多功能没有进行拓展：比如用户权限没有进行任何的限制，比如Excle表格读取没有进行任何的设置，只是把excle读取的功能给加上了，具体读取到的数据没有进行任何操作，这些大家都可以后续有兴趣添加一个。 ","date":"2022-02-05","objectID":"/posts/c++%E5%9B%BE%E5%BD%A2%E5%8C%96%E5%AE%9E%E7%8E%B0%E5%AD%A6%E7%94%9F%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/:2:0","tags":["C++图形化实现学生管理系统"],"title":"C++图形化实现学生管理系统","uri":"/posts/c++%E5%9B%BE%E5%BD%A2%E5%8C%96%E5%AE%9E%E7%8E%B0%E5%AD%A6%E7%94%9F%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/"},{"categories":["现代C++语法"],"content":"C++右值语义的基石——完美转发","date":"2022-02-04","objectID":"/posts/c++%E5%8F%B3%E5%80%BC%E8%AF%AD%E4%B9%89%E7%9A%84%E5%9F%BA%E7%9F%B3%E5%AE%8C%E7%BE%8E%E8%BD%AC%E5%8F%91/","tags":["C++右值语义的基石——完美转发"],"title":"C++右值语义的基石——完美转发","uri":"/posts/c++%E5%8F%B3%E5%80%BC%E8%AF%AD%E4%B9%89%E7%9A%84%E5%9F%BA%E7%9F%B3%E5%AE%8C%E7%BE%8E%E8%BD%AC%E5%8F%91/"},{"categories":["现代C++语法"],"content":"什么是完美转发？ 熟悉现代C++语法的都应该清楚，C++把变量分为左值和右值，为了实现对资源的转移而不是拷贝，右值和对应的移动构造函数应运而生，但我们发现，很多时候我们并不能把左值和右值精确的传递给对应版本的函数进行处理，比如下面一个简单的代码，你会发现即使我们把函数的参数类型设置为右值引用，但当拿它去调用对应的构造函数时，它给出的竟然是拷贝构造！故这个转发还不够完美！ #include\u003ciostream\u003eusing namespace std; class test{ public: test() = default; test(test\u0026\u0026 p){ cout\u003c\u003c\"move construct call\"\u003c\u003cendl; } test(const test\u0026 p){ cout\u003c\u003c\"copy construct call\"\u003c\u003cendl; } }; void test_fun(test\u0026\u0026 p){ test q(p); return; } int main() { test_fun(test()); return 0; } 为什么会出现这种情况呢？ 因为无论传入的形参是左值还是右值，对于函数内部来说，形参既有名称又能寻址，因此它都被认为是左值。 ","date":"2022-02-04","objectID":"/posts/c++%E5%8F%B3%E5%80%BC%E8%AF%AD%E4%B9%89%E7%9A%84%E5%9F%BA%E7%9F%B3%E5%AE%8C%E7%BE%8E%E8%BD%AC%E5%8F%91/:1:0","tags":["C++右值语义的基石——完美转发"],"title":"C++右值语义的基石——完美转发","uri":"/posts/c++%E5%8F%B3%E5%80%BC%E8%AF%AD%E4%B9%89%E7%9A%84%E5%9F%BA%E7%9F%B3%E5%AE%8C%E7%BE%8E%E8%BD%AC%E5%8F%91/"},{"categories":["现代C++语法"],"content":"如何实现完美转发？ 实现完美转发很简单，我们在现代C++中只需要 forward\u003cT\u003e 这个模板函数即可完成，其实际原理就是利用的 C++11 模板中提供的折叠引用的语法，最终达到的效果就是，把参数的类型强制转换为它该有的类型，是左值就转为左值，是右值就转为右值，从而实现该调用哪个版本的函数就调用哪个版本的函数，不再只被认定为右值了！ 先前的代码可以如此实现完美转发： #include\u003ciostream\u003eusing namespace std; class test{ public: test() = default; test(test\u0026\u0026 p){ cout\u003c\u003c\"move construct call\"\u003c\u003cendl; } test(const test\u0026 p){ cout\u003c\u003c\"copy construct call\"\u003c\u003cendl; } }; void test_fun(test\u0026\u0026 p){ test q(forward\u003ctest\u003e(p)); //修改的地方 return; } int main() { test_fun(test()); return 0; } ","date":"2022-02-04","objectID":"/posts/c++%E5%8F%B3%E5%80%BC%E8%AF%AD%E4%B9%89%E7%9A%84%E5%9F%BA%E7%9F%B3%E5%AE%8C%E7%BE%8E%E8%BD%AC%E5%8F%91/:2:0","tags":["C++右值语义的基石——完美转发"],"title":"C++右值语义的基石——完美转发","uri":"/posts/c++%E5%8F%B3%E5%80%BC%E8%AF%AD%E4%B9%89%E7%9A%84%E5%9F%BA%E7%9F%B3%E5%AE%8C%E7%BE%8E%E8%BD%AC%E5%8F%91/"},{"categories":["现代C++语法"],"content":"任何模板库都离不开完美转发 其实现在只要是C++的模板库，没有哪个是不用完美转发的，同时完美转发的问题也是产生自模板，而 forward 函数的实现其实也不是什么难事，实际就是利用 C++11 对模板提供的万能折叠语义： 当实参为左值或者左值引用（A\u0026）时，函数模板中 T\u0026\u0026 将转变为 A\u0026（A\u0026 \u0026\u0026 = A\u0026）； 当实参为右值或者右值引用（A\u0026\u0026）时，函数模板中 T\u0026\u0026 将转变为 A\u0026\u0026（A\u0026\u0026 \u0026\u0026 = A\u0026\u0026）。 以下为一个简单的利用完美转发设计的创建工厂： #include\u003ciostream\u003e#include \u003cmemory\u003e using namespace std; class test{ public: test() = default; test(int\u0026\u0026 arg):m_iData(arg){ cout\u003c\u003c\"move construct call\"\u003c\u003cendl; } test(const int\u0026 arg):m_iData(arg){ cout\u003c\u003c\"copy construct call\"\u003c\u003cendl; } private: int m_iData; }; template\u003ctypename T,typename Arg\u003e //不直接用T\u0026\u0026的原因在于，如果只使用一个模板参数会导致factory参数无法获得万能引用的效果 shared_ptr\u003cT\u003e factory(Arg\u0026\u0026 arg){ return shared_ptr\u003cT\u003e(new T(forward\u003cArg\u003e(arg)));//使用完美转发调用正确的构造函数 } int main() { int val = 5; auto p1 = factory\u003ctest\u003e(val); auto p2 = factory\u003ctest\u003e(5); return 0; } ","date":"2022-02-04","objectID":"/posts/c++%E5%8F%B3%E5%80%BC%E8%AF%AD%E4%B9%89%E7%9A%84%E5%9F%BA%E7%9F%B3%E5%AE%8C%E7%BE%8E%E8%BD%AC%E5%8F%91/:3:0","tags":["C++右值语义的基石——完美转发"],"title":"C++右值语义的基石——完美转发","uri":"/posts/c++%E5%8F%B3%E5%80%BC%E8%AF%AD%E4%B9%89%E7%9A%84%E5%9F%BA%E7%9F%B3%E5%AE%8C%E7%BE%8E%E8%BD%AC%E5%8F%91/"},{"categories":["现代C++语法"],"content":"std::forward的实现原理 gcc 的源代码实现如下： template\u003ctypename _Tp\u003e constexpr _Tp \u0026\u0026 forward(typename std::remove_reference\u003c_Tp\u003e::type \u0026__t) noexcept { return static_cast\u003c_Tp \u0026\u0026\u003e(__t); } template\u003ctypename _Tp\u003e constexpr _Tp \u0026\u0026 forward(typename std::remove_reference\u003c_Tp\u003e::type \u0026\u0026__t) noexcept { static_assert(!std::is_lvalue_reference\u003c_Tp\u003e::value, \"template argument\" \" substituting _Tp is an lvalue reference type\"); return static_cast\u003c_Tp \u0026\u0026\u003e(__t); } 我们发现，源代码中实现了两个模板特化，_Tp\u0026 和 _Tp\u0026\u0026 但最终都是通过 static_cast + 折叠引用的特性来实现强制转化的。也就是简单的强转而已！ ","date":"2022-02-04","objectID":"/posts/c++%E5%8F%B3%E5%80%BC%E8%AF%AD%E4%B9%89%E7%9A%84%E5%9F%BA%E7%9F%B3%E5%AE%8C%E7%BE%8E%E8%BD%AC%E5%8F%91/:4:0","tags":["C++右值语义的基石——完美转发"],"title":"C++右值语义的基石——完美转发","uri":"/posts/c++%E5%8F%B3%E5%80%BC%E8%AF%AD%E4%B9%89%E7%9A%84%E5%9F%BA%E7%9F%B3%E5%AE%8C%E7%BE%8E%E8%BD%AC%E5%8F%91/"},{"categories":["现代C++语法"],"content":"收获 在设计模板库的时候，如果需要根据左值右值语义比较清晰的实现转发，一定要用forward，否则参数只会被当作左值！ ","date":"2022-02-04","objectID":"/posts/c++%E5%8F%B3%E5%80%BC%E8%AF%AD%E4%B9%89%E7%9A%84%E5%9F%BA%E7%9F%B3%E5%AE%8C%E7%BE%8E%E8%BD%AC%E5%8F%91/:5:0","tags":["C++右值语义的基石——完美转发"],"title":"C++右值语义的基石——完美转发","uri":"/posts/c++%E5%8F%B3%E5%80%BC%E8%AF%AD%E4%B9%89%E7%9A%84%E5%9F%BA%E7%9F%B3%E5%AE%8C%E7%BE%8E%E8%BD%AC%E5%8F%91/"},{"categories":["算法——贪心"],"content":"leetcode每日一题——和为K的最少斐波那契数字数目","date":"2022-02-03","objectID":"/posts/leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E5%92%8C%E4%B8%BAk%E7%9A%84%E6%9C%80%E5%B0%91%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%AD%97%E6%95%B0%E7%9B%AE/","tags":["fib的贪心可行性"],"title":"leetcode每日一题——和为K的最少斐波那契数字数目","uri":"/posts/leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E5%92%8C%E4%B8%BAk%E7%9A%84%E6%9C%80%E5%B0%91%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%AD%97%E6%95%B0%E7%9B%AE/"},{"categories":["算法——贪心"],"content":"题目 题目链接 ","date":"2022-02-03","objectID":"/posts/leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E5%92%8C%E4%B8%BAk%E7%9A%84%E6%9C%80%E5%B0%91%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%AD%97%E6%95%B0%E7%9B%AE/:1:0","tags":["fib的贪心可行性"],"title":"leetcode每日一题——和为K的最少斐波那契数字数目","uri":"/posts/leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E5%92%8C%E4%B8%BAk%E7%9A%84%E6%9C%80%E5%B0%91%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%AD%97%E6%95%B0%E7%9B%AE/"},{"categories":["算法——贪心"],"content":"题目详解 我开始是想着构造好fib数组的值，然后用背包问题去解决它。可惜，直接超时了！ 后面直接用最简单的贪心方式没想到真的可行。。 然后看了题解才知道原来fib的「每次选择不超过当前 k 的最大数」这是一个特有的结论，然后大家都在证明他，虽然我看不懂，但我大受震撼😂 详解链接 ","date":"2022-02-03","objectID":"/posts/leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E5%92%8C%E4%B8%BAk%E7%9A%84%E6%9C%80%E5%B0%91%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%AD%97%E6%95%B0%E7%9B%AE/:2:0","tags":["fib的贪心可行性"],"title":"leetcode每日一题——和为K的最少斐波那契数字数目","uri":"/posts/leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E5%92%8C%E4%B8%BAk%E7%9A%84%E6%9C%80%E5%B0%91%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%AD%97%E6%95%B0%E7%9B%AE/"},{"categories":["算法——贪心"],"content":"解题代码 class Solution { public: int findMinFibonacciNumbers(int k) { vector\u003cint\u003eitems(2,1); int ret = 0; while(items.back()\u003ck){ items.push_back(items.back()+items[items.size()-2]); } for(int i=items.size()-1;i\u003e=0;i--){ ret += k/items[i]; k %= items[i]; } return ret; } }; ","date":"2022-02-03","objectID":"/posts/leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E5%92%8C%E4%B8%BAk%E7%9A%84%E6%9C%80%E5%B0%91%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%AD%97%E6%95%B0%E7%9B%AE/:3:0","tags":["fib的贪心可行性"],"title":"leetcode每日一题——和为K的最少斐波那契数字数目","uri":"/posts/leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E5%92%8C%E4%B8%BAk%E7%9A%84%E6%9C%80%E5%B0%91%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%AD%97%E6%95%B0%E7%9B%AE/"},{"categories":["算法——字符串"],"content":"字符串类型滑动窗口或递归分治解被ban字符求最长子串","date":"2022-02-01","objectID":"/posts/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B1%BB%E5%9E%8B%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%88%96%E9%80%92%E5%BD%92%E5%88%86%E6%B2%BB%E8%A7%A3%E8%A2%ABban%E5%AD%97%E7%AC%A6%E6%B1%82%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/","tags":["递归分治、滑动窗口、位运算"],"title":"字符串类型滑动窗口或递归分治解被ban字符求最长子串","uri":"/posts/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B1%BB%E5%9E%8B%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%88%96%E9%80%92%E5%BD%92%E5%88%86%E6%B2%BB%E8%A7%A3%E8%A2%ABban%E5%AD%97%E7%AC%A6%E6%B1%82%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/"},{"categories":["算法——字符串"],"content":"题目一：至少有 K 个重复字符的最长子串 395. 至少有 K 个重复字符的最长子串 ","date":"2022-02-01","objectID":"/posts/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B1%BB%E5%9E%8B%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%88%96%E9%80%92%E5%BD%92%E5%88%86%E6%B2%BB%E8%A7%A3%E8%A2%ABban%E5%AD%97%E7%AC%A6%E6%B1%82%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/:1:0","tags":["递归分治、滑动窗口、位运算"],"title":"字符串类型滑动窗口或递归分治解被ban字符求最长子串","uri":"/posts/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B1%BB%E5%9E%8B%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%88%96%E9%80%92%E5%BD%92%E5%88%86%E6%B2%BB%E8%A7%A3%E8%A2%ABban%E5%AD%97%E7%AC%A6%E6%B1%82%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/"},{"categories":["算法——字符串"],"content":"题目解析 有两种方法： 递归分治解决：该分治法的应用对象：解决那种不会去跨越任何一个段更新答案的题目。比如此题这种关于字符串子串的题。首先在整个字符串大范围内可以确定哪些字符没有达到k次，故只要存在这些字符的子串都被排除在外。具体到递归分治的代码上就是： 分治的每一段都不含上一个总字符串的被 ban (被禁)字符，故每个分治的对象都要进行以下几个步骤： 一、计算 [l,r] 之间所有字符的出现次数。 二、根据出现次数计算出被 ban 掉的字符类型。 三、根据是否有被 ban 的字符类型，来确定是否还需要再往下递归分治，如果没有被 ban 的字符类型，则该字符串就是一个符合条件的字符串。否则继续往下递归分治，分治的子对象都不能含有该被 ban 字符类型。 根据枚举类型的滑动窗口解决：按照字符类型的滑动窗口技巧，最外层用于枚举固定当前窗口内最多有多少类型。这个技巧就是，当我们无法直接找到滑动窗口的边界时，我们可以根据有限的类型来构造滑动窗口的边界，由于最多有26个类型的字符，而我们滑动窗口过程可以根据某个类型的字符数量是否符合条件来得到窗口内符合条件的类型数量，只要窗口内的类型数量等于符合条件的类型数量，那么该窗口内的字符串即为一个答案。但问题是，我们不清楚窗口内的类型数量是多大，这也就是我们没有明确的边界，此时我们根据枚举 1~26 个类型来进行窗口的滑动限制即可。 ","date":"2022-02-01","objectID":"/posts/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B1%BB%E5%9E%8B%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%88%96%E9%80%92%E5%BD%92%E5%88%86%E6%B2%BB%E8%A7%A3%E8%A2%ABban%E5%AD%97%E7%AC%A6%E6%B1%82%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/:1:1","tags":["递归分治、滑动窗口、位运算"],"title":"字符串类型滑动窗口或递归分治解被ban字符求最长子串","uri":"/posts/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B1%BB%E5%9E%8B%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%88%96%E9%80%92%E5%BD%92%E5%88%86%E6%B2%BB%E8%A7%A3%E8%A2%ABban%E5%AD%97%E7%AC%A6%E6%B1%82%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/"},{"categories":["算法——字符串"],"content":"解题代码 法一：递归分治 class Solution { public: int dfs(string\u0026 s,int l,int r,int k){ int cnt[26] = {0}; for(int i=l;i\u003c=r;i++){//计算字符的次数方便计算ban掉的字符类型 cnt[s[i]-'a']++; } char split = 0; for(int i=0;i\u003c26;i++){ if(cnt[i]!=0\u0026\u0026cnt[i]\u003ck){ //很明显在这个大范围内要是这个字符类型次数都小于k了，肯定就是要被ban的 split = i+'a'; break; } } if(split==0)//如果该段字符串没有被ban的字符类型则该字符串就是符合条件的字符串 return r-l+1; int ret = 0; //开始枚举分治到下面去 while(l\u003c=r){ while(l\u003c=r\u0026\u0026s[l]==split){//不让起始点从被ban的字符开始 l++; } if(l\u003er) break;//说明全是被ban的字符 int start = l; while(l\u003c=r\u0026\u0026s[l]!=split){//计算本次分段的长度（结束位置） l++; } int length = dfs(s,start,l-1,k); ret = max(ret,length); } return ret; } int longestSubstring(string s, int k) { return dfs(s,0,s.size()-1,k); } }; 法二：枚举类型的滑动窗口 class Solution { public: int longestSubstring(string s, int k) { int n = s.size(); int cnt[26]{0};//用于记录窗口内字符的出现次数 int maxLen = 0; for(int i=1;i\u003c=26;i++){ memset(cnt,0,sizeof(cnt)); for(int l=0,r=0,sum=0,tot=0;r\u003cn;r++){//sum、tot分别表示窗口内的有效字符种类数和总的种类数 cnt[s[r]-'a']++; if(cnt[s[r]-'a']==1) //增加种类数 tot++; if(cnt[s[r]-'a']==k) //为了防止多次更新千万别取大于号 sum++; //增加有效种类数 while(tot\u003ei){ //达到收缩窗口条件，因为窗口内的种类数限制为i个 int dup = (s[l++]-'a'); cnt[dup]--; if(cnt[dup]==0) //种类数此时需要-1 tot--; if(cnt[dup]==k-1)//有效种类数-1 sum--; } if(sum==tot) maxLen = max(maxLen,r-l+1); } } return maxLen; } }; ","date":"2022-02-01","objectID":"/posts/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B1%BB%E5%9E%8B%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%88%96%E9%80%92%E5%BD%92%E5%88%86%E6%B2%BB%E8%A7%A3%E8%A2%ABban%E5%AD%97%E7%AC%A6%E6%B1%82%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/:1:2","tags":["递归分治、滑动窗口、位运算"],"title":"字符串类型滑动窗口或递归分治解被ban字符求最长子串","uri":"/posts/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B1%BB%E5%9E%8B%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%88%96%E9%80%92%E5%BD%92%E5%88%86%E6%B2%BB%E8%A7%A3%E8%A2%ABban%E5%AD%97%E7%AC%A6%E6%B1%82%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/"},{"categories":["算法——字符串"],"content":"题目二：最长的美好子字符串 最长的美好子字符串 ","date":"2022-02-01","objectID":"/posts/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B1%BB%E5%9E%8B%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%88%96%E9%80%92%E5%BD%92%E5%88%86%E6%B2%BB%E8%A7%A3%E8%A2%ABban%E5%AD%97%E7%AC%A6%E6%B1%82%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/:2:0","tags":["递归分治、滑动窗口、位运算"],"title":"字符串类型滑动窗口或递归分治解被ban字符求最长子串","uri":"/posts/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B1%BB%E5%9E%8B%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%88%96%E9%80%92%E5%BD%92%E5%88%86%E6%B2%BB%E8%A7%A3%E8%A2%ABban%E5%AD%97%E7%AC%A6%E6%B1%82%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/"},{"categories":["算法——字符串"],"content":"题目解析 这题虽然由于数据量的关系，被划分为简单题，但实际上完全不亚于第一题。甚至还得用上一些位运算的思想。 这题我会的做法只有两种： 普通位运算枚举法：其实就是此题的暴力解法，只是用了位运算使得更为优雅，由于此题需要求最长的大小写都包含的字符串，我们用一个int位来表示所有小写字母的出现，用另一个int位来表示所有大写字母的出现，则对于每个字符串，都可以通过这两个int是否相等来判断是否正好是大小写都含有，然后就是暴力的遍历所有子串的过程了。 递归分治法：此题和上题差不多，也是不会跨越任何一个段去更新答案，所以也能使用递归分治的方式来进行解决。但前期处理被ban字符和上题是不一样的，其余都一样，这题要根据 [l,r] 之间字符的位运算结果 lower 和 upper 再与运算得到两者的交集来判断是否有被 ban 字符，或者是不被ban的字符。 ","date":"2022-02-01","objectID":"/posts/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B1%BB%E5%9E%8B%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%88%96%E9%80%92%E5%BD%92%E5%88%86%E6%B2%BB%E8%A7%A3%E8%A2%ABban%E5%AD%97%E7%AC%A6%E6%B1%82%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/:2:1","tags":["递归分治、滑动窗口、位运算"],"title":"字符串类型滑动窗口或递归分治解被ban字符求最长子串","uri":"/posts/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B1%BB%E5%9E%8B%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%88%96%E9%80%92%E5%BD%92%E5%88%86%E6%B2%BB%E8%A7%A3%E8%A2%ABban%E5%AD%97%E7%AC%A6%E6%B1%82%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/"},{"categories":["算法——字符串"],"content":"解题代码 方法一：位运算+暴力遍历 class Solution { public: string longestNiceSubstring(string s) { int sz = s.size(); int start,len=0; for(int i=0;i\u003csz;i++){ int lower = 0,upper = 0; for(int j=i;j\u003csz;j++){ if(islower(s[j])){ lower |= (1\u003c\u003c(s[j]-'a')); }else{ upper |= (1\u003c\u003c(s[j]-'A')); } if(lower==upper\u0026\u0026(j-i+1\u003elen)){ start = i; len = j-i+1; } } } return len==0?\"\":s.substr(start,len); } }; 方法二：递归分治 class Solution { public: void dfs(string \u0026s, int l, int r, pair\u003cint, int\u003e \u0026ret) { int lower = 0, upper = 0; for (int i = l; i \u003c= r; i++) { if (islower(s[i])) { lower |= (1 \u003c\u003c (s[i] - 'a')); } else { upper |= (1 \u003c\u003c (s[i] - 'A')); } } if (lower == upper) {//我之前这里的判断条件导致了无限循环，一旦满足第一个条件，但不满足第二个条件，就发生无限循环！！！所以注意放到下面去 if (r - l + 1 \u003e ret.second) { ret.first = l; ret.second = r - l + 1; } return; } int valid = lower \u0026 upper;//这两的交集代表大小写都出现的类型，为符合条件的类型，而被ban的就是不处于这里面的字符类型 int start; while (l \u003c= r) { while (l \u003c= r \u0026\u0026 !(valid \u0026 (1 \u003c\u003c (tolower(s[l]) - 'a')))) {//让start处于符合条件的类型 l++; } if (l \u003e r) break; start = l; while (l \u003c= r \u0026\u0026 (valid \u0026 (1 \u003c\u003c (tolower(s[l]) - 'a')))) {//得到符合条件的分段右端点 l++; } dfs(s, start, l - 1, ret); } } string longestNiceSubstring(string s) { pair\u003cint, int\u003e ret{0, 0}; dfs(s, 0, s.size() - 1, ret); return s.substr(ret.first, ret.second); } }; ","date":"2022-02-01","objectID":"/posts/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B1%BB%E5%9E%8B%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%88%96%E9%80%92%E5%BD%92%E5%88%86%E6%B2%BB%E8%A7%A3%E8%A2%ABban%E5%AD%97%E7%AC%A6%E6%B1%82%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/:2:2","tags":["递归分治、滑动窗口、位运算"],"title":"字符串类型滑动窗口或递归分治解被ban字符求最长子串","uri":"/posts/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B1%BB%E5%9E%8B%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%88%96%E9%80%92%E5%BD%92%E5%88%86%E6%B2%BB%E8%A7%A3%E8%A2%ABban%E5%AD%97%E7%AC%A6%E6%B1%82%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/"},{"categories":["算法——动态规划"],"content":"划分数问题","date":"2022-01-30","objectID":"/posts/%E5%88%92%E5%88%86%E6%95%B0%E9%97%AE%E9%A2%98/","tags":["划分数问题"],"title":"划分数问题","uri":"/posts/%E5%88%92%E5%88%86%E6%95%B0%E9%97%AE%E9%A2%98/"},{"categories":["算法——动态规划"],"content":"题目 题目链接 ","date":"2022-01-30","objectID":"/posts/%E5%88%92%E5%88%86%E6%95%B0%E9%97%AE%E9%A2%98/:1:0","tags":["划分数问题"],"title":"划分数问题","uri":"/posts/%E5%88%92%E5%88%86%E6%95%B0%E9%97%AE%E9%A2%98/"},{"categories":["算法——动态规划"],"content":"题目详解 划分数类型题目都是dp解决，而且都有固定的套路和公式，但我们还是需要在前人的公式上加以理解！ 划分数问题dp总结 我这里就提两个比较常见的划分数问题的dp原理： 如果对数字划分较为抽象，那么我们把这个数字可以比作苹果，即有n个苹果需要划分到m个盘子里面，而这几个盘子的顺序肯定是不考虑的，也就是5个苹果划分给3个盘子，则1 2 2和2 1 2是完全一样的情况，只看具体的数字组合不看内部排列！ 将n划分成不大于m的划分。 $dp[n][m] = dp[n-m][m]+dp[n][m-1]$ 对于以上的状态转移方程， dp[n-m][m] 表示n个苹果放入m个盘子中，无空盘的情况。 dp[n][m-1] 表示n个苹果放入m个盘子中，有空盘的情况(这就是划分成不大于m盘的关键所在)。这么写肯定是有些难以理解，但当你去举例子，将它递归往下写的时候，你就会发现这个dp[n][m-1] 包含了从 dp[n][1] 到 dp[n][m-1] 的所有情况！ 底层的基本case有： 当 n==1||m==1 ，即盘子或者苹果数量为1个的时候，那肯定就只有一种情况。即dp[n][m]=1。 当 n\u003em ，则还能继续划分即dp[n][m] = dp[n-m][m]+dp[n][m-1]。 当 n==m ，则有两种情况，当划分为m个时，结果为1，然后继续空盘子划分，即 dp[n][m]=dp[n][m-1]+1。 当 n\u003cm，由于可以空盘，所以是允许存在的，但此时不可能满盘，所以等于空盘的情况，即 dp[n][m] = dp[n][m-1]。 写成代码形式就是（我比较喜欢写记忆化dfs，毕竟不需要考虑初始化问题，只需考虑最后的跳出）： 以下的两个判断条件就把所有是以上四种情况包含在内了！ int memo[202][8];//记忆化的备忘录 //TODO 划分数记忆化方式 int dfs(int n,int m){ if(n\u003c0||m\u003c0) return 0; if(n==1||n==0||m==1) return 1; return memo[n][m] = dfs(n-m,m)+dfs(n,m-1); } 将n严格划分为m个数。(即n个苹果严格划分为m盘，不要有空位！) $dp[n][m] = dp[n-m][m]+dp[n-1][m-1]$ 下面给出我的一段手写推导： base case也在手写题解里面提到了，所以直接上代码： int memo[202][8]; //TODO 划分数n划成k份的记忆化方式 int dfs(int n,int k){ if(n\u003ck) return 0; if(n==k||k==1) return 1; if(memo[n][k])return memo[n][k]; return memo[n][k] = dfs(n-k, k) + dfs(n-1,k-1); } ","date":"2022-01-30","objectID":"/posts/%E5%88%92%E5%88%86%E6%95%B0%E9%97%AE%E9%A2%98/:2:0","tags":["划分数问题"],"title":"划分数问题","uri":"/posts/%E5%88%92%E5%88%86%E6%95%B0%E9%97%AE%E9%A2%98/"},{"categories":["算法——动态规划"],"content":"解题代码 前面已经介绍了两种划分数的dp，那么本题就属于第二种划分数的dp！ 直接把上面的代码拿下来直接秒！ #include\u003cbits/stdc++.h\u003eusing namespace std; using ll = long long; ll memo[202][8]; int n,k; //TODO 划分数记忆化方式 ll dfs(int a,int b){ if(a\u003cb) return 0; if(a==b||b==1) return 1; if(memo[a][b])return memo[a][b]; return memo[a][b] = dfs(a-b, b) + dfs(a-1,b-1); } int main(){ cin\u003e\u003en\u003e\u003ek; cout\u003c\u003cdfs(n, k); return 0; } ","date":"2022-01-30","objectID":"/posts/%E5%88%92%E5%88%86%E6%95%B0%E9%97%AE%E9%A2%98/:3:0","tags":["划分数问题"],"title":"划分数问题","uri":"/posts/%E5%88%92%E5%88%86%E6%95%B0%E9%97%AE%E9%A2%98/"},{"categories":["算法——路径更新问题"],"content":"leetcode每日一题——地图中的最高点","date":"2022-01-29","objectID":"/posts/leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E5%9C%B0%E5%9B%BE%E4%B8%AD%E7%9A%84%E6%9C%80%E9%AB%98%E7%82%B9/","tags":["leetcode每日一题——地图中的最高点"],"title":"leetcode每日一题——地图中的最高点","uri":"/posts/leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E5%9C%B0%E5%9B%BE%E4%B8%AD%E7%9A%84%E6%9C%80%E9%AB%98%E7%82%B9/"},{"categories":["算法——路径更新问题"],"content":"题目 题目链接 ","date":"2022-01-29","objectID":"/posts/leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E5%9C%B0%E5%9B%BE%E4%B8%AD%E7%9A%84%E6%9C%80%E9%AB%98%E7%82%B9/:1:0","tags":["leetcode每日一题——地图中的最高点"],"title":"leetcode每日一题——地图中的最高点","uri":"/posts/leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E5%9C%B0%E5%9B%BE%E4%B8%AD%E7%9A%84%E6%9C%80%E9%AB%98%E7%82%B9/"},{"categories":["算法——路径更新问题"],"content":"解题思路 两种解题思路，都是根据题目的意思更新路径信息即可： bfs思路：由于相邻的两个格子必须高度差为1，而水域必须高度为0，所以，直接以水域为bfs源点，进行bfs把整个区域的值给更新就行了。这是bfs思路。 dp思路：由于dp都依赖上一次更新的结果，而我们一般就是从左到右的遍历更新，而这题是和四个位置相关，所以，我们分为：从上到下从左到右更新，可以把依赖上和左的答案给更新，从下到上，从右到左更新，可以把依赖下和右的结果给更新完。 ","date":"2022-01-29","objectID":"/posts/leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E5%9C%B0%E5%9B%BE%E4%B8%AD%E7%9A%84%E6%9C%80%E9%AB%98%E7%82%B9/:2:0","tags":["leetcode每日一题——地图中的最高点"],"title":"leetcode每日一题——地图中的最高点","uri":"/posts/leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E5%9C%B0%E5%9B%BE%E4%B8%AD%E7%9A%84%E6%9C%80%E9%AB%98%E7%82%B9/"},{"categories":["算法——路径更新问题"],"content":"解题代码 BFS代码 class Solution { public: const int dx[4]={-1,1,0,0}; const int dy[4]={0,0,-1,1}; int n,m; bool isValid(int x,int y){ return x\u003cn\u0026\u0026x\u003e=0\u0026\u0026y\u003cm\u0026\u0026y\u003e=0; } const int maxn = 1e3+5; vector\u003cvector\u003cint\u003e\u003e highestPeak(vector\u003cvector\u003cint\u003e\u003e\u0026 isWater) { n = isWater.size(); m = isWater[0].size(); bool visit[maxn][maxn]; memset(visit,0,sizeof(visit)); queue\u003cpair\u003cint,int\u003e\u003eQ; for(int i=0;i\u003cn;i++){ for(int j=0;j\u003cm;j++){ if(isWater[i][j]){ visit[i][j] = 1; isWater[i][j] = 0; Q.push({i,j}); } } } int step = 1; while(!Q.empty()){ for(int i=Q.size();i\u003e0;i--){ auto[x,y] = Q.front();Q.pop(); for(int k=0;k\u003c4;k++){ int nx = x+dx[k]; int ny = y+dy[k]; if(isValid(nx,ny)\u0026\u0026!visit[nx][ny]){ visit[nx][ny] = 1; isWater[nx][ny] = step; Q.push({nx,ny}); } } } step++; } return isWater; } }; dp代码 class Solution { public: vector\u003cvector\u003cint\u003e\u003e highestPeak(vector\u003cvector\u003cint\u003e\u003e\u0026 isWater) { int n = isWater.size(); int m = isWater[0].size(); vector\u003cvector\u003cint\u003e\u003e dp(n, vector\u003cint\u003e(m, 1e9+7)); for(int i=0; i\u003cn; i++) { //从上到下从左到右 for(int j=0; j\u003cm; j++) { if(isWater[i][j]) dp[i][j] = 0; else { if(i \u003e 0) dp[i][j] = min(dp[i][j], dp[i-1][j]+1); if(j \u003e 0) dp[i][j] = min(dp[i][j], dp[i][j-1]+1); } } } for(int i=n-1; i\u003e=0; i--) { //从下到上从右到左 for(int j=m-1; j\u003e=0; j--) { if(isWater[i][j]) dp[i][j] = 0; else { if(i \u003c n-1) dp[i][j] = min(dp[i][j], dp[i+1][j]+1); if(j \u003c m-1) dp[i][j] = min(dp[i][j], dp[i][j+1]+1); } } } return dp; } }; ","date":"2022-01-29","objectID":"/posts/leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E5%9C%B0%E5%9B%BE%E4%B8%AD%E7%9A%84%E6%9C%80%E9%AB%98%E7%82%B9/:3:0","tags":["leetcode每日一题——地图中的最高点"],"title":"leetcode每日一题——地图中的最高点","uri":"/posts/leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E5%9C%B0%E5%9B%BE%E4%B8%AD%E7%9A%84%E6%9C%80%E9%AB%98%E7%82%B9/"},{"categories":["算法——贪心"],"content":"leetcode每日一题-游戏中弱角色的数量","date":"2022-01-28","objectID":"/posts/leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-%E6%B8%B8%E6%88%8F%E4%B8%AD%E5%BC%B1%E8%A7%92%E8%89%B2%E7%9A%84%E6%95%B0%E9%87%8F/","tags":["利用排序基于遍历过程处理的贪心-游戏中弱角色的数量"],"title":"leetcode每日一题-游戏中弱角色的数量","uri":"/posts/leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-%E6%B8%B8%E6%88%8F%E4%B8%AD%E5%BC%B1%E8%A7%92%E8%89%B2%E7%9A%84%E6%95%B0%E9%87%8F/"},{"categories":["算法——贪心"],"content":"题目 题目链接 ","date":"2022-01-28","objectID":"/posts/leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-%E6%B8%B8%E6%88%8F%E4%B8%AD%E5%BC%B1%E8%A7%92%E8%89%B2%E7%9A%84%E6%95%B0%E9%87%8F/:1:0","tags":["利用排序基于遍历过程处理的贪心-游戏中弱角色的数量"],"title":"leetcode每日一题-游戏中弱角色的数量","uri":"/posts/leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-%E6%B8%B8%E6%88%8F%E4%B8%AD%E5%BC%B1%E8%A7%92%E8%89%B2%E7%9A%84%E6%95%B0%E9%87%8F/"},{"categories":["算法——贪心"],"content":"解题思路 一句话解决：以第一个字段为标准从大到小排序，然后再遍历数组，对比第二字段的最大值即可。 关键细节： 为了避免第一个字段相同的情况下被更新，所以在排序时采取，攻击力降序防御力升序的方式(关键)来进行。 这样就让第一个字段相同时，按照从左到右的遍历顺序是不可能把第一个字段相同的情况拿来更新 cnt 。 ","date":"2022-01-28","objectID":"/posts/leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-%E6%B8%B8%E6%88%8F%E4%B8%AD%E5%BC%B1%E8%A7%92%E8%89%B2%E7%9A%84%E6%95%B0%E9%87%8F/:2:0","tags":["利用排序基于遍历过程处理的贪心-游戏中弱角色的数量"],"title":"leetcode每日一题-游戏中弱角色的数量","uri":"/posts/leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-%E6%B8%B8%E6%88%8F%E4%B8%AD%E5%BC%B1%E8%A7%92%E8%89%B2%E7%9A%84%E6%95%B0%E9%87%8F/"},{"categories":["算法——贪心"],"content":"解题代码 注意：golang 的代码中的断言型函数接口有点不一样。。它调用时用的是数组下标的形式来调用。 cpp version class Solution { public: //一句话解决：以第一个字段为标准从大到小排序，然后再遍历数组，对比第二字段的最大值即可。 //但为了避免第一个字段相同的情况下被更新，所以在排序时采取，攻击力降序防御力升序的方式(关键)来进行 //这样就让第一个字段相同时，按照从左到右的遍历顺序是不可能把第一个字段相同的情况拿来更新cnt。 int numberOfWeakCharacters(vector\u003cvector\u003cint\u003e\u003e\u0026 properties) { int n = properties.size(); auto cmp = [](vector\u003cint\u003e\u0026 t1,vector\u003cint\u003e\u0026t2){return t1[0]==t2[0]?t1[1]\u003ct2[1]:t1[0]\u003et2[0];}; sort(properties.begin(),properties.end(),cmp); int mx = INT_MIN; int cnt = 0; for(int i=0;i\u003cn;i++){ if(mx\u003eproperties[i][1]) cnt++; mx = max(mx,properties[i][1]); } return cnt; } }; java version class Solution { public int numberOfWeakCharacters(int[][] properties) { Arrays.sort(properties,(o1,o2)-\u003e o1[0]==o2[0]?o1[1]-o2[1]:o2[0]-o1[0]); int max = -1,cnt = 0; for(int[] p : properties){ if(p[1]\u003cmax) cnt++; max = Math.max(max,p[1]); } return cnt; } } golang version func numberOfWeakCharacters(properties [][]int) int { sort.Slice(properties,func (i int,j int) bool{//注意这个接口被写死只能用int型 p, q := properties[i], properties[j] return p[0] \u003e q[0] || p[0] == q[0] \u0026\u0026 p[1] \u003c q[1] }) var max = -1 cnt := 0 for _,v := range properties{ if max\u003ev[1] { cnt++ } max = int(math.Max(float64(max), float64(v[1]))) } return cnt } ","date":"2022-01-28","objectID":"/posts/leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-%E6%B8%B8%E6%88%8F%E4%B8%AD%E5%BC%B1%E8%A7%92%E8%89%B2%E7%9A%84%E6%95%B0%E9%87%8F/:3:0","tags":["利用排序基于遍历过程处理的贪心-游戏中弱角色的数量"],"title":"leetcode每日一题-游戏中弱角色的数量","uri":"/posts/leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-%E6%B8%B8%E6%88%8F%E4%B8%AD%E5%BC%B1%E8%A7%92%E8%89%B2%E7%9A%84%E6%95%B0%E9%87%8F/"},{"categories":["算法——贪心"],"content":"收获 被坑了，往二分+哈希表方向去写了。完全没想到之间排序+遍历就能解决。。。 排序的处理非常之精髓。 ","date":"2022-01-28","objectID":"/posts/leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-%E6%B8%B8%E6%88%8F%E4%B8%AD%E5%BC%B1%E8%A7%92%E8%89%B2%E7%9A%84%E6%95%B0%E9%87%8F/:4:0","tags":["利用排序基于遍历过程处理的贪心-游戏中弱角色的数量"],"title":"leetcode每日一题-游戏中弱角色的数量","uri":"/posts/leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-%E6%B8%B8%E6%88%8F%E4%B8%AD%E5%BC%B1%E8%A7%92%E8%89%B2%E7%9A%84%E6%95%B0%E9%87%8F/"},{"categories":["算法——计算几何"],"content":"leetcode每日一题-检测正方形","date":"2022-01-27","objectID":"/posts/leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-%E6%A3%80%E6%B5%8B%E6%AD%A3%E6%96%B9%E5%BD%A2/","tags":["leetcode每日一题-检测正方形"],"title":"leetcode每日一题-检测正方形","uri":"/posts/leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-%E6%A3%80%E6%B5%8B%E6%AD%A3%E6%96%B9%E5%BD%A2/"},{"categories":["算法——计算几何"],"content":"题目 题目链接 ","date":"2022-01-27","objectID":"/posts/leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-%E6%A3%80%E6%B5%8B%E6%AD%A3%E6%96%B9%E5%BD%A2/:1:0","tags":["leetcode每日一题-检测正方形"],"title":"leetcode每日一题-检测正方形","uri":"/posts/leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-%E6%A3%80%E6%B5%8B%E6%AD%A3%E6%96%B9%E5%BD%A2/"},{"categories":["算法——计算几何"],"content":"题目解析 注意此题为计算几何类型的题目，我认为这类问题最重要的就是把这个几何图形用好用的方法去表示出来。 三个重点： 点的表示：我们通过上下两点确定正方形的原则来表示，且点的存储方式一点不能用pair，这样效率及其低下，且难以有一定的自由度取操作 x，y 轴，我们采用哈希表套哈希表的方式取存储！ 点的记录：通过嵌套哈希表完成点的次数记录，比如： unordered_map\u003cint, unordered_map\u003cint, int\u003e\u003e cnt; cnt[y][x]++; 点的枚举：通过嵌套哈希表，可以很好的把 x，y 坐标的对应点数给限制住，所以我们要根据这点可以利用count方法直接把不是同一个纵轴的点给排除，比如： res += (colCnt.count(x) ? colCnt[x] : 0) * (yCnt.count(x + d) ? yCnt[x + d] : 0) * (colCnt.count(x + d)? colCnt[x + d] : 0); //一旦以上的count方法返回0，即表示该点不是同一个纵轴上的点，则得出结果0，整个res就相当于没有加任何数字。 再比如通过yCnt提前取出在同一个横轴的点： unordered_map\u003cint, int\u003e \u0026 yCnt = cnt[y]; //取和point在同一行的所有点 //这样后续的枚举过程直接可以套用yCnt[x+d]或者yCnt[x-d]来得到对应左右两种情况正方形的点个数。 最后一个优化：由于我们每次枚举同一纵轴上的点不确定是上面还是下面，实际上根本不重要，由于在计算时，我们都会把左右两种正方形的情况给计算完，而这个过程正好是两个相反的 +- 过程，所以无论枚举得到的正方形边长为正还是为负数，都不影响！ ","date":"2022-01-27","objectID":"/posts/leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-%E6%A3%80%E6%B5%8B%E6%AD%A3%E6%96%B9%E5%BD%A2/:2:0","tags":["leetcode每日一题-检测正方形"],"title":"leetcode每日一题-检测正方形","uri":"/posts/leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-%E6%A3%80%E6%B5%8B%E6%AD%A3%E6%96%B9%E5%BD%A2/"},{"categories":["算法——计算几何"],"content":"解题代码 非常详细的注释了 class DetectSquares { public: unordered_map\u003cint, unordered_map\u003cint, int\u003e\u003e cnt; DetectSquares() { } void add(vector\u003cint\u003e point) { int x = point[0], y = point[1]; cnt[y][x]++; } int count(vector\u003cint\u003e point) { int res = 0; int x = point[0], y = point[1]; if (!cnt.count(y)) { return 0; } unordered_map\u003cint, int\u003e \u0026 yCnt = cnt[y]; //取和point在同一行的所有点 for (auto \u0026 [col, colCnt] : cnt) { if (col != y) {//由于我们构造正方形是根据上下两条边，故此处枚举的另外一点不能在同一行 // 根据对称性，这里可以不用取绝对值，具体而言就是所有情况根据+-已经包括 int d = col - y;//得到正方形边长，根据这个值可以直接取到对应的另外几个点(如果存在的话) //这里的colCnt.count(x)用于判断是否和当前点在同一个纵轴，这样才可能构造上下两边，故下面只要有1个为0，则加的都是0 //由于我们指定了必须是同一个纵轴上的点，所以不可能构造出两个相同的正方形！ res += (colCnt.count(x) ? colCnt[x] : 0) * (yCnt.count(x + d) ? yCnt[x + d] : 0) * (colCnt.count(x + d)? colCnt[x + d] : 0); res += (colCnt.count(x) ? colCnt[x] : 0) * (yCnt.count(x - d) ? yCnt[x - d] : 0) * (colCnt.count(x - d) ? colCnt[x - d] : 0); } } return res; } }; ","date":"2022-01-27","objectID":"/posts/leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-%E6%A3%80%E6%B5%8B%E6%AD%A3%E6%96%B9%E5%BD%A2/:3:0","tags":["leetcode每日一题-检测正方形"],"title":"leetcode每日一题-检测正方形","uri":"/posts/leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-%E6%A3%80%E6%B5%8B%E6%AD%A3%E6%96%B9%E5%BD%A2/"},{"categories":["算法——计算几何"],"content":"总结 学到以下： 如何通过嵌套哈希表表示点，以及用它表示的而不用pair表示的好处。 重点好像也就上面那条。 ","date":"2022-01-27","objectID":"/posts/leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-%E6%A3%80%E6%B5%8B%E6%AD%A3%E6%96%B9%E5%BD%A2/:4:0","tags":["leetcode每日一题-检测正方形"],"title":"leetcode每日一题-检测正方形","uri":"/posts/leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-%E6%A3%80%E6%B5%8B%E6%AD%A3%E6%96%B9%E5%BD%A2/"},{"categories":["JavaWeb笔记"],"content":"Java网络编程","date":"2022-01-26","objectID":"/posts/java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/","tags":["JavaWeb第一节"],"title":"Java网络编程","uri":"/posts/java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"categories":["JavaWeb笔记"],"content":"Java网络编程 配套视频 在JavaSE阶段，我们学习了I/O流，既然I/O流如此强大，那么能否跨越不同的主机进行I/O操作呢？这就要提到Java的网络编程了。 注意：本章会涉及到计算机网络相关内容（只会讲解大致内容，不会完整的讲解计算机网络知识） 若没有计算机网络基础，实际上Java这里封装的Socket网络IO操作已经简单到完全不需要任何基础的，但是没有计算机网络相关的底层知识，以后的深入学习会非常不知所云。 ","date":"2022-01-26","objectID":"/posts/java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/:0:0","tags":["JavaWeb第一节"],"title":"Java网络编程","uri":"/posts/java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"categories":["JavaWeb笔记"],"content":"计算机网络基础 利用通信线路和通信设备，将地理位置不同的、功能独立的多台计算机互连起来，以功能完善的网络软件来实现资源共享和信息传递，就构成了计算机网络系统。 比如我们家里的路由器，通过将我们的设备（手机、平板、电脑、电视剧）连接到路由器，来实现对互联网的访问。实际上，我们的路由器连接在互联网上，而我们的设备又连接了路由器，这样我们的设备就可以通过路由器访问到互联网了。通过网络，我们可以直接访问互联网上的另一台主机，比如我们要把QQ的消息发送给我们的朋友，或是通过远程桌面管理来操作另一台电脑，也可以是连接本地网络上的打印机。 既然我们可以通过网络访问其他计算机，那么如何区别不同的计算机呢？通过IP地址，我们就可以区分不同的计算机了： 每一台电脑在同一个网络上都有一个自己的IP地址，用于区别于其他的电脑，我们可以通过对方主机的IP地址对其进行访问。那么我手机连接的移动流量，能访问到连接家里路由器的电脑吗？（不能，因为他们不属于同一个网络） 而我们的电脑上可能运行着大量的程序，每一个程序可能都需要通过网络来访问其他计算机，那这时该如何区分呢？我们可以通过端口号来区分： 因此，我们一般看到的是这样的：192.168.0.11:8080，通过IP:端口的形式来访问目标主机上的一个应用程序服务。注意端口号只能是0-65535之间的值！ IP地址分为IPv4和IPv6，IPv4类似于192.168.0.11，我们上面提到的例子都是使用的IPv4，它一共有四组数字，每组数字占8个bit位，IPv4地址0.0.0.0表示为2进制就是：00000000.00000000.00000000.00000000，共32个bit，最大为255.255.255.255，实际上，IPv4能够表示的所有地址，早就已经被用完了。IPv6能够保存128个bit位，因此它也可以表示更多的IP地址，一个IPv6地址看起来像这样：1030::C9B4:FF12:48AA:1A2B，目前也正在向IPv6的阶段过度。 TCP和UDP是两种不同的传输层协议： TCP：当一台计算机想要与另一台计算机通讯时，两台计算机之间的通信需要畅通且可靠（会进行三次握手，断开也会进行四次挥手），这样才能保证正确收发数据，因此TCP更适合一些可靠的数据传输场景。 UDP：它是一种无连接协议，数据想发就发，而且不会建立可靠传输，也就是说传输过程中有可能会导致部分数据丢失，但是它比TCP传输更加简单高效，适合视频直播之类的。 ","date":"2022-01-26","objectID":"/posts/java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/:1:0","tags":["JavaWeb第一节"],"title":"Java网络编程","uri":"/posts/java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"categories":["JavaWeb笔记"],"content":"了解Socket技术 通过Socket技术（它是计算机之间进行通信的一种约定或一种方式），我们就可以实现两台计算机之间的通信，Socket也被翻译为套接字，是操作系统底层提供的一项通信技术，它支持TCP和UDP。而Java就对socket底层支持进行了一套完整的封装，我们可以通过Java来实现Socket通信。 要实现Socket通信，我们必须创建一个数据发送者和一个数据接收者，也就是客户端和服务端，我们需要提前启动服务端，来等待客户端的连接，而客户端只需要随时启动去连接服务端即可！ //服务端 public static void main(String[] args) { try(ServerSocket server = new ServerSocket(8080)){ //将服务端创建在端口8080上 System.out.println(\"正在等待客户端连接...\"); Socket socket = server.accept(); //当没有客户端连接时，线程会阻塞，直到有客户端连接为止 System.out.println(\"客户端已连接，IP地址为：\"+socket.getInetAddress().getHostAddress()); }catch (IOException e){ e.printStackTrace(); } } //客户端 public static void main(String[] args) { try (Socket socket = new Socket(\"localhost\", 8080)){ System.out.println(\"已连接到服务端！\"); }catch (IOException e){ System.out.println(\"服务端连接失败！\"); e.printStackTrace(); } } 实际上它就是一个TCP连接的建立过程： 一旦TCP连接建立，服务端和客户端之间就可以相互发送数据，直到客户端主动关闭连接。当然，服务端不仅仅只可以让一个客户端进行连接，我们可以尝试让服务端一直运行来不断接受客户端的连接： public static void main(String[] args) { try(ServerSocket server = new ServerSocket(8080)){ //将服务端创建在端口8080上 System.out.println(\"正在等待客户端连接...\"); while (true){ //无限循环等待客户端连接 Socket socket = server.accept(); System.out.println(\"客户端已连接，IP地址为：\"+socket.getInetAddress().getHostAddress()); } }catch (IOException e){ e.printStackTrace(); } } 现在我们就可以多次去连接此服务端了。 ","date":"2022-01-26","objectID":"/posts/java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/:2:0","tags":["JavaWeb第一节"],"title":"Java网络编程","uri":"/posts/java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"categories":["JavaWeb笔记"],"content":"使用Socket进行数据传输 通过Socket对象，我们就可以获取到对应的I/O流进行网络数据传输： public static void main(String[] args) { try (Socket socket = new Socket(\"localhost\", 8080); Scanner scanner = new Scanner(System.in)){ System.out.println(\"已连接到服务端！\"); OutputStream stream = socket.getOutputStream(); OutputStreamWriter writer = new OutputStreamWriter(stream); //通过转换流来帮助我们快速写入内容 System.out.println(\"请输入要发送给服务端的内容：\"); String text = scanner.nextLine(); writer.write(text+'\\n'); //因为对方是readLine()这里加个换行符 writer.flush(); System.out.println(\"数据已发送：\"+text); }catch (IOException e){ System.out.println(\"服务端连接失败！\"); e.printStackTrace(); }finally { System.out.println(\"客户端断开连接！\"); } } } public static void main(String[] args) { try(ServerSocket server = new ServerSocket(8080)){ //将服务端创建在端口8080上 System.out.println(\"正在等待客户端连接...\"); Socket socket = server.accept(); System.out.println(\"客户端已连接，IP地址为：\"+socket.getInetAddress().getHostAddress()); BufferedReader reader = new BufferedReader(new InputStreamReader(socket.getInputStream())); //通过 System.out.print(\"接收到客户端数据：\"); System.out.println(reader.readLine()); socket.close(); //和服务端TCP连接完成之后，记得关闭socket }catch (IOException e){ e.printStackTrace(); } } 同理，既然服务端可以读取客户端的内容，客户端也可以在发送后等待服务端给予响应： public static void main(String[] args) { try (Socket socket = new Socket(\"localhost\", 8080); Scanner scanner = new Scanner(System.in)){ System.out.println(\"已连接到服务端！\"); OutputStream stream = socket.getOutputStream(); OutputStreamWriter writer = new OutputStreamWriter(stream); //通过转换流来帮助我们快速写入内容 System.out.println(\"请输入要发送给服务端的内容：\"); String text = scanner.nextLine(); writer.write(text+'\\n'); //因为对方是readLine()这里加个换行符 writer.flush(); System.out.println(\"数据已发送：\"+text); BufferedReader reader = new BufferedReader(new InputStreamReader(socket.getInputStream())); System.out.println(\"收到服务器返回：\"+reader.readLine()); }catch (IOException e){ System.out.println(\"服务端连接失败！\"); e.printStackTrace(); }finally { System.out.println(\"客户端断开连接！\"); } } public static void main(String[] args) { try(ServerSocket server = new ServerSocket(8080)){ //将服务端创建在端口8080上 System.out.println(\"正在等待客户端连接...\"); Socket socket = server.accept(); System.out.println(\"客户端已连接，IP地址为：\"+socket.getInetAddress().getHostAddress()); BufferedReader reader = new BufferedReader(new InputStreamReader(socket.getInputStream())); //通过 System.out.print(\"接收到客户端数据：\"); System.out.println(reader.readLine()); OutputStreamWriter writer = new OutputStreamWriter(socket.getOutputStream()); writer.write(\"已收到！\"); writer.flush(); }catch (IOException e){ e.printStackTrace(); } } 我们可以手动关闭单向的流： socket.shutdownOutput(); //关闭输出方向的流 socket.shutdownInput(); //关闭输入方向的流 如果我们不希望服务端等待太长的时间，我们可以通过调用setSoTimeout()方法来设定IO超时时间： socket.setSoTimeout(3000); 当超过设定时间都依然没有收到客户端或是服务端的数据时，会抛出异常： java.net.SocketTimeoutException: Read timed out at java.net.SocketInputStream.socketRead0(Native Method) at java.net.SocketInputStream.socketRead(SocketInputStream.java:116) at java.net.SocketInputStream.read(SocketInputStream.java:171) at java.net.SocketInputStream.read(SocketInputStream.java:141) at sun.nio.cs.StreamDecoder.readBytes(StreamDecoder.java:284) at sun.nio.cs.StreamDecoder.implRead(StreamDecoder.java:326) at sun.nio.cs.StreamDecoder.read(StreamDecoder.java:178) at java.io.InputStreamReader.read(InputStreamReader.java:184) at java.io.BufferedReader.fill(BufferedReader.java:161) at java.io.BufferedReader.readLine(BufferedReader.java:324) at java.io.BufferedReader.readLine(BufferedReader.java:389) at com.test.Main.main(Main.java:41) 我们之前使用的都是通过构造方法直接连接服务端，那么是否可以等到我们想要的时候再去连接呢？ try (Socket socket = new Socket(); //调用无参构造不会自动连接 Scanner scanner = new Scanner(System.in)){ socket.connect(new InetSocketAddress(\"localhost\", 8080), 1000); //手动调用connect方法进行连接 如果连接的双方发生意外而通知不到对方，导致一方还持有连接，这样就会占用资源，因此我们可以使用setKeepAlive()方法来防止此类情况发生： socket.setKeepAlive(true); 当客户端连接后，如果设置了keeplive为 true，当对方没有发送任何数据过来，超过一个时间(看系统内核参数配置)，那么我们这边会发送一个ack探测包发到对方，探测双方的TCP/IP连接是否有效。 TCP在传输过程中，实际上会有一个缓冲区用于数据的发送和接收： 此缓冲区大小为：8192，我们可以手动调整其大小来优化传输效率： socket.setReceiveBufferSize(25565); /","date":"2022-01-26","objectID":"/posts/java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/:3:0","tags":["JavaWeb第一节"],"title":"Java网络编程","uri":"/posts/java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"categories":["JavaWeb笔记"],"content":"使用Socket传输文件 既然Socket为我们提供了IO流便于数据传输，那么我们就可以轻松地实现文件传输了。 ","date":"2022-01-26","objectID":"/posts/java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/:4:0","tags":["JavaWeb第一节"],"title":"Java网络编程","uri":"/posts/java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"categories":["JavaWeb笔记"],"content":"使用浏览器访问Socket服务器 在了解了如何使用Socket传输文件后，我们来看看，浏览器是如何向服务器发起请求的： public static void main(String[] args) { try(ServerSocket server = new ServerSocket(8080)){ //将服务端创建在端口8080上 System.out.println(\"正在等待客户端连接...\"); Socket socket = server.accept(); System.out.println(\"客户端已连接，IP地址为：\"+socket.getInetAddress().getHostAddress()); InputStream in = socket.getInputStream(); //通过 System.out.println(\"接收到客户端数据：\"); while (true){ int i = in.read(); if(i == -1) break; System.out.print((char) i); } }catch (Exception e){ e.printStackTrace(); } } 我们现在打开浏览器，输入http://localhost:8080或是http://127.0.0.1:8080/，来连接我们本地开放的服务器。 我们发现浏览器是无法打开这个链接的，但是我们服务端却收到了不少的信息： GET / HTTP/1.1\rHost: 127.0.0.1:8080\rConnection: keep-alive\rCache-Control: max-age=0\rsec-ch-ua: \"Chromium\";v=\"94\", \"Google Chrome\";v=\"94\", \";Not A Brand\";v=\"99\"\rsec-ch-ua-mobile: ?0\rsec-ch-ua-platform: \"macOS\"\rUpgrade-Insecure-Requests: 1\rUser-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/94.0.4606.81 Safari/537.36\rAccept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9\rSec-Fetch-Site: none\rSec-Fetch-Mode: navigate\rSec-Fetch-User: ?1\rSec-Fetch-Dest: document\rAccept-Encoding: gzip, deflate, br\rAccept-Language: zh-CN,zh;q=0.9,und;q=0.8,en;q=0.7\r实际上这些内容都是Http协议规定的请求头内容。HTTP是一种应用层协议，全称为超文本传输协议，它本质也是基于TCP协议进行数据传输，因此我们的服务端能够读取HTTP请求。但是Http协议并不会保持长连接，在得到我们响应的数据后会立即关闭TCP连接。 既然使用的是Http连接，如果我们的服务器要支持响应HTTP请求，那么就需要按照HTTP协议的规则，返回一个规范的响应文本，首先是响应头，它至少要包含一个响应码： HTTP/1.1 200 Accpeted\r然后就是响应内容（注意一定要换行再写），我们尝试来编写一下支持HTTP协议的响应内容： public static void main(String[] args) { try(ServerSocket server = new ServerSocket(8080)){ //将服务端创建在端口8080上 System.out.println(\"正在等待客户端连接...\"); Socket socket = server.accept(); System.out.println(\"客户端已连接，IP地址为：\"+socket.getInetAddress().getHostAddress()); BufferedReader reader = new BufferedReader(new InputStreamReader(socket.getInputStream())); //通过 System.out.println(\"接收到客户端数据：\"); while (reader.ready()) System.out.println(reader.readLine()); //ready是判断当前流中是否还有可读内容 OutputStreamWriter writer = new OutputStreamWriter(socket.getOutputStream()); writer.write(\"HTTP/1.1 200 Accepted\\r\\n\"); //200是响应码，Http协议规定200为接受请求，400为错误的请求，404为找不到此资源（不止这些，还有很多） writer.write(\"\\r\\n\"); //在请求头写完之后还要进行一次换行，然后写入我们的响应实体（会在浏览器上展示的内容） writer.write(\"lbwnb!\"); writer.flush(); }catch (Exception e){ e.printStackTrace(); } } 我们可以打开浏览器的开发者模式（这里推荐使用Chrome/Edge浏览器，按下F12即可打开），我们来观察一下浏览器的实际请求过程。 ","date":"2022-01-26","objectID":"/posts/java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/:5:0","tags":["JavaWeb第一节"],"title":"Java网络编程","uri":"/posts/java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"categories":["Linux网络编程"],"content":"TCP网络编程中connect、listen、accept三者之间的关系","date":"2022-01-26","objectID":"/posts/tcp%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E4%B8%ADconnectlistenaccept%E4%B8%89%E8%80%85%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB/","tags":["TCP网络编程中connect、listen、accept三者之间的关系"],"title":"TCP网络编程中connect、listen、accept三者之间的关系","uri":"/posts/tcp%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E4%B8%ADconnectlistenaccept%E4%B8%89%E8%80%85%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB/"},{"categories":["Linux网络编程"],"content":" 基于 TCP 的网络编程开发分为服务器端和客户端两部分，常见的核心步骤和流程如下： 整个函数调用(image)\"\r整个函数调用(image)\r ","date":"2022-01-26","objectID":"/posts/tcp%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E4%B8%ADconnectlistenaccept%E4%B8%89%E8%80%85%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB/:0:0","tags":["TCP网络编程中connect、listen、accept三者之间的关系"],"title":"TCP网络编程中connect、listen、accept三者之间的关系","uri":"/posts/tcp%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E4%B8%ADconnectlistenaccept%E4%B8%89%E8%80%85%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB/"},{"categories":["Linux网络编程"],"content":"accept()函数 对于客户端的 connect() 函数，该函数的功能为客户端主动连接服务器，建立连接是通过三次握手，而这个连接的过程是由内核完成，不是这个函数完成的，这个函数的作用仅仅是通知 Linux 内核，让 Linux 内核自动完成 TCP 三次握手连接，最后把连接的结果返回给这个函数的返回值（成功连接为0， 失败为-1）。 通常的情况，客户端的 connect() 函数默认会一直阻塞，直到三次握手成功或超时失败才返回（正常的情况，这个过程很快完成）。 ","date":"2022-01-26","objectID":"/posts/tcp%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E4%B8%ADconnectlistenaccept%E4%B8%89%E8%80%85%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB/:1:0","tags":["TCP网络编程中connect、listen、accept三者之间的关系"],"title":"TCP网络编程中connect、listen、accept三者之间的关系","uri":"/posts/tcp%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E4%B8%ADconnectlistenaccept%E4%B8%89%E8%80%85%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB/"},{"categories":["Linux网络编程"],"content":"listen()函数 对于服务器，它是被动连接的。举一个生活中的例子，通常的情况下，移动的客服（相当于服务器）是等待着客户（相当于客户端）电话的到来。而这个过程，需要调用listen()函数。 #include\u003csys/socket.h\u003eint listen(int sockfd, int backlog); listen() 函数的主要作用就是将套接字( sockfd )变成被动的连接监听套接字（被动等待客户端的连接），至于参数 backlog 的作用是设置内核中连接队列的长度（这个长度有什么用，后面做详细的解释），TCP 三次握手也不是由这个函数完成，listen()的作用仅仅告诉内核一些信息。 这样的话，当有一个客户端主动连接 connect()，Linux 内核就自动完成TCP 三次握手，将建立好的链接自动存储到队列中，如此重复。 所以，只要 TCP 服务器调用了 listen()，客户端就可以通过 connect() 和服务器建立连接，而这个连接的过程是由内核完成。 三次握手\"\r三次握手\r 下面为测试的服务器和客户端代码，运行程序时，要先运行服务器，再运行客户端： 服务器： #include \u003cstdio.h\u003e#include \u003cstdlib.h\u003e#include \u003cstring.h\u003e #include \u003cunistd.h\u003e#include \u003csys/socket.h\u003e#include \u003cnetinet/in.h\u003e#include \u003carpa/inet.h\u003e int main(int argc, char *argv[]) { unsigned short port = 8000; int sockfd; sockfd = socket(AF_INET, SOCK_STREAM, 0);// 创建通信端点：套接字 if(sockfd \u003c 0) { perror(\"socket\"); exit(-1); } struct sockaddr_in my_addr; bzero(\u0026my_addr, sizeof(my_addr)); my_addr.sin_family = AF_INET; my_addr.sin_port = htons(port); my_addr.sin_addr.s_addr = htonl(INADDR_ANY); int err_log = bind(sockfd, (struct sockaddr*)\u0026my_addr, sizeof(my_addr)); if( err_log != 0) { perror(\"binding\"); close(sockfd); exit(-1); } err_log = listen(sockfd, 10); if(err_log != 0) { perror(\"listen\"); close(sockfd); exit(-1); } printf(\"listen client @port=%d...\\n\",port); sleep(10); // 延时10s system(\"netstat -an | grep 8000\"); // 查看连接状态 return 0; } 客户端 #include \u003cstdio.h\u003e#include \u003cunistd.h\u003e#include \u003cstring.h\u003e#include \u003cstdlib.h\u003e#include \u003carpa/inet.h\u003e#include \u003csys/socket.h\u003e#include \u003cnetinet/in.h\u003eint main(int argc, char *argv[]) { unsigned short port = 8000; // 服务器的端口号 char *server_ip = \"10.221.20.12\"; // 服务器ip地址 int sockfd; sockfd = socket(AF_INET, SOCK_STREAM, 0);// 创建通信端点：套接字 if(sockfd \u003c 0) { perror(\"socket\"); exit(-1); } struct sockaddr_in server_addr; bzero(\u0026server_addr,sizeof(server_addr)); // 初始化服务器地址 server_addr.sin_family = AF_INET; server_addr.sin_port = htons(port); inet_pton(AF_INET, server_ip, \u0026server_addr.sin_addr); int err_log = connect(sockfd, (struct sockaddr*)\u0026server_addr, sizeof(server_addr)); // 主动连接服务器 if(err_log != 0) { perror(\"connect\"); close(sockfd); exit(-1); } system(\"netstat -an | grep 8000\"); // 查看连接状态 while(1); return 0; } 运行结果： ","date":"2022-01-26","objectID":"/posts/tcp%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E4%B8%ADconnectlistenaccept%E4%B8%89%E8%80%85%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB/:2:0","tags":["TCP网络编程中connect、listen、accept三者之间的关系"],"title":"TCP网络编程中connect、listen、accept三者之间的关系","uri":"/posts/tcp%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E4%B8%ADconnectlistenaccept%E4%B8%89%E8%80%85%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB/"},{"categories":["Linux网络编程"],"content":"三次握手的连接队列 这里详细的介绍一下 listen() 函数的第二个参数（ backlog）的作用：告诉内核连接队列的长度。 为了更好的理解 backlog 参数，我们必须认识到内核为任何一个给定的监听套接口维护两个队列： 未完成连接队列（incomplete connection queue），以某个客户发出并到达服务器，而服务器正在等待完成相应的 TCP 三次握手过程。这些端口都处于处于 SYN_RCVD 状态。 已完成连接队列（completed connection queue），这些端口处于 ESTABLISHED 状态。 当来自客户的 SYN 到达时，TCP 在未完成连接队列中创建一个新项，然后响应以三次握手的第二个分节：服务器的 SYN 响应，其中稍带对客户 SYN 的 ACK（即SYN+ACK），这一项一直保留在未完成连接队列中，直到三次握手的第三个分节（客户对服务器 SYN 的 ACK ）到达或者该项超时为止（源自Berkeley的实现为这些未完成连接的项设置的超时值为75秒）。 如果三次握手正常完成，该项就从未完成连接队列移到已完成连接队列的队尾。 backlog 参数历史上被定义为上面两个队列的大小之和，大多数实现默认值为 5，当服务器把这个完成连接队列的某个连接取走后，这个队列的位置又空出一个，这样来回实现动态平衡，但在高并发 web 服务器中此值显然不够。 ","date":"2022-01-26","objectID":"/posts/tcp%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E4%B8%ADconnectlistenaccept%E4%B8%89%E8%80%85%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB/:3:0","tags":["TCP网络编程中connect、listen、accept三者之间的关系"],"title":"TCP网络编程中connect、listen、accept三者之间的关系","uri":"/posts/tcp%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E4%B8%ADconnectlistenaccept%E4%B8%89%E8%80%85%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB/"},{"categories":["Linux网络编程"],"content":"accept()函数 accept()函数功能是，从处于 established 状态的连接队列头部取出一个已经完成的连接，如果这个队列没有已经完成的连接，accept()函数就会阻塞，直到取出队列中已完成的用户连接为止。 如果，服务器不能及时调用 accept() 取走队列中已完成的连接，队列满掉后会怎样呢？UNP（《unix网络编程》）告诉我们，服务器的连接队列满掉后，服务器不会对再对建立新连接的syn进行应答，所以客户端的 connect 就会返回 ETIMEDOUT。但实际上Linux的并不是这样的！ ","date":"2022-01-26","objectID":"/posts/tcp%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E4%B8%ADconnectlistenaccept%E4%B8%89%E8%80%85%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB/:4:0","tags":["TCP网络编程中connect、listen、accept三者之间的关系"],"title":"TCP网络编程中connect、listen、accept三者之间的关系","uri":"/posts/tcp%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E4%B8%ADconnectlistenaccept%E4%B8%89%E8%80%85%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB/"},{"categories":["Linux网络编程"],"content":"实验 下面为测试代码，服务器 listen() 函数只指定队列长度为 2，客户端有 6 个不同的套接字主动连接服务器，同时，保证客户端的 6 个 connect()函数都先调用完毕，服务器的 accpet() 才开始调用。 服务端： #include \u003cstdio.h\u003e#include \u003cstdlib.h\u003e#include \u003cstring.h\u003e #include \u003cunistd.h\u003e#include \u003csys/socket.h\u003e#include \u003cnetinet/in.h\u003e#include \u003carpa/inet.h\u003e int main(int argc, char *argv[]) { unsigned short port = 8000; int sockfd = socket(AF_INET, SOCK_STREAM, 0); if(sockfd \u003c 0) { perror(\"socket\"); exit(-1); } struct sockaddr_in my_addr; bzero(\u0026my_addr, sizeof(my_addr)); my_addr.sin_family = AF_INET; my_addr.sin_port = htons(port); my_addr.sin_addr.s_addr = htonl(INADDR_ANY); int err_log = bind(sockfd, (struct sockaddr*)\u0026my_addr, sizeof(my_addr)); if( err_log != 0) { perror(\"binding\"); close(sockfd); exit(-1); } err_log = listen(sockfd, 2); // 等待队列为2 if(err_log != 0) { perror(\"listen\"); close(sockfd); exit(-1); } printf(\"after listen\\n\"); sleep(20); //延时 20秒 printf(\"listen client @port=%d...\\n\",port); int i = 0; while(1) { struct sockaddr_in client_addr; char cli_ip[INET_ADDRSTRLEN] = \"\"; socklen_t cliaddr_len = sizeof(client_addr); int connfd; connfd = accept(sockfd, (struct sockaddr*)\u0026client_addr, \u0026cliaddr_len); if(connfd \u003c 0) { perror(\"accept\"); continue; } inet_ntop(AF_INET, \u0026client_addr.sin_addr, cli_ip, INET_ADDRSTRLEN); printf(\"-----------%d------\\n\", ++i); printf(\"client ip=%s,port=%d\\n\", cli_ip,ntohs(client_addr.sin_port)); char recv_buf[512] = {0}; while( recv(connfd, recv_buf, sizeof(recv_buf), 0) \u003e 0 ) { printf(\"recv data ==%s\\n\",recv_buf); break; } close(connfd); //关闭已连接套接字 //printf(\"client closed!\\n\"); } close(sockfd); //关闭监听套接字 return 0; } 客户端： #include \u003cstdio.h\u003e#include \u003cunistd.h\u003e#include \u003cstring.h\u003e#include \u003cstdlib.h\u003e#include \u003carpa/inet.h\u003e#include \u003csys/socket.h\u003e#include \u003cnetinet/in.h\u003e void test_connect() { unsigned short port = 8000; // 服务器的端口号 char *server_ip = \"10.221.20.12\"; // 服务器ip地址 int sockfd; sockfd = socket(AF_INET, SOCK_STREAM, 0);// 创建通信端点：套接字 if(sockfd \u003c 0) { perror(\"socket\"); exit(-1); } struct sockaddr_in server_addr; bzero(\u0026server_addr,sizeof(server_addr)); // 初始化服务器地址 server_addr.sin_family = AF_INET; server_addr.sin_port = htons(port); inet_pton(AF_INET, server_ip, \u0026server_addr.sin_addr); int err_log = connect(sockfd, (struct sockaddr*)\u0026server_addr, sizeof(server_addr)); // 主动连接服务器 if(err_log != 0) { perror(\"connect\"); close(sockfd); exit(-1); } printf(\"err_log ========= %d\\n\", err_log); char send_buf[100]=\"this is for test\"; send(sockfd, send_buf, strlen(send_buf), 0); // 向服务器发送信息 system(\"netstat -an | grep 8000\"); // 查看连接状态 //close(sockfd); } int main(int argc, char *argv[]) { pid_t pid; pid = fork(); if(0 == pid){ test_connect(); // 1 pid_t pid = fork(); if(0 == pid){ test_connect(); // 2 }else if(pid \u003e 0){ test_connect(); // 3 } }else if(pid \u003e 0){ test_connect(); // 4 pid_t pid = fork(); if(0 == pid){ test_connect(); // 5 }else if(pid \u003e 0){ test_connect(); // 6 } } while(1); return 0; } 服务器调用 accept()函数前延时了 20 秒。保证了客户端的 connect() 全部调用完毕后再调用 accept(),运行结果如下： 客户端运行效果图： 按照 UNP 的说法，连接队列满后（这里设置长度为 2，发了 6 个连接），以后再调用 connect() 应该统统超时失败，但实际上测试结果是：有的 connect()立刻成功返回了，有的经过明显延迟后成功返回了。对于服务器 accpet() 函数也是这样的结果：有的立马成功返回，有的延迟后成功返回。 对于上面服务器的代码，我们把lisen()的第二个参数改为 0 ，重新运行程序，发现： 客户端 connect() 全部返回连接成功（有些会延时）： 服务器 accpet() 函数却不能把连接队列的所有连接都取出来： 对于上面服务器的代码，我们把lisen()的第二个参数改为大于 6 的数(如 10)，重新运行程序，发现，客户端 connect() 立马返回连接成功， 服务器 accpet() 函数也立马返回成功。 ","date":"2022-01-26","objectID":"/posts/tcp%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E4%B8%ADconnectlistenaccept%E4%B8%89%E8%80%85%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB/:4:1","tags":["TCP网络编程中connect、listen、accept三者之间的关系"],"title":"TCP网络编程中connect、listen、accept三者之间的关系","uri":"/posts/tcp%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E4%B8%ADconnectlistenaccept%E4%B8%89%E8%80%85%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB/"},{"categories":["Linux网络编程"],"content":"总结 TCP 的连接队列满后，Linux 不会如书中所说的拒绝连接，只是有些会延时连接，但千万注意此时accept()就不一定能把已经建立好的连接全部取出来（如：当队列的长度指定为 0 ），写程序时服务器的 listen() 的第二个参数最好还是根据需要填写，写太大不好（具体可以看cat /proc/sys/net/core/somaxconn，默认最大值限制是 128），浪费资源，写太小也不好，延时建立连接。 ","date":"2022-01-26","objectID":"/posts/tcp%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E4%B8%ADconnectlistenaccept%E4%B8%89%E8%80%85%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB/:4:2","tags":["TCP网络编程中connect、listen、accept三者之间的关系"],"title":"TCP网络编程中connect、listen、accept三者之间的关系","uri":"/posts/tcp%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E4%B8%ADconnectlistenaccept%E4%B8%89%E8%80%85%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB/"},{"categories":["现代C++语法"],"content":"C++与python文件系统对比","date":"2022-01-25","objectID":"/posts/c++%E4%B8%8Epython%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%AF%B9%E6%AF%94/","tags":["C++与python文件系统对比"],"title":"C++与python文件系统对比","uri":"/posts/c++%E4%B8%8Epython%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%AF%B9%E6%AF%94/"},{"categories":["现代C++语法"],"content":"C++17 和 python 中好用的文件操作 | filesystem | os | shutil C++ 17 python 功能 filesystem::path::is_absolute() os.path.isabs() 判断是否为绝对路径 filesystem::path::parent_path() os.path.dirname() 路径分割 filesystem::path::filename() os.path.basename() 路径分割 filesystem::operator/() os.path.join() 路径拼接 filesystem::current_path() os.getcwd() 获取当前路径 filesystem::directory_iterator os.listdir() 返回指定目录下的所有文件/文件夹 filesystem::recursive_directory_iterator os.walk() 递归返回指定目录下的所有文件/文件夹 filesystem::exists() os.path.exists() 判断路径是否存在 filesystem::is_regular_file() os.path.isfile() 判断路径是文件还是目录 filesystem::is_directory() os.path.isdir() 判断路径是文件还是目录 filesystem::absolute() os.path.abspath() 返回绝对路径 filesystem::copy_file() shutil.copyfile() 文件拷贝 filesystem::remove() os.remove() 文件删除 filesystem::copy() shutil.copytree 路径拷贝 filesystem::remove_all shutil.rmtree() 路径删除 ","date":"2022-01-25","objectID":"/posts/c++%E4%B8%8Epython%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%AF%B9%E6%AF%94/:0:0","tags":["C++与python文件系统对比"],"title":"C++与python文件系统对比","uri":"/posts/c++%E4%B8%8Epython%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%AF%B9%E6%AF%94/"},{"categories":["现代C++语法"],"content":"filesystem::path vs. os.path filesystem::path是一个类，里面封装了很多方法，我们通过实例化之后直接调用方法。 os.path是一个模块，里面有很多函数，可以直接调用。 ","date":"2022-01-25","objectID":"/posts/c++%E4%B8%8Epython%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%AF%B9%E6%AF%94/:1:0","tags":["C++与python文件系统对比"],"title":"C++与python文件系统对比","uri":"/posts/c++%E4%B8%8Epython%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%AF%B9%E6%AF%94/"},{"categories":["现代C++语法"],"content":"判断是否为绝对路径 什么是绝对路径？我个人的理解是从根目录开始的就是绝对路径，例如/usr/local和C:\\\\Users，其余都是相对路径。可以发现，在不同操作系统中路径的分割符是不同的。同时在相对路径中./和../有特殊含义，./表示当前目录，../表示上一层目录，相应地，../../就是上两层目录。 1.filesystem::path中提供了判断是否为绝对路径/相对路径方法。 _LIBCPP_INLINE_VISIBILITY bool is_absolute() const { return has_root_directory(); } _LIBCPP_INLINE_VISIBILITY bool is_relative() const { return !is_absolute(); } 可以发现，判断相对路径的结果就是绝对路径取反。 void eg1_1() { /*判断是否为绝对路径*/ // std::filesystem::path abs_path = \"C:\\\\Users\"; std::filesystem::path abs_path = \"/usr/local\"; // 注意，实例化path的时候可以直接用等号 std::cout \u003c\u003c \"abs_path.is_absolute() : \" \u003c\u003c abs_path.is_absolute() \u003c\u003c std::endl; std::cout \u003c\u003c \"abs_path.is_relative() : \" \u003c\u003c abs_path.is_relative() \u003c\u003c std::endl; std::filesystem::path rel_path = \"../\"; std::cout \u003c\u003c \"rel_path.is_absolute() : \" \u003c\u003c rel_path.is_absolute() \u003c\u003c std::endl; std::cout \u003c\u003c \"rel_path.is_relative() : \" \u003c\u003c rel_path.is_relative() \u003c\u003c std::endl; } abs_path.is_absolute() : 1 abs_path.is_relative() : 0 rel_path.is_absolute() : 0 rel_path.is_relative() : 1 os.path中提供了isabs()函数用于判断是否为绝对路径。 def eg1_1(): \"\"\"判断是否为绝对路径\"\"\" # abs_path = \"C:\\\\Users\" abs_path = \"/usr/local\" print(\"os.path.isabs({}) : {}\".format(abs_path, os.path.isabs(abs_path))) rel_path = \"../\" print(\"os.path.isabs({}) : {}\".format(rel_path, os.path.isabs(rel_path))) os.path.isabs(/usr/local) : True os.path.isabs(../) : False ","date":"2022-01-25","objectID":"/posts/c++%E4%B8%8Epython%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%AF%B9%E6%AF%94/:1:1","tags":["C++与python文件系统对比"],"title":"C++与python文件系统对比","uri":"/posts/c++%E4%B8%8Epython%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%AF%B9%E6%AF%94/"},{"categories":["现代C++语法"],"content":"路径分割 filesystem::path中提供了路径分割的方法。 // decomposition _LIBCPP_INLINE_VISIBILITY path root_name() const { return string_type(__root_name()); } _LIBCPP_INLINE_VISIBILITY path root_directory() const { return string_type(__root_directory()); } _LIBCPP_INLINE_VISIBILITY path root_path() const { return root_name().append(string_type(__root_directory())); } _LIBCPP_INLINE_VISIBILITY path relative_path() const { return string_type(__relative_path()); } _LIBCPP_INLINE_VISIBILITY path parent_path() const { return string_type(__parent_path()); } _LIBCPP_INLINE_VISIBILITY path filename() const { return string_type(__filename()); } _LIBCPP_INLINE_VISIBILITY path stem() const { return string_type(__stem()); } _LIBCPP_INLINE_VISIBILITY path extension() const { return string_type(__extension()); } void eg1_2() { /*路径分割*/ std::filesystem::path path = \"../test_dir/1.txt\"; std::cout \u003c\u003c \"path.relative_path() : \" \u003c\u003c path.relative_path() \u003c\u003c std::endl; std::cout \u003c\u003c \"path.parent_path() : \" \u003c\u003c path.parent_path() \u003c\u003c std::endl; std::cout \u003c\u003c \"path.filename() : \" \u003c\u003c path.filename() \u003c\u003c std::endl; std::cout \u003c\u003c \"path.stem() : \" \u003c\u003c path.stem() \u003c\u003c std::endl; std::cout \u003c\u003c \"path.extension() : \" \u003c\u003c path.extension() \u003c\u003c std::endl; } path.relative_path() : \"../test_dir/1.txt\" path.parent_path() : \"../test_dir\" path.filename() : \"1.txt\" path.stem() : \"1\" path.extension() : \".txt\" os.path中提供了分割函数split()以及dirname()，basename()。 def eg1_2(): \"\"\"路径分割\"\"\" path = \"../test_dir/1.txt\" print(\"os.path.split(path) : {}\".format(os.path.split(path))) print(\"os.path.dirname(path) : {}\".format(os.path.dirname(path))) print(\"os.path.basename(path) : {}\".format(os.path.basename(path))) os.path.split(path) : ('../test_dir', '1.txt') os.path.dirname(path) : ../test_dir os.path.basename(path) : 1.txt ","date":"2022-01-25","objectID":"/posts/c++%E4%B8%8Epython%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%AF%B9%E6%AF%94/:1:2","tags":["C++与python文件系统对比"],"title":"C++与python文件系统对比","uri":"/posts/c++%E4%B8%8Epython%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%AF%B9%E6%AF%94/"},{"categories":["现代C++语法"],"content":"路径拼接 filesystem::path中重载了符号/和/=。 friend _LIBCPP_INLINE_VISIBILITY path operator/(const path\u0026 __lhs, const path\u0026 __rhs) { path __result(__lhs); __result /= __rhs; return __result; } void eg1_3() { /*路径拼接*/ std::filesystem::path path = \"../test_dir\"; std::filesystem::path txt1_path = path / \"1.txt\"; std::filesystem::path txt2_path = path / \"1_dir\" / \"2.txt\"; std::cout \u003c\u003c \"txt1_path : \" \u003c\u003c txt1_path \u003c\u003c std::endl; std::cout \u003c\u003c \"txt2_path : \" \u003c\u003c txt2_path \u003c\u003c std::endl; path /= \"1.txt\"; std::cout \u003c\u003c \"path : \" \u003c\u003c path \u003c\u003c std::endl; } txt1_path : \"../test_dir/1.txt\" txt2_path : \"../test_dir/1_dir/2.txt\" path : \"../test_dir/1.txt\" os.path中提供了join()函数。 def eg1_3(): \"\"\"路径拼接\"\"\" path = \"../test_dir\" txt1_path = os.path.join(path, \"1.txt\") txt2_path = os.path.join(path, \"1_dir\", \"2.txt\") print(\"txt1_path : {}\".format(txt1_path)) print(\"txt2_path : {}\".format(txt2_path)) txt1_path : ../test_dir/1.txt txt2_path : ../test_dir/1_dir/2.txt 注意，不同操作系统的分隔符不同，所以在Windows中运行结果如下。 txt1_path : ../test_dir\\1.txt txt2_path : ../test_dir\\1_dir\\2.txt ","date":"2022-01-25","objectID":"/posts/c++%E4%B8%8Epython%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%AF%B9%E6%AF%94/:1:3","tags":["C++与python文件系统对比"],"title":"C++与python文件系统对比","uri":"/posts/c++%E4%B8%8Epython%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%AF%B9%E6%AF%94/"},{"categories":["现代C++语法"],"content":"filesystem vs. os ","date":"2022-01-25","objectID":"/posts/c++%E4%B8%8Epython%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%AF%B9%E6%AF%94/:2:0","tags":["C++与python文件系统对比"],"title":"C++与python文件系统对比","uri":"/posts/c++%E4%B8%8Epython%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%AF%B9%E6%AF%94/"},{"categories":["现代C++语法"],"content":"获取当前工作目录 filesystem提供了获取当前路径的函数current_path()，注意返回的是绝对路径。 void eg2_1() { /*获取当前路径*/ std::filesystem::path current_path = std::filesystem::current_path(); std::cout \u003c\u003c \"current_path : \" \u003c\u003c current_path \u003c\u003c std::endl; } current_path : \"/Users/xxx/Github/intro_to_C-python/xxx/cmake-build-debug\" os提供了函数getcwd()。 def eg2_1(): \"\"\"获取当前路径\"\"\" current_path = os.getcwd() print(\"current_path : {}\".format(current_path)) current_path : /Users/xxx/Github/intro_to_C-python/xxx 这里先展示一下目录树，方便理解后边的例子。 └── test_dir ├── 1.txt └── 1_dir ├── 2.txt └── empty_dir ","date":"2022-01-25","objectID":"/posts/c++%E4%B8%8Epython%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%AF%B9%E6%AF%94/:2:1","tags":["C++与python文件系统对比"],"title":"C++与python文件系统对比","uri":"/posts/c++%E4%B8%8Epython%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%AF%B9%E6%AF%94/"},{"categories":["现代C++语法"],"content":"返回指定目录下的所有文件/文件夹 filesystem的类directory_iterator可以实现该功能。 void eg2_2() { /*返回指定目录下的所有文件/文件夹*/ std::filesystem::directory_iterator iter(\"../test_dir\"); for(const auto \u0026i : iter) { std::cout \u003c\u003c i.path() \u003c\u003cstd::endl; } } \"../test_dir/1.txt\" \"../test_dir/1_dir\" os中提供了函数listdir()。 def eg2_2(): \"\"\"返回指定目录下的所有文件/文件夹\"\"\" for i in os.listdir(\"./test_dir\"): print(i) 1.txt 1_dir ","date":"2022-01-25","objectID":"/posts/c++%E4%B8%8Epython%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%AF%B9%E6%AF%94/:2:2","tags":["C++与python文件系统对比"],"title":"C++与python文件系统对比","uri":"/posts/c++%E4%B8%8Epython%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%AF%B9%E6%AF%94/"},{"categories":["现代C++语法"],"content":"递归返回指定目录下的所有文件/文件夹 filesystem的类recursive_directory_iterator可以实现该功能。 void eg2_3() { /*递归返回指定目录下的所有文件/文件夹*/ std::filesystem::recursive_directory_iterator iter(\"../test_dir\"); for(const auto \u0026i : iter) { std::cout \u003c\u003c i.path() \u003c\u003cstd::endl; } } \"../test_dir/1.txt\" \"../test_dir/1_dir\" \"../test_dir/1_dir/empty_dir\" \"../test_dir/1_dir/2.txt\" os中提供了函数walk()。 def eg2_3(): \"\"\"递归返回指定目录下的所有文件/文件夹\"\"\" for root, dirs, files in os.walk(\"./test_dir\"): print(\"root : {}, dirs : {}, files : {}\".format(root, dirs, files)) root : ./test_dir, dirs : ['1_dir'], files : ['1.txt'] root : ./test_dir/1_dir, dirs : ['empty_dir'], files : ['2.txt'] root : ./test_dir/1_dir/empty_dir, dirs : [], files : [] ","date":"2022-01-25","objectID":"/posts/c++%E4%B8%8Epython%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%AF%B9%E6%AF%94/:2:3","tags":["C++与python文件系统对比"],"title":"C++与python文件系统对比","uri":"/posts/c++%E4%B8%8Epython%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%AF%B9%E6%AF%94/"},{"categories":["现代C++语法"],"content":"判断路径是否存在 filesystem提供了判断路径是否存在的函数exists()。 void eg2_4() { /*判断路径是否存在*/ bool exist = std::filesystem::exists(\"C:\\\\Users\"); std::cout \u003c\u003c \"exist : \" \u003c\u003c exist \u003c\u003c std::endl; } exist : 0 os.path中提供了函数exists()。 def eg2_4(): \"\"\"判断路径是否存在\"\"\" path = \"C:\\\\Users\" print(\"os.path.exists({}) : {}\".format(path, os.path.exists(path))) os.path.exists(C:\\Users) : False ","date":"2022-01-25","objectID":"/posts/c++%E4%B8%8Epython%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%AF%B9%E6%AF%94/:2:4","tags":["C++与python文件系统对比"],"title":"C++与python文件系统对比","uri":"/posts/c++%E4%B8%8Epython%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%AF%B9%E6%AF%94/"},{"categories":["现代C++语法"],"content":"判断路径是文件还是目录 filesystem提供了判断路径是文件还是目录的函数。（比较多） inline _LIBCPP_INLINE_VISIBILITY bool is_block_file(file_status __s) noexcept { return __s.type() == file_type::block; } inline _LIBCPP_INLINE_VISIBILITY bool is_block_file(const path\u0026 __p) { return is_block_file(__status(__p)); } inline _LIBCPP_INLINE_VISIBILITY bool is_block_file(const path\u0026 __p, error_code\u0026 __ec) noexcept { return is_block_file(__status(__p, \u0026__ec)); } inline _LIBCPP_INLINE_VISIBILITY bool is_character_file(file_status __s) noexcept { return __s.type() == file_type::character; } inline _LIBCPP_INLINE_VISIBILITY bool is_character_file(const path\u0026 __p) { return is_character_file(__status(__p)); } inline _LIBCPP_INLINE_VISIBILITY bool is_character_file(const path\u0026 __p, error_code\u0026 __ec) noexcept { return is_character_file(__status(__p, \u0026__ec)); } inline _LIBCPP_INLINE_VISIBILITY bool is_directory(file_status __s) noexcept { return __s.type() == file_type::directory; } inline _LIBCPP_INLINE_VISIBILITY bool is_directory(const path\u0026 __p) { return is_directory(__status(__p)); } inline _LIBCPP_INLINE_VISIBILITY bool is_directory(const path\u0026 __p, error_code\u0026 __ec) noexcept { return is_directory(__status(__p, \u0026__ec)); } inline _LIBCPP_INLINE_VISIBILITY bool is_empty(const path\u0026 __p) { return __fs_is_empty(__p); } inline _LIBCPP_INLINE_VISIBILITY bool is_empty(const path\u0026 __p, error_code\u0026 __ec) { return __fs_is_empty(__p, \u0026__ec); } inline _LIBCPP_INLINE_VISIBILITY bool is_fifo(file_status __s) noexcept { return __s.type() == file_type::fifo; } inline _LIBCPP_INLINE_VISIBILITY bool is_fifo(const path\u0026 __p) { return is_fifo(__status(__p)); } inline _LIBCPP_INLINE_VISIBILITY bool is_fifo(const path\u0026 __p, error_code\u0026 __ec) noexcept { return is_fifo(__status(__p, \u0026__ec)); } inline _LIBCPP_INLINE_VISIBILITY bool is_regular_file(file_status __s) noexcept { return __s.type() == file_type::regular; } inline _LIBCPP_INLINE_VISIBILITY bool is_regular_file(const path\u0026 __p) { return is_regular_file(__status(__p)); } inline _LIBCPP_INLINE_VISIBILITY bool is_regular_file(const path\u0026 __p, error_code\u0026 __ec) noexcept { return is_regular_file(__status(__p, \u0026__ec)); } inline _LIBCPP_INLINE_VISIBILITY bool is_socket(file_status __s) noexcept { return __s.type() == file_type::socket; } inline _LIBCPP_INLINE_VISIBILITY bool is_socket(const path\u0026 __p) { return is_socket(__status(__p)); } inline _LIBCPP_INLINE_VISIBILITY bool is_socket(const path\u0026 __p, error_code\u0026 __ec) noexcept { return is_socket(__status(__p, \u0026__ec)); } inline _LIBCPP_INLINE_VISIBILITY bool is_symlink(file_status __s) noexcept { return __s.type() == file_type::symlink; } inline _LIBCPP_INLINE_VISIBILITY bool is_symlink(const path\u0026 __p) { return is_symlink(__symlink_status(__p)); } inline _LIBCPP_INLINE_VISIBILITY bool is_symlink(const path\u0026 __p, error_code\u0026 __ec) noexcept { return is_symlink(__symlink_status(__p, \u0026__ec)); } inline _LIBCPP_INLINE_VISIBILITY bool is_other(file_status __s) noexcept { return exists(__s) \u0026\u0026 !is_regular_file(__s) \u0026\u0026 !is_directory(__s) \u0026\u0026 !is_symlink(__s); } inline _LIBCPP_INLINE_VISIBILITY bool is_other(const path\u0026 __p) { return is_other(__status(__p)); } inline _LIBCPP_INLINE_VISIBILITY bool is_other(const path\u0026 __p, error_code\u0026 __ec) noexcept { return is_other(__status(__p, \u0026__ec)); } void eg2_5() { /*判断路径是文件还是目录*/ std::filesystem::path file_path = \"../test_dir/1.txt\"; std::filesystem::path dir_path = \"../test_dir/1_dir\"; std::cout \u003c\u003c \"is_regular_file(file_path) : \" \u003c\u003c std::filesystem::is_regular_file(file_path) \u003c\u003c std::endl; std::cout \u003c\u003c \"is_directory(dir_path) : \" \u003c\u003c std::filesystem::is_directory(dir_path) \u003c\u003c std::endl; } is_regular_file(file_path) : 1 is_directory(dir_path) : 1 os.path中提供了函数isfile()和isdir()。 def eg2_5(): \"\"\"判断路径是文件还是目录\"\"\" file_path = \"./test_dir/1.txt\" dir_path = \"./test_dir/1_dir\" print(\"os.path.isfile({}) : {}\".format(file_path, os.path.isfile(file_path))) print(\"os.path.isdir({}) : {}\".format(dir_path, os.path.isdir(dir_path))) os.path.isfile(./test_dir/1.txt) : True os.path.i","date":"2022-01-25","objectID":"/posts/c++%E4%B8%8Epython%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%AF%B9%E6%AF%94/:2:5","tags":["C++与python文件系统对比"],"title":"C++与python文件系统对比","uri":"/posts/c++%E4%B8%8Epython%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%AF%B9%E6%AF%94/"},{"categories":["现代C++语法"],"content":"返回绝对路径【神奇】 filesystem中提供了函数absolute()。 void eg2_6() { /*返回绝对路径*/ std::filesystem::path path = \"../test_dir\"; std::filesystem::path abs_path = std::filesystem::absolute(path); std::cout \u003c\u003c \"abs_path : \" \u003c\u003c abs_path \u003c\u003c std::endl; std::cout \u003c\u003c \"exists(abs_path) : \" \u003c\u003c std::filesystem::exists(abs_path) \u003c\u003c std::endl; } abs_path : \"/Users/xxx/Github/intro_to_C-python/xxx/cmake-build-debug/../test_dir\" exists(abs_path) : 1 在Windows系统中结果如下。 abs_path : \"D:\\\\GitHub\\\\intro_to_C-python\\\\xxx\\\\test_dir\" exists(abs_path) : 1 os.path中提供了函数abspath()。 def eg2_6(): \"\"\"返回绝对路径\"\"\" path = \"../../-PyTorch-\" abs_path = os.path.abspath(path) print(\"abs_path : {}\".format(abs_path)) print(\"os.path.exists({}) : {}\".format(abs_path, os.path.exists(abs_path))) abs_path : /Users/xxx/Github/-PyTorch- os.path.exists(/Users/xxx/Github/-PyTorch-) : True ","date":"2022-01-25","objectID":"/posts/c++%E4%B8%8Epython%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%AF%B9%E6%AF%94/:2:6","tags":["C++与python文件系统对比"],"title":"C++与python文件系统对比","uri":"/posts/c++%E4%B8%8Epython%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%AF%B9%E6%AF%94/"},{"categories":["现代C++语法"],"content":"filesystem vs. shutil shutil = shell + util，对os进行一些补充。 ","date":"2022-01-25","objectID":"/posts/c++%E4%B8%8Epython%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%AF%B9%E6%AF%94/:3:0","tags":["C++与python文件系统对比"],"title":"C++与python文件系统对比","uri":"/posts/c++%E4%B8%8Epython%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%AF%B9%E6%AF%94/"},{"categories":["现代C++语法"],"content":"文件拷贝 filesystem中提供了copy_file()函数，可以拷贝文件或空文件夹。 void eg3_1() { /*文件拷贝*/ std::cout \u003c\u003c \"~~~~~~before copy_file~~~~~~\" \u003c\u003c std::endl; for (const auto \u0026i :std::filesystem::directory_iterator(\"../test_dir\")) { std::cout \u003c\u003c i.path() \u003c\u003c std::endl; } std::filesystem::copy_file(\"../test_dir/1.txt\", \"../test_dir/eg3_1.txt\"); std::cout \u003c\u003c \"~~~~~~after copy_file~~~~~~\" \u003c\u003c std::endl; for (const auto \u0026i :std::filesystem::directory_iterator(\"../test_dir\")) { std::cout \u003c\u003c i.path() \u003c\u003c std::endl; } } ~~~~~~before copy_file~~~~~~ \"../test_dir/1.txt\" \"../test_dir/1_dir\" ~~~~~~after copy_file~~~~~~ \"../test_dir/eg3_1.txt\" \"../test_dir/1.txt\" \"../test_dir/1_dir\" shutil中提供函数copyfile()。 def eg3_1(): \"\"\"文件拷贝\"\"\" print(\"~~~~~~before copy_file~~~~~~\") for i in os.listdir(\"./test_dir\"): print(i) src_path = \"./test_dir/1.txt\" dst_path = \"./test_dir/eg3_1.txt\" shutil.copyfile(src_path, dst_path) print(\"~~~~~~after copy_file~~~~~~\") for i in os.listdir(\"./test_dir\"): print(i) ~~~~~~before copy_file~~~~~~ 1.txt 1_dir ~~~~~~after copy_file~~~~~~ eg3_1.txt 1.txt 1_dir ","date":"2022-01-25","objectID":"/posts/c++%E4%B8%8Epython%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%AF%B9%E6%AF%94/:3:1","tags":["C++与python文件系统对比"],"title":"C++与python文件系统对比","uri":"/posts/c++%E4%B8%8Epython%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%AF%B9%E6%AF%94/"},{"categories":["现代C++语法"],"content":"文件删除 filesystem中提供了remove()函数，可以删除文件或空文件夹。 void eg3_2() { /*文件删除*/ std::cout \u003c\u003c \"~~~~~~before remove~~~~~~\" \u003c\u003c std::endl; for (const auto \u0026i :std::filesystem::directory_iterator(\"../test_dir\")) { std::cout \u003c\u003c i.path() \u003c\u003c std::endl; } std::filesystem::remove(\"../test_dir/eg3_1.txt\"); std::cout \u003c\u003c \"~~~~~~after remove~~~~~~\" \u003c\u003c std::endl; for (const auto \u0026i :std::filesystem::directory_iterator(\"../test_dir\")) { std::cout \u003c\u003c i.path() \u003c\u003c std::endl; } } ~~~~~~before remove~~~~~~ \"../test_dir/eg3_1.txt\" \"../test_dir/1.txt\" \"../test_dir/1_dir\" ~~~~~~after remove~~~~~~ \"../test_dir/1.txt\" \"../test_dir/1_dir\" os中提供了函数remove()。 def eg3_2(): \"\"\"文件删除\"\"\" print(\"~~~~~~before remove~~~~~~\") for i in os.listdir(\"./test_dir\"): print(i) rm_path = \"./test_dir/eg3_1.txt\" os.remove(rm_path) print(\"~~~~~~after remove~~~~~~\") for i in os.listdir(\"./test_dir\"): print(i) ~~~~~~before remove~~~~~~ eg3_1.txt 1.txt 1_dir ~~~~~~after remove~~~~~~ 1.txt 1_dir ","date":"2022-01-25","objectID":"/posts/c++%E4%B8%8Epython%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%AF%B9%E6%AF%94/:3:2","tags":["C++与python文件系统对比"],"title":"C++与python文件系统对比","uri":"/posts/c++%E4%B8%8Epython%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%AF%B9%E6%AF%94/"},{"categories":["现代C++语法"],"content":"路径拷贝 filesystem中提供了copy()函数，可以按照选项（是否递归）拷贝文件或文件夹。 void eg3_3() { /*路径拷贝*/ std::cout \u003c\u003c \"~~~~~~before copy[1_dir]~~~~~~\" \u003c\u003c std::endl; for (const auto \u0026i :std::filesystem::directory_iterator(\"../test_dir/1_dir\")) { std::cout \u003c\u003c i.path() \u003c\u003c std::endl; } std::filesystem::copy(\"../test_dir/1_dir\", \"../test_dir/eg3_3_dir\", std::filesystem::copy_options::recursive); std::cout \u003c\u003c \"~~~~~~after copy[eg3_3_dir]~~~~~~\" \u003c\u003c std::endl; for (const auto \u0026i :std::filesystem::directory_iterator(\"../test_dir/eg3_3_dir\")) { std::cout \u003c\u003c i.path() \u003c\u003c std::endl; } } ~~~~~~before copy[1_dir]~~~~~~ \"../test_dir/1_dir/empty_dir\" \"../test_dir/1_dir/2.txt\" ~~~~~~after copy[eg3_3_dir]~~~~~~ \"../test_dir/eg3_3_dir/empty_dir\" \"../test_dir/eg3_3_dir/2.txt\" shutil提供了函数copytree()。 def eg3_3(): \"\"\"路径拷贝\"\"\" print(\"~~~~~~before copy[1_dir]~~~~~~\") for i in os.listdir(\"./test_dir/1_dir\"): print(i) src_path = \"./test_dir/1_dir\" dst_path = \"./test_dir/eg3_3_dir\" shutil.copytree(src_path, dst_path) print(\"~~~~~~after copy[eg3_3_dir]~~~~~~\") for i in os.listdir(\"./test_dir/eg3_3_dir\"): print(i) ~~~~~~before copy[1_dir]~~~~~~ empty_dir 2.txt ~~~~~~after copy[eg3_3_dir]~~~~~~ empty_dir 2.txt ","date":"2022-01-25","objectID":"/posts/c++%E4%B8%8Epython%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%AF%B9%E6%AF%94/:3:3","tags":["C++与python文件系统对比"],"title":"C++与python文件系统对比","uri":"/posts/c++%E4%B8%8Epython%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%AF%B9%E6%AF%94/"},{"categories":["现代C++语法"],"content":"递归删除 filesystem中提供了remove_all()函数，可以递归删除文件或文件夹。 void eg3_4() { /*递归删除*/ std::filesystem::path dir_path = \"../test_dir/eg3_3_dir\"; std::cout \u003c\u003c \"exists(dir_path) : \" \u003c\u003c std::filesystem::exists(dir_path) \u003c\u003c std::endl; std::filesystem::remove_all(dir_path); std::cout \u003c\u003c \"exists(dir_path) : \" \u003c\u003c std::filesystem::exists(dir_path) \u003c\u003c std::endl; } exists(dir_path) : 1 exists(dir_path) : 0 shutil提供了函数rmtree()。 def eg3_4(): \"\"\"递归删除\"\"\" dir_path = \"./test_dir/eg3_3_dir\" print(\"os.path.exists({}) : {}\".format(dir_path, os.path.exists(dir_path))) shutil.rmtree(dir_path) print(\"os.path.exists({}) : {}\".format(dir_path, os.path.exists(dir_path))) os.path.exists(./test_dir/eg3_3_dir) : True os.path.exists(./test_dir/eg3_3_dir) : False ","date":"2022-01-25","objectID":"/posts/c++%E4%B8%8Epython%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%AF%B9%E6%AF%94/:3:4","tags":["C++与python文件系统对比"],"title":"C++与python文件系统对比","uri":"/posts/c++%E4%B8%8Epython%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%AF%B9%E6%AF%94/"},{"categories":["JavaSE笔记"],"content":"Java I/O","date":"2022-01-23","objectID":"/posts/java-io/","tags":["Java I/O"],"title":"Java I/O","uri":"/posts/java-io/"},{"categories":["JavaSE笔记"],"content":"Java I/O 配套视频 注意：这块会涉及到操作系统和计算机组成原理相关内容。 I/O简而言之，就是输入输出，那么为什么会有I/O呢？其实I/O无时无刻都在我们的身边，比如读取硬盘上的文件，网络文件传输，鼠标键盘输入，也可以是接受单片机发回的数据，而能够支持这些操作的设备就是I/O设备。 我们可以大致看一下整个计算机的总线结构： 常见的I/O设备一般是鼠标、键盘这类通过USB进行传输的外设或者是通过Sata接口或是M.2连接的硬盘。一般情况下，这些设备是由CPU发出指令通过南桥芯片间接进行控制，而不是由CPU直接操作。 而我们在程序中，想要读取这些外部连接的I/O设备中的内容，就需要将数据传输到内存中。而需要实现这样的操作，单单凭借一个小的程序是无法做到的，而操作系统（如：Windows/Linux/MacOS）就是专门用于控制和管理计算机硬件和软件资源的软件，我们需要读取一个IO设备的内容时，可以向操作系统发出请求，由操作系统帮助我们来和底层的硬件交互以完成我们的读取/写入请求。从读取硬盘文件的角度来说，不同的操作系统有着不同的文件系统（也就是文件在硬盘中的存储排列方式，如Windows就是NTFS、MacOS就是APFS），硬盘只能存储一个个0和1这样的二进制数据，至于0和1如何排列，各自又代表什么意思，就是由操作系统的文件系统来决定的。从网络通信角度来说，网络信号通过网卡等设备翻译为二进制信号，再交给系统进行读取，最后再由操作系统来给到程序。 JDK提供了一套用于IO操作的框架，根据流的传输方向和读取单位，分为字节流InputStream和OutputStream以及字符流Reader和Writer，当然，这里的Stream并不是前面集合框架认识的Stream，这里的流指的是数据流，通过流，我们就可以一直从流中读取数据，直到读取到尽头，或是不断向其中写入数据，直到我们写入完成。而这类IO就是我们所说的BIO， 字节流一次读取一个字节，也就是一个byte的大小，而字符流顾名思义，就是一次读取一个字符，也就是一个char的大小（在读取纯文本文件的时候更加适合），有关这两种流，会在后面详细介绍，这个章节我们需要学习16个关键的流。 ","date":"2022-01-23","objectID":"/posts/java-io/:0:0","tags":["Java I/O"],"title":"Java I/O","uri":"/posts/java-io/"},{"categories":["JavaSE笔记"],"content":"文件流 要学习和使用IO，首先就要从最易于理解的读取文件开始说起。 ","date":"2022-01-23","objectID":"/posts/java-io/:1:0","tags":["Java I/O"],"title":"Java I/O","uri":"/posts/java-io/"},{"categories":["JavaSE笔记"],"content":"文件字节流 首先介绍一下FileInputStream，通过它来获取文件的输入流。 public static void main(String[] args) { try { FileInputStream inputStream = new FileInputStream(\"路径\"); //路径支持相对路径和绝对路径 } catch (FileNotFoundException e) { e.printStackTrace(); } } 相对路径是在当前运行的路径下寻找文件，而绝对路径，是从根目录开始寻找。路径分割符支持使用/或是\\\\，但是不能写为\\因为它是转义字符！ 在使用完成一个流之后，必须关闭这个流来完成对资源的释放，否则资源会被一直占用！ public static void main(String[] args) { FileInputStream inputStream = null; //定义可以先放在try外部 try { inputStream = new FileInputStream(\"路径\"); } catch (FileNotFoundException e) { e.printStackTrace(); } finally { try { //建议在finally中进行，因为这个是任何情况都必须要执行的！ if(inputStream != null) inputStream.close(); } catch (IOException e) { e.printStackTrace(); } } } 虽然这样的写法才是最保险的，但是显得过于繁琐了，尤其是finally中再次嵌套了一个try-catch块，因此在JDK1.7新增了try-with-resource语法，用于简化这样的写法（本质上还是和这样的操作一致，只是换了个写法） public static void main(String[] args) { //注意，这种语法只支持实现了AutoCloseable接口的类！ try(FileInputStream inputStream = new FileInputStream(\"路径\")) { //直接在try()中定义要在完成之后释放的资源 } catch (IOException e) { //这里变成IOException是因为调用close()可能会出现，而FileNotFoundException是继承自IOException的 e.printStackTrace(); } //无需再编写finally语句块，因为在最后自动帮我们调用了close() } 之后为了方便，我们都使用此语法进行教学。 public static void main(String[] args) { //test.txt：a try(FileInputStream inputStream = new FileInputStream(\"test.txt\")) { //使用read()方法进行字符读取 System.out.println((char) inputStream.read()); //读取一个字节的数据（英文字母只占1字节，中文占2字节） System.out.println(inputStream.read()); //唯一一个字节的内容已经读完了，再次读取返回-1表示没有内容了 }catch (IOException e){ e.printStackTrace(); } } 使用read可以直接读取一个字节的数据，注意，流的内容是有限的，读取一个少一个！我们如果想一次性全部读取的话，可以直接使用一个while循环来完成： public static void main(String[] args) { //test.txt：abcd try(FileInputStream inputStream = new FileInputStream(\"test.txt\")) { int tmp; while ((tmp = inputStream.read()) != -1){ //通过while循环来一次性读完内容 System.out.println((char)tmp); } }catch (IOException e){ e.printStackTrace(); } } 使用方法能查看当前可读的剩余字节数量（注意：并不一定真实的数据量就是这么多，尤其是在网络I/O操作时，这个方法只能进行一个预估也可以说是暂时能一次性读取的数量） try(FileInputStream inputStream = new FileInputStream(\"test.txt\")) { System.out.println(inputStream.available()); //查看剩余数量 }catch (IOException e){ e.printStackTrace(); } 当然，一个一个读取效率太低了，那能否一次性全部读取呢？我们可以预置一个合适容量的byte[]数组来存放。 public static void main(String[] args) { //test.txt：abcd try(FileInputStream inputStream = new FileInputStream(\"test.txt\")) { byte[] bytes = new byte[inputStream.available()]; //我们可以提前准备好合适容量的byte数组来存放 System.out.println(inputStream.read(bytes)); //一次性读取全部内容（返回值是读取的字节数） System.out.println(new String(bytes)); //通过String(byte[])构造方法得到字符串 }catch (IOException e){ e.printStackTrace(); } } 也可以控制要读取数量： System.out.println(inputStream.read(bytes, 1, 2)); //第二个参数是从给定数组的哪个位置开始放入内容，第三个参数是读取流中的字节数 注意：一次性读取同单个读取一样，当没有任何数据可读时，依然会返回-1 通过skip()方法可以跳过指定数量的字节： public static void main(String[] args) { //test.txt：abcd try(FileInputStream inputStream = new FileInputStream(\"test.txt\")) { System.out.println(inputStream.skip(1)); System.out.println((char) inputStream.read()); //跳过了一个字节 }catch (IOException e){ e.printStackTrace(); } } 注意：FileInputStream是不支持reset()的，虽然有这个方法，但是这里先不提及。 既然有输入流，那么文件输出流也是必不可少的： public static void main(String[] args) { //输出流也需要在最后调用close()方法，并且同样支持try-with-resource try(FileOutputStream outputStream = new FileOutputStream(\"output.txt\")) { //注意：若此文件不存在，会直接创建这个文件！ }catch (IOException e){ e.printStackTrace(); } } 输出流没有read()操作而是write()操作，使用方法同输入流一样，只不过现在的方向变为我们向文件里写入内容： public static void main(String[] args) { try(FileOutputStream outputStream = new FileOutputStream(\"output.txt\")) { outputStream.write('c'); //同read一样，可以直接写入内容 outputStream.write(\"lbwnb\".getBytes()); //也可以直接写入byte[] outputStream.write(\"lbwnb\".getBytes(), 0, 1); //同上输入流 outputStream.flush(); //建议在最后执行一次刷新操作（强制写入）来保证数据正确写入到硬盘文件中 }catch (IOException e){ e.printStackTrace(); } } 那么如果是我只想在文件尾部进行追加写入数据呢？我们可以调用另一个构造方法来实现： public static void main(String[] args) { try(FileOutputStream outputStream = new FileOutputStream(\"output.txt\", true)) { outputStream.write(\"lb\".getBytes()); //现在只会进行追加写入，而不是直接替换原文件内容 outputStream.flush(); }catch (IOException e){ e.printStackTrace(); } } ","date":"2022-01-23","objectID":"/posts/java-io/:1:1","tags":["Java I/O"],"title":"Java I/O","uri":"/posts/java-io/"},{"categories":["JavaSE笔记"],"content":"文件字符流 字符流不同于字节，字符流是以一个具体的字符进行读取，因此它只适合读纯文本的文件，如果是其他类型的文件不适用： public static void main(String[] args) { try(FileReader reader = new FileReader(\"test.txt\")){ reader.skip(1); //现在跳过的是一个字符 System.out.println((char) reader.read()); //现在是按字符进行读取，而不是字节，因此可以直接读取到中文字符 }catch (IOException e){ e.printStackTrace(); } } 同理，字符流只支持char[]类型作为存储： public static void main(String[] args) { try(FileReader reader = new FileReader(\"test.txt\")){ char[] str = new char[10]; reader.read(str); System.out.println(str); //直接读取到char[]中 }catch (IOException e){ e.printStackTrace(); } } 既然有了Reader肯定也有Writer： public static void main(String[] args) { try(FileWriter writer = new FileWriter(\"output.txt\")){ writer.getEncoding(); //支持获取编码（不同的文本文件可能会有不同的编码类型） writer.write('牛'); writer.append('牛'); //其实功能和write一样 writer.flush(); //刷新 }catch (IOException e){ e.printStackTrace(); } } 我们发现不仅有write()方法，还有一个append()方法，但是实际上他们效果是一样的，看源码： /** * Appends the specified character to this writer. * * \u003cp\u003e An invocation of this method of the form \u003ctt\u003eout.append(c)\u003c/tt\u003e * behaves in exactly the same way as the invocation * * \u003cpre\u003e * out.write(c) \u003c/pre\u003e * * @param c * The 16-bit character to append * * @return This writer * * @throws IOException * If an I/O error occurs * * @since 1.5 */ public Writer append(char c) throws IOException { write(c); return this; } append支持像StringBuilder那样的链式调用，返回的是Writer对象本身。 练习：尝试一下用Reader和Writer来拷贝纯文本文件 ","date":"2022-01-23","objectID":"/posts/java-io/:1:2","tags":["Java I/O"],"title":"Java I/O","uri":"/posts/java-io/"},{"categories":["JavaSE笔记"],"content":"File类 File类专门用于表示一个文件或文件夹，只不过它只是代表这个文件，但并不是这个文件本身。通过File对象，可以更好地管理和操作硬盘上的文件。 public static void main(String[] args) { File file = new File(\"test.txt\"); //直接创建文件对象，可以是相对路径，也可以是绝对路径 System.out.println(file.exists()); //此文件是否存在 System.out.println(file.length()); //获取文件的大小 System.out.println(file.isDirectory()); //是否为一个文件夹 System.out.println(file.canRead()); //是否可读 System.out.println(file.canWrite()); //是否可写 System.out.println(file.canExecute()); //是否可执行 } 通过File对象，我们就能快速得到文件的所有信息，如果是文件夹，还可以获取文件夹内部的文件列表等内容： File file = new File(\"/\"); System.out.println(Arrays.toString(file.list())); //快速获取文件夹下的文件名称列表 for (File f : file.listFiles()){ //所有子文件的File对象 System.out.println(f.getAbsolutePath()); //获取文件的绝对路径 } 如果我们希望读取某个文件的内容，可以直接将File作为参数传入字节流或是字符流： File file = new File(\"test.txt\"); try (FileInputStream inputStream = new FileInputStream(file)){ //直接做参数 System.out.println(inputStream.available()); }catch (IOException e){ e.printStackTrace(); } 练习：尝试拷贝文件夹下的所有文件到另一个文件夹 ","date":"2022-01-23","objectID":"/posts/java-io/:1:3","tags":["Java I/O"],"title":"Java I/O","uri":"/posts/java-io/"},{"categories":["JavaSE笔记"],"content":"缓冲流 虽然普通的文件流读取文件数据非常便捷，但是每次都需要从外部I/O设备去获取数据，由于外部I/O设备的速度一般都达不到内存的读取速度，很有可能造成程序反应迟钝，因此性能还不够高，而缓冲流正如其名称一样，它能够提供一个缓冲，提前将部分内容存入内存（缓冲区）在下次读取时，如果缓冲区中存在此数据，则无需再去请求外部设备。同理，当向外部设备写入数据时，也是由缓冲区处理，而不是直接向外部设备写入。 ","date":"2022-01-23","objectID":"/posts/java-io/:2:0","tags":["Java I/O"],"title":"Java I/O","uri":"/posts/java-io/"},{"categories":["JavaSE笔记"],"content":"缓冲字节流 要创建一个缓冲字节流，只需要将原本的流作为构造参数传入BufferedInputStream即可： public static void main(String[] args) { try (BufferedInputStream bufferedInputStream = new BufferedInputStream(new FileInputStream(\"test.txt\"))){ //传入FileInputStream System.out.println((char) bufferedInputStream.read()); //操作和原来的流是一样的 }catch (IOException e){ e.printStackTrace(); } } 实际上进行I/O操作的并不是BufferedInputStream，而是我们传入的FileInputStream，而BufferedInputStream虽然有着同样的方法，但是进行了一些额外的处理然后再调用FileInputStream的同名方法，这样的写法称为装饰者模式 public void close() throws IOException { byte[] buffer; while ( (buffer = buf) != null) { if (bufUpdater.compareAndSet(this, buffer, null)) { //CAS无锁算法，并发会用到，暂时不管 InputStream input = in; in = null; if (input != null) input.close(); return; } // Else retry in case a new buf was CASed in fill() } } 实际上这种模式是父类FilterInputStream提供的规范，后面我们还会讲到更多FilterInputStream的子类。 我们可以发现在BufferedInputStream中还存在一个专门用于缓存的数组： /** * The internal buffer array where the data is stored. When necessary, * it may be replaced by another array of * a different size. */ protected volatile byte buf[]; I/O操作一般不能重复读取内容（比如键盘发送的信号，主机接收了就没了），而缓冲流提供了缓冲机制，一部分内容可以被暂时保存，BufferedInputStream支持reset()和mark()操作，首先我们来看看mark()方法的介绍： /** * Marks the current position in this input stream. A subsequent * call to the \u003ccode\u003ereset\u003c/code\u003e method repositions this stream at * the last marked position so that subsequent reads re-read the same bytes. * \u003cp\u003e * The \u003ccode\u003ereadlimit\u003c/code\u003e argument tells this input stream to * allow that many bytes to be read before the mark position gets * invalidated. * \u003cp\u003e * This method simply performs \u003ccode\u003ein.mark(readlimit)\u003c/code\u003e. * * @param readlimit the maximum limit of bytes that can be read before * the mark position becomes invalid. * @see java.io.FilterInputStream#in * @see java.io.FilterInputStream#reset() */ public synchronized void mark(int readlimit) { in.mark(readlimit); } 当调用mark()之后，输入流会以某种方式保留之后读取的readlimit数量的内容，当读取的内容数量超过readlimit则之后的内容不会被保留，当调用reset()之后，会使得当前的读取位置回到mark()调用时的位置。 public static void main(String[] args) { try (BufferedInputStream bufferedInputStream = new BufferedInputStream(new FileInputStream(\"test.txt\"))){ bufferedInputStream.mark(1); //只保留之后的1个字符 System.out.println((char) bufferedInputStream.read()); System.out.println((char) bufferedInputStream.read()); bufferedInputStream.reset(); //回到mark时的位置 System.out.println((char) bufferedInputStream.read()); System.out.println((char) bufferedInputStream.read()); }catch (IOException e) { e.printStackTrace(); } } 我们发现虽然后面的部分没有保存，但是依然能够正常读取，其实mark()后保存的读取内容是取readlimit和BufferedInputStream类的缓冲区大小两者中的最大值，而并非完全由readlimit确定。因此我们限制一下缓冲区大小，再来观察一下结果： public static void main(String[] args) { try (BufferedInputStream bufferedInputStream = new BufferedInputStream(new FileInputStream(\"test.txt\"), 1)){ //将缓冲区大小设置为1 bufferedInputStream.mark(1); //只保留之后的1个字符 System.out.println((char) bufferedInputStream.read()); System.out.println((char) bufferedInputStream.read()); //已经超过了readlimit，继续读取会导致mark失效 bufferedInputStream.reset(); //mark已经失效，无法reset() System.out.println((char) bufferedInputStream.read()); System.out.println((char) bufferedInputStream.read()); }catch (IOException e) { e.printStackTrace(); } } 了解完了BufferedInputStream之后，我们再来看看BufferedOutputStream，其实和BufferedInputStream原理差不多，只是反向操作： public static void main(String[] args) { try (BufferedOutputStream outputStream = new BufferedOutputStream(new FileOutputStream(\"output.txt\"))){ outputStream.write(\"lbwnb\".getBytes()); outputStream.flush(); }catch (IOException e) { e.printStackTrace(); } } 操作和FileOutputStream一致，这里就不多做介绍了。 ","date":"2022-01-23","objectID":"/posts/java-io/:2:1","tags":["Java I/O"],"title":"Java I/O","uri":"/posts/java-io/"},{"categories":["JavaSE笔记"],"content":"缓冲字符流 缓存字符流和缓冲字节流一样，也有一个专门的缓冲区，BufferedReader构造时需要传入一个Reader对象： public static void main(String[] args) { try (BufferedReader reader = new BufferedReader(new FileReader(\"test.txt\"))){ System.out.println((char) reader.read()); }catch (IOException e) { e.printStackTrace(); } } 使用和reader也是一样的，内部也包含一个缓存数组： private char cb[]; 相比Reader更方便的是，它支持按行读取： public static void main(String[] args) { try (BufferedReader reader = new BufferedReader(new FileReader(\"test.txt\"))){ System.out.println(reader.readLine()); //按行读取 }catch (IOException e) { e.printStackTrace(); } } 读取后直接得到一个字符串，当然，它还能把每一行内容依次转换为集合类提到的Stream流： public static void main(String[] args) { try (BufferedReader reader = new BufferedReader(new FileReader(\"test.txt\"))){ reader .lines() .limit(2) .distinct() .sorted() .forEach(System.out::println); }catch (IOException e) { e.printStackTrace(); } } 它同样也支持mark()和reset()操作： public static void main(String[] args) { try (BufferedReader reader = new BufferedReader(new FileReader(\"test.txt\"))){ reader.mark(1); System.out.println((char) reader.read()); reader.reset(); System.out.println((char) reader.read()); }catch (IOException e) { e.printStackTrace(); } } BufferedReader处理纯文本文件时就更加方便了，BufferedWriter在处理时也同样方便： public static void main(String[] args) { try (BufferedWriter reader = new BufferedWriter(new FileWriter(\"output.txt\"))){ reader.newLine(); //使用newLine进行换行 reader.write(\"汉堡做滴彳亍不彳亍\"); //可以直接写入一个字符串 reader.flush(); //清空缓冲区 }catch (IOException e) { e.printStackTrace(); } } ","date":"2022-01-23","objectID":"/posts/java-io/:2:2","tags":["Java I/O"],"title":"Java I/O","uri":"/posts/java-io/"},{"categories":["JavaSE笔记"],"content":"转换流 有时会遇到这样一个很麻烦的问题：我这里读取的是一个字符串或是一个个字符，但是我只能往一个OutputStream里输出，但是OutputStream又只支持byte类型，如果要往里面写入内容，进行数据转换就会很麻烦，那么能否有更加简便的方式来做这样的事情呢？ public static void main(String[] args) { try(OutputStreamWriter writer = new OutputStreamWriter(new FileOutputStream(\"test.txt\"))){ //虽然给定的是FileOutputStream，但是现在支持以Writer的方式进行写入 writer.write(\"lbwnb\"); //以操作Writer的样子写入OutputStream }catch (IOException e){ e.printStackTrace(); } } 同样的，我们现在只拿到了一个InputStream，但是我们希望能够按字符的方式读取，我们就可以使用InputStreamReader来帮助我们实现： public static void main(String[] args) { try(InputStreamReader reader = new InputStreamReader(new FileInputStream(\"test.txt\"))){ //虽然给定的是FileInputStream，但是现在支持以Reader的方式进行读取 System.out.println((char) reader.read()); }catch (IOException e){ e.printStackTrace(); } } InputStreamReader和OutputStreamWriter本质也是Reader和Writer，因此可以直接放入BufferedReader来实现更加方便的操作。 ","date":"2022-01-23","objectID":"/posts/java-io/:3:0","tags":["Java I/O"],"title":"Java I/O","uri":"/posts/java-io/"},{"categories":["JavaSE笔记"],"content":"打印流 打印流其实我们从一开始就在使用了，比如System.out就是一个PrintStream，PrintStream也继承自FilterOutputStream类因此依然是装饰我们传入的输出流，但是它存在自动刷新机制，例如当向PrintStream流中写入一个字节数组后自动调用flush()方法。PrintStream也永远不会抛出异常，而是使用内部检查机制checkError()方法进行错误检查。最方便的是，它能够格式化任意的类型，将它们以字符串的形式写入到输出流。 public final static PrintStream out = null; 可以看到System.out也是PrintStream，不过默认是向控制台打印，我们也可以让它向文件中打印： public static void main(String[] args) { try(PrintStream stream = new PrintStream(new FileOutputStream(\"test.txt\"))){ stream.println(\"lbwnb\"); //其实System.out就是一个PrintStream }catch (IOException e){ e.printStackTrace(); } } 我们平时使用的println方法就是PrintStream中的方法，它会直接打印基本数据类型或是调用对象的toString()方法得到一个字符串，并将字符串转换为字符，放入缓冲区再经过转换流输出到给定的输出流上。 因此实际上内部还包含这两个内容： /** * Track both the text- and character-output streams, so that their buffers * can be flushed without flushing the entire stream. */ private BufferedWriter textOut; private OutputStreamWriter charOut; 与此相同的还有一个PrintWriter，不过他们的功能基本一致，PrintWriter的构造方法可以接受一个Writer作为参数，这里就不再做过多阐述了。 ","date":"2022-01-23","objectID":"/posts/java-io/:4:0","tags":["Java I/O"],"title":"Java I/O","uri":"/posts/java-io/"},{"categories":["JavaSE笔记"],"content":"数据流 数据流DataInputStream也是FilterInputStream的子类，同样采用装饰者模式，最大的不同是它支持基本数据类型的直接读取： public static void main(String[] args) { try (DataInputStream dataInputStream = new DataInputStream(new FileInputStream(\"test.txt\"))){ System.out.println(dataInputStream.readBoolean()); //直接将数据读取为任意基本数据类型 }catch (IOException e) { e.printStackTrace(); } } 用于写入基本数据类型： public static void main(String[] args) { try (DataOutputStream dataOutputStream = new DataOutputStream(new FileOutputStream(\"output.txt\"))){ dataOutputStream.writeBoolean(false); }catch (IOException e) { e.printStackTrace(); } } 注意，写入的是二进制数据，并不是写入的字符串，使用DataInputStream可以读取，一般他们是配合一起使用的。 ","date":"2022-01-23","objectID":"/posts/java-io/:5:0","tags":["Java I/O"],"title":"Java I/O","uri":"/posts/java-io/"},{"categories":["JavaSE笔记"],"content":"对象流 既然基本数据类型能够读取和写入基本数据类型，那么能否将对象也支持呢？ObjectOutputStream不仅支持基本数据类型，通过对对象的序列化操作，以某种格式保存对象，来支持对象类型的IO，注意：它不是继承自FilterInputStream的。 public static void main(String[] args) { try (ObjectOutputStream outputStream = new ObjectOutputStream(new FileOutputStream(\"output.txt\")); ObjectInputStream inputStream = new ObjectInputStream(new FileInputStream(\"output.txt\"))){ People people = new People(\"lbw\"); outputStream.writeObject(people); outputStream.flush(); people = (People) inputStream.readObject(); System.out.println(people.name); }catch (IOException | ClassNotFoundException e) { e.printStackTrace(); } } static class People implements Serializable{ //必须实现Serializable接口才能被序列化 String name; public People(String name){ this.name = name; } } 在我们后续的操作中，有可能会使得这个类的一些结构发生变化，而原来保存的数据只适用于之前版本的这个类，因此我们需要一种方法来区分类的不同版本： static class People implements Serializable{ private static final long serialVersionUID = 123456; //在序列化时，会被自动添加这个属性，它代表当前类的版本，我们也可以手动指定版本。 String name; public People(String name){ this.name = name; } } 当发生版本不匹配时，会无法反序列化为对象： java.io.InvalidClassException: com.test.Main$People; local class incompatible: stream classdesc serialVersionUID = 123456, local class serialVersionUID = 1234567 at java.io.ObjectStreamClass.initNonProxy(ObjectStreamClass.java:699) at java.io.ObjectInputStream.readNonProxyDesc(ObjectInputStream.java:2003) at java.io.ObjectInputStream.readClassDesc(ObjectInputStream.java:1850) at java.io.ObjectInputStream.readOrdinaryObject(ObjectInputStream.java:2160) at java.io.ObjectInputStream.readObject0(ObjectInputStream.java:1667) at java.io.ObjectInputStream.readObject(ObjectInputStream.java:503) at java.io.ObjectInputStream.readObject(ObjectInputStream.java:461) at com.test.Main.main(Main.java:27) 如果我们不希望某些属性参与到序列化中进行保存，我们可以添加transient关键字： public static void main(String[] args) { try (ObjectOutputStream outputStream = new ObjectOutputStream(new FileOutputStream(\"output.txt\")); ObjectInputStream inputStream = new ObjectInputStream(new FileInputStream(\"output.txt\"))){ People people = new People(\"lbw\"); outputStream.writeObject(people); outputStream.flush(); people = (People) inputStream.readObject(); System.out.println(people.name); //虽然能得到对象，但是name属性并没有保存，因此为null }catch (IOException | ClassNotFoundException e) { e.printStackTrace(); } } static class People implements Serializable{ private static final long serialVersionUID = 1234567; transient String name; public People(String name){ this.name = name; } } 其实我们可以看到，在一些JDK内部的源码中，也存在大量的transient关键字，使得某些属性不参与序列化，取消这些不必要保存的属性，可以节省数据空间占用以及减少序列化时间。 ","date":"2022-01-23","objectID":"/posts/java-io/:6:0","tags":["Java I/O"],"title":"Java I/O","uri":"/posts/java-io/"},{"categories":["JavaSE笔记"],"content":"Java I/O编程实战 ","date":"2022-01-23","objectID":"/posts/java-io/:7:0","tags":["Java I/O"],"title":"Java I/O","uri":"/posts/java-io/"},{"categories":["JavaSE笔记"],"content":"图书管理系统 要求实现一个图书管理系统（控制台），支持以下功能：保存书籍信息（要求持久化），查询、添加、删除、修改书籍信息。 参考代码： import java.io.*; import java.util.HashSet; import java.util.Objects; import java.util.Scanner; public class Library { static private HashSet\u003cBook\u003e MAP; public static void main(String[] args) { //TODO 注意先分配内存 Scanner scan = new Scanner(System.in); readData(); while (true) { System.out.println(\"============图书馆管理系统===========\"); System.out.println(\"1.插入数据\"); System.out.println(\"2.修改数据\"); System.out.println(\"3.查询图书列表\"); System.out.println(\"4.删除图书\"); System.out.println(\"(按下任意其他键退出程序)\"); String str = scan.nextLine(); switch (str) { case \"1\": insertBooks(scan); break; case \"2\": modifyBook(scan); break; case \"3\": showBooks(); break; case \"4\": deleteBooks(scan); break; default: saveData(); scan.close(); return; } } } //TODO 程序启动前，读取持久化数据 private static void readData(){ File file = new File(\"data\"); if(file.exists()){ try(ObjectInputStream inputStream = new ObjectInputStream(new FileInputStream(\"data\"))){ MAP = (HashSet\u003cBook\u003e) inputStream.readObject(); }catch (IOException|ClassNotFoundException e){ e.printStackTrace(); } }else { MAP = new HashSet\u003c\u003e(); } } //TODO 程序结束时，持久序列化保存数据 private static void saveData(){ try(ObjectOutputStream outputStream = new ObjectOutputStream(new FileOutputStream(\"data\"))){ outputStream.writeObject(MAP); outputStream.flush(); }catch (IOException e){ e.printStackTrace(); } } //TODO 修改图书数据 private static void modifyBook(Scanner scan) { showBooks(); System.out.println(\"输入您要修改书籍的索书号：\"); int index = scan.nextInt(); scan.nextLine(); Book t = new Book().setIndex(index); if (!MAP.contains(t)) { System.out.println(\"输入错误图书馆内无该书籍!\"); } else { System.out.println(\"请输入您要更改的信息：书名，作者，价格\"); String name = scan.nextLine(); String author = scan.nextLine(); double price = scan.nextDouble(); scan.nextLine(); for (Book tt : MAP) { if (tt.equals(t)) { tt.setAuthor(author); tt.setName(name); tt.setPrice(price); break; } } } } //TODO 删除书籍 private static void deleteBooks(Scanner scan) { showBooks(); System.out.println(\"请输入要删除书籍的索书号：\"); int index = scan.nextInt(); scan.nextLine(); Book t = new Book().setIndex(index); if (!MAP.contains(t)) { System.out.println(\"索书号出错没有这样的书籍\"); } else { System.out.printf(\"删除索书号为:%d 的书籍成功!\\n\", index); MAP.remove(t); } } //TODO 显示图书信息 private static void showBooks() { MAP.forEach(System.out::println); } //TODO 插入书籍 private static void insertBooks(Scanner scan) { System.out.println(\"请输入 索书号 书名 作者 价格。每输入一个信息按下回车键确认！\"); MAP.add(new Book().setIndex(scan.nextInt()) .setName(scan.nextLine() + scan.nextLine()) .setAuthor(scan.nextLine()) .setPrice(scan.nextDouble()) ); scan.nextLine(); } //TODO 书籍类 private static class Book implements Serializable{ int index;//索书号 String name;//书名 String author;//作者 double price;//价格 public Book setName(String name) { this.name = name; return this; } public Book setIndex(int index) { this.index = index; return this; } public Book setAuthor(String author) { this.author = author; return this; } public Book setPrice(double price) { this.price = price; return this; } @Override public String toString() { return \"书籍{\" + \"索书号=\" + index + \", 书名='\" + name + '\\'' + \", 作者='\" + author + '\\'' + \", 价格=\" + price + '}'; } @Override public boolean equals(Object o) { if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; Book book = (Book) o; return index == book.index; } @Override public int hashCode() { return Objects.hash(index); } } } ","date":"2022-01-23","objectID":"/posts/java-io/:7:1","tags":["Java I/O"],"title":"Java I/O","uri":"/posts/java-io/"},{"categories":["JavaSE笔记"],"content":"Java反射与注解","date":"2022-01-23","objectID":"/posts/java%E5%8F%8D%E5%B0%84%E4%B8%8E%E6%B3%A8%E5%B0%84/","tags":["Java反射与注解"],"title":"Java反射与注解","uri":"/posts/java%E5%8F%8D%E5%B0%84%E4%B8%8E%E6%B3%A8%E5%B0%84/"},{"categories":["JavaSE笔记"],"content":"Java反射和注解 配套视频 **注意：**本章节涉及到JVM相关底层原理，难度会有一些大。 反射就是把Java类中的各个成分映射成一个个的Java对象。即在运行状态中，对于任意一个类，都能够知道这个类所有的属性和方法，对于任意一个对象，都能调用它的任意一个方法和属性。这种动态获取信息及动态调用对象方法的功能叫Java的反射机制。 简而言之，我们可以通过反射机制，获取到类的一些属性，包括类里面有哪些字段，有哪些方法，继承自哪个类，甚至还能获取到泛型！它的权限非常高，慎重使用！ ","date":"2022-01-23","objectID":"/posts/java%E5%8F%8D%E5%B0%84%E4%B8%8E%E6%B3%A8%E5%B0%84/:0:0","tags":["Java反射与注解"],"title":"Java反射与注解","uri":"/posts/java%E5%8F%8D%E5%B0%84%E4%B8%8E%E6%B3%A8%E5%B0%84/"},{"categories":["JavaSE笔记"],"content":"Java类加载机制 在学习Java的反射机制之前，我们需要先了解一下类的加载机制，一个类是如何被加载和使用的： 在Java程序启动时，JVM会将一部分类（class文件）先加载（并不是所有的类都会在一开始加载），通过ClassLoader将类加载，在加载过程中，会将类的信息提取出来（存放在元空间中，JDK1.8之前存放在永久代），同时也会生成一个Class对象存放在内存（堆内存），注意此Class对象只会存在一个，与加载的类唯一对应！ **思考：**既然说和与加载的类唯一对应，那如果我们手动创建一个与JDK包名一样，同时类名也保持一致，那么JVM会加载这个类吗？ package java.lang; public class String { //JDK提供的String类也是 public static void main(String[] args) { System.out.println(\"我姓🐴，我叫🐴nb\"); } } 我们发现，会出现以下报错： 错误: 在类 java.lang.String 中找不到 main 方法, 请将 main 方法定义为: public static void main(String[] args) 但是我们明明在自己写的String类中定义了main方法啊，为什么会找不到此方法呢？实际上这是ClassLoader的双亲委派机制在保护Java程序的正常运行： 实际上我们的类最开始是由BootstarpClassLoader进行加载，BootstarpClassLoader用于加载JDK提供的类，而我们自己编写的类实际上是AppClassLoader，只有BootstarpClassLoader都没有加载的类，才会让AppClassLoader来加载，因此我们自己编写的同名包同名类不会被加载，而实际要去启动的是真正的String类，也就自然找不到main方法了！ public class Main { public static void main(String[] args) { System.out.println(Main.class.getClassLoader()); //查看当前类的类加载器 System.out.println(Main.class.getClassLoader().getParent()); //父加载器 System.out.println(Main.class.getClassLoader().getParent().getParent()); //爷爷加载器 System.out.println(String.class.getClassLoader()); //String类的加载器 } } 由于BootstarpClassLoader是C++编写的，我们在Java中是获取不到的。 ","date":"2022-01-23","objectID":"/posts/java%E5%8F%8D%E5%B0%84%E4%B8%8E%E6%B3%A8%E5%B0%84/:1:0","tags":["Java反射与注解"],"title":"Java反射与注解","uri":"/posts/java%E5%8F%8D%E5%B0%84%E4%B8%8E%E6%B3%A8%E5%B0%84/"},{"categories":["JavaSE笔记"],"content":"Class对象 通过前面，我们了解了类的加载，同时会提取一个类的信息生成Class对象存放在内存中，而反射机制其实就是利用这些存放的类信息，来获取类的信息和操作类。那么如何获取到每个类对应的Class对象呢，我们可以通过以下方式： public static void main(String[] args) throws ClassNotFoundException { Class\u003cString\u003e clazz = String.class; //使用class关键字，通过类名获取 Class\u003c?\u003e clazz2 = Class.forName(\"java.lang.String\"); //使用Class类静态方法forName()，通过包名.类名获取，注意返回值是Class\u003c?\u003e Class\u003c?\u003e clazz3 = new String(\"cpdd\").getClass(); //通过实例对象获取 } 注意Class类也是一个泛型类，只有第一种方法，能够直接获取到对应类型的Class对象，而以下两种方法使用了?通配符作为返回值，但是实际上都和第一个返回的是同一个对象： Class\u003cString\u003e clazz = String.class; //使用class关键字，通过类名获取 Class\u003c?\u003e clazz2 = Class.forName(\"java.lang.String\"); //使用Class类静态方法forName()，通过包名.类名获取，注意返回值是Class\u003c?\u003e Class\u003c?\u003e clazz3 = new String(\"cpdd\").getClass(); System.out.println(clazz == clazz2); System.out.println(clazz == clazz3); 通过比较，验证了我们一开始的结论，在JVM中每个类始终只存在一个Class对象，无论通过什么方法获取，都是一样的。现在我们再来看看这个问题： public static void main(String[] args) { Class\u003c?\u003e clazz = int.class; //基本数据类型有Class对象吗？ System.out.println(clazz); } 迷了，不是每个类才有Class对象吗，基本数据类型又不是类，这也行吗？实际上，基本数据类型也有对应的Class对象（反射操作可能需要用到），而且我们不仅可以通过class关键字获取，其实本质上是定义在对应的包装类中的： /** * The {@code Class} instance representing the primitive type * {@code int}. * * @since JDK1.1 */ @SuppressWarnings(\"unchecked\") public static final Class\u003cInteger\u003e TYPE = (Class\u003cInteger\u003e) Class.getPrimitiveClass(\"int\"); /* * Return the Virtual Machine's Class object for the named * primitive type */ static native Class\u003c?\u003e getPrimitiveClass(String name); //C++实现，并非Java定义 每个包装类中（包括Void），都有一个获取原始类型Class方法，注意，getPrimitiveClass获取的是原始类型，并不是包装类型，只是可以使用包装类来表示。 public static void main(String[] args) { Class\u003c?\u003e clazz = int.class; System.out.println(Integer.TYPE == int.class); } 通过对比，我们发现实际上包装类型都有一个TYPE，其实也就是基本类型的Class，那么包装类的Class和基本类的Class一样吗？ public static void main(String[] args) { System.out.println(Integer.TYPE == Integer.class); } 我们发现，包装类型的Class对象并不是基本类型Class对象。数组类型也是一种类型，只是编程不可见，因此我们可以直接获取数组的Class对象： public static void main(String[] args) { Class\u003cString[]\u003e clazz = String[].class; System.out.println(clazz.getName()); //获取类名称（得到的是包名+类名的完整名称） System.out.println(clazz.getSimpleName()); System.out.println(clazz.getTypeName()); System.out.println(clazz.getClassLoader()); //获取它的类加载器 System.out.println(clazz.cast(new Integer(\"10\"))); //强制类型转换 } ","date":"2022-01-23","objectID":"/posts/java%E5%8F%8D%E5%B0%84%E4%B8%8E%E6%B3%A8%E5%B0%84/:2:0","tags":["Java反射与注解"],"title":"Java反射与注解","uri":"/posts/java%E5%8F%8D%E5%B0%84%E4%B8%8E%E6%B3%A8%E5%B0%84/"},{"categories":["JavaSE笔记"],"content":"再谈instanceof 正常情况下，我们使用instanceof进行类型比较： public static void main(String[] args) { String str = \"\"; System.out.println(str instanceof String); } 它可以判断一个对象是否为此接口或是类的实现或是子类，而现在我们有了更多的方式去判断类型： public static void main(String[] args) { String str = \"\"; System.out.println(str.getClass() == String.class); //直接判断是否为这个类型 } 如果需要判断是否为子类或是接口/抽象类的实现，我们可以使用asSubClass()方法： public static void main(String[] args) { Integer i = 10; i.getClass().asSubclass(Number.class); //当Integer不是Number的子类时，会产生异常 } ","date":"2022-01-23","objectID":"/posts/java%E5%8F%8D%E5%B0%84%E4%B8%8E%E6%B3%A8%E5%B0%84/:2:1","tags":["Java反射与注解"],"title":"Java反射与注解","uri":"/posts/java%E5%8F%8D%E5%B0%84%E4%B8%8E%E6%B3%A8%E5%B0%84/"},{"categories":["JavaSE笔记"],"content":"获取父类信息 通过getSuperclass()方法，我们可以获取到父类的Class对象： public static void main(String[] args) { Integer i = 10; System.out.println(i.getClass().getSuperclass()); } 也可以通过getGenericSuperclass()获取父类的原始类型的Type： public static void main(String[] args) { Integer i = 10; Type type = i.getClass().getGenericSuperclass(); System.out.println(type); System.out.println(type instanceof Class); } 我们发现Type实际上是Class类的父接口，但是获取到的Type的实现并不一定是Class。 同理，我们也可以像上面这样获取父接口： public static void main(String[] args) { Integer i = 10; for (Class\u003c?\u003e anInterface : i.getClass().getInterfaces()) { System.out.println(anInterface.getName()); } for (Type genericInterface : i.getClass().getGenericInterfaces()) { System.out.println(genericInterface.getTypeName()); } } ","date":"2022-01-23","objectID":"/posts/java%E5%8F%8D%E5%B0%84%E4%B8%8E%E6%B3%A8%E5%B0%84/:2:2","tags":["Java反射与注解"],"title":"Java反射与注解","uri":"/posts/java%E5%8F%8D%E5%B0%84%E4%B8%8E%E6%B3%A8%E5%B0%84/"},{"categories":["JavaSE笔记"],"content":"创建类对象 既然我们拿到了类的定义，那么是否可以通过Class对象来创建对象、调用方法、修改变量呢？当然是可以的，那我们首先来探讨一下如何创建一个类的对象： public static void main(String[] args) throws InstantiationException, IllegalAccessException { Class\u003cStudent\u003e clazz = Student.class; Student student = clazz.newInstance(); student.test(); } static class Student{ public void test(){ System.out.println(\"萨日朗\"); } } 通过使用newInstance()方法来创建对应类型的实例，返回泛型T，注意它会抛出InstantiationException和IllegalAccessException异常，那么什么情况下会出现异常呢？ public static void main(String[] args) throws InstantiationException, IllegalAccessException { Class\u003cStudent\u003e clazz = Student.class; Student student = clazz.newInstance(); student.test(); } static class Student{ public Student(String text){ } public void test(){ System.out.println(\"萨日朗\"); } } 当类默认的构造方法被带参构造覆盖时，会出现InstantiationException异常，因为newInstance()只适用于默认无参构造。 public static void main(String[] args) throws InstantiationException, IllegalAccessException { Class\u003cStudent\u003e clazz = Student.class; Student student = clazz.newInstance(); student.test(); } static class Student{ private Student(){} public void test(){ System.out.println(\"萨日朗\"); } } 当默认无参构造的权限不是public时，会出现IllegalAccessException异常，表示我们无权去调用默认构造方法。在JDK9之后，不再推荐使用newInstance()方法了，而是使用我们接下来要介绍到的，通过获取构造器，来实例化对象： public static void main(String[] args) throws NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException { Class\u003cStudent\u003e clazz = Student.class; Student student = clazz.getConstructor(String.class).newInstance(\"what's up\"); student.test(); } static class Student{ public Student(String str){} public void test(){ System.out.println(\"萨日朗\"); } } 通过获取类的构造方法（构造器）来创建对象实例，会更加合理，我们可以使用getConstructor()方法来获取类的构造方法，同时我们需要向其中填入参数，也就是构造方法需要的类型，当然我们这里只演示了。那么，当访问权限不是public的时候呢？ public static void main(String[] args) throws NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException { Class\u003cStudent\u003e clazz = Student.class; Student student = clazz.getConstructor(String.class).newInstance(\"what's up\"); student.test(); } static class Student{ private Student(String str){} public void test(){ System.out.println(\"萨日朗\"); } } 我们发现，当访问权限不足时，会无法找到此构造方法，那么如何找到非public的构造方法呢？ Class\u003cStudent\u003e clazz = Student.class; Constructor\u003cStudent\u003e constructor = clazz.getDeclaredConstructor(String.class); constructor.setAccessible(true); //修改访问权限 Student student = constructor.newInstance(\"what's up\"); student.test(); 使用getDeclaredConstructor()方法可以找到类中的非public构造方法，但是在使用之前，我们需要先修改访问权限，在修改访问权限之后，就可以使用非public方法了（这意味着，反射可以无视权限修饰符访问类的内容） ","date":"2022-01-23","objectID":"/posts/java%E5%8F%8D%E5%B0%84%E4%B8%8E%E6%B3%A8%E5%B0%84/:3:0","tags":["Java反射与注解"],"title":"Java反射与注解","uri":"/posts/java%E5%8F%8D%E5%B0%84%E4%B8%8E%E6%B3%A8%E5%B0%84/"},{"categories":["JavaSE笔记"],"content":"调用类的方法 我们可以通过反射来调用类的方法（本质上还是类的实例进行调用）只是利用反射机制实现了方法的调用，我们在包下创建一个新的类： package com.test; public class Student { public void test(String str){ System.out.println(\"萨日朗\"+str); } } 这次我们通过forName(String)来找到这个类并创建一个新的对象： public static void main(String[] args) throws ReflectiveOperationException { Class\u003c?\u003e clazz = Class.forName(\"com.test.Student\"); Object instance = clazz.newInstance(); //创建出学生对象 Method method = clazz.getMethod(\"test\", String.class); //通过方法名和形参类型获取类中的方法 method.invoke(instance, \"what's up\"); //通过Method对象的invoke方法来调用方法 } 通过调用getMethod()方法，我们可以获取到类中所有声明为public的方法，得到一个Method对象，我们可以通过Method对象的invoke()方法（返回值就是方法的返回值，因为这里是void，返回值为null）来调用已经获取到的方法，注意传参。 我们发现，利用反射之后，在一个对象从构造到方法调用，没有任何一处需要引用到对象的实际类型，我们也没有导入Student类，整个过程都是反射在代替进行操作，使得整个过程被模糊了，过多的使用反射，会极大地降低后期维护性。 同构造方法一样，当出现非public方法时，我们可以通过反射来无视权限修饰符，获取非public方法并调用，现在我们将test()方法的权限修饰符改为private： public static void main(String[] args) throws ReflectiveOperationException { Class\u003c?\u003e clazz = Class.forName(\"com.test.Student\"); Object instance = clazz.newInstance(); //创建出学生对象 Method method = clazz.getDeclaredMethod(\"test\", String.class); //通过方法名和形参类型获取类中的方法 method.setAccessible(true); method.invoke(instance, \"what's up\"); //通过Method对象的invoke方法来调用方法 } Method和Constructor都和Class一样，他们存储了方法的信息，包括方法的形式参数列表，返回值，方法的名称等内容，我们可以直接通过Method对象来获取这些信息： public static void main(String[] args) throws ReflectiveOperationException { Class\u003c?\u003e clazz = Class.forName(\"com.test.Student\"); Method method = clazz.getDeclaredMethod(\"test\", String.class); //通过方法名和形参类型获取类中的方法 System.out.println(method.getName()); //获取方法名称 System.out.println(method.getReturnType()); //获取返回值类型 } 当方法的参数为可变参数时，我们该如何获取方法呢？实际上，我们在之前就已经提到过，可变参数实际上就是一个数组，因此我们可以直接使用数组的class对象表示： Method method = clazz.getDeclaredMethod(\"test\", String[].class); 反射非常强大，尤其是我们提到的越权访问，但是请一定谨慎使用，别人将某个方法设置为private一定有他的理由，如果实在是需要使用别人定义为private的方法，就必须确保这样做是安全的，在没有了解别人代码的整个过程就强行越权访问，可能会出现无法预知的错误。 ","date":"2022-01-23","objectID":"/posts/java%E5%8F%8D%E5%B0%84%E4%B8%8E%E6%B3%A8%E5%B0%84/:4:0","tags":["Java反射与注解"],"title":"Java反射与注解","uri":"/posts/java%E5%8F%8D%E5%B0%84%E4%B8%8E%E6%B3%A8%E5%B0%84/"},{"categories":["JavaSE笔记"],"content":"修改类的属性 我们还可以通过反射访问一个类中定义的成员字段也可以修改一个类的对象中的成员字段值，通过getField()方法来获取一个类定义的指定字段： public static void main(String[] args) throws ReflectiveOperationException { Class\u003c?\u003e clazz = Class.forName(\"com.test.Student\"); Object instance = clazz.newInstance(); Field field = clazz.getField(\"i\"); //获取类的成员字段i field.set(instance, 100); //将类实例instance的成员字段i设置为100 Method method = clazz.getMethod(\"test\"); method.invoke(instance); } 在得到Field之后，我们就可以直接通过set()方法为某个对象，设定此属性的值，比如上面，我们就为instance对象设定值为100，当访问private字段时，同样可以按照上面的操作进行越权访问： public static void main(String[] args) throws ReflectiveOperationException { Class\u003c?\u003e clazz = Class.forName(\"com.test.Student\"); Object instance = clazz.newInstance(); Field field = clazz.getDeclaredField(\"i\"); //获取类的成员字段i field.setAccessible(true); field.set(instance, 100); //将类实例instance的成员字段i设置为100 Method method = clazz.getMethod(\"test\"); method.invoke(instance); } 现在我们已经知道，反射几乎可以把一个类的老底都给扒出来，任何属性，任何内容，都可以被反射修改，无论权限修饰符是什么，那么，如果我的字段被标记为final呢？现在在字段i前面添加final关键字，我们再来看看效果： private final int i = 10; 这时，当字段为final时，就修改失败了！当然，通过反射可以直接将final修饰符直接去除，去除后，就可以随意修改内容了，我们来尝试修改Integer的value值： public static void main(String[] args) throws ReflectiveOperationException { Integer i = 10; Field field = Integer.class.getDeclaredField(\"value\"); Field modifiersField = Field.class.getDeclaredField(\"modifiers\"); //这里要获取Field类的modifiers字段进行修改 modifiersField.setAccessible(true); modifiersField.setInt(field,field.getModifiers()\u0026~Modifier.FINAL); //去除final标记 field.setAccessible(true); field.set(i, 100); //强行设置值 System.out.println(i); } 我们可以发现，反射非常暴力，就连被定义为final字段的值都能强行修改，几乎能够无视一切阻拦。我们来试试看修改一些其他的类型： public static void main(String[] args) throws ReflectiveOperationException { List\u003cString\u003e i = new ArrayList\u003c\u003e(); Field field = ArrayList.class.getDeclaredField(\"size\"); field.setAccessible(true); field.set(i, 10); i.add(\"测试\"); //只添加一个元素 System.out.println(i.size()); //大小直接变成11 i.remove(10); //瞎移除都不带报错的，淦 } 实际上，整个ArrayList体系由于我们的反射操作，导致被破坏，因此它已经无法正常工作了！ 再次强调，在进行反射操作时，必须注意是否安全，虽然拥有了创世主的能力，但是我们不能滥用，我们只能把它当做一个不得已才去使用的工具！ ","date":"2022-01-23","objectID":"/posts/java%E5%8F%8D%E5%B0%84%E4%B8%8E%E6%B3%A8%E5%B0%84/:5:0","tags":["Java反射与注解"],"title":"Java反射与注解","uri":"/posts/java%E5%8F%8D%E5%B0%84%E4%B8%8E%E6%B3%A8%E5%B0%84/"},{"categories":["JavaSE笔记"],"content":"自定义ClassLoader加载类 我们可以自己手动将class文件加载到JVM中吗？先写好我们定义的类： package com.test; public class Test { public String text; public void test(String str){ System.out.println(text+\" \u003e 我是测试方法！\"+str); } } 通过javac命令，手动编译一个.class文件： nagocoler@NagodeMacBook-Pro HelloWorld % javac src/main/java/com/test/Test.java 编译后，得到一个class文件，我们把它放到根目录下，然后编写一个我们自己的ClassLoader，因为普通的ClassLoader无法加载二进制文件，因此我们编写一个自己的来让它支持： //定义一个自己的ClassLoader static class MyClassLoader extends ClassLoader{ public Class\u003c?\u003e defineClass(String name, byte[] b){ return defineClass(name, b, 0, b.length); //调用protected方法，支持载入外部class文件 } } public static void main(String[] args) throws IOException { MyClassLoader classLoader = new MyClassLoader(); FileInputStream stream = new FileInputStream(\"Test.class\"); byte[] bytes = new byte[stream.available()]; stream.read(bytes); Class\u003c?\u003e clazz = classLoader.defineClass(\"com.test.Test\", bytes); //类名必须和我们定义的保持一致 System.out.println(clazz.getName()); //成功加载外部class文件 } 现在，我们就将此class文件读取并解析为Class了，现在我们就可以对此类进行操作了（注意，我们无法在代码中直接使用此类型，因为它是我们直接加载的），我们来试试看创建一个此类的对象并调用其方法： try { Object obj = clazz.newInstance(); Method method = clazz.getMethod(\"test\", String.class); //获取我们定义的test(String str)方法 method.invoke(obj, \"哥们这瓜多少钱一斤？\"); }catch (Exception e){ e.printStackTrace(); } 我们来试试看修改成员字段之后，再来调用此方法： try { Object obj = clazz.newInstance(); Field field = clazz.getField(\"text\"); //获取成员变量 String text; field.set(obj, \"华强\"); Method method = clazz.getMethod(\"test\", String.class); //获取我们定义的test(String str)方法 method.invoke(obj, \"哥们这瓜多少钱一斤？\"); }catch (Exception e){ e.printStackTrace(); } 通过这种方式，我们就可以实现外部加载甚至是网络加载一个类，只需要把类文件传递即可，这样就无需再将代码写在本地，而是动态进行传递，不仅可以一定程度上防止源代码被反编译（只是一定程度上，想破解你代码有的是方法），而且在更多情况下，我们还可以对byte[]进行加密，保证在传输过程中的安全性。 ","date":"2022-01-23","objectID":"/posts/java%E5%8F%8D%E5%B0%84%E4%B8%8E%E6%B3%A8%E5%B0%84/:6:0","tags":["Java反射与注解"],"title":"Java反射与注解","uri":"/posts/java%E5%8F%8D%E5%B0%84%E4%B8%8E%E6%B3%A8%E5%B0%84/"},{"categories":["JavaSE笔记"],"content":"注解 其实我们在之前就接触到注解了，比如@Override表示重写父类方法（当然不加效果也是一样的，此注解在编译时会被自动丢弃）注解本质上也是一个类，只不过它的用法比较特殊。 注解可以被标注在任意地方，包括方法上、类名上、参数上、成员属性上、注解定义上等，就像注释一样，它相当于我们对某样东西的一个标记。而与注释不同的是，注解可以通过反射在运行时获取，注解也可以选择是否保留到运行时。 ","date":"2022-01-23","objectID":"/posts/java%E5%8F%8D%E5%B0%84%E4%B8%8E%E6%B3%A8%E5%B0%84/:7:0","tags":["Java反射与注解"],"title":"Java反射与注解","uri":"/posts/java%E5%8F%8D%E5%B0%84%E4%B8%8E%E6%B3%A8%E5%B0%84/"},{"categories":["JavaSE笔记"],"content":"预设注解 JDK预设了以下注解，作用于代码： @Override - 检查（仅仅是检查，不保留到运行时）该方法是否是重写方法。如果发现其父类，或者是引用的接口中并没有该方法时，会报编译错误。 @Deprecated - 标记过时方法。如果使用该方法，会报编译警告。 @SuppressWarnings - 指示编译器去忽略注解中声明的警告（仅仅编译器阶段，不保留到运行时） @FunctionalInterface - Java 8 开始支持，标识一个匿名函数或函数式接口。 @SafeVarargs - Java 7 开始支持，忽略任何使用参数为泛型变量的方法或构造函数调用产生的警告。 ","date":"2022-01-23","objectID":"/posts/java%E5%8F%8D%E5%B0%84%E4%B8%8E%E6%B3%A8%E5%B0%84/:7:1","tags":["Java反射与注解"],"title":"Java反射与注解","uri":"/posts/java%E5%8F%8D%E5%B0%84%E4%B8%8E%E6%B3%A8%E5%B0%84/"},{"categories":["JavaSE笔记"],"content":"元注解 元注解是作用于注解上的注解，用于我们编写自定义的注解： @Retention - 标识这个注解怎么保存，是只在代码中，还是编入class文件中，或者是在运行时可以通过反射访问。 @Documented - 标记这些注解是否包含在用户文档中。 @Target - 标记这个注解应该是哪种 Java 成员。 @Inherited - 标记这个注解是继承于哪个注解类(默认 注解并没有继承于任何子类) @Repeatable - Java 8 开始支持，标识某注解可以在同一个声明上使用多次。 看了这么多预设的注解，你们肯定眼花缭乱了，那我们来看看@Override是如何定义的： @Target(ElementType.METHOD) @Retention(RetentionPolicy.SOURCE) public @interface Override { } 该注解由@Target限定为只能作用于方法上，ElementType是一个枚举类型，用于表示此枚举的作用域，一个注解可以有很多个作用域。@Retention表示此注解的保留策略，包括三种策略，在上述中有写到，而这里定义为只在代码中。一般情况下，自定义的注解需要定义1个@Retention和1-n个@Target。 既然了解了元注解的使用和注解的定义方式，我们就来尝试定义一个自己的注解： @Target(ElementType.METHOD) @Retention(RetentionPolicy.RUNTIME) public @interface Test { } 这里我们定义一个Test注解，并将其保留到运行时，同时此注解可以作用于方法或是类上： @Test public class Main { @Test public static void main(String[] args) { } } 这样，一个最简单的注解就被我们创建了。 ","date":"2022-01-23","objectID":"/posts/java%E5%8F%8D%E5%B0%84%E4%B8%8E%E6%B3%A8%E5%B0%84/:7:2","tags":["Java反射与注解"],"title":"Java反射与注解","uri":"/posts/java%E5%8F%8D%E5%B0%84%E4%B8%8E%E6%B3%A8%E5%B0%84/"},{"categories":["JavaSE笔记"],"content":"注解的使用 我们还可以在注解中定义一些属性，注解的属性也叫做成员变量，注解只有成员变量，没有方法。注解的成员变量在注解的定义中以“无形参的方法”形式来声明，其方法名定义了该成员变量的名字，其返回值定义了该成员变量的类型： @Target({ElementType.METHOD, ElementType.TYPE}) @Retention(RetentionPolicy.RUNTIME) public @interface Test { String value(); } 默认只有一个属性时，我们可以将其名字设定为value，否则，我们需要在使用时手动指定注解的属性名称，使用value则无需填入： @Target({ElementType.METHOD, ElementType.TYPE}) @Retention(RetentionPolicy.RUNTIME) public @interface Test { String test(); } public class Main { @Test(test = \"\") public static void main(String[] args) { } } 我们也可以使用default关键字来为这些属性指定默认值： @Target({ElementType.METHOD, ElementType.TYPE}) @Retention(RetentionPolicy.RUNTIME) public @interface Test { String value() default \"都看到这里了，给个三连吧！\"; } 当属性存在默认值时，使用注解的时候可以不用传入属性值。当属性为数组时呢？ @Target({ElementType.METHOD, ElementType.TYPE}) @Retention(RetentionPolicy.RUNTIME) public @interface Test { String[] value(); } 当属性为数组，我们在使用注解传参时，如果数组里面只有一个内容，我们可以直接传入一个值，而不是创建一个数组： @Test(\"关注点了吗\") public static void main(String[] args) { } public class Main { @Test({\"value1\", \"value2\"}) //多个值时就使用花括号括起来 public static void main(String[] args) { } } ","date":"2022-01-23","objectID":"/posts/java%E5%8F%8D%E5%B0%84%E4%B8%8E%E6%B3%A8%E5%B0%84/:7:3","tags":["Java反射与注解"],"title":"Java反射与注解","uri":"/posts/java%E5%8F%8D%E5%B0%84%E4%B8%8E%E6%B3%A8%E5%B0%84/"},{"categories":["JavaSE笔记"],"content":"反射获取注解 既然我们的注解可以保留到运行时，那么我们来看看，如何获取我们编写的注解，我们需要用到反射机制： public static void main(String[] args) { Class\u003cStudent\u003e clazz = Student.class; for (Annotation annotation : clazz.getAnnotations()) { System.out.println(annotation.annotationType()); //获取类型 System.out.println(annotation instanceof Test); //直接判断是否为Test Test test = (Test) annotation; System.out.println(test.value()); //获取我们在注解中写入的内容 } } 通过反射机制，我们可以快速获取到我们标记的注解，同时还能获取到注解中填入的值，那么我们来看看，方法上的标记是不是也可以通过这种方式获取注解： public static void main(String[] args) throws NoSuchMethodException { Class\u003cStudent\u003e clazz = Student.class; for (Annotation annotation : clazz.getMethod(\"test\").getAnnotations()) { System.out.println(annotation.annotationType()); //获取类型 System.out.println(annotation instanceof Test); //直接判断是否为Test Test test = (Test) annotation; System.out.println(test.value()); //获取我们在注解中写入的内容 } } 无论是方法、类、还是字段，都可以使用getAnnotations()方法（还有几个同名的）来快速获取我们标记的注解。 所以说呢，这玩意学来有啥用？丝毫get不到这玩意的用处。其实不是，现阶段你们还体会不到注解带来的快乐，在接触到Spring和SpringBoot等大型框架后，就能感受到注解带来的魅力了。 ","date":"2022-01-23","objectID":"/posts/java%E5%8F%8D%E5%B0%84%E4%B8%8E%E6%B3%A8%E5%B0%84/:7:4","tags":["Java反射与注解"],"title":"Java反射与注解","uri":"/posts/java%E5%8F%8D%E5%B0%84%E4%B8%8E%E6%B3%A8%E5%B0%84/"},{"categories":["JavaSE笔记"],"content":"Java多线程","date":"2022-01-23","objectID":"/posts/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/","tags":["Java多线程"],"title":"Java多线程","uri":"/posts/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"categories":["JavaSE笔记"],"content":"Java多线程 配套视频 **注意：**本章节会涉及到 操作系统 相关知识。 在了解多线程之前，让我们回顾一下操作系统中提到的进程概念： 进程是程序执行的实体，每一个进程都是一个应用程序（比如我们运行QQ、浏览器、LOL、网易云音乐等软件），都有自己的内存空间，CPU一个核心同时只能处理一件事情，当出现多个进程需要同时运行时，CPU一般通过时间片轮转调度算法，来实现多个进程的同时运行。 在早期的计算机中，进程是拥有资源和独立运行的最小单位，也是程序执行的最小单位。但是，如果我希望两个任务同时进行，就必须运行两个进程，由于每个进程都有一个自己的内存空间，进程之间的通信就变得非常麻烦（比如要共享某些数据）而且执行不同进程会产生上下文切换，非常耗时，那么能否实现在一个进程中就能够执行多个任务呢？ 后来，线程横空出世，一个进程可以有多个线程，线程是程序执行中一个单一的顺序控制流程，现在线程才是程序执行流的最小单元，各个线程之间共享程序的内存空间（也就是所在进程的内存空间），上下文切换速度也高于进程。 在Java中，我们从开始，一直以来编写的都是单线程应用程序（运行main()方法的内容），也就是说只能同时执行一个任务（无论你是调用方法、还是进行计算，始终都是依次进行的，也就是同步的），而如果我们希望同时执行多个任务（两个方法同时在运行或者是两个计算同时在进行，也就是异步的），就需要用到Java多线程框架。实际上一个Java程序启动后，会创建很多线程，不仅仅只运行一个主线程： public static void main(String[] args) { ThreadMXBean bean = ManagementFactory.getThreadMXBean(); long[] ids = bean.getAllThreadIds(); ThreadInfo[] infos = bean.getThreadInfo(ids); for (ThreadInfo info : infos) { System.out.println(info.getThreadName()); } } 关于除了main线程默认以外的线程，涉及到JVM相关底层原理，在这里不做讲解，了解就行。 ","date":"2022-01-23","objectID":"/posts/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/:0:0","tags":["Java多线程"],"title":"Java多线程","uri":"/posts/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"categories":["JavaSE笔记"],"content":"线程的创建和启动 通过创建Thread对象来创建一个新的线程，Thread构造方法中需要传入一个Runnable接口的实现（其实就是编写要在另一个线程执行的内容逻辑）同时Runnable只有一个未实现方法，因此可以直接使用lambda表达式： @FunctionalInterface public interface Runnable { /** * When an object implementing interface \u003ccode\u003eRunnable\u003c/code\u003e is used * to create a thread, starting the thread causes the object's * \u003ccode\u003erun\u003c/code\u003e method to be called in that separately executing * thread. * \u003cp\u003e * The general contract of the method \u003ccode\u003erun\u003c/code\u003e is that it may * take any action whatsoever. * * @see java.lang.Thread#run() */ public abstract void run(); } 创建好后，通过调用start()方法来运行此线程： public static void main(String[] args) { Thread t = new Thread(() -\u003e { //直接编写逻辑 System.out.println(\"我是另一个线程！\"); }); t.start(); //调用此方法来开始执行此线程 } 可能上面的例子看起来和普通的单线程没两样，那我们先来看看下面这段代码的运行结果： public static void main(String[] args) { Thread t = new Thread(() -\u003e { System.out.println(\"我是线程：\"+Thread.currentThread().getName()); System.out.println(\"我正在计算 0-10000 之间所有数的和...\"); int sum = 0; for (int i = 0; i \u003c= 10000; i++) { sum += i; } System.out.println(\"结果：\"+sum); }); t.start(); System.out.println(\"我是主线程！\"); } 我们发现，这段代码执行输出结果并不是按照从上往下的顺序了，因为他们分别位于两个线程，他们是同时进行的！如果你还是觉得很疑惑，我们接着来看下面的代码运行结果： public static void main(String[] args) { Thread t1 = new Thread(() -\u003e { for (int i = 0; i \u003c 50; i++) { System.out.println(\"我是一号线程：\"+i); } }); Thread t2 = new Thread(() -\u003e { for (int i = 0; i \u003c 50; i++) { System.out.println(\"我是二号线程：\"+i); } }); t1.start(); t2.start(); } 我们可以看到打印实际上是在交替进行的，也证明了他们是在同时运行！ 注意：我们发现还有一个run方法，也能执行线程里面定义的内容，但是run是直接在当前线程执行，并不是创建一个线程执行！ 实际上，线程和进程差不多，也会等待获取CPU资源，一旦获取到，就开始按顺序执行我们给定的程序，当需要等待外部IO操作（比如Scanner获取输入的文本），就会暂时处于休眠状态，等待通知，或是调用sleep()方法来让当前线程休眠一段时间： public static void main(String[] args) throws InterruptedException { System.out.println(\"l\"); Thread.sleep(1000); //休眠时间，以毫秒为单位，1000ms = 1s System.out.println(\"b\"); Thread.sleep(1000); System.out.println(\"w\"); Thread.sleep(1000); System.out.println(\"nb!\"); } 我们也可以使用stop()方法来强行终止此线程： public static void main(String[] args) throws InterruptedException { Thread t = new Thread(() -\u003e { Thread me = Thread.currentThread(); //获取当前线程对象 for (int i = 0; i \u003c 50; i++) { System.out.println(\"打印:\"+i); if(i == 20) me.stop(); //此方法会直接终止此线程 } }); t.start(); } 虽然stop()方法能够终止此线程，但是并不是所推荐的做法，有关线程中断相关问题，我们会在后面继续了解。 思考：猜猜以下程序输出结果： private static int value = 0; public static void main(String[] args) throws InterruptedException { Thread t1 = new Thread(() -\u003e { for (int i = 0; i \u003c 10000; i++) value++; System.out.println(\"线程1完成\"); }); Thread t2 = new Thread(() -\u003e { for (int i = 0; i \u003c 10000; i++) value++; System.out.println(\"线程2完成\"); }); t1.start(); t2.start(); Thread.sleep(1000); //主线程停止1秒，保证两个线程执行完成 System.out.println(value); } 我们发现，value最后的值并不是我们理想的结果，有关为什么会出现这种问题，在我们学习到线程锁的时候，再来探讨。 ","date":"2022-01-23","objectID":"/posts/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/:1:0","tags":["Java多线程"],"title":"Java多线程","uri":"/posts/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"categories":["JavaSE笔记"],"content":"线程的休眠和中断 我们前面提到，一个线程处于运行状态下，线程的下一个状态会出现以下情况： 当CPU给予的运行时间结束时，会从运行状态回到就绪（可运行）状态，等待下一次获得CPU资源。 当线程进入休眠 / 阻塞(如等待IO请求) / 手动调用wait()方法时，会使得线程处于等待状态，当等待状态结束后会回到就绪状态。 当线程出现异常或错误 / 被stop() 方法强行停止 / 所有代码执行结束时，会使得线程的运行终止。 而这个部分我们着重了解一下线程的休眠和中断，首先我们来了解一下如何使得线程进如休眠状态： public static void main(String[] args) { Thread t = new Thread(() -\u003e { try { System.out.println(\"l\"); Thread.sleep(1000); //sleep方法是Thread的静态方法，它只作用于当前线程（它知道当前线程是哪个） System.out.println(\"b\"); //调用sleep后，线程会直接进入到等待状态，直到时间结束 } catch (InterruptedException e) { e.printStackTrace(); } }); t.start(); } 通过调用sleep()方法来将当前线程进入休眠，使得线程处于等待状态一段时间。我们发现，此方法显示声明了会抛出一个InterruptedException异常，那么这个异常在什么时候会发生呢？ public static void main(String[] args) { Thread t = new Thread(() -\u003e { try { Thread.sleep(10000); //休眠10秒 } catch (InterruptedException e) { e.printStackTrace(); } }); t.start(); try { Thread.sleep(3000); //休眠3秒，一定比线程t先醒来 t.interrupt(); //调用t的interrupt方法 } catch (InterruptedException e) { e.printStackTrace(); } } 我们发现，每一个Thread对象中，都有一个interrupt()方法，调用此方法后，会给指定线程添加一个中断标记以告知线程需要立即停止运行或是进行其他操作，由线程来响应此中断并进行相应的处理，我们前面提到的stop()方法是强制终止线程，这样的做法虽然简单粗暴，但是很有可能导致资源不能完全释放，而类似这样的发送通知来告知线程需要中断，让线程自行处理后续，会更加合理一些，也是更加推荐的做法。我们来看看interrupt的用法： public static void main(String[] args) { Thread t = new Thread(() -\u003e { System.out.println(\"线程开始运行！\"); while (true){ //无限循环 if(Thread.currentThread().isInterrupted()){ //判断是否存在中断标志 break; //响应中断 } } System.out.println(\"线程被中断了！\"); }); t.start(); try { Thread.sleep(3000); //休眠3秒，一定比线程t先醒来 t.interrupt(); //调用t的interrupt方法 } catch (InterruptedException e) { e.printStackTrace(); } } 通过isInterrupted()可以判断线程是否存在中断标志，如果存在，说明外部希望当前线程立即停止，也有可能是给当前线程发送一个其他的信号，如果我们并不是希望收到中断信号就是结束程序，而是通知程序做其他事情，我们可以在收到中断信号后，复位中断标记，然后继续做我们的事情： public static void main(String[] args) { Thread t = new Thread(() -\u003e { System.out.println(\"线程开始运行！\"); while (true){ if(Thread.currentThread().isInterrupted()){ //判断是否存在中断标志 System.out.println(\"发现中断信号，复位，继续运行...\"); Thread.interrupted(); //复位中断标记（返回值是当前是否有中断标记，这里不用管） } } }); t.start(); try { Thread.sleep(3000); //休眠3秒，一定比线程t先醒来 t.interrupt(); //调用t的interrupt方法 } catch (InterruptedException e) { e.printStackTrace(); } } 复位中断标记后，会立即清除中断标记。那么，如果现在我们想暂停线程呢？我们希望线程暂时停下，比如等待其他线程执行完成后，再继续运行，那这样的操作怎么实现呢？ public static void main(String[] args) { Thread t = new Thread(() -\u003e { System.out.println(\"线程开始运行！\"); Thread.currentThread().suspend(); //暂停此线程 System.out.println(\"线程继续运行！\"); }); t.start(); try { Thread.sleep(3000); //休眠3秒，一定比线程t先醒来 t.resume(); //恢复此线程 } catch (InterruptedException e) { e.printStackTrace(); } } 虽然这样很方便地控制了线程的暂停状态，但是这两个方法我们发现实际上也是不推荐的做法，它很容易导致死锁！有关为什么被弃用的原因，我们会在线程锁继续探讨。 ","date":"2022-01-23","objectID":"/posts/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/:2:0","tags":["Java多线程"],"title":"Java多线程","uri":"/posts/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"categories":["JavaSE笔记"],"content":"线程的优先级 实际上，Java程序中的每个线程并不是平均分配CPU时间的，为了使得线程资源分配更加合理，Java采用的是抢占式调度方式，优先级越高的线程，优先使用CPU资源！我们希望CPU花费更多的时间去处理更重要的任务，而不太重要的任务，则可以先让出一部分资源。线程的优先级一般分为以下三种： MIN_PRIORITY 最低优先级 MAX_PRIORITY 最高优先级 NOM_PRIORITY 常规优先级 public static void main(String[] args) { Thread t = new Thread(() -\u003e { System.out.println(\"线程开始运行！\"); }); t.start(); t.setPriority(Thread.MIN_PRIORITY); //通过使用setPriority方法来设定优先级 } 优先级越高的线程，获得CPU资源的概率会越大，并不是说一定优先级越高的线程越先执行！ ","date":"2022-01-23","objectID":"/posts/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/:3:0","tags":["Java多线程"],"title":"Java多线程","uri":"/posts/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"categories":["JavaSE笔记"],"content":"线程的礼让和加入 我们还可以在当前线程的工作不重要时，将CPU资源让位给其他线程，通过使用yield()方法来将当前资源让位给其他同优先级线程： public static void main(String[] args) { Thread t1 = new Thread(() -\u003e { System.out.println(\"线程1开始运行！\"); for (int i = 0; i \u003c 50; i++) { if(i % 5 == 0) { System.out.println(\"让位！\"); Thread.yield(); } System.out.println(\"1打印：\"+i); } System.out.println(\"线程1结束！\"); }); Thread t2 = new Thread(() -\u003e { System.out.println(\"线程2开始运行！\"); for (int i = 0; i \u003c 50; i++) { System.out.println(\"2打印：\"+i); } }); t1.start(); t2.start(); } 观察结果，我们发现，在让位之后，尽可能多的在执行线程2的内容。 当我们希望一个线程等待另一个线程执行完成后再继续进行，我们可以使用join()方法来实现线程的加入： public static void main(String[] args) { Thread t1 = new Thread(() -\u003e { System.out.println(\"线程1开始运行！\"); for (int i = 0; i \u003c 50; i++) { System.out.println(\"1打印：\"+i); } System.out.println(\"线程1结束！\"); }); Thread t2 = new Thread(() -\u003e { System.out.println(\"线程2开始运行！\"); for (int i = 0; i \u003c 50; i++) { System.out.println(\"2打印：\"+i); if(i == 10){ try { System.out.println(\"线程1加入到此线程！\"); t1.join(); //在i==10时，让线程1加入，先完成线程1的内容，在继续当前内容 } catch (InterruptedException e) { e.printStackTrace(); } } } }); t1.start(); t2.start(); } 我们发现，线程1加入后，线程2等待线程1待执行的内容全部执行完成之后，再继续执行的线程2内容。注意，线程的加入只是等待另一个线程的完成，并不是将另一个线程和当前线程合并！我们来看看： public static void main(String[] args) { Thread t1 = new Thread(() -\u003e { System.out.println(Thread.currentThread().getName()+\"开始运行！\"); for (int i = 0; i \u003c 50; i++) { System.out.println(Thread.currentThread().getName()+\"打印：\"+i); } System.out.println(\"线程1结束！\"); }); Thread t2 = new Thread(() -\u003e { System.out.println(\"线程2开始运行！\"); for (int i = 0; i \u003c 50; i++) { System.out.println(\"2打印：\"+i); if(i == 10){ try { System.out.println(\"线程1加入到此线程！\"); t1.join(); //在i==10时，让线程1加入，先完成线程1的内容，在继续当前内容 } catch (InterruptedException e) { e.printStackTrace(); } } } }); t1.start(); t2.start(); } 实际上，t2线程只是暂时处于等待状态，当t1执行结束时，t2才开始继续执行，只是在效果上看起来好像是两个线程合并为一个线程在执行而已。 ","date":"2022-01-23","objectID":"/posts/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/:4:0","tags":["Java多线程"],"title":"Java多线程","uri":"/posts/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"categories":["JavaSE笔记"],"content":"线程锁和线程同步 在开始讲解线程同步之前，我们需要先了解一下多线程情况下Java的内存管理： 线程之间的共享变量（比如之前悬念中的value变量）存储在主内存（main memory）中，每个线程都有一个私有的工作内存（本地内存），工作内存中存储了该线程以读/写共享变量的副本。它类似于我们在计算机组成原理中学习的多处理器高速缓存机制： 高速缓存通过保存内存中数据的副本来提供更加快速的数据访问，但是如果多个处理器的运算任务都涉及同一块内存区域，就可能导致各自的高速缓存数据不一致，在写回主内存时就会发生冲突，这就是引入高速缓存引发的新问题，称之为：缓存一致性。 实际上，Java的内存模型也是这样类似设计的，当我们同时去操作一个共享变量时，如果仅仅是读取还好，但是如果同时写入内容，就会出现问题！好比说一个银行，如果我和我的朋友同时在银行取我账户里面的钱，难道取1000还可能吐2000出来吗？我们需要一种更加安全的机制来维持秩序，保证数据的安全性！ ","date":"2022-01-23","objectID":"/posts/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/:5:0","tags":["Java多线程"],"title":"Java多线程","uri":"/posts/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"categories":["JavaSE笔记"],"content":"悬念破案 我们再来回顾一下之前留给大家的悬念： private static int value = 0; public static void main(String[] args) throws InterruptedException { Thread t1 = new Thread(() -\u003e { for (int i = 0; i \u003c 10000; i++) value++; System.out.println(\"线程1完成\"); }); Thread t2 = new Thread(() -\u003e { for (int i = 0; i \u003c 10000; i++) value++; System.out.println(\"线程2完成\"); }); t1.start(); t2.start(); Thread.sleep(1000); //主线程停止1秒，保证两个线程执行完成 System.out.println(value); } 实际上，当两个线程同时读取value的时候，可能会同时拿到同样的值，而进行自增操作之后，也是同样的值，再写回主内存后，本来应该进行2次自增操作，实际上只执行了一次！ 那么要去解决这样的问题，我们就必须采取某种同步机制，来限制不同线程对于共享变量的访问！我们希望的是保证共享变量value自增操作的原子性（原子性是指一个操作或多个操作要么全部执行，且执行的过程不会被任何因素打断，包括其他线程，要么就都不执行） ","date":"2022-01-23","objectID":"/posts/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/:5:1","tags":["Java多线程"],"title":"Java多线程","uri":"/posts/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"categories":["JavaSE笔记"],"content":"线程锁 通过synchronized关键字来创造一个线程锁，首先我们来认识一下synchronized代码块，它需要在括号中填入一个内容，必须是一个对象或是一个类，我们在value自增操作外套上同步代码块： private static int value = 0; public static void main(String[] args) throws InterruptedException { Thread t1 = new Thread(() -\u003e { for (int i = 0; i \u003c 10000; i++) { synchronized (Main.class){ value++; } } System.out.println(\"线程1完成\"); }); Thread t2 = new Thread(() -\u003e { for (int i = 0; i \u003c 10000; i++) { synchronized (Main.class){ value++; } } System.out.println(\"线程2完成\"); }); t1.start(); t2.start(); Thread.sleep(1000); //主线程停止1秒，保证两个线程执行完成 System.out.println(value); } 我们发现，现在得到的结果就是我们想要的内容了，因为在同步代码块执行过程中，拿到了我们传入对象或类的锁（传入的如果是对象，就是对象锁，不同的对象代表不同的对象锁，如果是类，就是类锁，类锁只有一个，实际上类锁也是对象锁，是Class类实例，但是Class类实例同样的类无论怎么获取都是同一个），但是注意两个线程必须使用同一把锁！ 当一个线程进入到同步代码块时，会获取到当前的锁，而这时如果其他使用同样的锁的同步代码块也想执行内容，就必须等待当前同步代码块的内容执行完毕，在执行完毕后会自动释放这把锁，而其他的线程才能拿到这把锁并开始执行同步代码块里面的内容。（实际上synchronized是一种悲观锁，随时都认为有其他线程在对数据进行修改，后面有机会我们还会讲到乐观锁，如CAS算法） 那么我们来看看，如果使用的是不同对象的锁，那么还能顺利进行吗？ private static int value = 0; public static void main(String[] args) throws InterruptedException { Main main1 = new Main(); Main main2 = new Main(); Thread t1 = new Thread(() -\u003e { for (int i = 0; i \u003c 10000; i++) { synchronized (main1){ value++; } } System.out.println(\"线程1完成\"); }); Thread t2 = new Thread(() -\u003e { for (int i = 0; i \u003c 10000; i++) { synchronized (main2){ value++; } } System.out.println(\"线程2完成\"); }); t1.start(); t2.start(); Thread.sleep(1000); //主线程停止1秒，保证两个线程执行完成 System.out.println(value); } 当对象不同时，获取到的是不同的锁，因此并不能保证自增操作的原子性，最后也得不到我们想要的结果。 synchronized关键字也可以作用于方法上，调用此方法时也会获取锁： private static int value = 0; private static synchronized void add(){ value++; } public static void main(String[] args) throws InterruptedException { Thread t1 = new Thread(() -\u003e { for (int i = 0; i \u003c 10000; i++) add(); System.out.println(\"线程1完成\"); }); Thread t2 = new Thread(() -\u003e { for (int i = 0; i \u003c 10000; i++) add(); System.out.println(\"线程2完成\"); }); t1.start(); t2.start(); Thread.sleep(1000); //主线程停止1秒，保证两个线程执行完成 System.out.println(value); } 我们发现实际上效果是相同的，只不过这个锁不用你去给，如果是静态方法，就是使用的类锁，而如果是普通成员方法，就是使用的对象锁。通过灵活的使用synchronized就能很好地解决我们之前提到的问题了！ ","date":"2022-01-23","objectID":"/posts/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/:5:2","tags":["Java多线程"],"title":"Java多线程","uri":"/posts/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"categories":["JavaSE笔记"],"content":"死锁 其实死锁的概念在操作系统中也有提及，它是指两个线程相互持有对方需要的锁，但是又迟迟不释放，导致程序卡住： 我们发现，线程A和线程B都需要对方的锁，但是又被对方牢牢把握，由于线程被无限期地阻塞，因此程序不可能正常终止。我们来看看以下这段代码会得到什么结果： public static void main(String[] args) throws InterruptedException { Object o1 = new Object(); Object o2 = new Object(); Thread t1 = new Thread(() -\u003e { synchronized (o1){ try { Thread.sleep(1000); synchronized (o2){ System.out.println(\"线程1\"); } } catch (InterruptedException e) { e.printStackTrace(); } } }); Thread t2 = new Thread(() -\u003e { synchronized (o2){ try { Thread.sleep(1000); synchronized (o1){ System.out.println(\"线程2\"); } } catch (InterruptedException e) { e.printStackTrace(); } } }); t1.start(); t2.start(); } 那么我们如何去检测死锁呢？我们可以利用jstack命令来检测死锁，首先利用jps找到我们的java进程： nagocoler@NagodeMacBook-Pro ~ % jps 51592 Launcher 51690 Jps 14955 51693 Main nagocoler@NagodeMacBook-Pro ~ % jstack 51693 ... Java stack information for the threads listed above: =================================================== \"Thread-1\": at com.test.Main.lambda$main$1(Main.java:46) - waiting to lock \u003c0x000000076ad27fc0\u003e (a java.lang.Object) - locked \u003c0x000000076ad27fd0\u003e (a java.lang.Object) at com.test.Main$$Lambda$2/1867750575.run(Unknown Source) at java.lang.Thread.run(Thread.java:748) \"Thread-0\": at com.test.Main.lambda$main$0(Main.java:34) - waiting to lock \u003c0x000000076ad27fd0\u003e (a java.lang.Object) - locked \u003c0x000000076ad27fc0\u003e (a java.lang.Object) at com.test.Main$$Lambda$1/396873410.run(Unknown Source) at java.lang.Thread.run(Thread.java:748) Found 1 deadlock. jstack自动帮助我们找到了一个死锁，并打印出了相关线程的栈追踪信息。 不推荐使用 suspend() 去挂起线程的原因，是因为suspend()在使线程暂停的同时，并不会去释放任何锁资源。其他线程都无法访问被它占用的锁。直到对应的线程执行resume()方法后，被挂起的线程才能继续，从而其它被阻塞在这个锁的线程才可以继续执行。但是，如果resume()操作出现在suspend()之前执行，那么线程将一直处于挂起状态，同时一直占用锁，这就产生了死锁。 ","date":"2022-01-23","objectID":"/posts/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/:5:3","tags":["Java多线程"],"title":"Java多线程","uri":"/posts/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"categories":["JavaSE笔记"],"content":"wait和notify方法 其实我们之前可能就发现了，Object类还有三个方法我们从来没有使用过，分别是wait()、notify()以及notifyAll()，他们其实是需要配合synchronized来使用的，只有在同步代码块中才能使用这些方法，我们来看看他们的作用是什么： public static void main(String[] args) throws InterruptedException { Object o1 = new Object(); Thread t1 = new Thread(() -\u003e { synchronized (o1){ try { System.out.println(\"开始等待\"); o1.wait(); //进入等待状态并释放锁 System.out.println(\"等待结束！\"); } catch (InterruptedException e) { e.printStackTrace(); } } }); Thread t2 = new Thread(() -\u003e { synchronized (o1){ System.out.println(\"开始唤醒！\"); o1.notify(); //唤醒处于等待状态的线程 for (int i = 0; i \u003c 50; i++) { System.out.println(i); } //唤醒后依然需要等待这里的锁释放之前等待的线程才能继续 } }); t1.start(); Thread.sleep(1000); t2.start(); } 我们可以发现，对象的wait()方法会暂时使得此线程进入等待状态，同时会释放当前代码块持有的锁，这时其他线程可以获取到此对象的锁，当其他线程调用对象的notify()方法后，会唤醒刚才变成等待状态的线程（这时并没有立即释放锁）。注意，必须是在持有锁（同步代码块内部）的情况下使用，否则会抛出异常！ notifyAll其实和notify一样，也是用于唤醒，但是前者是唤醒所有调用wait()后处于等待的线程，而后者是看运气随机选择一个。 ","date":"2022-01-23","objectID":"/posts/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/:5:4","tags":["Java多线程"],"title":"Java多线程","uri":"/posts/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"categories":["JavaSE笔记"],"content":"ThreadLocal的使用 既然每个线程都有一个自己的工作内存，那么能否只在自己的工作内存中创建变量仅供线程自己使用呢？ 我们可以是ThreadLocal类，来创建工作内存中的变量，它将我们的变量值存储在内部（只能存储一个变量），不同的变量访问到ThreadLocal对象时，都只能获取到自己线程所属的变量。 public static void main(String[] args) throws InterruptedException { ThreadLocal\u003cString\u003e local = new ThreadLocal\u003c\u003e(); //注意这是一个泛型类，存储类型为我们要存放的变量类型 Thread t1 = new Thread(() -\u003e { local.set(\"lbwnb\"); //将变量的值给予ThreadLocal System.out.println(\"变量值已设定！\"); System.out.println(local.get()); //尝试获取ThreadLocal中存放的变量 }); Thread t2 = new Thread(() -\u003e { System.out.println(local.get()); //尝试获取ThreadLocal中存放的变量 }); t1.start(); Thread.sleep(3000); //间隔三秒 t2.start(); } 上面的例子中，我们开启两个线程分别去访问ThreadLocal对象，我们发现，第一个线程存放的内容，第一个线程可以获取，但是第二个线程无法获取，我们再来看看第一个线程存入后，第二个线程也存放，是否会覆盖第一个线程存放的内容： public static void main(String[] args) throws InterruptedException { ThreadLocal\u003cString\u003e local = new ThreadLocal\u003c\u003e(); //注意这是一个泛型类，存储类型为我们要存放的变量类型 Thread t1 = new Thread(() -\u003e { local.set(\"lbwnb\"); //将变量的值给予ThreadLocal System.out.println(\"线程1变量值已设定！\"); try { Thread.sleep(2000); //间隔2秒 } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(\"线程1读取变量值：\"); System.out.println(local.get()); //尝试获取ThreadLocal中存放的变量 }); Thread t2 = new Thread(() -\u003e { local.set(\"yyds\"); //将变量的值给予ThreadLocal System.out.println(\"线程2变量值已设定！\"); }); t1.start(); Thread.sleep(1000); //间隔1秒 t2.start(); } 我们发现，即使线程2重新设定了值，也没有影响到线程1存放的值，所以说，不同线程向ThreadLocal存放数据，只会存放在线程自己的工作空间中，而不会直接存放到主内存中，因此各个线程直接存放的内容互不干扰。 我们发现在线程中创建的子线程，无法获得父线程工作内存中的变量： public static void main(String[] args) { ThreadLocal\u003cString\u003e local = new ThreadLocal\u003c\u003e(); Thread t = new Thread(() -\u003e { local.set(\"lbwnb\"); new Thread(() -\u003e { System.out.println(local.get()); }).start(); }); t.start(); } 我们可以使用InheritableThreadLocal来解决： public static void main(String[] args) { ThreadLocal\u003cString\u003e local = new InheritableThreadLocal\u003c\u003e(); Thread t = new Thread(() -\u003e { local.set(\"lbwnb\"); new Thread(() -\u003e { System.out.println(local.get()); }).start(); }); t.start(); } 在InheritableThreadLocal存放的内容，会自动向子线程传递。 ","date":"2022-01-23","objectID":"/posts/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/:5:5","tags":["Java多线程"],"title":"Java多线程","uri":"/posts/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"categories":["JavaSE笔记"],"content":"定时器 我们有时候会有这样的需求，我希望定时执行任务，比如3秒后执行，其实我们可以通过使用Thread.sleep()来实现： public static void main(String[] args) { new TimerTask(() -\u003e System.out.println(\"我是定时任务！\"), 3000).start(); //创建并启动此定时任务 } static class TimerTask{ Runnable task; long time; public TimerTask(Runnable runnable, long time){ this.task = runnable; this.time = time; } public void start(){ new Thread(() -\u003e { try { Thread.sleep(time); task.run(); //休眠后再运行 } catch (InterruptedException e) { e.printStackTrace(); } }).start(); } } 我们通过自行封装一个TimerTask类，并在启动时，先休眠3秒钟，再执行我们传入的内容。那么现在我们希望，能否循环执行一个任务呢？比如我希望每隔1秒钟执行一次代码，这样该怎么做呢？ public static void main(String[] args) { new TimerLoopTask(() -\u003e System.out.println(\"我是定时任务！\"), 3000).start(); //创建并启动此定时任务 } static class TimerLoopTask{ Runnable task; long loopTime; public TimerLoopTask(Runnable runnable, long loopTime){ this.task = runnable; this.loopTime = loopTime; } public void start(){ new Thread(() -\u003e { try { while (true){ //无限循环执行 Thread.sleep(loopTime); task.run(); //休眠后再运行 } } catch (InterruptedException e) { e.printStackTrace(); } }).start(); } } 现在我们将单次执行放入到一个无限循环中，这样就能一直执行了，并且按照我们的间隔时间进行。 但是终究是我们自己实现，可能很多方面还没考虑到，Java也为我们提供了一套自己的框架用于处理定时任务： public static void main(String[] args) { Timer timer = new Timer(); //创建定时器对象 timer.schedule(new TimerTask() { //注意这个是一个抽象类，不是接口，无法使用lambda表达式简化，只能使用匿名内部类 @Override public void run() { System.out.println(Thread.currentThread().getName()); //打印当前线程名称 } }, 1000); //执行一个延时任务 } 我们可以通过创建一个Timer类来让它进行定时任务调度，我们可以通过此对象来创建任意类型的定时任务，包延时任务、循环定时任务等。我们发现，虽然任务执行完成了，但是我们的程序并没有停止，这是因为Timer内存维护了一个任务队列和一个工作线程： public class Timer { /** * The timer task queue. This data structure is shared with the timer * thread. The timer produces tasks, via its various schedule calls, * and the timer thread consumes, executing timer tasks as appropriate, * and removing them from the queue when they're obsolete. */ private final TaskQueue queue = new TaskQueue(); /** * The timer thread. */ private final TimerThread thread = new TimerThread(queue); ... } TimerThread继承自Thread，是一个新创建的线程，在构造时自动启动： public Timer(String name) { thread.setName(name); thread.start(); } 而它的run方法会循环地读取队列中是否还有任务，如果有任务依次执行，没有的话就暂时处于休眠状态： public void run() { try { mainLoop(); } finally { // Someone killed this Thread, behave as if Timer cancelled synchronized(queue) { newTasksMayBeScheduled = false; queue.clear(); // Eliminate obsolete references } } } /** * The main timer loop. (See class comment.) */ private void mainLoop() { try { TimerTask task; boolean taskFired; synchronized(queue) { // Wait for queue to become non-empty while (queue.isEmpty() \u0026\u0026 newTasksMayBeScheduled) //当队列为空同时没有被关闭时，会调用wait()方法暂时处于等待状态，当有新的任务时，会被唤醒。 queue.wait(); if (queue.isEmpty()) break; //当被唤醒后都没有任务时，就会结束循环，也就是结束工作线程 ... } newTasksMayBeScheduled实际上就是标记当前定时器是否关闭，当它为false时，表示已经不会再有新的任务到来，也就是关闭，我们可以通过调用cancel()方法来关闭它的工作线程： public void cancel() { synchronized(queue) { thread.newTasksMayBeScheduled = false; queue.clear(); queue.notify(); //唤醒wait使得工作线程结束 } } 因此，我们可以在使用完成后，调用Timer的cancel()方法以正常退出我们的程序： public static void main(String[] args) { Timer timer = new Timer(); timer.schedule(new TimerTask() { @Override public void run() { System.out.println(Thread.currentThread().getName()); timer.cancel(); //结束 } }, 1000); } ","date":"2022-01-23","objectID":"/posts/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/:6:0","tags":["Java多线程"],"title":"Java多线程","uri":"/posts/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"categories":["JavaSE笔记"],"content":"守护线程 不要把守护进程和守护线程相提并论！守护进程在后台运行运行，不需要和用户交互，本质和普通进程类似。而守护线程就不一样了，当其他所有的非守护线程结束之后，守护线程是自动结束，也就是说，Java中所有的线程都执行完毕后，守护线程自动结束，因此守护线程不适合进行IO操作，只适合打打杂： public static void main(String[] args) throws InterruptedException{ Thread t = new Thread(() -\u003e { while (true){ try { System.out.println(\"程序正常运行中...\"); Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } } }); t.setDaemon(true); //设置为守护线程（必须在开始之前，中途是不允许转换的） t.start(); for (int i = 0; i \u003c 5; i++) { Thread.sleep(1000); } } 在守护线程中产生的新线程也是守护的： public static void main(String[] args) throws InterruptedException{ Thread t = new Thread(() -\u003e { Thread it = new Thread(() -\u003e { while (true){ try { System.out.println(\"程序正常运行中...\"); Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } } }); it.start(); }); t.setDaemon(true); //设置为守护线程（必须在开始之前，中途是不允许转换的） t.start(); for (int i = 0; i \u003c 5; i++) { Thread.sleep(1000); } } ","date":"2022-01-23","objectID":"/posts/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/:7:0","tags":["Java多线程"],"title":"Java多线程","uri":"/posts/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"categories":["JavaSE笔记"],"content":"再谈集合类并行方法 其实我们之前在讲解集合类的根接口时，就发现有这样一个方法： default Stream\u003cE\u003e parallelStream() { return StreamSupport.stream(spliterator(), true); } 并行流，其实就是一个多线程执行的流，它通过默认的ForkJoinPool实现（这里不讲解原理），它可以提高你的多线程任务的速度。 public static void main(String[] args) { List\u003cInteger\u003e list = new ArrayList\u003c\u003e(Arrays.asList(1, 4, 5, 2, 9, 3, 6, 0)); list .parallelStream() //获得并行流 .forEach(i -\u003e System.out.println(Thread.currentThread().getName()+\" -\u003e \"+i)); } 我们发现，forEach操作的顺序，并不是我们实际List中的顺序，同时每次打印也是不同的线程在执行！我们可以通过调用forEachOrdered()方法来使用单线程维持原本的顺序： public static void main(String[] args) { List\u003cInteger\u003e list = new ArrayList\u003c\u003e(Arrays.asList(1, 4, 5, 2, 9, 3, 6, 0)); list .parallelStream() //获得并行流 .forEachOrdered(System.out::println); } 我们之前还发现，在Arrays数组工具类中，也包含大量的并行方法： public static void main(String[] args) { int[] arr = new int[]{1, 4, 5, 2, 9, 3, 6, 0}; Arrays.parallelSort(arr); //使用多线程进行并行排序，效率更高 System.out.println(Arrays.toString(arr)); } 更多地使用并行方法，可以更加充分地发挥现代计算机多核心的优势，但是同时需要注意多线程产生的异步问题！ public static void main(String[] args) { int[] arr = new int[]{1, 4, 5, 2, 9, 3, 6, 0}; Arrays.parallelSetAll(arr, i -\u003e { System.out.println(Thread.currentThread().getName()); return arr[i]; }); System.out.println(Arrays.toString(arr)); } 通过对Java多线程的了解，我们就具备了利用多线程解决问题的思维！ ","date":"2022-01-23","objectID":"/posts/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/:8:0","tags":["Java多线程"],"title":"Java多线程","uri":"/posts/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"categories":["JavaSE笔记"],"content":"Java多线程编程实战 这是整个教程最后一个编程实战内容了，下一章节为反射一般开发者使用比较少，属于选学内容，不编排编程实战课程。 ","date":"2022-01-23","objectID":"/posts/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/:9:0","tags":["Java多线程"],"title":"Java多线程","uri":"/posts/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"categories":["JavaSE笔记"],"content":"生产者与消费者 所谓的生产者消费者模型，是通过一个容器来解决生产者和消费者的强耦合问题。通俗的讲，就是生产者在不断的生产，消费者也在不断的消费，可是消费者消费的产品是生产者生产的，这就必然存在一个中间容器，我们可以把这个容器想象成是一个货架，当货架空的时候，生产者要生产产品，此时消费者在等待生产者往货架上生产产品，而当货架有货物的时候，消费者可以从货架上拿走商品，生产者此时等待货架出现空位，进而补货，这样不断的循环。 通过多线程编程，来模拟一个餐厅的2个厨师和3个顾客，假设厨师炒出一个菜的时间为3秒，顾客吃掉菜品的时间为4秒。 ","date":"2022-01-23","objectID":"/posts/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/:9:1","tags":["Java多线程"],"title":"Java多线程","uri":"/posts/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"categories":["JavaSE笔记"],"content":"java面向对象","date":"2022-01-23","objectID":"/posts/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/","tags":["Java对象和多态"],"title":"Java对象和多态","uri":"/posts/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"categories":["JavaSE笔记"],"content":"Java对象和多态 （面向对象） 配套视频 ","date":"2022-01-23","objectID":"/posts/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/:0:0","tags":["Java对象和多态"],"title":"Java对象和多态","uri":"/posts/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"categories":["JavaSE笔记"],"content":"面向对象基础 面向对象程序设计(Object Oriented Programming) 对象基于类创建，类相当于一个模板，对象就是根据模板创建出来的实体（就像做月饼，我们要做一个月饼首先需要一个模具，模具就是我们的类，而做出来的月饼，就是类的实现，也叫做对象），类是抽象的数据类型，并不能代表某一个具体的事物，类是对象的一个模板。类具有自己的属性，包括成员变量、成员方法等，我们可以调用类的成员方法来让类进行一些操作。 Scanner sc = new Scanner(System.in); String str = sc.nextLine(); System.out.println(\"你输入了：\"+str); sc.close(); 所有的对象，都需要通过new关键字创建，基本数据类型不是对象！Java不是纯面对对象语言！ 不是基本类型的变量，都是引用类型，引用类型变量代表一个对象，而基本数据类型变量，保存的是基本数据类型的值，我们可以通过引用来对对象进行操作。（最好不要理解为引用指向对象的地址，初学者不要谈内存，学到JVM时再来讨论） 对象占用的内存由JVM统一管理，不需要手动释放内存，当一个对象不再使用时（比如失去引用或是离开了作用域）会被JVM自动清理，内存管理更方便！ ","date":"2022-01-23","objectID":"/posts/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/:1:0","tags":["Java对象和多态"],"title":"Java对象和多态","uri":"/posts/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"categories":["JavaSE笔记"],"content":"类的基本结构 为了快速掌握，我们自己创建一个自己的类，创建的类文件名称应该和类名一致。 ","date":"2022-01-23","objectID":"/posts/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/:2:0","tags":["Java对象和多态"],"title":"Java对象和多态","uri":"/posts/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"categories":["JavaSE笔记"],"content":"成员变量 在类中，可以包含许多的成员变量，也叫成员属性，成员字段(field)通过.来访问我们类中的成员变量，我们可以通过类创建的对象来访问和修改这些变量。成员变量是属于对象的！ public class Test { int age; String name; } public static void main(String[] args) { Test test = new Test(); test.name = \"奥利给\"; System.out.println(test.name); } 成员变量默认带有初始值，也可以自己定义初始值。 ","date":"2022-01-23","objectID":"/posts/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/:2:1","tags":["Java对象和多态"],"title":"Java对象和多态","uri":"/posts/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"categories":["JavaSE笔记"],"content":"成员方法 我们之前的学习中接触过方法(Method)吗？主方法！ public static void main(String[] args) { //Body } 方法是语句的集合，是为了完成某件事情而存在的。完成某件事情，可以有结果，也可以做了就做了，不返回结果。比如计算两个数字的和，我们需要得到计算后的结果，所以说方法需要有返回值；又比如，我们只想吧数字打印在控制台，只需要打印就行，不用给我结果，所以说方法不需要有返回值。 方法的定义和使用 在类中，我们可以定义自己的方法，格式如下： [返回值类型] 方法名称([参数]){ //方法体 return 结果; } 返回值类型：可以是引用类型和基本类型，还可以是void，表示没有返回值 方法名称：和标识符的规则一致，和变量一样，规范小写字母开头！ 参数：例如方法需要计算两个数的和，那么我们就要把两个数到底是什么告诉方法，那么它们就可以作为参数传入方法 方法体：方法具体要干的事情 结果：方法执行的结果通过return返回（如果返回类型为void，可以省略return） 非void方法中，return关键字不一定需要放在最后，但是一定要保证方法在任何情况下都具有返回值！ int test(int a){ if(a \u003e 0){ //缺少retrun语句！ }else{ return 0; } } return也能用来提前结束整个方法，无论此时程序执行到何处，无论return位于哪里，都会立即结束个方法！ void main(String[] args) { for (int i = 0; i \u003c 10; i++) { if(i == 1) return; //在循环内返回了！和break区别？ } System.out.println(\"淦\"); //还会到这里吗？ } 传入方法的参数，如果是基本类型，会在调用方法的时候，对参数的值进行复制，方法中的参数变量，不是我们传入的变量本身！ public static void main(String[] args) { int a = 10, b = 20; new Test().swap(a, b); System.out.println(\"a=\"+a+\", b=\"+b); } public class Test{ void swap(int a, int b){ //传递的仅仅是值而已！ int temp = a; a = b; b = temp; } } 传入方法的参数，如果是引用类型，那么传入的依然是该对象的引用！（类似于C语言的指针） public class B{ String name; } public class A{ void test(B b){ //传递的是对象的引用，而不是值 System.out.println(b.name); } } public static void main(String[] args) { int a = 10, b = 20; B b = new B(); b.name = \"lbw\"; new A().test(b); System.out.println(\"a=\"+a+\", b=\"+b); } 方法之间可以相互调用 void a(){ //xxxx } void b(){ a(); } 当方法在自己内部调用自己时，称为递归调用（递归很危险，慎重！） int a(){ return a(); } 成员方法和成员变量一样，是属于对象的，只能通过对象去调用！ ","date":"2022-01-23","objectID":"/posts/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/:2:2","tags":["Java对象和多态"],"title":"Java对象和多态","uri":"/posts/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"categories":["JavaSE笔记"],"content":"对象设计练习 学生应该具有以下属性：名字、年龄 学生应该具有以下行为：学习、运动、说话 ","date":"2022-01-23","objectID":"/posts/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/:2:3","tags":["Java对象和多态"],"title":"Java对象和多态","uri":"/posts/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"categories":["JavaSE笔记"],"content":"方法的重载 一个类中可以包含多个同名的方法，但是需要的形式参数不一样。（补充：形式参数就是定义方法需要的参数，实际参数就传入的参数）方法的返回类型，可以相同，也可以不同，但是仅返回类型不同，是不允许的！ public class Test { int a(){ //原本的方法 return 1; } int a(int i){ //ok，形参不同 return i; } void a(byte i){ //ok，返回类型和形参都不同 } void a(){ //错误，仅返回值类型名称不同不能重载 } } 现在我们就可以使用不同的参数，但是支持调用同样的方法，执行一样的逻辑： public class Test { int sum(int a, int b){ //只有int支持，不灵活！ return a+b; } double sum(double a, double b){ //重写一个double类型的，就支持小数计算了 return a+b; } } 现在我们有很多种重写的方法，那么传入实参后，到底进了哪个方法呢？ public class Test { void a(int i){ System.out.println(\"调用了int\"); } void a(short i){ System.out.println(\"调用了short\"); } void a(long i){ System.out.println(\"调用了long\"); } void a(char i){ System.out.println(\"调用了char\"); } void a(double i){ System.out.println(\"调用了double\"); } void a(float i){ System.out.println(\"调用了float\"); } public static void main(String[] args) { Test test = new Test(); test.a(1); //直接输入整数 test.a(1.0); //直接输入小数 short s = 2; test.a(s); //会对号入座吗？ test.a(1.0F); } } ","date":"2022-01-23","objectID":"/posts/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/:2:4","tags":["Java对象和多态"],"title":"Java对象和多态","uri":"/posts/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"categories":["JavaSE笔记"],"content":"构造方法 构造方法（构造器）没有返回值，也可以理解为，返回的是当前对象的引用！每一个类都默认自带一个无参构造方法。 //反编译结果 package com.test; public class Test { public Test() { //即使你什么都不编写，也自带一个无参构造方法，只是默认是隐藏的 } } 反编译其实就是把我们编译好的class文件变回Java源代码。 Test test = new Test(); //实际上存在Test()这个的方法，new关键字就是用来创建并得到引用的 // new + 你想要使用的构造方法 这种方法没有写明返回值，但是每个类都必须具有这个方法！只有调用类的构造方法，才能创建类的对象！ 类要在一开始准备的所有东西，都会在构造方法里面执行，完成构造方法的内容后，才能创建出对象！ 一般最常用的就是给成员属性赋初始值： public class Student { String name; Student(){ name = \"伞兵一号\"; } } 我们可以手动指定有参构造，当遇到名称冲突时，需要用到this关键字 public class Student { String name; Student(String name){ //形参和类成员变量冲突了，Java会优先使用形式参数定义的变量！ this.name = name; //通过this指代当前的对象属性，this就代表当前对象 } } //idea 右键快速生成！ 注意，this只能用于指代当前对象的内容，因此，只有属于对象拥有的部分才可以使用this，也就是说，只能在类的成员方法中使用this，不能在静态方法中使用this关键字。 在我们定义了新的有参构造之后，默认的无参构造会被覆盖！ //反编译后依然只有我们定义的有参构造！ 如果同时需要有参和无参构造，那么就需要用到方法的重载！手动再去定义一个无参构造。 public class Student { String name; Student(){ } Student(String name){ this.name = name; } } 成员变量的初始化始终在构造方法执行之前 public class Student { String a = \"sadasa\"; Student(){ System.out.println(a); } public static void main(String[] args) { Student s = new Student(); } } ","date":"2022-01-23","objectID":"/posts/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/:2:5","tags":["Java对象和多态"],"title":"Java对象和多态","uri":"/posts/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"categories":["JavaSE笔记"],"content":"静态变量和静态方法 静态变量和静态方法是类具有的属性（后面还会提到静态类、静态代码块），也可以理解为是所有对象共享的内容。我们通过使用static关键字来声明一个变量或一个方法为静态的，一旦被声明为静态，那么通过这个类创建的所有对象，操作的都是同一个目标，也就是说，对象再多，也只有这一个静态的变量或方法。那么，一个对象改变了静态变量的值，那么其他的对象读取的就是被改变的值。 public class Student { static int a; } public static void main(String[] args) { Student s1 = new Student(); s1.a = 10; Student s2 = new Student(); System.out.println(s2.a); } 不推荐使用对象来调用，被标记为静态的内容，可以直接通过类名.xxx的形式访问 public static void main(String[] args) { Student.a = 10; System.out.println(Student.a); } 简述类加载机制 类并不是在一开始就全部加载好，而是在需要时才会去加载（提升速度）以下情况会加载类： 访问类的静态变量，或者为静态变量赋值 new 创建类的实例（隐式加载） 调用类的静态方法 子类初始化时 其他的情况会在讲到反射时介绍 所有被标记为静态的内容，会在类刚加载的时候就分配，而不是在对象创建的时候分配，所以说静态内容一定会在第一个对象初始化之前完成加载。 public class Student { static int a = test(); //直接调用静态方法，只能调用静态方法 Student(){ System.out.println(\"构造类对象\"); } static int test(){ //静态方法刚加载时就有了 System.out.println(\"初始化变量a\"); return 1; } } 思考：下面这种情况下，程序能正常运行吗？如果能，会输出什么内容？ public class Student { static int a = test(); static int test(){ return a; } public static void main(String[] args) { System.out.println(Student.a); } } 定义和赋值是两个阶段，在定义时会使用默认值（上面讲的，类的成员变量会有默认值）定义出来之后，如果发现有赋值语句，再进行赋值，而这时，调用了静态方法，所以说会先去加载静态方法，静态方法调用时拿到a，而a这时仅仅是刚定义，所以说还是初始值，最后得到0 ","date":"2022-01-23","objectID":"/posts/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/:2:6","tags":["Java对象和多态"],"title":"Java对象和多态","uri":"/posts/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"categories":["JavaSE笔记"],"content":"代码块和静态代码块 代码块在对象创建时执行，也是属于类的内容，但是它在构造方法执行之前执行（和成员变量初始值一样），且每创建一个对象时，只执行一次！（相当于构造之前的准备工作） public class Student { { System.out.println(\"我是代码块\"); } Student(){ System.out.println(\"我是构造方法\"); } } 静态代码块和上面的静态方法和静态变量一样，在类刚加载时就会调用； public class Student { static int a; static { a = 10; } public static void main(String[] args) { System.out.println(Student.a); } } ","date":"2022-01-23","objectID":"/posts/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/:2:7","tags":["Java对象和多态"],"title":"Java对象和多态","uri":"/posts/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"categories":["JavaSE笔记"],"content":"String和StringBuilder类 字符串类是一个比较特殊的类，他是Java中唯一重载运算符的类！(Java不支持运算符重载，String是特例) String的对象直接支持使用+或+=运算符来进行拼接，并形成新的String对象！（String的字符串是不可变的！） String a = \"dasdsa\", b = \"dasdasdsa\"; String l = a+b; System.out.println(l); 大量进行字符串的拼接似乎不太好，编译器是很聪明的，String的拼接有可能会被编译器优化为StringBuilder来减少对象创建（对象频繁创建时很费时间同时占内存的！） String result=\"String\"+\"and\"; //会被优化成一句！ String str1=\"String\"; String str2=\"and\"; String result=str1+str2; //变量随时可变，在编译时无法确定result的值，那么只能在运行时再去确定 String str1=\"String\"; String str2=\"and\"; String result=(new StringBuilder(String.valueOf(str1))).append(str2).toString(); //使用StringBuilder，会采用类似于第一种实现，显然会更快！ StringBuilder也是一个类，但是它能够存储可变长度的字符串！ StringBuilder builder = new StringBuilder(); builder .append(\"a\") .append(\"bc\") .append(\"d\"); //链式调用 String str = builder.toString(); System.out.println(str); ","date":"2022-01-23","objectID":"/posts/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/:2:8","tags":["Java对象和多态"],"title":"Java对象和多态","uri":"/posts/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"categories":["JavaSE笔记"],"content":"包和访问控制 ","date":"2022-01-23","objectID":"/posts/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/:3:0","tags":["Java对象和多态"],"title":"Java对象和多态","uri":"/posts/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"categories":["JavaSE笔记"],"content":"包声明和导入 包其实就是用来区分类位置的东西，也可以用来将我们的类进行分类，类似于C++中的namespace！ package com.test; public class Test{ } 包其实是文件夹，比如com.test就是一个com文件夹中包含一个test文件夹，再包含我们Test类。 一般包按照个人或是公司域名的规则倒过来写 顶级域名.一级域名.二级域名 com.java.xxxx 如果需要使用其他包里面的类，那么我们需要import（类似于C/C++中的include） import com.test.Student; 也可以导入包下的全部（一般导入会由编译器自带帮我们补全，但是一定要记得我们需要导包！） import com.test.* Java默认为我们导入了以下的包，不需要去声明 import java.lang.* ","date":"2022-01-23","objectID":"/posts/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/:3:1","tags":["Java对象和多态"],"title":"Java对象和多态","uri":"/posts/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"categories":["JavaSE笔记"],"content":"静态导入 静态导入可以直接导入某个类的静态方法或者是静态变量，导入后，相当于这个方法或是类在定义在当前类中，可以直接调用该方法。 import static com.test.ui.Student.test; public class Main { public static void main(String[] args) { test(); } } 静态导入不会进行类的初始化！ ","date":"2022-01-23","objectID":"/posts/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/:3:2","tags":["Java对象和多态"],"title":"Java对象和多态","uri":"/posts/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"categories":["JavaSE笔记"],"content":"访问控制 Java支持对类属性访问的保护，也就是说，不希望外部类访问类中的属性或是方法，只允许内部调用，这种情况下我们就需要用到权限控制符。 ![image-20210819160939950](C:/Users/Alone/Users/nagocoler/Library/Application Support/typora-user-images/image-20210819160939950.png) 权限控制符可以声明在方法、成员变量、类前面，一旦声明private，只能类内部访问！ public class Student { private int a = 10; //具有私有访问权限，只能类内部访问 } public static void main(String[] args) { Student s = new Student(); System.out.println(s.a); //还可以访问吗？ } 和文件名称相同的类，只能是public，并且一个java文件中只能有一个public class！ // Student.java public class Student { } class Test{ //不能添加权限修饰符！只能是default } ","date":"2022-01-23","objectID":"/posts/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/:3:3","tags":["Java对象和多态"],"title":"Java对象和多态","uri":"/posts/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"categories":["JavaSE笔记"],"content":"数组类型 假设出现一种情况，我想记录100个数字，定义100个变量还可行吗？ 我们可以使用到数组，数组是相同类型数据的有序集合。数组可以代表任何相同类型的一组内容（包括引用类型和基本类型）其中存放的每一个数据称为数组的一个元素，数组的下标是从0开始，也就是第一个元素的索引是0！ int[] arr = new int[10]; //需要new关键字来创建！ String[] arr2 = new String[10]; 数组本身也是类（编程不可见，C++写的），不是基本数据类型！ int[] arr = new int[10]; System.out.println(arr.length); //数组有成员变量！ System.out.println(arr.toString()); //数组有成员方法！ ","date":"2022-01-23","objectID":"/posts/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/:4:0","tags":["Java对象和多态"],"title":"Java对象和多态","uri":"/posts/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"categories":["JavaSE笔记"],"content":"一维数组 一维数组中，元素是依次排列的（线性），每个数组元素可以通过下标来访问！声明格式如下： 类型[] 变量名称 = new 类型[数组大小]; 类型 变量名称n = new 类型[数组大小]; //支持C语言样式，但不推荐！ 类型[] 变量名称 = new 类型[]{...}; //静态初始化（直接指定值和大小） 类型[] 变量名称 = {...}; //同上，但是只能在定义时赋值 创建出来的数组每个元素都有默认值（规则和类的成员变量一样，C语言创建的数组需要手动设置默认值），我们可以通过下标去访问： int[] arr = new int[10]; arr[0] = 626; System.out.println(arr[0]); System.out.println(arr[1]); 我们可以通过数组变量名称.length来获取当前数组长度： int[] arr = new int[]{1, 2, 3}; System.out.println(arr.length); //打印length成员变量的值 数组在创建时，就固定长度，不可更改！访问超出数组长度的内容，会出现错误！ String[] arr = new String[10]; System.out.println(arr[10]); //出现异常！ //Exception in thread \"main\" java.lang.ArrayIndexOutOfBoundsException: 11 // at com.test.Application.main(Application.java:7) 思考：能不能直接修改length的值来实现动态扩容呢？ int[] arr = new int[]{1, 2, 3}; arr.length = 10; 数组做实参，因为数组也是类，所以形参得到的是数组的引用而不是复制的数组，操作的依然是数组对象本身 public static void main(String[] args) { int[] arr = new int[]{1, 2, 3}; test(arr); System.out.println(arr[0]); } private static void test(int[] arr){ arr[0] = 2934; } ","date":"2022-01-23","objectID":"/posts/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/:4:1","tags":["Java对象和多态"],"title":"Java对象和多态","uri":"/posts/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"categories":["JavaSE笔记"],"content":"数组的遍历 如果我们想要快速打印数组中的每一个元素，又怎么办呢？ 传统for循环 我们很容易就联想到for循环 int[] arr = new int[]{1, 2, 3}; for (int i = 0; i \u003c arr.length; i++) { System.out.println(arr[i]); } foreach 传统for循环虽然可控性高，但是不够省事，要写一大堆东西，有没有一种省事的写法呢？ int[] arr = new int[]{1, 2, 3}; for (int i : arr) { System.out.println(i); } foreach属于增强型的for循环，它使得代码更简洁，同时我们能直接拿到数组中的每一个数字。 ","date":"2022-01-23","objectID":"/posts/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/:4:2","tags":["Java对象和多态"],"title":"Java对象和多态","uri":"/posts/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"categories":["JavaSE笔记"],"content":"二维数组 二维数组其实就是存放数组的数组，每一个元素都存放一个数组的引用，也就相当于变成了一个平面。 //三行两列 int[][] arr = { {1, 2}, {3, 4}, {5, 6}}; System.out.println(arr[2][1]); 二维数组的遍历同一维数组一样，只不过需要嵌套循环！ int[][] arr = new int[][]{ {1, 2}, {3, 4}, {5, 6}}; for (int i = 0; i \u003c 3; i++) { for (int j = 0; j \u003c 2; j++) { System.out.println(arr[i][j]); } } ","date":"2022-01-23","objectID":"/posts/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/:4:3","tags":["Java对象和多态"],"title":"Java对象和多态","uri":"/posts/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"categories":["JavaSE笔记"],"content":"多维数组 不止二维数组，还存在三维数组，也就是存放数组的数组的数组，原理同二维数组一样，逐级访问即可。 ","date":"2022-01-23","objectID":"/posts/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/:4:4","tags":["Java对象和多态"],"title":"Java对象和多态","uri":"/posts/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"categories":["JavaSE笔记"],"content":"可变长参数 可变长参数其实就是数组的一种应用，我们可以指定方法的形参为一个可变长参数，要求实参可以根据情况动态填入0个或多个，而不是固定的数量 public static void main(String[] args) { test(\"AAA\", \"BBB\", \"CCC\"); //可变长，最后都会被自动封装成一个数组 } private static void test(String... test){ System.out.println(test[0]); //其实参数就是一个数组 } 由于是数组，所以说只能使用一种类型的可变长参数，并且可变长参数只能放在最后一位！ ","date":"2022-01-23","objectID":"/posts/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/:4:5","tags":["Java对象和多态"],"title":"Java对象和多态","uri":"/posts/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"categories":["JavaSE笔记"],"content":"实战：三大基本排序算法 现在我们有一个数组，但是数组里面的数据是乱序排列的，如何使它变得有序？ int[] arr = {8, 5, 0, 1, 4, 9, 2, 3, 6, 7}; 排序是编程的一个重要技能，掌握排序算法，你的技术才能更上一层楼，很多的项目都需要用到排序！三大排序算法： 冒泡排序 冒泡排序就是冒泡，其实就是不断使得我们无序数组中的最大数向前移动，经历n轮循环逐渐将每一个数推向最前。 插入排序 插入排序其实就跟我们打牌是一样的，我们在摸牌的时候，牌堆是乱序的，但是我们一张一张摸到手中进行排序，使得它变成了有序的！ 选择排序 选择排序其实就是每次都选择当前数组中最大的数排到最前面！ ","date":"2022-01-23","objectID":"/posts/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/:4:6","tags":["Java对象和多态"],"title":"Java对象和多态","uri":"/posts/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"categories":["JavaSE笔记"],"content":"封装、继承和多态 封装、继承和多态是面向对象编程的三大特性。 ","date":"2022-01-23","objectID":"/posts/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/:5:0","tags":["Java对象和多态"],"title":"Java对象和多态","uri":"/posts/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"categories":["JavaSE笔记"],"content":"封装 封装的目的是为了保证变量的安全性，使用者不必在意具体实现细节，而只是通过外部接口即可访问类的成员，如果不进行封装，类中的实例变量可以直接查看和修改，可能给整个代码带来不好的影响，因此在编写类时一般将成员变量私有化，外部类需要同getter和setter方法来查看和设置变量。 设想：学生小明已经创建成功，正常情况下能随便改他的名字和年龄吗？ public class Student { private String name; private int age; public Student(String name, int age) { this.name = name; this.age = age; } public int getAge() { return age; } public String getName() { return name; } } 也就是说，外部现在只能通过调用我定义的方法来获取成员属性，而我们可以在这个方法中进行一些额外的操作，比如小明可以修改名字，但是名字中不能包含\"小\"这个字。 public void setName(String name) { if(name.contains(\"小\")) return; this.name = name; } 单独给外部开放设置名称的方法，因为我还需要做一些额外的处理，所以说不能给外部直接操作成员变量的权限！ 封装思想其实就是把实现细节给隐藏了，外部只需知道这个方法是什么作用，而无需关心实现。 封装就是通过访问权限控制来实现的。 ","date":"2022-01-23","objectID":"/posts/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/:5:1","tags":["Java对象和多态"],"title":"Java对象和多态","uri":"/posts/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"categories":["JavaSE笔记"],"content":"继承 继承属于非常重要的内容，在定义不同类的时候存在一些相同属性，为了方便使用可以将这些共同属性抽象成一个父类，在定义其他子类时可以继承自该父类，减少代码的重复定义，子类可以使用父类中非私有的成员。 现在学生分为两种，艺术生和体育生，他们都是学生的分支，但是他们都有自己的方法： public class SportsStudent extends Student{ //通过extends关键字来继承父类 public SportsStudent(String name, int age) { super(name, age); //必须先通过super关键字（指代父类），实现父类的构造方法！ } public void exercise(){ System.out.println(\"我超勇的！\"); } } public class ArtStudent extends Student{ public ArtStudent(String name, int age) { super(name, age); } public void art(){ System.out.println(\"随手画个毕加索！\"); } } 子类具有父类的全部属性，protected可见但外部无法使用（包括private属性，不可见，无法使用），同时子类还能有自己的方法。继承只能继承一个父类，不支持多继承！ 每一个子类必须定义一个实现父类构造方法的构造方法，也就是需要在构造方法开始使用super()，如果父类使用的是默认构造方法，那么子类不用手动指明。 所有类都默认继承自Object类，除非手动指定类型，但是依然改变不了最顶层的父类是Object类。所有类都包含Object类中的方法，比如： public static void main(String[] args) { Object obj = new Object; System.out.println(obj.hashCode()); //求对象的hashcode，默认是对象的内存地址 System.out.println(obj.equals(obj)); //比较对象是否相同，默认比较的是对象的内存地址，也就是等同于 == System.out.println(obj.toString()); //将对象转换为字符串，默认生成对象的类名称+hashcode } 关于Object类的其他方法，我们会在Java多线程中再来提及。 ","date":"2022-01-23","objectID":"/posts/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/:5:2","tags":["Java对象和多态"],"title":"Java对象和多态","uri":"/posts/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"categories":["JavaSE笔记"],"content":"多态 多态是同一个行为具有多个不同表现形式或形态的能力。也就是同样的方法，由于实现类不同，执行的结果也不同！ 方法的重写 我们之前学习了方法的重载，方法的重写和重载是不一样的，重载是原有的方法逻辑不变的情况下，支持更多参数的实现，而重写是直接覆盖原有方法！ //父类中的study public void study(){ System.out.println(\"学习\"); } //子类中的study @Override //声明这个方法是重写的，但是可以不要，我们现阶段不接触 public void study(){ System.out.println(\"给你看点好康的\"); } 再次定义同样的方法后，父类的方法就被覆盖！子类还可以给父类方法提升访问权限！ public static void main(String[] args) { SportsStudent student = new SportsStudent(\"lbw\", 20); student.study(); //输出子类定义的内容 } 思考：静态方法能被重写吗？ 当我们在重写方法时，不仅想使用我们自己的逻辑，同时还希望执行父类的逻辑（也就是调用父类的方法）怎么办呢？ public void study(){ super.study(); System.out.println(\"给你看点好康的\"); } 同理，如果想访问父类的成员变量，也可以使用super关键字来访问，注意，子类可以具有和父类相同的成员变量！而在方法中访问的默认是 形参列表中 \u003e 当前类的成员变量 \u003e 父类成员变量 public void setTest(int test){ test = 1; this.test = 1; super.test = 1; } 再谈类型转换 我们曾经学习过基本数据类型的类型转换，支持一种数据类型转换为另一种数据类型，而我们的类也是支持类型转换的（仅限于存在亲缘关系的类之间进行转换）比如子类可以直接向上转型： Student student = new SportsStudent(\"lbw\", 20); //父类变量引用子类实例 student.study(); //得到依然是具体实现的结果，而不是当前类型的结果 我们也可以把已经明确是由哪个类实现的父类引用，强制转换为对应的类型： Student student = new SportsStudent(\"lbw\", 20); //是由SportsStudent进行实现的 //... do something... SportsStudent ps = (SportsStudent)student; //让它变成一个具体的子类 ps.sport(); //调用具体实现类的方法 这样的类型转换称为向下转型。 instanceof关键字 那么我们如果只是得到一个父类引用，但是不知道它到底是哪一个子类的实现怎么办？我们可以使用instanceof关键字来实现，它能够进行类型判断！ private static void test(Student student){ if (student instanceof SportsStudent){ SportsStudent sportsStudent = (SportsStudent) student; sportsStudent.sport(); }else if (student instanceof ArtStudent){ ArtStudent artStudent = (ArtStudent) student; artStudent.art(); } } 通过进行类型判断，我们就可以明确类的具体实现到底是哪个类！ 思考：student instanceof Student的结果是什么？ 再谈final关键字 我们目前只知道final关键字能够使得一个变量的值不可更改，那么如果在类前面声明final，会发生什么？ public final class Student { //类被声明为终态，那么它还能被继承吗 } 类一旦被声明为终态，将无法再被继承，不允许子类的存在！而方法被声明为final呢？ public final void study(){ //还能重写吗 System.out.println(\"学习\"); } 如果类的成员属性被声明为final，那么必须在构造方法中或是在定义时赋初始值！ private final String name; //引用类型不允许再指向其他对象 private final int age; //基本类型值不允许发生改变 public Student(String name, int age) { this.name = name; this.age = age; } 学习完封装继承和多态之后，我们推荐在不会再发生改变的成员属性上添加final关键字，JVM会对添加了final关键字的属性进行优化！ 抽象类 类本身就是一种抽象，而抽象类，把类还要抽象，也就是说，抽象类可以只保留特征，而不保留具体呈现形态，比如方法可以定义好，但是我可以不去实现它，而是交由子类来进行实现！ public abstract class Student { //抽象类 public abstract void test(); //抽象方法 } 通过使用abstract关键字来表明一个类是一个抽象类，抽象类可以使用abstract关键字来表明一个方法为抽象方法，也可以定义普通方法，抽象方法不需要编写具体实现（无方法体）但是必须由子类实现（除非子类也是一个抽象类）！ 抽象类由于不是具体的类定义，因此无法直接通过new关键字来创建对象！ Student s = new Student(){ //只能直接创建带实现的匿名内部类！ public void test(){ } } 因此，抽象类一般只用作继承使用！抽象类使得继承关系之间更加明确： public void study(){ //现在只能由子类编写，父类没有定义，更加明确了多态的定义！同一个方法多种实现！ System.out.println(\"给你看点好康的\"); } 接口 接口甚至比抽象类还抽象，他只代表某个确切的功能！也就是只包含方法的定义，甚至都不是一个类！接口包含了一些列方法的具体定义，类可以实现这个接口，表示类支持接口代表的功能（类似于一个插件，只能作为一个附属功能加在主体上，同时具体实现还需要由主体来实现） public interface Eat { void eat(); } 通过使用interface关键字来表明是一个接口（注意，这里class关键字被替换为了interface）接口只能包含public权限的抽象方法！（Java8以后可以有默认实现）我们可以通过声明default关键字来给抽象方法一个默认实现： public interface Eat { default void eat(){ //do something... } } 接口中定义的变量，默认为public static final public interface Eat { int a = 1; void eat(); } 一个类可以实现很多个接口，但是不能理解为多继承！（实际上实现接口是附加功能，和继承的概念有一定出入，顶多说是多继承的一种替代方案）一个类可以附加很多个功能！ public class SportsStudent extends Student implements Eat, ...{ @Override public void eat() { } } 类通过implements关键字来声明实现的接口！每个接口之间用逗号隔开！ 实现接口的类也能通过instanceof关键字判断，也支持向上和向下转型！ ","date":"2022-01-23","objectID":"/posts/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/:5:3","tags":["Java对象和多态"],"title":"Java对象和多态","uri":"/posts/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"categories":["JavaSE笔记"],"content":"内部类 类中可以存在一个类！各种各样的长相怪异的代码就是从这里开始出现的！ ","date":"2022-01-23","objectID":"/posts/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/:6:0","tags":["Java对象和多态"],"title":"Java对象和多态","uri":"/posts/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"categories":["JavaSE笔记"],"content":"成员内部类 我们的类中可以在嵌套一个类： public class Test { class Inner{ //类中定义的一个内部类 } } 成员内部类和成员变量和成员方法一样，都是属于对象的，也就是说，必须存在外部对象，才能创建内部类的对象！ public static void main(String[] args) { Test test = new Test(); Test.Inner inner = test.new Inner(); //写法有那么一丝怪异，但是没毛病！ } ","date":"2022-01-23","objectID":"/posts/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/:6:1","tags":["Java对象和多态"],"title":"Java对象和多态","uri":"/posts/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"categories":["JavaSE笔记"],"content":"静态内部类 静态内部类其实就和类中的静态变量和静态方法一样，是属于类拥有的，我们可以直接通过类名.去访问: public class Test { static class Inner{ } } public static void main(String[] args) { Test.Inner inner = new Test.Inner(); //不用再创建外部类对象了！ } ","date":"2022-01-23","objectID":"/posts/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/:6:2","tags":["Java对象和多态"],"title":"Java对象和多态","uri":"/posts/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"categories":["JavaSE笔记"],"content":"局部内部类 对，你没猜错，就是和局部变量一样哒~ public class Test { public void test(){ class Inner{ } Inner inner = new Inner(); } } 反正我是没用过！内部类 -\u003e 累不累 -\u003e 反正我累了！ ","date":"2022-01-23","objectID":"/posts/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/:6:3","tags":["Java对象和多态"],"title":"Java对象和多态","uri":"/posts/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"categories":["JavaSE笔记"],"content":"匿名内部类 匿名内部类才是我们的重点，也是实现lambda表达式的原理！匿名内部类其实就是在new的时候，直接对接口或是抽象类的实现： public static void main(String[] args) { Eat eat = new Eat() { @Override public void eat() { //DO something... } }; } 我们不用单独去创建一个类来实现，而是可以直接在new的时候写对应的实现！但是，这样写，无法实现复用，只能在这里使用！ lambda表达式 读作λ表达式，它其实就是我们接口匿名实现的简化，比如说： public static void main(String[] args) { Eat eat = new Eat() { @Override public void eat() { //DO something... } }; } public static void main(String[] args) { Eat eat = () -\u003e {}; //等价于上述内容 } lambda表达式（匿名内部类）只能访问外部的final类型或是隐式final类型的局部变量！ 为了方便，JDK默认就为我们提供了专门写函数式的接口，这里只介绍Consumer ","date":"2022-01-23","objectID":"/posts/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/:6:4","tags":["Java对象和多态"],"title":"Java对象和多态","uri":"/posts/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"categories":["JavaSE笔记"],"content":"枚举类 假设现在我们想给小明添加一个状态（跑步、学习、睡觉），外部可以实时获取小明的状态： public class Student { private final String name; private final int age; private String status; //... public void setStatus(String status) { this.status = status; } public String getStatus() { return status; } } 但是这样会出现一个问题，如果我们仅仅是存储字符串，似乎外部可以不按照我们规则，传入一些其他的字符串。这显然是不够严谨的！ 有没有一种办法，能够更好地去实现这样的状态标记呢？我们希望开发者拿到使用的就是我们定义好的状态，我们可以使用枚举类！ public enum Status { RUNNING, STUDY, SLEEP //直接写每个状态的名字即可，分号可以不打，但是推荐打上 } 使用枚举类也非常方便，我们只需要直接访问即可 public class Student { private final String name; private final int age; private Status status; //... public void setStatus(Status status) { //不再是String，而是我们指定的枚举类型 this.status = status; } public Status getStatus() { return status; } } public static void main(String[] args) { Student student = new Student(\"小明\", 18); student.setStatus(Status.RUNNING); System.out.println(student.getStatus()); } 枚举类型使用起来就非常方便了，其实枚举类型的本质就是一个普通的类，但是它继承自Enum类，我们定义的每一个状态其实就是一个public static final的Status类型成员变量！ // Compiled from \"Status.java\" public final class com.test.Status extends java.lang.Enum\u003ccom.test.Status\u003e { public static final com.test.Status RUNNING; public static final com.test.Status STUDY; public static final com.test.Status SLEEP; public static com.test.Status[] values(); public static com.test.Status valueOf(java.lang.String); static {}; } 既然枚举类型是普通的类，那么我们也可以给枚举类型添加独有的成员方法 public enum Status { RUNNING(\"睡觉\"), STUDY(\"学习\"), SLEEP(\"睡觉\"); //无参构造方法被覆盖，创建枚举需要添加参数（本质就是调用的构造方法！） private final String name; //枚举的成员变量 Status(String name){ //覆盖原有构造方法（默认private，只能内部使用！） this.name = name; } public String getName() { //获取封装的成员变量 return name; } } public static void main(String[] args) { Student student = new Student(\"小明\", 18); student.setStatus(Status.RUNNING); System.out.println(student.getStatus().getName()); } 枚举类还自带一些继承下来的实用方法 Status.valueOf(\"\") //将名称相同的字符串转换为枚举 Status.values() //快速获取所有的枚举 ","date":"2022-01-23","objectID":"/posts/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/:7:0","tags":["Java对象和多态"],"title":"Java对象和多态","uri":"/posts/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"categories":["JavaSE笔记"],"content":"基本类型包装类 Java并不是纯面向对象的语言，虽然Java语言是一个面向对象的语言，但是Java中的基本数据类型却不是面向对象的。在学习泛型和集合之前，基本类型的包装类是一定要讲解的内容！ 我们的基本类型，如果想通过对象的形式去使用他们，Java提供的基本类型包装类，使得Java能够更好的体现面向对象的思想，同时也使得基本类型能够支持对象操作！ byte -\u003e Byte boolean -\u003e Boolean short -\u003e Short char -\u003e Character int -\u003e Integer long -\u003e Long float -\u003e Float double -\u003e Double 包装类实际上就行将我们的基本数据类型，封装成一个类（运用了封装的思想） private final int value; //Integer内部其实本质还是存了一个基本类型的数据，但是我们不能直接操作 public Integer(int value) { this.value = value; } 现在我们操作的就是Integer对象而不是一个int基本类型了！ public static void main(String[] args) { Integer i = 1; //包装类型可以直接接收对应类型的数据，并变为一个对象！ System.out.println(i + i); //包装类型可以直接被当做一个基本类型进行操作！ } 自动装箱和拆箱 那么为什么包装类型能直接使用一个具体值来赋值呢？其实依靠的是自动装箱和拆箱机制 Integer i = 1; //其实这里只是简写了而已 Integer i = Integer.valueOf(1); //编译后真正的样子 调用valueOf来生成一个Integer对象！ public static Integer valueOf(int i) { if (i \u003e= IntegerCache.low \u0026\u0026 i \u003c= IntegerCache.high) //注意，Java为了优化，有一个缓存机制，如果是在-128~127之间的数，会直接使用已经缓存好的对象，而不是再去创建新的！（面试常考） return IntegerCache.cache[i + (-IntegerCache.low)]; return new Integer(i); //返回一个新创建好的对象 } 而如果使用包装类来进行运算，或是赋值给一个基本类型变量，会进行自动拆箱： public static void main(String[] args) { Integer i = Integer.valueOf(1); int a = i; //简写 int a = i.intValue(); //编译后实际的代码 long c = i.longValue(); //其他类型也有！ } 既然现在是包装类型了，那么我们还能使用==来判断两个数是否相等吗？ public static void main(String[] args) { Integer i1 = 28914; Integer i2 = 28914; System.out.println(i1 == i2); //实际上判断是两个对象是否为同一个对象（内存地址是否相同） System.out.println(i1.equals(i2)); //这个才是真正的值判断！ } 注意IntegerCache带来的影响！ 思考：下面这种情况结果会是什么？ public static void main(String[] args) { Integer i1 = 28914; Integer i2 = 28914; System.out.println(i1+1 == i2+1); } 在集合类的学习中，我们还会继续用到我们的包装类型！ ","date":"2022-01-23","objectID":"/posts/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/:8:0","tags":["Java对象和多态"],"title":"Java对象和多态","uri":"/posts/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"categories":["JavaSE笔记"],"content":"面向对象编程实战 虽然我们学习了编程，但是我们不能一股脑的所有问题都照着编程的思维去解决，编程只是解决问题的一种手段，灵活的运用我们所学的知识，才是解决问题的最好办法！比如，求1到100所有数的和： public static void main(String[] args) { int sum = 0; for (int i = 1; i \u003c= 100; i++) { //for循环暴力求解，简单，但是效率似乎低了一些 sum += i; } System.out.println(sum); } public static void main(String[] args) { System.out.println((1 + 100) * 50); //高斯求和公式，利用数学，瞬间计算结果！ } 说到最后，其实数学和逻辑思维才是解决问题的最终办法！ ","date":"2022-01-23","objectID":"/posts/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/:9:0","tags":["Java对象和多态"],"title":"Java对象和多态","uri":"/posts/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"categories":["JavaSE笔记"],"content":"对象设计（面向对象、多态运用） 设计一个Person抽象类，包含吃饭运动学习三种行为，分为工人、学生、老师三种职业。 设计设计一个接口考试，只有老师和学生会考试。 设计一个方法，模拟让人类进入考场，要求只有会考试的人才能进入，并且考试。 ","date":"2022-01-23","objectID":"/posts/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/:9:1","tags":["Java对象和多态"],"title":"Java对象和多态","uri":"/posts/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"categories":["JavaSE笔记"],"content":"二分搜索（搜索算法） 现在有一个有序数组（从小到大，数组长度 0 \u003c n \u003c 1000000）如何快速寻找我们想要的数在哪个位置，如果存在请返回下标，不存在返回-1即可。 int[] arr = new int[]{1, 4, 5, 6, 7, 10, 12, 14, 20, 22, 26}; //测试用例 private static int test(int[] arr, int target){ //请在这里实现搜索算法 } ","date":"2022-01-23","objectID":"/posts/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/:9:2","tags":["Java对象和多态"],"title":"Java对象和多态","uri":"/posts/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"categories":["JavaSE笔记"],"content":"快速排序（排序算法、递归分治） （开始之前先介绍一下递归！）快速排序其实是一种排序执行效率很高的排序算法，它利用分治法来对待排序序列进行分治排序，它的思想主要是通过一趟排序将待排记录分隔成独立的两部分，其中的一部分比关键字小，后面一部分比关键字大，然后再对这前后的两部分分别采用这种方式进行排序，通过递归的运算最终达到整个序列有序。 快速排序就像它的名字一样，快速！在极端情况下，会退化成冒泡排序！ ","date":"2022-01-23","objectID":"/posts/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/:9:3","tags":["Java对象和多态"],"title":"Java对象和多态","uri":"/posts/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"categories":["JavaSE笔记"],"content":"0/1背包问题（回溯法、剪枝/动态规划优化） 给定 n 件物品，每一个物品的重量为 w[n]，每个物品的价值为 v[n]。现挑选物品放入背包中，假定背包能承受的最大重量为 capacity，求装入物品的最大价值是多少? int[] w = {2, 3, 4, 5}; int[] v = {3, 4, 5, 6}; int capacity = 8; ","date":"2022-01-23","objectID":"/posts/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/:9:4","tags":["Java对象和多态"],"title":"Java对象和多态","uri":"/posts/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"categories":["JavaSE笔记"],"content":"Java异常处理机制","date":"2022-01-23","objectID":"/posts/java%E5%BC%82%E5%B8%B8/","tags":["Java异常处理"],"title":"Java异常处理机制","uri":"/posts/java%E5%BC%82%E5%B8%B8/"},{"categories":["JavaSE笔记"],"content":"Java异常机制 配套视频 在理想的情况下，我们的程序会按照我们的思路去运行，按理说是不会出现问题的，但是，代码实际编写后并不一定是完美的，可能会有我们没有考虑到的情况，如果这些情况能够正常得到一个错误的结果还好，但是如果直接导致程序运行出现问题了呢？ public static void main(String[] args) { test(1, 0); //当b为0的时候，还能正常运行吗？ } private static int test(int a, int b){ return a/b; //没有任何的判断而是直接做计算 } Exception in thread \"main\" java.lang.ArithmeticException: / by zero at com.test.Application.test(Application.java:9) at com.test.Application.main(Application.java:5) 当程序运行出现我们没有考虑到的情况时，就有可能出现异常或是错误！ ","date":"2022-01-23","objectID":"/posts/java%E5%BC%82%E5%B8%B8/:0:0","tags":["Java异常处理"],"title":"Java异常处理机制","uri":"/posts/java%E5%BC%82%E5%B8%B8/"},{"categories":["JavaSE笔记"],"content":"异常 我们在之前其实已经接触过一些异常了，比如数组越界异常，空指针异常，算术异常等，他们其实都是异常类型，我们的每一个异常也是一个类，他们都继承自Exception类！异常类型本质依然类的对象，但是异常类型支持在程序运行出现问题时抛出（也就是上面出现的红色报错）也可以提前声明，告知使用者需要处理可能会出现的异常！ ","date":"2022-01-23","objectID":"/posts/java%E5%BC%82%E5%B8%B8/:1:0","tags":["Java异常处理"],"title":"Java异常处理机制","uri":"/posts/java%E5%BC%82%E5%B8%B8/"},{"categories":["JavaSE笔记"],"content":"运行时异常 异常的第一种类型是运行时异常，如上述的列子，在编译阶段无法感知代码是否会出现问题，只有在运行的时候才知道会不会出错（正常情况下是不会出错的），这样的异常称为运行时异常。所有的运行时异常都继承自RuntimeException。 ","date":"2022-01-23","objectID":"/posts/java%E5%BC%82%E5%B8%B8/:1:1","tags":["Java异常处理"],"title":"Java异常处理机制","uri":"/posts/java%E5%BC%82%E5%B8%B8/"},{"categories":["JavaSE笔记"],"content":"编译时异常 异常的另一种类型是编译时异常，编译时异常是明确会出现的异常，在编译阶段就需要进行处理的异常（捕获异常）如果不进行处理，将无法通过编译！默认继承自Exception类的异常都是编译时异常。 File file = new File(\"my.txt\"); file.createNewFile(); //要调用此方法，首先需要处理异常 ","date":"2022-01-23","objectID":"/posts/java%E5%BC%82%E5%B8%B8/:1:2","tags":["Java异常处理"],"title":"Java异常处理机制","uri":"/posts/java%E5%BC%82%E5%B8%B8/"},{"categories":["JavaSE笔记"],"content":"错误 错误比异常更严重，异常就是不同寻常，但不一定会导致致命的问题，而错误是致命问题，一般出现错误可能JVM就无法继续正常运行了，比如OutOfMemoryError就是内存溢出错误（内存占用已经超出限制，无法继续申请内存了） int[] arr = new int[Integer.MAX_VALUE]; //能创建如此之大的数组吗？ 运行后得到以下内容： Exception in thread \"main\" java.lang.OutOfMemoryError: Requested array size exceeds VM limit at com.test.Main.main(Main.java:14) 错误都继承自Error类，一般情况下，程序中只能处理异常，错误是很难进行处理的，Error和Execption都继承自Throwable类。当程序中出现错误或异常时又没有进行处理时，程序（当前线程）将终止运行： int[] arr = new int[Integer.MAX_VALUE]; System.out.println(\"lbwnb\"); //还能正常打印吗？ ","date":"2022-01-23","objectID":"/posts/java%E5%BC%82%E5%B8%B8/:2:0","tags":["Java异常处理"],"title":"Java异常处理机制","uri":"/posts/java%E5%BC%82%E5%B8%B8/"},{"categories":["JavaSE笔记"],"content":"异常的处理 当程序没有按照我们想要的样子运行而出现异常时（默认会交给JVM来处理，JVM发现任何异常都会立即终止程序运行，并在控制台打印栈追踪信息），我们希望能够自己处理出现的问题，让程序继续运行下去，就需要对异常进行捕获，比如： int[] arr = new int[5]; arr[5] = 1; //我们需要处理这种情况，保证后面的代码正常运行！ System.out.println(\"lbwnb\"); 我们可以使用try和catch语句块来处理： int[] arr = new int[5]; try{ //在try块中运行代码 arr[5] = 1; //当代码出现异常时，异常会被捕获，并在catch块中得到异常类型的对象 }catch (ArrayIndexOutOfBoundsException e){ //捕获的异常类型 System.out.println(\"程序运行出现异常！\"); //出现异常时执行 } //后面的代码会正常运行 System.out.println(\"lbwnb\"); 当异常被捕获后，就由我们自己进行处理（不再交给JVM处理），因此就不会导致程序终止运行。 我们可以通过使用e.printStackTrace()来打印栈追踪信息，定位我们的异常出现位置： java.lang.ArrayIndexOutOfBoundsException: 5 at com.test.Main.main(Main.java:7) //Main类的第7行出现问题 程序运行出现异常！ lbwnb 运行时异常在编译时可以不用捕获，但是编译时异常必须进行处理： File file = new File(\"my.txt\"); try { file.createNewFile(); } catch (IOException e) { //捕获声明的异常类型 e.printStackTrace(); } 可以捕获到类型不止是Exception的子类，只要是继承自Throwalbe的类，都能被捕获，也就是说，Error也能被捕获，但是不建议这样做，因为错误一般是虚拟机相关的问题，出现Error应该从问题的根源去解决。 ","date":"2022-01-23","objectID":"/posts/java%E5%BC%82%E5%B8%B8/:3:0","tags":["Java异常处理"],"title":"Java异常处理机制","uri":"/posts/java%E5%BC%82%E5%B8%B8/"},{"categories":["JavaSE笔记"],"content":"异常的抛出 当别人调用我们的方法时，如果传入了错误的参数导致程序无法正常运行，这时我们就需要手动抛出一个异常来终止程序继续运行下去，同时告知上一级方法执行出现了问题： public static void main(String[] args) { try { test(1, 0); } catch (Exception e) { //捕获方法中会出现的异常 e.printStackTrace(); } } private static int test(int a, int b) throws Exception { //声明抛出的异常类型 if(b == 0) throw new Exception(\"0不能做除数！\"); //创建异常对象并抛出异常 return a/b; //抛出异常会终止代码运行 } 通过throw关键字抛出异常（抛出异常后，后面的代码不再执行）当程序运行到这一行时，就会终止执行，并出现一个异常。 如果方法中抛出了非运行时异常，但是不希望在此方法内处理，而是交给调用者来处理异常，就需要在方法定义后面显式声明抛出的异常类型！如果抛出的是运行时异常，则不需要在方法后面声明异常类型，调用时也无需捕获，但是出现异常时同样会导致程序终止（出现运行时异常同时未被捕获会默认交给JVM处理，也就是直接中止程序并在控制台打印栈追踪信息） 如果想要调用声明编译时异常的方法，但是依然不想去处理，可以同样的在方法上声明throws来继续交给上一级处理。 public static void main(String[] args) throws Exception { //出现异常就再往上抛，而不是在此方法内处理 test(1, 0); } private static int test(int a, int b) throws Exception { //声明抛出的异常类型 if(b == 0) throw new Exception(\"0不能做除数！\"); //创建异常对象并抛出异常 return a/b; } 当main方法都声明抛出异常时，出现异常就由JVM进行处理，也就是默认的处理方式（直接中止程序并在控制台打印栈追踪信息） 异常只能被捕获一次，当异常捕获出现嵌套时，只会在最内层被捕获： public static void main(String[] args) throws Exception { try{ test(1, 0); }catch (Exception e){ System.out.println(\"外层\"); } } private static int test(int a, int b){ try{ if(b == 0) throw new Exception(\"0不能做除数！\"); }catch (Exception e){ System.out.println(\"内层\"); return 0; } return a/b; } ","date":"2022-01-23","objectID":"/posts/java%E5%BC%82%E5%B8%B8/:4:0","tags":["Java异常处理"],"title":"Java异常处理机制","uri":"/posts/java%E5%BC%82%E5%B8%B8/"},{"categories":["JavaSE笔记"],"content":"自定义异常 JDK为我们已经提前定义了一些异常了，但是可能对我们来说不够，那么就需要自定义异常： public class MyException extends Exception { //直接继承即可 } public static void main(String[] args) throws MyException { throw new MyException(); //直接使用 } 也可以使用父类的带描述的构造方法： public class MyException extends Exception { public MyException(String message){ super(message); } } public static void main(String[] args) throws MyException { throw new MyException(\"出现了自定义的错误\"); } 捕获异常指定的类型，会捕获其所有子异常类型： try { throw new MyException(\"出现了自定义的错误\"); } catch (Exception e) { //捕获父异常类型 System.out.println(\"捕获到异常\"); } ","date":"2022-01-23","objectID":"/posts/java%E5%BC%82%E5%B8%B8/:5:0","tags":["Java异常处理"],"title":"Java异常处理机制","uri":"/posts/java%E5%BC%82%E5%B8%B8/"},{"categories":["JavaSE笔记"],"content":"多重异常捕获和finally关键字 当代码可能出现多种类型的异常时，我们希望能够分不同情况处理不同类型的异常，就可以使用多重异常捕获： try { //.... } catch (NullPointerException e) { } catch (IndexOutOfBoundsException e){ } catch (RuntimeException e){ } 注意，类似于if-else if的结构，父异常类型只能放在最后！ try { //.... } catch (RuntimeException e){ //父类型在前，会将子类的也捕获 } catch (NullPointerException e) { //永远都不会被捕获 } catch (IndexOutOfBoundsException e){ //永远都不会被捕获 } 如果希望把这些异常放在一起进行处理： try { //.... } catch (NullPointerException | IndexOutOfBoundsException e) { //用|隔开每种类型即可 } 当我们希望，程序运行时，无论是否出现异常，都会在最后执行的任务，可以交给finally语句块来处理： try { //.... }catch (Exception e){ }finally { System.out.println(\"lbwnb\"); //无论是否出现异常，都会在最后执行 } try语句块至少要配合catch或finally中的一个： try { int a = 10; a /= 0; }finally { //不捕获异常，程序会终止，但在最后依然会执行下面的内容 System.out.println(\"lbwnb\"); } 思考：try、catch和finally执行顺序： private static int test(int a){ try{ return a; }catch (Exception e){ return 0; }finally { a = a + 1; } } ","date":"2022-01-23","objectID":"/posts/java%E5%BC%82%E5%B8%B8/:6:0","tags":["Java异常处理"],"title":"Java异常处理机制","uri":"/posts/java%E5%BC%82%E5%B8%B8/"},{"categories":["JavaSE笔记"],"content":"Java泛型与集合类","date":"2022-01-23","objectID":"/posts/java%E6%B3%9B%E5%9E%8B%E4%B8%8E%E9%9B%86%E5%90%88%E7%B1%BB/","tags":["Java泛型与集合类"],"title":"Java泛型与集合类","uri":"/posts/java%E6%B3%9B%E5%9E%8B%E4%B8%8E%E9%9B%86%E5%90%88%E7%B1%BB/"},{"categories":["JavaSE笔记"],"content":"Java泛型与集合类 配套视频 在前面我们学习了最重要的类和对象，了解了面向对象编程的思想，注意，非常重要，面向对象是必须要深入理解和掌握的内容，不能草草结束。在本章节，我们会继续深入了解，从我们的泛型开始，再到我们的数据结构，最后再开始我们的集合类学习。 ","date":"2022-01-23","objectID":"/posts/java%E6%B3%9B%E5%9E%8B%E4%B8%8E%E9%9B%86%E5%90%88%E7%B1%BB/:0:0","tags":["Java泛型与集合类"],"title":"Java泛型与集合类","uri":"/posts/java%E6%B3%9B%E5%9E%8B%E4%B8%8E%E9%9B%86%E5%90%88%E7%B1%BB/"},{"categories":["JavaSE笔记"],"content":"走进泛型 为了统计学生成绩，要求设计一个Score对象，包括课程名称、课程号、课程成绩，但是成绩分为两种，一种是以优秀、良好、合格 来作为结果，还有一种就是 60.0、75.5、92.5 这样的数字分数，那么现在该如何去设计这样的一个Score类呢？现在的问题就是，成绩可能是String类型，也可能是Integer类型，如何才能很好的去存可能出现的两种类型呢？ public class Score { String name; String id; Object score; //因为Object是所有类型的父类，因此既可以存放Integer也能存放String public Score(String name, String id, Object score) { this.name = name; this.id = id; this.score = score; } } 以上的方法虽然很好地解决了多种类型存储问题，但是Object类型在编译阶段并不具有良好的类型判断能力，很容易出现以下的情况： public static void main(String[] args) { Score score = new Score(\"数据结构与算法基础\", \"EP074512\", \"优秀\"); //是String类型的 //.... Integer number = (Integer) score.score; //获取成绩需要进行强制类型转换，虽然并不是一开始的类型，但是编译不会报错 } //运行时出现异常！ Exception in thread \"main\" java.lang.ClassCastException: java.lang.String cannot be cast to java.lang.Integer at com.test.Main.main(Main.java:14) 使用Object类型作为引用，取值只能进行强制类型转换，显然无法在编译期确定类型是否安全，项目中代码量非常之大，进行类型比较又会导致额外的开销和增加代码量，如果不经比较就很容易出现类型转换异常，代码的健壮性有所欠缺！（此方法虽然可行，但并不是最好的方法） 为了解决以上问题，JDK1.5新增了泛型，它能够在编译阶段就检查类型安全，大大提升开发效率。 public class Score\u003cT\u003e { //将Score转变为泛型类\u003cT\u003e String name; String id; T score; //T为泛型，根据用户提供的类型自动变成对应类型 public Score(String name, String id, T score) { //提供的score类型即为T代表的类型 this.name = name; this.id = id; this.score = score; } } public static void main(String[] args) { //直接确定Score的类型是字符串类型的成绩 Score\u003cString\u003e score = new Score\u003cString\u003e(\"数据结构与算法基础\", \"EP074512\", \"优秀\"); Integer i = score.score; //编译不通过，因为成员变量score类型被定为String！ } 泛型将数据类型的确定控制在了编译阶段，在编写代码的时候就能明确泛型的类型！如果类型不符合，将无法通过编译！ 泛型本质上也是一个语法糖（并不是JVM所支持的语法，编译后会转成编译器支持的语法，比如之前的foreach就是），在编译后会被擦除，变回上面的Object类型调用，但是类型转换由编译器帮我们完成，而不是我们自己进行转换（安全） //反编译后的代码 public static void main(String[] args) { Score score = new Score(\"数据结构与算法基础\", \"EP074512\", \"优秀\"); String i = (String)score.score; //其实依然会变为强制类型转换，但是这是由编译器帮我们完成的 } 像这样在编译后泛型的内容消失转变为Object的情况称为类型擦除（重要，需要完全理解），所以泛型只是为了方便我们在编译阶段确定类型的一种语法而已，并不是JVM所支持的。 综上，泛型其实就是一种类型参数，用于指定类型。 ","date":"2022-01-23","objectID":"/posts/java%E6%B3%9B%E5%9E%8B%E4%B8%8E%E9%9B%86%E5%90%88%E7%B1%BB/:1:0","tags":["Java泛型与集合类"],"title":"Java泛型与集合类","uri":"/posts/java%E6%B3%9B%E5%9E%8B%E4%B8%8E%E9%9B%86%E5%90%88%E7%B1%BB/"},{"categories":["JavaSE笔记"],"content":"泛型的使用 ","date":"2022-01-23","objectID":"/posts/java%E6%B3%9B%E5%9E%8B%E4%B8%8E%E9%9B%86%E5%90%88%E7%B1%BB/:2:0","tags":["Java泛型与集合类"],"title":"Java泛型与集合类","uri":"/posts/java%E6%B3%9B%E5%9E%8B%E4%B8%8E%E9%9B%86%E5%90%88%E7%B1%BB/"},{"categories":["JavaSE笔记"],"content":"泛型类 上一节我们已经提到泛型类的定义，实际上就是普通的类多了一个类型参数，也就是在使用时需要指定具体的泛型类型。泛型的名称一般取单个大写字母，比如T代表Type，也就是类型的英文单词首字母，当然也可以添加数字和其他的字符。 public class Score\u003cT\u003e { //将Score转变为泛型类\u003cT\u003e String name; String id; T score; //T为泛型，根据用户提供的类型自动变成对应类型 public Score(String name, String id, T score) { //提供的score类型即为T代表的类型 this.name = name; this.id = id; this.score = score; } } 在一个普通类型中定义泛型，泛型T称为参数化类型，在定义泛型类的引用时，需要明确指出类型： Score\u003cString\u003e score = new Score\u003cString\u003e(\"数据结构与算法基础\", \"EP074512\", \"优秀\"); 此时类中的泛型T已经被替换为String了，在我们获取此对象的泛型属性时，编译器会直接告诉我们类型： Integer i = score.score; //编译不通过，因为成员变量score明确为String类型 注意，泛型只能用于对象属性，也就是非静态的成员变量才能使用： static T score; //错误，不能在静态成员上定义 由此可见，泛型是只有在创建对象后编译器才能明确泛型类型，而静态类型是类所具有的属性，不足以使得编译器完成类型推断。 泛型无法使用基本类型，如果需要基本类型，只能使用基本类型的包装类进行替换！ Score\u003cdouble\u003e score = new Score\u003cdouble\u003e(\"数据结构与算法基础\", \"EP074512\", 90.5); //编译不通过 那么为什么泛型无法使用基本类型呢？回想上一节提到的类型擦除，其实就很好理解了。由于JVM没有泛型概念，因此泛型最后还是会被编译器编译为Object，并采用强制类型转换的形式进行类型匹配，而我们的基本数据类型和引用类型之间无法进行类型转换，所以只能使用基本类型的包装类来处理。 ","date":"2022-01-23","objectID":"/posts/java%E6%B3%9B%E5%9E%8B%E4%B8%8E%E9%9B%86%E5%90%88%E7%B1%BB/:2:1","tags":["Java泛型与集合类"],"title":"Java泛型与集合类","uri":"/posts/java%E6%B3%9B%E5%9E%8B%E4%B8%8E%E9%9B%86%E5%90%88%E7%B1%BB/"},{"categories":["JavaSE笔记"],"content":"类的泛型方法 泛型方法的使用也很简单，我们只需要把它当做一个未知的类型来使用即可： public T getScore() { //若方法的返回值类型为泛型，那么编译器会自动进行推断 return score; } public void setScore(T score) { //若方法的形式参数为泛型，那么实参只能是定义时的类型 this.score = score; } Score\u003cString\u003e score = new Score\u003cString\u003e(\"数据结构与算法基础\", \"EP074512\", \"优秀\"); score.setScore(10); //编译不通过，因为只接受String类型 同样地，静态方法无法直接使用类定义的泛型（注意是无法直接使用，静态方法可以使用泛型） ","date":"2022-01-23","objectID":"/posts/java%E6%B3%9B%E5%9E%8B%E4%B8%8E%E9%9B%86%E5%90%88%E7%B1%BB/:2:2","tags":["Java泛型与集合类"],"title":"Java泛型与集合类","uri":"/posts/java%E6%B3%9B%E5%9E%8B%E4%B8%8E%E9%9B%86%E5%90%88%E7%B1%BB/"},{"categories":["JavaSE笔记"],"content":"自定义泛型方法 那么如果我想在静态方法中使用泛型呢？首先我们要明确之前为什么无法使用泛型，因为之前我们的泛型定义是在类上的，只有明确具体的类型才能开始使用，也就是创建对象时完成类型确定，但是静态方法不需要依附于对象，那么只能在使用时再来确定了，所以静态方法可以使用泛型，但是需要单独定义： public static \u003cE\u003e void test(E e){ //在方法定义前声明泛型 System.out.println(e); } 同理，成员方法也能自行定义泛型，在实际使用时再进行类型确定： public \u003cE\u003e void test(E e){ System.out.println(e); } 其实，无论是泛型类还是泛型方法，再使用时一定要能够进行类型推断，明确类型才行。 注意一定要区分类定义的泛型和方法前定义的泛型！ ","date":"2022-01-23","objectID":"/posts/java%E6%B3%9B%E5%9E%8B%E4%B8%8E%E9%9B%86%E5%90%88%E7%B1%BB/:2:3","tags":["Java泛型与集合类"],"title":"Java泛型与集合类","uri":"/posts/java%E6%B3%9B%E5%9E%8B%E4%B8%8E%E9%9B%86%E5%90%88%E7%B1%BB/"},{"categories":["JavaSE笔记"],"content":"泛型引用 可以看到我们在定义一个泛型类的引用时，需要在后面指出此类型： Score\u003cInteger\u003e score; //声明泛型为Integer类型 如果不希望指定类型，或是希望此引用类型可以引用任意泛型的Score类对象，可以使用?通配符，来表示自动匹配任意的可用类型： Score\u003c?\u003e score; //score可以引用任意的Score类型对象了！ 那么使用通配符之后，得到的泛型成员变量会是什么类型呢？ Object o = score.getScore(); //只能变为Object 因为使用了通配符，编译器就无法进行类型推断，所以只能使用原始类型。 在学习了泛型的界限后，我们还会继续了解通配符的使用。 ","date":"2022-01-23","objectID":"/posts/java%E6%B3%9B%E5%9E%8B%E4%B8%8E%E9%9B%86%E5%90%88%E7%B1%BB/:2:4","tags":["Java泛型与集合类"],"title":"Java泛型与集合类","uri":"/posts/java%E6%B3%9B%E5%9E%8B%E4%B8%8E%E9%9B%86%E5%90%88%E7%B1%BB/"},{"categories":["JavaSE笔记"],"content":"泛型的界限 现在有一个新的需求，现在没有String类型的成绩了，但是成绩依然可能是整数，也可能是小数，这时我们不希望用户将泛型指定为除数字类型外的其他类型，我们就需要使用到泛型的上界定义： public class Score\u003cT extends Number\u003e { //设定泛型上界，必须是Number的子类 private final String name; private final String id; private T score; public Score(String name, String id, T score) { this.name = name; this.id = id; this.score = score; } public T getScore() { return score; } } 通过extends关键字进行上界限定，只有指定类型或指定类型的子类才能作为类型参数。 同样的，泛型通配符也支持泛型的界限： Score\u003c? extends Number\u003e score; //限定为匹配Number及其子类的类型 同理，既然泛型有上限，那么也有下限： Score\u003c? super Integer\u003e score; //限定为匹配Integer及其父类 通过super关键字进行下界限定，只有指定类型或指定类型的父类才能作为类型参数。 图解如下： 那么限定了上界后，我们再来使用这个对象的泛型成员，会变成什么类型呢？ Score\u003c? extends Number\u003e score = new Score\u003c\u003e(\"数据结构与算法基础\", \"EP074512\", 10); Number o = score.getScore(); //得到的结果为上界类型 也就是说，一旦我们指定了上界后，编译器就将范围从原始类型Object提升到我们指定的上界Number，但是依然无法明确具体类型。思考：那如果定义下限呢？ 那么既然我们可以给泛型类限定上界，现在我们来看编译后结果呢： //使用javap -l 进行反编译 public class com.test.Score\u003cT extends java.lang.Number\u003e { public com.test.Score(java.lang.String, java.lang.String, T); LineNumberTable: line 8: 0 line 9: 4 line 10: 9 line 11: 14 line 12: 19 LocalVariableTable: Start Length Slot Name Signature 0 20 0 this Lcom/test/Score; 0 20 1 name Ljava/lang/String; 0 20 2 id Ljava/lang/String; 0 20 3 score Ljava/lang/Number; //可以看到score的类型直接被编译为Number类 public T getScore(); LineNumberTable: line 15: 0 LocalVariableTable: Start Length Slot Name Signature 0 5 0 this Lcom/test/Score; } 因此，一旦确立上限后，编译器会自动将类型提升到上限类型。 ","date":"2022-01-23","objectID":"/posts/java%E6%B3%9B%E5%9E%8B%E4%B8%8E%E9%9B%86%E5%90%88%E7%B1%BB/:2:5","tags":["Java泛型与集合类"],"title":"Java泛型与集合类","uri":"/posts/java%E6%B3%9B%E5%9E%8B%E4%B8%8E%E9%9B%86%E5%90%88%E7%B1%BB/"},{"categories":["JavaSE笔记"],"content":"钻石运算符 我们发现，每次创建泛型对象都需要在前后都标明类型，但是实际上后面的类型声明是可以去掉的，因为我们在传入参数时或定义泛型类的引用时，就已经明确了类型，因此JDK1.7提供了钻石运算符来简化代码： Score\u003cInteger\u003e score = new Score\u003cInteger\u003e(\"数据结构与算法基础\", \"EP074512\", 10); //1.7之前 Score\u003cInteger\u003e score = new Score\u003c\u003e(\"数据结构与算法基础\", \"EP074512\", 10); //1.7之后 ","date":"2022-01-23","objectID":"/posts/java%E6%B3%9B%E5%9E%8B%E4%B8%8E%E9%9B%86%E5%90%88%E7%B1%BB/:2:6","tags":["Java泛型与集合类"],"title":"Java泛型与集合类","uri":"/posts/java%E6%B3%9B%E5%9E%8B%E4%B8%8E%E9%9B%86%E5%90%88%E7%B1%BB/"},{"categories":["JavaSE笔记"],"content":"泛型与多态 泛型不仅仅可以可以定义在类上，同时也能定义在接口上： public interface ScoreInterface\u003cT\u003e { T getScore(); void setScore(T t); } 当实现此接口时，我们可以选择在实现类明确泛型类型或是继续使用此泛型，让具体创建的对象来确定类型。 public class Score\u003cT\u003e implements ScoreInterface\u003cT\u003e{ //将Score转变为泛型类\u003cT\u003e private final String name; private final String id; private T score; public Score(String name, String id, T score) { this.name = name; this.id = id; this.score = score; } public T getScore() { return score; } @Override public void setScore(T score) { this.score = score; } } public class StringScore implements ScoreInterface\u003cString\u003e{ //在实现时明确类型 @Override public String getScore() { return null; } @Override public void setScore(String s) { } } 抽象类同理，这里就不多做演示了。 ","date":"2022-01-23","objectID":"/posts/java%E6%B3%9B%E5%9E%8B%E4%B8%8E%E9%9B%86%E5%90%88%E7%B1%BB/:2:7","tags":["Java泛型与集合类"],"title":"Java泛型与集合类","uri":"/posts/java%E6%B3%9B%E5%9E%8B%E4%B8%8E%E9%9B%86%E5%90%88%E7%B1%BB/"},{"categories":["JavaSE笔记"],"content":"多态类型擦除 思考一个问题，既然继承后明确了泛型类型，那么为什么@Override不会出现错误呢，重写的条件是需要和父类的返回值类型、形式参数一致，而泛型默认的原始类型是Object类型，子类明确后变为Number类型，这显然不满足重写的条件，但是为什么依然能编译通过呢？ class A\u003cT\u003e{ private T t; public T get(){ return t; } public void set(T t){ this.t=t; } } class B extends A\u003cNumber\u003e{ private Number n; @Override public Number get(){ //这并不满足重写的要求，因为只能重写父类同样返回值和参数的方法，但是这样却能够通过编译！ return t; } @Override public void set(Number t){ this.t=t; } } 通过反编译进行观察，实际上是编译器帮助我们生成了两个桥接方法用于支持重写： @Override public Object get(){ return this.get();//调用返回Number的那个方法 } @Override public void set(Object t ){ this.set((Number)t ); //调用参数是Number的那个方法 } ","date":"2022-01-23","objectID":"/posts/java%E6%B3%9B%E5%9E%8B%E4%B8%8E%E9%9B%86%E5%90%88%E7%B1%BB/:2:8","tags":["Java泛型与集合类"],"title":"Java泛型与集合类","uri":"/posts/java%E6%B3%9B%E5%9E%8B%E4%B8%8E%E9%9B%86%E5%90%88%E7%B1%BB/"},{"categories":["JavaSE笔记"],"content":"数据结构基础 警告！本章最难的部分！ 学习集合类之前，我们还有最关键的内容需要学习，同第一章一样，自底向上才是最佳的学习方向，比起直接带大家认识集合类，不如先了解一下数据结构，只有了解了数据结构基础，才能更好地学习集合类，同时，数据结构也是你以后深入学习JDK源码的必备条件！（学习不要快餐式！）当然，我们主要是讲解Java，数据结构作为铺垫作用，所以我们只会讲解关键的部分，其他部分可以下去自行了解。 在计算机科学中，数据结构是一种数据组织、管理和存储的格式,它可以帮助我们实现对数据高效的访问和修改。更准确地说,数据结构是数据值的集合，可以体现数据值之间的关系，以及可以对数据进行应用的函数或操作。 通俗地说，我们需要去学习在计算机中如何去更好地管理我们的数据，才能让我们对我们的数据控制更加灵活！ ","date":"2022-01-23","objectID":"/posts/java%E6%B3%9B%E5%9E%8B%E4%B8%8E%E9%9B%86%E5%90%88%E7%B1%BB/:3:0","tags":["Java泛型与集合类"],"title":"Java泛型与集合类","uri":"/posts/java%E6%B3%9B%E5%9E%8B%E4%B8%8E%E9%9B%86%E5%90%88%E7%B1%BB/"},{"categories":["JavaSE笔记"],"content":"线性表 线性表是最基本的一种数据结构，它是表示一组相同类型数据的有限序列，你可以把它与数组进行参考，但是它并不是数组，线性表是一种表结构，它能够支持数据的插入、删除、更新、查询等，同时数组可以随意存放在数组中任意位置，而线性表只能依次有序排列，不能出现空隙，因此，我们需要进一步的设计。 顺序表 将数据依次存储在连续的整块物理空间中，这种存储结构称为顺序存储结构，而以这种方式实现的线性表，我们称为顺序表。 同样的，表中的每一个个体都被称为元素，元素左边的元素（上一个元素），称为前驱，同理，右边的元素（后一个元素）称为后驱。 我们设计线性表的目标就是为了去更好地管理我们的数据，也就是说，我们可以基于数组，来进行封装，实现增删改查！既然要存储一组数据，那么很容易联想到我们之前学过的数组，数组就能够容纳一组同类型的数据。 目标：以数组为底层，编写以下抽象类的具体实现 /** * 线性表抽象类 * @param \u003cE\u003e 存储的元素(Element)类型 */ public abstract class AbstractList\u003cE\u003e { /** * 获取表的长度 * @return 顺序表的长度 */ public abstract int size(); /** * 添加一个元素 * @param e 元素 * @param index 要添加的位置(索引) */ public abstract void add(E e, int index); /** * 移除指定位置的元素 * @param index 位置 * @return 移除的元素 */ public abstract E remove(int index); /** * 获取指定位置的元素 * @param index 位置 * @return 元素 */ public abstract E get(int index); } 链表 数据分散的存储在物理空间中，通过一根线保存着它们之间的逻辑关系，这种存储结构称为链式存储结构 实际上，就是每一个结点存放一个元素和一个指向下一个结点的引用（C语言里面是指针，Java中就是对象的引用，代表下一个结点对象） 利用这种思想，我们再来尝试实现上面的抽象类，从实际的代码中感受！ 比较：顺序表和链表的优异？ 顺序表优缺点： 访问速度快，随机访问性能高 插入和删除的效率低下，极端情况下需要变更整个表 不易扩充，需要复制并重新创建数组 链表优缺点： 插入和删除效率高，只需要改变连接点的指向即可 动态扩充容量，无需担心容量问题 访问元素需要依次寻找，随机访问元素效率低下 链表只能指向后面，能不能指向前面呢？双向链表！ 栈和队列实际上就是对线性表加以约束的一种数据结构，如果前面的线性表的掌握已经ok，那么栈和队列就非常轻松了！ 栈 栈遵循先入后出原则，只能在线性表的一端添加和删除元素。我们可以把栈看做一个杯子，杯子只有一个口进出，最低处的元素只能等到上面的元素离开杯子后，才能离开。 向栈中插入一个元素时，称为入栈（压栈），移除栈顶元素称为出栈，我们需要尝试实现以下抽象类型： /** * 抽象类型栈，待实现 * @param \u003cE\u003e 元素类型 */ public abstract class AbstractStack\u003cE\u003e { /** * 出栈操作 * @return 栈顶元素 */ public abstract E pop(); /** * 入栈操作 * @param e 元素 */ public abstract void push(E e); } 其实，我们的JVM在处理方法调用时，也是一个栈操作： 所以说，如果玩不好递归，就会像这样： public class Main { public static void main(String[] args) { go(); } private static void go(){ go(); } } Exception in thread \"main\" java.lang.StackOverflowError at com.test.Main.go(Main.java:13) at com.test.Main.go(Main.java:13) at com.test.Main.go(Main.java:13) at com.test.Main.go(Main.java:13) at com.test.Main.go(Main.java:13) at com.test.Main.go(Main.java:13) at com.test.Main.go(Main.java:13) at com.test.Main.go(Main.java:13) ... 栈的深度是有限制的，如果达到限制，将会出现StackOverflowError错误（注意是错误！说明是JVM出现了问题） 队列 队列同样也是受限制的线性表，不过队列就像我们排队一样，只能从队尾开始排，从队首出。 所以我们要实现以下内容： /** * * @param \u003cE\u003e */ public abstract class AbstractQueue\u003cE\u003e { /** * 进队操作 * @param e 元素 */ public abstract void offer(E e); /** * 出队操作 * @return 元素 */ public abstract E poll(); } ","date":"2022-01-23","objectID":"/posts/java%E6%B3%9B%E5%9E%8B%E4%B8%8E%E9%9B%86%E5%90%88%E7%B1%BB/:3:1","tags":["Java泛型与集合类"],"title":"Java泛型与集合类","uri":"/posts/java%E6%B3%9B%E5%9E%8B%E4%B8%8E%E9%9B%86%E5%90%88%E7%B1%BB/"},{"categories":["JavaSE笔记"],"content":"二叉树 本版块主要学习的是二叉树，树也是一种数据结构，但是它使用起来更加的复杂。 树 我们前面已经学习过链表了，我们知道链表是单个结点之间相连，也就是一种一对一的关系，而树则是一个结点连接多个结点，也就是一对多的关系。 一个结点可以有N个子结点，就像上图一样，看起来就像是一棵树。而位于最顶端的结点（没有父结点）我们称为根结点，而结点拥有的子节点数量称为度，每向下一级称为一个层次，树中出现的最大层次称为树的深度(高度)。 二叉树 二叉树是一种特殊的树，每个结点最多有两颗子树，所以二叉树中不存在度大于2的结点，位于两边的子结点称为左右子树（注意，左右子树是明确区分的，是左就是左，是右就是右） 数学性质： 在二叉树的第i层上最多有2^(i-1) 个节点。 二叉树中如果深度为k，那么最多有2^k-1个节点。 设计一个二叉树结点类： public class TreeNode\u003cE\u003e { public E e; //当前结点数据 public TreeNode\u003cE\u003e left; //左子树 public TreeNode\u003cE\u003e right; //右子树 } 二叉树的遍历 顺序表的遍历其实就是依次有序去访问表中每一个元素，而像二叉树这样的复杂结构，我们有四种遍历方式，他们是：前序遍历、中序遍历、后序遍历以及层序遍历，本版块我们主要讨论前三种遍历方式： 前序遍历：从二叉树的根结点出发，到达结点时就直接输出结点数据，按照先向左在向右的方向访问。ABCDEF 中序遍历：从二叉树的根结点出发，优先输出左子树的节点的数据，再输出当前节点本身，最后才是右子树。CBDAEF 后序遍历：从二叉树的根结点出发，优先遍历其左子树，再遍历右子树，最后在输出当前节点本身。CDBFEA 满二叉树和完全二叉树 满二叉树和完全二叉树其实就是特殊情况下的二叉树，满二叉树左右的所有叶子节点都在同一层，也就是说，完全把每一个层级都给加满了结点。完全二叉树与满二叉树不同的地方在于，它的最下层叶子节点可以不满，但是最下层的叶子节点必须靠左排布。 其实满二叉树和完全二叉树就是有一定规律的二叉树，很容易理解。 ","date":"2022-01-23","objectID":"/posts/java%E6%B3%9B%E5%9E%8B%E4%B8%8E%E9%9B%86%E5%90%88%E7%B1%BB/:3:2","tags":["Java泛型与集合类"],"title":"Java泛型与集合类","uri":"/posts/java%E6%B3%9B%E5%9E%8B%E4%B8%8E%E9%9B%86%E5%90%88%E7%B1%BB/"},{"categories":["JavaSE笔记"],"content":"快速查找 我们之前提到的这些数据结构，很好地帮我们管理了数据，但是，如果需要查找某一个元素是否存在于数据结构中，如何才能更加高效的去完成呢？ 哈希表 通过前面的学习，我们发现，顺序表虽然查询效率高，但是插入删除有严重表更新的问题，而链表虽然弥补了更新问题，但是查询效率实在是太低了，能否有一种折中方案？哈希表！ 不知大家在之前的学习中是否发现，我们的Object类中，定义了一个叫做hashcode()的方法？而这个方法呢，就是为了更好地支持哈希表的实现。hashcode()默认得到的是对象的内存地址，也就是说，每个对象的hashCode都不一样。 哈希表，其实本质上就是一个存放链表的数组，那么它是如何去存储数据的呢？我们先来看看长啥样： 数组中每一个元素都是一个头结点，用于保存数据，那我们怎么确定数据应该放在哪一个位置呢？通过hash算法，我们能够瞬间得到元素应该放置的位置。 //假设hash表长度为16，hash算法为： private int hash(int hashcode){ return hashcode % 16; } 设想这样一个问题，如果计算出来的hash值和之前已经存在的元素相同了呢？这种情况我们称为hash碰撞，这也是为什么要将每一个表元素设置为一个链表的头结点的原因，一旦发现重复，我们可以往后继续添加节点。 当然，以上的hash表结构只是一种设计方案，在面对大额数据时，是不够用的，在JDK1.8中，集合类使用的是数组+二叉树的形式解决的（这里的二叉树是经过加强的二叉树，不是前面讲得简单二叉树，我们下一节就会开始讲） 二叉排序树 我们前面学习的二叉树效率是不够的，我们需要的是一种效率更高的二叉树，因此，基于二叉树的改进，提出了二叉查找树，可以看到结构像下面这样： 不难发现，每个节点的左子树，一定小于当前节点的值，每个节点的右子树，一定大于当前节点的值，这样的二叉树称为二叉排序树。利用二分搜索的思想，我们就可以快速查找某个节点！ 平衡二叉树 在了解了二叉查找树之后，我们发现，如果根节点为10，现在加入到结点的值从9开始，依次减小到1，那么这个表就会很奇怪，就像下面这样： 显然，当所有的结点都排列到一边，这种情况下，查找效率会直接退化为最原始的二叉树！因此我们需要维持二叉树的平衡，才能维持原有的查找效率。 现在我们对二叉排序树加以约束，要求每个结点的左右两个子树的高度差的绝对值不超过1，这样的二叉树称为平衡二叉树，同时要求每个结点的左右子树都是平衡二叉树，这样，就不会因为一边的疯狂增加导致失衡。我们来看看以下几种情况： 左左失衡 右右失衡 左右失衡 右左失衡 通过以上四种情况的处理，最终得到维护平衡二叉树的算法。 红黑树 红黑树也是二叉排序树的一种改进，同平衡二叉树一样，红黑树也是一种维护平衡的二叉排序树，但是没有平衡二叉树那样严格（平衡二叉树每次插入新结点时，可能会出现大量的旋转，而红黑树保证不超过三次），红黑树降低了对于旋转的要求，因此效率有一定的提升同时实现起来也更加简单。但是红黑树的效率却高于平衡二叉树，红黑树也是JDK1.8中使用的数据结构！ 红黑树的特性: （1）每个节点或者是黑色，或者是红色。 （2）根节点是黑色。 （3）每个叶子节点的两边也需要表示（虽然没有，但是null也需要表示出来）是黑色。 （4）如果一个节点是红色的，则它的子节点必须是黑色的。 （5）从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点。 我们来看看一个节点，是如何插入到红黑树中的： 基本的 插入规则和平衡二叉树一样，但是在插入后： 将新插入的节点标记为红色 如果 X 是根结点(root)，则标记为黑色 如果 X 的 parent 不是黑色，同时 X 也不是 root: 3.1 如果 X 的 uncle (叔叔) 是红色 3.1.1 将 parent 和 uncle 标记为黑色 3.1.2 将 grand parent (祖父) 标记为红色 3.1.3 让 X 节点的颜色与 X 祖父的颜色相同，然后重复步骤 2、3 3.2 如果 X 的 uncle (叔叔) 是黑色，我们要分四种情况处理 3.2.1 左左 (P 是 G 的左孩子，并且 X 是 P 的左孩子) 3.2.2 左右 (P 是 G 的左孩子，并且 X 是 P 的右孩子) 3.2.3 右右 (P 是 G 的右孩子，并且 X 是 P 的右孩子) 3.2.4 右左 (P 是 G 的右孩子，并且 X 是 P 的左孩子) 其实这种情况下处理就和我们的平衡二叉树一样了 ","date":"2022-01-23","objectID":"/posts/java%E6%B3%9B%E5%9E%8B%E4%B8%8E%E9%9B%86%E5%90%88%E7%B1%BB/:3:3","tags":["Java泛型与集合类"],"title":"Java泛型与集合类","uri":"/posts/java%E6%B3%9B%E5%9E%8B%E4%B8%8E%E9%9B%86%E5%90%88%E7%B1%BB/"},{"categories":["JavaSE笔记"],"content":"认识集合类 集合表示一组对象，称为其元素。一些集合允许重复的元素，而另一些则不允许。一些集合是有序的，而其他则是无序的。 集合类其实就是为了更好地组织、管理和操作我们的数据而存在的，包括列表、集合、队列、映射等数据结构。从这一块开始，我们会从源码角度给大家讲解（数据结构很重要！），不仅仅是教会大家如何去使用。 集合类最顶层不是抽象类而是接口，因为接口代表的是某个功能，而抽象类是已经快要成形的类型，不同的集合类的底层实现是不相同的，同时一个集合类可能会同时具有两种及以上功能（既能做队列也能做列表），所以采用接口会更加合适，接口只需定义支持的功能即可。 ","date":"2022-01-23","objectID":"/posts/java%E6%B3%9B%E5%9E%8B%E4%B8%8E%E9%9B%86%E5%90%88%E7%B1%BB/:4:0","tags":["Java泛型与集合类"],"title":"Java泛型与集合类","uri":"/posts/java%E6%B3%9B%E5%9E%8B%E4%B8%8E%E9%9B%86%E5%90%88%E7%B1%BB/"},{"categories":["JavaSE笔记"],"content":"数组与集合 相同之处： 它们都是容器，都能够容纳一组元素。 不同之处： 数组的大小是固定的，集合的大小是可变的。 数组可以存放基本数据类型，但集合只能存放对象。 数组存放的类型只能是一种，但集合可以有不同种类的元素。 ","date":"2022-01-23","objectID":"/posts/java%E6%B3%9B%E5%9E%8B%E4%B8%8E%E9%9B%86%E5%90%88%E7%B1%BB/:4:1","tags":["Java泛型与集合类"],"title":"Java泛型与集合类","uri":"/posts/java%E6%B3%9B%E5%9E%8B%E4%B8%8E%E9%9B%86%E5%90%88%E7%B1%BB/"},{"categories":["JavaSE笔记"],"content":"集合根接口Collection 本接口中定义了全部的集合基本操作，我们可以在源码中看看。 我们再来看看List和Set以及Queue接口。 ","date":"2022-01-23","objectID":"/posts/java%E6%B3%9B%E5%9E%8B%E4%B8%8E%E9%9B%86%E5%90%88%E7%B1%BB/:4:2","tags":["Java泛型与集合类"],"title":"Java泛型与集合类","uri":"/posts/java%E6%B3%9B%E5%9E%8B%E4%B8%8E%E9%9B%86%E5%90%88%E7%B1%BB/"},{"categories":["JavaSE笔记"],"content":"集合类的使用 ","date":"2022-01-23","objectID":"/posts/java%E6%B3%9B%E5%9E%8B%E4%B8%8E%E9%9B%86%E5%90%88%E7%B1%BB/:5:0","tags":["Java泛型与集合类"],"title":"Java泛型与集合类","uri":"/posts/java%E6%B3%9B%E5%9E%8B%E4%B8%8E%E9%9B%86%E5%90%88%E7%B1%BB/"},{"categories":["JavaSE笔记"],"content":"List列表 首先介绍ArrayList，它的底层是用数组实现的，内部维护的是一个可改变大小的数组，也就是我们之前所说的线性表！跟我们之前自己写的ArrayList相比，它更加的规范，同时继承自List接口。 先看看ArrayList的源码！ 基本操作 List\u003cString\u003e list = new ArrayList\u003c\u003e(); //默认长度的列表 List\u003cString\u003e listInit = new ArrayList\u003c\u003e(100); //初始长度为100的列表 向列表中添加元素： List\u003cString\u003e list = new ArrayList\u003c\u003e(); list.add(\"lbwnb\"); list.add(\"yyds\"); list.contains(\"yyds\"); //是否包含某个元素 System.out.println(list); 移除元素： public static void main(String[] args) { List\u003cString\u003e list = new ArrayList\u003c\u003e(); list.add(\"lbwnb\"); list.add(\"yyds\"); list.remove(0); //按下标移除元素 list.remove(\"yyds\"); //移除指定元素 System.out.println(list); } 也支持批量操作： public static void main(String[] args) { ArrayList\u003cString\u003e list = new ArrayList\u003c\u003e(); list.addAll(new ArrayList\u003c\u003e()); //在尾部批量添加元素 list.removeAll(new ArrayList\u003c\u003e()); //批量移除元素（只有给定集合中存在的元素才会被移除） list.retainAll(new ArrayList\u003c\u003e()); //只保留某些元素 System.out.println(list); } 我们再来看LinkedList，其实本质就是一个链表！我们来看看源码。 其实与我们之前编写的LinkedList不同之处在于，它内部使用的是一个双向链表： private static class Node\u003cE\u003e { E item; Node\u003cE\u003e next; Node\u003cE\u003e prev; Node(Node\u003cE\u003e prev, E element, Node\u003cE\u003e next) { this.item = element; this.next = next; this.prev = prev; } } 当然，我们发现它还实现了Queue接口，所以LinkedList也能被当做一个队列或是栈来使用。 public static void main(String[] args) { LinkedList\u003cString\u003e list = new LinkedList\u003c\u003e(); list.offer(\"A\"); //入队 System.out.println(list.poll()); //出队 list.push(\"A\"); list.push(\"B\"); //进栈 list.push(\"C\"); System.out.println(list.pop()); System.out.println(list.pop()); //出栈 System.out.println(list.pop()); } 利用代码块来快速添加内容 前面我们学习了匿名内部类，我们就可以利用代码块，来快速生成一个自带元素的List List\u003cString\u003e list = new LinkedList\u003cString\u003e(){{ //初始化时添加 this.add(\"A\"); this.add(\"B\"); }}; 如果是需要快速生成一个只读的List，后面我们会讲解Arrays工具类。 集合的排序 List\u003cInteger\u003e list = new LinkedList\u003cInteger\u003e(){ //Java9才支持匿名内部类使用钻石运算符 { this.add(10); this.add(2); this.add(5); this.add(8); } }; list.sort((a, b) -\u003e { //排序已经由JDK实现，现在只需要填入自定义规则，完成Comparator接口实现 return a - b; //返回值小于0，表示a应该在b前面，返回值大于0，表示b应该在a后面，等于0则不进行交换 }); System.out.println(list); ","date":"2022-01-23","objectID":"/posts/java%E6%B3%9B%E5%9E%8B%E4%B8%8E%E9%9B%86%E5%90%88%E7%B1%BB/:5:1","tags":["Java泛型与集合类"],"title":"Java泛型与集合类","uri":"/posts/java%E6%B3%9B%E5%9E%8B%E4%B8%8E%E9%9B%86%E5%90%88%E7%B1%BB/"},{"categories":["JavaSE笔记"],"content":"迭代器 集合的遍历 所有的集合类，都支持foreach循环！ public static void main(String[] args) { List\u003cInteger\u003e list = new LinkedList\u003cInteger\u003e(){ //Java9才支持匿名内部类使用钻石运算符 { this.add(10); this.add(2); this.add(5); this.add(8); } }; for (Integer integer : list) { System.out.println(integer); } } 当然，也可以使用JDK1.8新增的forEach方法，它接受一个Consumer接口实现： list.forEach(i -\u003e { System.out.println(i); }); 从JDK1.8开始，lambda表达式开始逐渐成为主流，我们需要去适应函数式编程的这种语法，包括批量替换，也是用到了函数式接口来完成的。 list.replaceAll((i) -\u003e { if(i == 2) return 3; //将所有的2替换为3 else return i; //不是2就不变 }); System.out.println(list); Iterable和Iterator接口 我们之前学习数据结构时，已经得知，不同的线性表实现，在获取元素时的效率也不同，因此我们需要一种更好地方式来统一不同数据结构的遍历。 由于ArrayList对于随机访问的速度更快，而LinkedList对于顺序访问的速度更快，因此在上述的传统for循环遍历操作中，ArrayList的效率更胜一筹，因此我们要使得LinkedList遍历效率提升，就需要采用顺序访问的方式进行遍历，如果没有迭代器帮助我们统一标准，那么我们在应对多种集合类型的时候，就需要对应编写不同的遍历算法，很显然这样会降低我们的开发效率，而迭代器的出现就帮助我们解决了这个问题。 我们先来看看迭代器里面方法： public interface Iterator\u003cE\u003e { //... } 每个集合类都有自己的迭代器，通过iterator()方法来获取： Iterator\u003cInteger\u003e iterator = list.iterator(); //生成一个新的迭代器 while (iterator.hasNext()){ //判断是否还有下一个元素 Integer i = iterator.next(); //获取下一个元素（获取一个少一个） System.out.println(i); } 迭代器生成后，默认指向第一个元素，每次调用next()方法，都会将指针后移，当指针移动到最后一个元素之后，调用hasNext()将会返回false，迭代器是一次性的，用完即止，如果需要再次使用，需要调用iterator()方法。 ListIterator\u003cInteger\u003e iterator = list.listIterator(); //List还有一个更好地迭代器实现ListIterator ListIterator是List中独有的迭代器，在原有迭代器基础上新增了一些额外的操作。 ","date":"2022-01-23","objectID":"/posts/java%E6%B3%9B%E5%9E%8B%E4%B8%8E%E9%9B%86%E5%90%88%E7%B1%BB/:5:2","tags":["Java泛型与集合类"],"title":"Java泛型与集合类","uri":"/posts/java%E6%B3%9B%E5%9E%8B%E4%B8%8E%E9%9B%86%E5%90%88%E7%B1%BB/"},{"categories":["JavaSE笔记"],"content":"Set集合 我们之前已经看过Set接口的定义了，我们发现接口中定义的方法都是Collection中直接继承的，因此，Set支持的功能其实也就和Collection中定义的差不多，只不过使用方法上稍有不同。 Set集合特点： 不允许出现重复元素 不支持随机访问（不允许通过下标访问） 首先认识一下HashSet，它的底层就是采用哈希表实现的（我们在这里先不去探讨实现原理，因为底层实质上维护的是一个HashMap，我们学习了Map之后再来讨论） public static void main(String[] args) { HashSet\u003cInteger\u003e set = new HashSet\u003c\u003e(); set.add(120); //支持插入元素，但是不支持指定位置插入 set.add(13); set.add(11); for (Integer integer : set) { System.out.println(integer); } } 运行上面代码发现，最后Set集合中存在的元素顺序，并不是我们的插入顺序，这是因为HashSet底层是采用哈希表来实现的，实际的存放顺序是由Hash算法决定的。 那么我们希望数据按照我们插入的顺序进行保存该怎么办呢？我们可以使用LinkedHashSet： public static void main(String[] args) { LinkedHashSet\u003cInteger\u003e set = new LinkedHashSet\u003c\u003e(); //会自动保存我们的插入顺序 set.add(120); set.add(13); set.add(11); for (Integer integer : set) { System.out.println(integer); } } LinkedHashSet底层维护的不再是一个HashMap，而是LinkedHashMap，它能够在插入数据时利用链表自动维护顺序，因此这样就能够保证我们插入顺序和最后的迭代顺序一致了。 还有一种Set叫做TreeSet，它会在元素插入时进行排序： public static void main(String[] args) { TreeSet\u003cInteger\u003e set = new TreeSet\u003c\u003e(); set.add(1); set.add(3); set.add(2); System.out.println(set); } 可以看到最后得到的结果并不是我们插入顺序，而是按照数字的大小进行排列。当然，我们也可以自定义排序规则： public static void main(String[] args) { TreeSet\u003cInteger\u003e set = new TreeSet\u003c\u003e((a, b) -\u003e b - a); //在创建对象时指定规则即可 set.add(1); set.add(3); set.add(2); System.out.println(set); } 现在的结果就是我们自定义的排序规则了。 虽然Set集合只是粗略的进行了讲解，但是学习Map之后，我们还会回来看我们Set的底层实现，所以说最重要的还是Map。本节只需要记住Set的性质、使用即可。 ","date":"2022-01-23","objectID":"/posts/java%E6%B3%9B%E5%9E%8B%E4%B8%8E%E9%9B%86%E5%90%88%E7%B1%BB/:5:3","tags":["Java泛型与集合类"],"title":"Java泛型与集合类","uri":"/posts/java%E6%B3%9B%E5%9E%8B%E4%B8%8E%E9%9B%86%E5%90%88%E7%B1%BB/"},{"categories":["JavaSE笔记"],"content":"Map映射 什么是映射 我们在高中阶段其实已经学习过映射了，映射指两个元素的之间相互“对应”的关系，也就是说，我们的元素之间是两两对应的，是以键值对的形式存在。 Map接口 Map就是为了实现这种数据结构而存在的，我们通过保存键值对的形式来存储映射关系。 我们先来看看Map接口中定义了哪些操作。 HashMap和LinkedHashMap HashMap的实现过程，相比List，就非常地复杂了，它并不是简简单单的表结构，而是利用哈希表存放映射关系，我们来看看HashMap是如何实现的，首先回顾我们之前学习的哈希表，它长这样： 哈希表的本质其实就是一个用于存放后续节点的头结点的数组，数组里面的每一个元素都是一个头结点（也可以说就是一个链表），当要新插入一个数据时，会先计算该数据的哈希值，找到数组下标，然后创建一个新的节点，添加到对应的链表后面。 而HashMap就是采用的这种方式，我们可以看到源码中同样定义了这样的一个结构： /** * The table, initialized on first use, and resized as * necessary. When allocated, length is always a power of two. * (We also tolerate length zero in some operations to allow * bootstrapping mechanics that are currently not needed.) */ transient Node\u003cK,V\u003e[] table; 这个表会在第一次使用时初始化，同时在必要时进行扩容，并且它的大小永远是2的倍数！ /** * The default initial capacity - MUST be a power of two. */ static final int DEFAULT_INITIAL_CAPACITY = 1 \u003c\u003c 4; // aka 16 我们可以看到默认的大小为2的4次方，每次都需要是2的倍数，也就是说，下一次增长之后，大小会变成2的5次方。 我们现在需要思考一个问题，当我们表中的数据不断增加之后，链表会变得越来越长，这样会严重导致查询速度变慢，首先想到办法就是，我们可以对数组的长度进行扩容，来存放更多的链表，那么什么情况下会进行扩容呢？ /** * The load factor for the hash table. * * @serial */ final float loadFactor; 我们还发现HashMap源码中有这样一个变量，也就是负载因子，那么它是干嘛的呢？ 负载因子其实就是用来衡量当前情况是否需要进行扩容的标准。我们可以看到默认的负载因子是0.75 /** * The load factor used when none specified in constructor. */ static final float DEFAULT_LOAD_FACTOR = 0.75f; 那么负载因子是怎么控制扩容的呢？0.75的意思是，在插入新的结点后，如果当前数组的占用率达到75%则进行扩容。在扩容时，会将所有的数据，重新计算哈希值，得到一个新的下标，组成新的哈希表。 但是这样依然有一个问题，链表过长的情况还是有可能发生，所以，为了从根源上解决这个问题，在JDK1.8时，引入了红黑树这个数据结构。 当链表的长度达到8时，会自动将链表转换为红黑树，这样能使得原有的查询效率大幅度降低！当使用红黑树之后，我们就可以利用二分搜索的思想，快速地去寻找我们想要的结果，而不是像链表一样挨个去看。 /** * Entry for Tree bins. Extends LinkedHashMap.Entry (which in turn * extends Node) so can be used as extension of either regular or * linked node. */ static final class TreeNode\u003cK,V\u003e extends LinkedHashMap.Entry\u003cK,V\u003e { 除了Node以外，HashMap还有TreeNode，很明显这就是为了实现红黑树而设计的内部类。不过我们发现，TreeNode并不是直接继承Node，而是使用了LinkedHashMap中的Entry实现，它保存了前后节点的顺序（也就是我们的插入顺序）。 /** * HashMap.Node subclass for normal LinkedHashMap entries. */ static class Entry\u003cK,V\u003e extends HashMap.Node\u003cK,V\u003e { Entry\u003cK,V\u003e before, after; Entry(int hash, K key, V value, Node\u003cK,V\u003e next) { super(hash, key, value, next); } } LinkedHashMap是直接继承自HashMap，具有HashMap的全部性质，同时得益于每一个节点都是一个双向链表，保存了插入顺序，这样我们在遍历LinkedHashMap时，顺序就同我们的插入顺序一致。当然，也可以使用访问顺序，也就是说对于刚访问过的元素，会被排到最后一位。 public static void main(String[] args) { LinkedHashMap\u003cInteger, String\u003e map = new LinkedHashMap\u003c\u003e(16, 0.75f, true); //以访问顺序 map.put(1, \"A\"); map.put(2, \"B\"); map.put(3, \"C\"); map.get(2); System.out.println(map); } 观察结果，我们发现，刚访问的结果被排到了最后一位。 TreeMap TreeMap其实就是自动维护顺序的一种Map，就和我们前面提到的TreeSet一样： /** * The comparator used to maintain order in this tree map, or * null if it uses the natural ordering of its keys. * * @serial */ private final Comparator\u003c? super K\u003e comparator; private transient Entry\u003cK,V\u003e root; /** * Node in the Tree. Doubles as a means to pass key-value pairs back to * user (see Map.Entry). */ static final class Entry\u003cK,V\u003e implements Map.Entry\u003cK,V\u003e { 我们发现它的内部直接维护了一个红黑树，就像它的名字一样，就是一个Tree，因为它默认就是有序的，所以说直接采用红黑树会更好。我们在创建时，直接给予一个比较规则即可。 Map的使用 我们首先来看看Map的一些基本操作： public static void main(String[] args) { Map\u003cInteger, String\u003e map = new HashMap\u003c\u003e(); map.put(1, \"A\"); map.put(2, \"B\"); map.put(3, \"C\"); System.out.println(map.get(1)); //获取Key为1的值 System.out.println(map.getOrDefault(0, \"K\")); //不存在就返回K map.remove(1); //移除这个Key的键值对 } 由于Map并未实现迭代器接口，因此不支持foreach，但是JDK1.8为我们提供了forEach方法使用： public static void main(String[] args) { Map\u003cInteger, String\u003e map = new HashMap\u003c\u003e(); map.put(1, \"A\"); map.put(2, \"B\"); map.put(3, \"C\"); map.forEach((k, v) -\u003e System.out.println(k+\"-\u003e\"+v)); for (Map.Entry\u003cInteger, String\u003e entry : map.entrySet()) { //也可以获取所有的Entry来foreach int key = entry.getKey(); String value = entry.getValue(); System.out.println(key+\" -\u003e \"+value); } } 我们也可以单独获取所有的值或者是键： public static void main(String[] args) { Map\u003cInteger, String\u003e map = new HashMap\u003c\u003e(); map.put(1, \"A\"); map.put(2, \"B\"); map.put(3, \"C\"); System.out.println(map.keySet()); //直接获取所有的key System.out.println(map.values()); //直接获取所有的值 } 再谈Set原理 通过观察Hash","date":"2022-01-23","objectID":"/posts/java%E6%B3%9B%E5%9E%8B%E4%B8%8E%E9%9B%86%E5%90%88%E7%B1%BB/:5:4","tags":["Java泛型与集合类"],"title":"Java泛型与集合类","uri":"/posts/java%E6%B3%9B%E5%9E%8B%E4%B8%8E%E9%9B%86%E5%90%88%E7%B1%BB/"},{"categories":["JavaSE笔记"],"content":"集合的嵌套 既然集合类型中的元素类型是泛型，那么能否嵌套存储呢？ public static void main(String[] args) { Map\u003cString, List\u003cInteger\u003e\u003e map = new HashMap\u003c\u003e(); //每一个映射都是 字符串\u003c-\u003e列表 map.put(\"卡布奇诺今犹在\", new LinkedList\u003c\u003e()); map.put(\"不见当年倒茶人\", new LinkedList\u003c\u003e()); System.out.println(map.keySet()); System.out.println(map.values()); } 通过Key获取到对应的值后，就是一个列表： map.get(\"卡布奇诺今犹在\").add(10); System.out.println(map.get(\"卡布奇诺今犹在\").get(0)); 让套娃继续下去： public static void main(String[] args) { Map\u003cInteger, Map\u003cInteger, Map\u003cInteger, String\u003e\u003e\u003e map = new HashMap\u003c\u003e(); } 你也可以使用List来套娃别的： public static void main(String[] args) { List\u003cMap\u003cString, Set\u003cString\u003e\u003e\u003e list = new LinkedList\u003c\u003e(); } ","date":"2022-01-23","objectID":"/posts/java%E6%B3%9B%E5%9E%8B%E4%B8%8E%E9%9B%86%E5%90%88%E7%B1%BB/:5:5","tags":["Java泛型与集合类"],"title":"Java泛型与集合类","uri":"/posts/java%E6%B3%9B%E5%9E%8B%E4%B8%8E%E9%9B%86%E5%90%88%E7%B1%BB/"},{"categories":["JavaSE笔记"],"content":"流Stream和Optional的使用 Java 8 API添加了一个新的抽象称为流Stream，可以让你以一种声明的方式处理数据。Stream 使用一种类似用 SQL 语句从数据库查询数据的直观方式来提供一种对 Java 集合运算和表达的高阶抽象。Stream API可以极大提高Java程序员的生产力，让程序员写出高效率、干净、简洁的代码。这种风格将要处理的元素集合看作一种流， 流在管道中传输， 并且可以在管道的节点上进行处理， 比如筛选， 排序，聚合等。元素流在管道中经过中间操作（intermediate operation）的处理，最后由最终操作(terminal operation)得到前面处理的结果。 它看起来就像一个工厂的流水线一样！我们就可以把一个Stream当做流水线处理： public static void main(String[] args) { List\u003cString\u003e list = new ArrayList\u003c\u003e(); list.add(\"A\"); list.add(\"B\"); list.add(\"C\"); //移除为B的元素 Iterator\u003cString\u003e iterator = list.iterator(); while (iterator.hasNext()){ if(iterator.next().equals(\"B\")) iterator.remove(); } //Stream操作 list = list //链式调用 .stream() //获取流 .filter(e -\u003e !e.equals(\"B\")) //只允许所有不是B的元素通过流水线 .collect(Collectors.toList()); //将流水线中的元素重新收集起来，变回List System.out.println(list); } 可能从上述例子中还不能感受到流处理带来的便捷，我们通过下面这个例子来感受一下： public static void main(String[] args) { List\u003cInteger\u003e list = new ArrayList\u003c\u003e(); list.add(1); list.add(2); list.add(3); list.add(3); list = list .stream() .distinct() //去重（使用equals判断） .sorted((a, b) -\u003e b - a) //进行倒序排列 .map(e -\u003e e+1) //每个元素都要执行+1操作 .limit(2) //只放行前两个元素 .collect(Collectors.toList()); System.out.println(list); } 当遇到大量的复杂操作时，我们就可以使用Stream来快速编写代码，这样不仅代码量大幅度减少，而且逻辑也更加清晰明了（如果你学习过SQL的话，你会发现它更像一个Sql语句） 注意：不能认为每一步是直接依次执行的！ List\u003cInteger\u003e list = new ArrayList\u003c\u003e(); list.add(1); list.add(2); list.add(3); list.add(3); list = list .stream() .distinct() //断点 .sorted((a, b) -\u003e b - a) .map(e -\u003e { System.out.println(\"\u003e\u003e\u003e \"+e); //断点 return e+1; }) .limit(2) //断点 .collect(Collectors.toList()); //实际上，stream会先记录每一步操作，而不是直接开始执行内容，当整个链式调用完成后，才会依次进行！ 接下来，我们用一堆随机数来进行更多流操作的演示： public static void main(String[] args) { Random random = new Random(); //Random是一个随机数工具类 random .ints(-100, 100) //生成-100~100之间的，随机int型数字（本质上是一个IntStream） .limit(10) //只获取前10个数字（这是一个无限制的流，如果不加以限制，将会无限进行下去！） .filter(i -\u003e i \u003c 0) //只保留小于0的数字 .sorted() //默认从小到大排序 .forEach(System.out::println); //依次打印 } 我们可以生成一个统计实例来帮助我们快速进行统计： public static void main(String[] args) { Random random = new Random(); //Random是一个随机数工具类 IntSummaryStatistics statistics = random .ints(0, 100) .limit(100) .summaryStatistics(); //获取语法统计实例 System.out.println(statistics.getMax()); //快速获取最大值 System.out.println(statistics.getCount()); //获取数量 System.out.println(statistics.getAverage()); //获取平均值 } 普通的List只需要一个方法就可以直接转换到方便好用的IntStream了： public static void main(String[] args) { List\u003cInteger\u003e list = new ArrayList\u003c\u003e(); list.add(1); list.add(1); list.add(2); list.add(3); list.add(4); list.stream() .mapToInt(i -\u003e i) //将每一个元素映射为Integer类型（这里因为本来就是Integer） .summaryStatistics(); } 我们还可以通过flat来对整个流进行进一步细分： public static void main(String[] args) { List\u003cString\u003e list = new ArrayList\u003c\u003e(); list.add(\"A,B\"); list.add(\"C,D\"); list.add(\"E,F\"); //我们想让每一个元素通过,进行分割，变成独立的6个元素 list = list .stream() //生成流 .flatMap(e -\u003e Arrays.stream(e.split(\",\"))) //分割字符串并生成新的流 .collect(Collectors.toList()); //汇成新的List System.out.println(list); //得到结果 } 我们也可以只通过Stream来完成所有数字的和，使用reduce方法： public static void main(String[] args) { List\u003cInteger\u003e list = new ArrayList\u003c\u003e(); list.add(1); list.add(2); list.add(3); int sum = list .stream() .reduce((a, b) -\u003e a + b) //计算规则为：a是上一次计算的值，b是当前要计算的参数，这里是求和 .get(); //我们发现得到的是一个Optional类实例，不是我们返回的类型，通过get方法返回得到的值 System.out.println(sum); } 通过上面的例子，我们发现，Stream不喜欢直接给我们返回一个结果，而是通过Optinal的方式，那么什么是Optional呢？ Optional类是Java8为了解决null值判断问题，使用Optional类可以避免显式的null值判断（null的防御性检查），避免null导致的NPE（NullPointerException）。总而言之，就是对控制的一个判断，为了避免空指针异常。 public static void main(String[] args) { String str = null; if(str != null){ //当str不为空时添加元素到List中 list.add(str); } } 有了Optional之后，我们就可以这样写： public static void main(String[] args) { String str = null; Optional\u003cString\u003e optional = Optional.ofNullable(str); //转换为Optional optional.ifPresent(System.out::println); //当存在时再执行方法 } 就类似于Kotlin中的： var str : String? = null str?.upperCase() 我们可以选择直接get或是当值为null时，获取备选值： public static void main(String[] args) { String str = null; Optional optional = Optional.ofNullable(str); //转换为Optional（可空） System.out.println(optional.orElse(\"lbwnb\")); // S","date":"2022-01-23","objectID":"/posts/java%E6%B3%9B%E5%9E%8B%E4%B8%8E%E9%9B%86%E5%90%88%E7%B1%BB/:5:6","tags":["Java泛型与集合类"],"title":"Java泛型与集合类","uri":"/posts/java%E6%B3%9B%E5%9E%8B%E4%B8%8E%E9%9B%86%E5%90%88%E7%B1%BB/"},{"categories":["JavaSE笔记"],"content":"Arrays和Collections的使用 Arrays是一个用于操作数组的工具类，它给我们提供了大量的工具方法： /** * This class contains various methods for manipulating arrays (such as * sorting and searching). This class also contains a static factory * that allows arrays to be viewed as lists. \u003c- 注意，这句话很关键 * * @author Josh Bloch * @author Neal Gafter * @author John Rose * @since 1.2 */ public class Arrays { 由于操作数组并不像集合那样方便，因此JDK提供了Arrays类来增强对数组操作，比如： public static void main(String[] args) { int[] array = {1, 5, 2, 4, 7, 3, 6}; Arrays.sort(array); //直接进行排序（底层原理：进行判断，元素少使用插入排序，大量元素使用双轴快速/归并排序） System.out.println(array); //由于int[]是一个对象类型，而数组默认是没有重写toString()方法，因此无法打印到想要的结果 System.out.println(Arrays.toString(array)); //我们可以使用Arrays.toString()来像集合一样直接打印每一个元素出来 } public static void main(String[] args) { int[] array = {1, 5, 2, 4, 7, 3, 6}; Arrays.sort(array); System.out.println(\"排序后的结果：\"+Arrays.toString(array)); System.out.println(\"目标元素3位置为：\"+Arrays.binarySearch(array, 3)); //二分搜素，必须是已经排序好的数组！ } public static void main(String[] args) { int[] array = {1, 5, 2, 4, 7, 3, 6}; Arrays .stream(array) //将数组转换为流进行操作 .sorted() .forEach(System.out::println); } public static void main(String[] args) { int[] array = {1, 5, 2, 4, 7, 3, 6}; int[] array2 = Arrays.copyOf(array, array.length); //复制一个一模一样的数组 System.out.println(Arrays.toString(array2)); System.out.println(Arrays.equals(array, array2)); //比较两个数组是否值相同 Arrays.fill(array, 0); //将数组的所有值全部填充为指定值 System.out.println(Arrays.toString(array)); Arrays.setAll(array2, i -\u003e array2[i] + 2); //依次计算每一个元素（注意i是下标位置） System.out.println(Arrays.toString(array2)); //这里计算让每个元素值+2 } 思考：当二维数组使用Arrays.equals()进行比较以及Arrays.toString()进行打印时，还会得到我们想要的结果吗？ public static void main(String[] args) { Integer[][] array = {{1, 5}, {2, 4}, {7, 3}, {6}}; Integer[][] array2 = {{1, 5}, {2, 4}, {7, 3}, {6}}; System.out.println(Arrays.toString(array)); //这样还会得到我们想要的结果吗？ System.out.println(Arrays.equals(array2, array)); //这样还会得到true吗？ System.out.println(Arrays.deepToString(array)); //使用deepToString就能到打印多维数组 System.out.println(Arrays.deepEquals(array2, array)); //使用deepEquals就能比较多维数组 } 那么，一开始提到的当做List进行操作呢？我们可以使用Arrays.asList()来将数组转换为一个 固定长度的List public static void main(String[] args) { Integer[] array = {1, 5, 2, 4, 7, 3, 6}; List\u003cInteger\u003e list = Arrays.asList(array); //不支持基本类型数组，必须是对象类型数组 Arrays.asList(\"A\", \"B\", \"C\"); //也可以逐个添加，因为是可变参数 list.add(1); //此List实现是长度固定的，是Arrays内部单独实现的一个类型，因此不支持添加操作 list.remove(0); //同理，也不支持移除 list.set(0, 8); //直接设置指定下标的值就可以 list.sort(Comparator.reverseOrder()); //也可以执行排序操作 System.out.println(list); //也可以像List那样直接打印 } 文字游戏：allows arrays to be viewed as lists，实际上只是当做List使用，本质还是数组，因此数组的属性依然存在！因此如果要将数组快速转换为实际的List，可以像这样： public static void main(String[] args) { Integer[] array = {1, 5, 2, 4, 7, 3, 6}; List\u003cInteger\u003e list = new ArrayList\u003c\u003e(Arrays.asList(array)); } 通过自行创建一个真正的ArrayList并在构造时将Arrays的List值传递。 既然数组操作都这么方便了，集合操作能不能也安排点高级的玩法呢？那必须的，JDK为我们准备的Collocations类就是专用于集合的工具类： public static void main(String[] args) { List\u003cInteger\u003e list = new ArrayList\u003c\u003e(); Collections.max(list); Collections.min(list); } 当然，Collections提供的内容相比Arrays会更多，希望大家下去自行了解，这里就不多做介绍了。 ","date":"2022-01-23","objectID":"/posts/java%E6%B3%9B%E5%9E%8B%E4%B8%8E%E9%9B%86%E5%90%88%E7%B1%BB/:5:7","tags":["Java泛型与集合类"],"title":"Java泛型与集合类","uri":"/posts/java%E6%B3%9B%E5%9E%8B%E4%B8%8E%E9%9B%86%E5%90%88%E7%B1%BB/"},{"categories":["JavaSE笔记"],"content":"集合类编程实战 ","date":"2022-01-23","objectID":"/posts/java%E6%B3%9B%E5%9E%8B%E4%B8%8E%E9%9B%86%E5%90%88%E7%B1%BB/:6:0","tags":["Java泛型与集合类"],"title":"Java泛型与集合类","uri":"/posts/java%E6%B3%9B%E5%9E%8B%E4%B8%8E%E9%9B%86%E5%90%88%E7%B1%BB/"},{"categories":["JavaSE笔记"],"content":"反转链表 1 \u003c- 3 \u003c- 5 \u003c- 7 \u003c- 9 转换为 1 \u003c- 3 \u003c- 5 \u003c- 7 \u003c- 9 现在有一个单链表，尝试将其所有节点倒序排列 public class Main { public static void main(String[] args) { Node head = new Node(1); head.next = new Node(3); head.next.next = new Node(5); head.next.next.next = new Node(7); head.next.next.next.next = new Node(9); head = reverse(head); while (head != null){ System.out.println(head.value+\" \"); head = head.next; } } public static class Node { public int value; public Node next; public Node(int data) { this.value = data; } } public static Node reverse(Node head) { //在这里实现 } } ","date":"2022-01-23","objectID":"/posts/java%E6%B3%9B%E5%9E%8B%E4%B8%8E%E9%9B%86%E5%90%88%E7%B1%BB/:6:1","tags":["Java泛型与集合类"],"title":"Java泛型与集合类","uri":"/posts/java%E6%B3%9B%E5%9E%8B%E4%B8%8E%E9%9B%86%E5%90%88%E7%B1%BB/"},{"categories":["JavaSE笔记"],"content":"重建二叉树 现在知道二叉树的前序: GDAFEMHZ，以及中序: ADEFGHMZ，请根据已知信息还原这颗二叉树。 ","date":"2022-01-23","objectID":"/posts/java%E6%B3%9B%E5%9E%8B%E4%B8%8E%E9%9B%86%E5%90%88%E7%B1%BB/:6:2","tags":["Java泛型与集合类"],"title":"Java泛型与集合类","uri":"/posts/java%E6%B3%9B%E5%9E%8B%E4%B8%8E%E9%9B%86%E5%90%88%E7%B1%BB/"},{"categories":["JavaSE笔记"],"content":"实现计算器 实现一个计算器，要求输入一个计算公式（含加减乘除运算符，没有负数但是有小数），得到结果，比如输入：1+4*3/1.321，得到结果为：2.2 ","date":"2022-01-23","objectID":"/posts/java%E6%B3%9B%E5%9E%8B%E4%B8%8E%E9%9B%86%E5%90%88%E7%B1%BB/:6:3","tags":["Java泛型与集合类"],"title":"Java泛型与集合类","uri":"/posts/java%E6%B3%9B%E5%9E%8B%E4%B8%8E%E9%9B%86%E5%90%88%E7%B1%BB/"},{"categories":["JavaSE笔记"],"content":"字符串匹配（KMP算法） 现在给定一个主字符串和一个子字符串，请判断主字符串是否包含子字符串，例如主字符串：ABCABCDHI，子字符串：ABCD，因此主字符串包含此子字符串；主字符串：ABCABCUISA，子字符串：ABCD，则不包含。 ","date":"2022-01-23","objectID":"/posts/java%E6%B3%9B%E5%9E%8B%E4%B8%8E%E9%9B%86%E5%90%88%E7%B1%BB/:6:4","tags":["Java泛型与集合类"],"title":"Java泛型与集合类","uri":"/posts/java%E6%B3%9B%E5%9E%8B%E4%B8%8E%E9%9B%86%E5%90%88%E7%B1%BB/"},{"categories":["C++实战"],"content":"”一起来领略C++模板的奥义“","date":"2022-01-20","objectID":"/posts/c++%E7%9A%84%E6%A8%A1%E6%9D%BF%E5%86%99println/","tags":["C++模板"],"title":"C++变参模板运用实战——实现PrintLn","uri":"/posts/c++%E7%9A%84%E6%A8%A1%E6%9D%BF%E5%86%99println/"},{"categories":["C++实战"],"content":"想要实现PrintLn，关键在于支持无限个参数的打印函数，所以我大致总结下C++能够如何去实现它！ ","date":"2022-01-20","objectID":"/posts/c++%E7%9A%84%E6%A8%A1%E6%9D%BF%E5%86%99println/:0:0","tags":["C++模板"],"title":"C++变参模板运用实战——实现PrintLn","uri":"/posts/c++%E7%9A%84%E6%A8%A1%E6%9D%BF%E5%86%99println/"},{"categories":["C++实战"],"content":"方式一：用初始化列表实现PrintLn() 【C++11】 ","date":"2022-01-20","objectID":"/posts/c++%E7%9A%84%E6%A8%A1%E6%9D%BF%E5%86%99println/:1:0","tags":["C++模板"],"title":"C++变参模板运用实战——实现PrintLn","uri":"/posts/c++%E7%9A%84%E6%A8%A1%E6%9D%BF%E5%86%99println/"},{"categories":["C++实战"],"content":"版本一：朴素初始化列表版本版本 函数版本： #include\u003ciostream\u003eusing namespace std; void PrintLn(std::initializer_list\u003cint\u003e args){ for(auto arg:args){ cout\u003c\u003carg\u003c\u003c\", \"; } cout\u003c\u003cstd::endl; } int main() { PrintLn({3,23,2,12}); return 0; } 类的构造器版本(可去掉小括号)： #include\u003ciostream\u003eusing namespace std; class PrintLn { public: PrintLn(std::initializer_list\u003cint\u003e args) { for (auto arg:args) { cout \u003c\u003c arg \u003c\u003c \", \"; } cout \u003c\u003c std::endl; } }; int main() { auto t = PrintLn{3, 23, 2, 12}; return 0; } ","date":"2022-01-20","objectID":"/posts/c++%E7%9A%84%E6%A8%A1%E6%9D%BF%E5%86%99println/:1:1","tags":["C++模板"],"title":"C++变参模板运用实战——实现PrintLn","uri":"/posts/c++%E7%9A%84%E6%A8%A1%E6%9D%BF%E5%86%99println/"},{"categories":["C++实战"],"content":"版本二：加模板参数版本 实际上和上面的基本没太大区别，除了上面确定为了int类型，二加了模板后，可以为任意类型，但是实际上传入的还是只能是同一个类型。所以初始化列表实现是非常的不好用的。 #incldue\u003ciostream\u003e using namespace std; template\u003ctypename T\u003e class PrintLn { public: PrintLn(std::initializer_list\u003cT\u003e args) { for (auto arg:args) { cout \u003c\u003c arg \u003c\u003c \", \"; }# PrintLn函数实现 想要实现PrintLn，关键在于支持无限个参数的打印函数，所以我大致总结下C++能够如何去实现它！ ## 方式一：用初始化列表实现PrintLn() 【C++11】 ### 版本一：朴素初始化列表版本版本 \u003e 函数版本： ```cpp #include\u003ciostream\u003eusing namespace std; void PrintLn(std::initializer_list\u003cint\u003e args){ for(auto arg:args){ cout\u003c\u003carg\u003c\u003c\", \"; } cout\u003c\u003cstd::endl; } int main() { PrintLn({3,23,2,12}); return 0; } 类的构造器版本(可去掉小括号)： #include\u003ciostream\u003eusing namespace std; class PrintLn { public: PrintLn(std::initializer_list\u003cint\u003e args) { for (auto arg:args) { cout \u003c\u003c arg \u003c\u003c \", \"; } cout \u003c\u003c std::endl; } }; int main() { auto t = PrintLn{3, 23, 2, 12}; return 0; } ","date":"2022-01-20","objectID":"/posts/c++%E7%9A%84%E6%A8%A1%E6%9D%BF%E5%86%99println/:1:2","tags":["C++模板"],"title":"C++变参模板运用实战——实现PrintLn","uri":"/posts/c++%E7%9A%84%E6%A8%A1%E6%9D%BF%E5%86%99println/"},{"categories":["C++实战"],"content":"版本二：加模板参数版本 实际上和上面的基本没太大区别，除了上面确定为了int类型，而加了模板后，可以为任意类型，但是实际上传入的还是只能是同一个类型。所以初始化列表的方式实现Println只能说形似而神不似。 #incldue\u003ciostream\u003e using namespace std; template\u003ctypename T\u003e class PrintLn { public: PrintLn(std::initializer_list\u003cT\u003e args) { for (auto arg:args) { cout \u003c\u003c arg \u003c\u003c \", \"; } cout \u003c\u003c std::endl; } }; int main() { auto t = PrintLn\u003cint\u003e{3, 23, 2, 12}; return 0; } ","date":"2022-01-20","objectID":"/posts/c++%E7%9A%84%E6%A8%A1%E6%9D%BF%E5%86%99println/:1:3","tags":["C++模板"],"title":"C++变参模板运用实战——实现PrintLn","uri":"/posts/c++%E7%9A%84%E6%A8%A1%E6%9D%BF%E5%86%99println/"},{"categories":["C++实战"],"content":"方式二：用可变参模板实现 【C++11/17】 如果有了解过C的可变参函数和可变参的宏，那么这个可变参模板与它有些类型，只不过C里面的va_start,va_list,va_arg,va_end这一系列实现可变参数的宏用起来非常麻烦，而且无法确定每个参数的类型，而可变参的模板则带有模板的泛型性质，所以是能确定类型的，甚至由于模板可以传值，后面还可直接传值使用。 以下简单描述可变参模板的使用方式： typenam... 算C++的一个新的关键字，它可以用来定义一个可变参的模板类型，而这个类型在其他地方定义使用的时候也要在后面带上 ... 表示拆包，否则会报错。 例如： template\u003ctypename... T\u003e void f(T... t){//TODO 这种类型或变量在任何地方作为参数定义或者传递的时候都需要加上...表示拆包 f(t...) } 在C++17出现fold expression之前，这个拆包过程只能借助另一个模板参数来得到模板参数包里面的内容。 注意以上两点，那么可以开始编写泛型模板，实现可变参数的完全打印过程了。 ","date":"2022-01-20","objectID":"/posts/c++%E7%9A%84%E6%A8%A1%E6%9D%BF%E5%86%99println/:2:0","tags":["C++模板"],"title":"C++变参模板运用实战——实现PrintLn","uri":"/posts/c++%E7%9A%84%E6%A8%A1%E6%9D%BF%E5%86%99println/"},{"categories":["C++实战"],"content":"C++11版本实现 错误实现版本：如果你直接像下面这样进行拆包，那么编译是会报错的，因为拆包过程相当于一个递归的过程，而你这个递归的过程没有一个跳出的条件，比如args如果为0个参数时，继续在往下就无法展开了，所以需要实现一个没有参数的版本让拆包过程停止。 template\u003ctypename T,typename... Args\u003e void PrintLn(T firstArg,Args... args){ cout\u003c\u003cfirstArg\u003c\u003c\", \"; PrintLn(args...); } //拆包过程：PrintLn(3,1,3,4)-\u003e // PrintLn(firstArg:3,args(1,3,4)); // PrintLn(firstArg:1,args(3,4)); // PrintLn(firstArg:3,args(4)); // PrintLn(firstArg:4,args(null)) // 由于到了上面的第四行还要继续往下拆包 // 而此时只有0个参数，没有对应的PrintLn版本可以调用，故报错！ 以下为正确修改版本： #include\u003ciostream\u003eusing namespace std; void PrintLn(){ } template\u003ctypename T,typename... Args\u003e void PrintLn(T firstArg,Args... args){ cout\u003c\u003cfirstArg\u003c\u003c\", \"; PrintLn(args...); } int main() { PrintLn(3, 23, 2, 12); return 0; 当然也可以控制只剩一个参数时就停止拆包。 #include\u003ciostream\u003eusing namespace std; template\u003ctypename T\u003e void PrintLn(T arg){ cout\u003c\u003carg\u003c\u003cendl; } template\u003ctypename T,typename... Args\u003e void PrintLn(T firstArg,Args... args){ cout\u003c\u003cfirstArg\u003c\u003c\", \"; PrintLn(args...); } int main() { PrintLn(3, 23, 2, 12); return 0; } ","date":"2022-01-20","objectID":"/posts/c++%E7%9A%84%E6%A8%A1%E6%9D%BF%E5%86%99println/:2:1","tags":["C++模板"],"title":"C++变参模板运用实战——实现PrintLn","uri":"/posts/c++%E7%9A%84%E6%A8%A1%E6%9D%BF%E5%86%99println/"},{"categories":["C++实战"],"content":"C++17版本实现 上面的实现流程实际上在C++17中可以用 if constexpr()+sizeof… 在编译期间来进行流程控制。 首先来讲一讲为什么普通的 if + sizeof… 来实现可变参数的长度控制流程会报错呢？ 因为整个模板推断和拆包解包过程是在编译期完成的，而if的控制流程在编译期是完全不清楚的，所以会报错，但是有了if constexpr之后，就能控制编译期的模板拆包过程了！ 如上面实现PrintLn，可以直接简化成下面这样： #include\u003ciostream\u003eusing namespace std; template\u003ctypename T,typename... Args\u003e void PrintLn(T firstArg,Args... args){ if constexpr(sizeof...(args)==0){//当参数个数为0个的时候就不继续拆包了 cout\u003c\u003cfirstArg\u003c\u003cendl; }else{ cout\u003c\u003cfirstArg\u003c\u003c\", \"; PrintLn(args...);//往下继续拆包 } } int main() { PrintLn(3, 23, 2, 12); return 0; } ","date":"2022-01-20","objectID":"/posts/c++%E7%9A%84%E6%A8%A1%E6%9D%BF%E5%86%99println/:2:2","tags":["C++模板"],"title":"C++变参模板运用实战——实现PrintLn","uri":"/posts/c++%E7%9A%84%E6%A8%A1%E6%9D%BF%E5%86%99println/"},{"categories":["C++实战"],"content":"方式三：可变参模板的fold expression展开 【C++17】 在C++17中，加入了一个fold expression的语法，让可变参数模板可以不通过递归的方式来解包，直接把每个包解开放入一个表达式，然后剩余的包都以该表达式解开，基本的语法如下： ((expression)op...); expression : 表示希望每个解开的参数所执行的表达式。 op : 你指定的操作符。 ... : 一直不断的解包，由于此处放的位置是右边，所以往右边解包，如果放左边则往左边解包。 示例代码： #include \u003cbits/stdc++.h\u003eusing namespace std; template\u003ctypename... Args\u003e double sum(Args... args){ return (args+...);//等价于3+23+1+3.32 } template\u003cauto... val\u003e//可变的传值的模板参数 constexpr int sum(){ return (val+...); } int main() { cout\u003c\u003csum\u003c3,23,1,32\u003e()\u003c\u003cendl;//传值模板参数不支持浮点类型，所以全用的int类型 cout\u003c\u003csum(3,23,1,3.32); return 0; } ","date":"2022-01-20","objectID":"/posts/c++%E7%9A%84%E6%A8%A1%E6%9D%BF%E5%86%99println/:3:0","tags":["C++模板"],"title":"C++变参模板运用实战——实现PrintLn","uri":"/posts/c++%E7%9A%84%E6%A8%A1%E6%9D%BF%E5%86%99println/"},{"categories":["C++实战"],"content":"简单的利用fold expr实现 基于以上对fold expr的使用，我们来正式实现PrintLn，值得一提的是，这个fold expr的性能肯定是比之前递归解包的性能要好的，因为只是迭代的拓宽而已。 我们可以将拆开的包用 ',' 展开 #include\u003ciostream\u003eusing namespace std; template\u003ctypename... Args\u003e void PrintLn(Args... args){ ((cout\u003c\u003cargs\u003c\u003c\", \"),...)\u003c\u003cendl; } int main() { PrintLn(1,2.3,\"LB\",\"hhh\"); return 0; } ","date":"2022-01-20","objectID":"/posts/c++%E7%9A%84%E6%A8%A1%E6%9D%BF%E5%86%99println/:3:1","tags":["C++模板"],"title":"C++变参模板运用实战——实现PrintLn","uri":"/posts/c++%E7%9A%84%E6%A8%A1%E6%9D%BF%E5%86%99println/"},{"categories":["C++实战"],"content":"加上流程控制实现 通过更复杂的流程控制把最后一个打印出来的逗号去掉。 通过延申三元运算符，使得运行时能够正确的打印最后一次。 反正我这里编译期只负责文本替换，所以被fold expr展开的表达式并不会有什么要是编译期常量的要求。 这一切都看作简单宏替换即可。 #include\u003ciostream\u003eusing namespace std; template\u003ctypename... Args\u003e void PrintLn(Args... args){ int lastIndex = sizeof...(args)-1;//得到传入的参数长度 int i = 0; ((i++==lastIndex?cout\u003c\u003cargs\u003c\u003cendl:cout\u003c\u003cargs\u003c\u003c\", \"),...); } int main() { PrintLn(1,2.3,\"LB\",\"hhh\"); return 0; } ","date":"2022-01-20","objectID":"/posts/c++%E7%9A%84%E6%A8%A1%E6%9D%BF%E5%86%99println/:3:2","tags":["C++模板"],"title":"C++变参模板运用实战——实现PrintLn","uri":"/posts/c++%E7%9A%84%E6%A8%A1%E6%9D%BF%E5%86%99println/"},{"categories":["C++实战"],"content":"更多fold expr运用… 利用与或表达式展开，然后利用它们的短路性质，实现得到拆包元素的精准打击（获得包里的第几个元素）。 #include\u003ciostream\u003eusing namespace std; template\u003ctypename... Args\u003e auto GetNth(int n, Args... args) { int i = 0; using CommonType = common_type_t\u003cArgs...\u003e; CommonType ret; ((i++ == n \u0026\u0026 (ret = args, true))||...); return ret; } int main() { cout \u003c\u003c GetNth(3, 2, 1, 2.3, 32.2); return 0; } 上面为了存储不确定的类型用了common_type_t，这个可以帮助你得到一个公共可用的类型，而这个类型必须是公共可用，比如int了float型可以进行相互转化所以有公共类型，而 char* 和int类型则没有，所以这个GetNth中的元素不能传递 char* 类型的同时传递int类型。 ","date":"2022-01-20","objectID":"/posts/c++%E7%9A%84%E6%A8%A1%E6%9D%BF%E5%86%99println/:3:3","tags":["C++模板"],"title":"C++变参模板运用实战——实现PrintLn","uri":"/posts/c++%E7%9A%84%E6%A8%A1%E6%9D%BF%E5%86%99println/"},{"categories":["C++实战"],"content":"”Socket基本操作的C++封装“","date":"2022-01-20","objectID":"/posts/socket%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9Cc++%E5%B0%81%E8%A3%85/","tags":["socket通信"],"title":"Socket基本操作的C++封装","uri":"/posts/socket%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9Cc++%E5%B0%81%E8%A3%85/"},{"categories":["C++实战"],"content":"封装过程 ","date":"2022-01-20","objectID":"/posts/socket%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9Cc++%E5%B0%81%E8%A3%85/:1:0","tags":["socket通信"],"title":"Socket基本操作的C++封装","uri":"/posts/socket%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9Cc++%E5%B0%81%E8%A3%85/"},{"categories":["C++实战"],"content":"接口类的实现(抽象类) _public_socket.h 该头文件用于包含所有该系统平台socket所需要依赖的库。 windows平台 #ifndef MY_TINY_STL__PUBLIC_SOCKET_H #define MY_TINY_STL__PUBLIC_SOCKET_H #include \u003cwinsock2.h\u003e#pragma comment (lib, \"ws2_32.lib\") //加载 ws2_32.dll #endif //MY_TINY_STL__PUBLIC_SOCKET_H Linux平台 #include \u003cunistd.h\u003e#include \u003carpa/inet.h\u003e#include \u003csys/socket.h\u003e#include \u003cnetinet/in.h\u003eTCP_INTERFACE.h(作用于win平台) 由于该接口由服务器端和客户端继承，而两者同样的函数成员也就是这些了，设计客户端和服务器端时就只需要考虑各自的套接字以及其余操作的成员函数，也不需要管理DLL的开关。 还有一个erro_die()成员函数用于阻断错误并打印对应情况。 // // Created by Alone on 2021/8/17. // #ifndef MY_TINY_STL_TCP_INTERFACE_H #define MY_TINY_STL_TCP_INTERFACE_H #include \u003ccstdio\u003e#include \"_public_socket.h\" class TCP_INTERFACE { public: TCP_INTERFACE() { //初始化 DLL WSADATA wsaData; WSAStartup(MAKEWORD(2, 2), \u0026wsaData); } //返回值小于等于0时发生错误 virtual int Send(SOCKET clnt, const void *buf, const int buflen) = 0; virtual int Recv(SOCKET clnt, void *buf, const int buflen) = 0; //closesocket返回值不为0则发生错误 virtual void Close(SOCKET clnt) = 0; virtual void error_die(const char *str) = 0; ~TCP_INTERFACE() { WSACleanup(); } }; #endif //MY_TINY_STL_TCP_INTERFACE_H ","date":"2022-01-20","objectID":"/posts/socket%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9Cc++%E5%B0%81%E8%A3%85/:1:1","tags":["socket通信"],"title":"Socket基本操作的C++封装","uri":"/posts/socket%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9Cc++%E5%B0%81%E8%A3%85/"},{"categories":["C++实战"],"content":"服务器端封装 这次修改了下逻辑，还是用accept返回一个套接字进行发送和接收操作比较好。类的底层没有再保留用于和某个客户端通信的套接字了，自己控制各个客户端套接字的关闭和使用。 TCP_SOCKET_SERVER.h // // Created by Alone on 2021/8/16. // #ifndef MY_TINY_STL_TCP_SOCKET_SERVER_H #define MY_TINY_STL_TCP_SOCKET_SERVER_H #include \"TCP_INTERFACE.h\" class TCP_SOCKET_SERVER : public TCP_INTERFACE { public: TCP_SOCKET_SERVER(); ~TCP_SOCKET_SERVER(); void Bind(int port); void Listen(); SOCKET Accept(); int Send(SOCKET clnt, const void *buf, const int buflen); int Recv(SOCKET clnt, void *buf, const int buflen); void Close(SOCKET clnt); void error_die(const char *str); private: SOCKET servSock; sockaddr_in sockAddr; }; #endif //MY_TINY_STL_TCP_SOCKET_SERVER_H TCP_SOCKET_SERVER.cpp // // Created by Alone on 2021/8/16. // #include \"TCP_SOCKET_SERVER.h\" //初始化操作 TCP_SOCKET_SERVER::TCP_SOCKET_SERVER() : servSock(0) { memset(\u0026sockAddr, 0, sizeof(sockAddr)); //每个字节都用0填充 } //绑定操作 void TCP_SOCKET_SERVER::Bind(int port) { servSock = socket(PF_INET, SOCK_STREAM, IPPROTO_TCP); sockAddr.sin_family = PF_INET; //使用IPv4地址 sockAddr.sin_addr.s_addr = htonl(INADDR_ANY); //具体的IP地址 sockAddr.sin_port = htons(port); //端口 if (bind(servSock, (SOCKADDR *) \u0026sockAddr, sizeof(SOCKADDR)) != 0) { error_die(\"bind\"); } } //置于监听状态 void TCP_SOCKET_SERVER::Listen() { if (servSock == 0) error_die(\"listen\"); if (listen(servSock, SOMAXCONN) != 0) { error_die(\"listen\"); } } //利用套接字的监听串口，接收客户端的请求，建立新的套接字进行存储信息 SOCKET TCP_SOCKET_SERVER::Accept() { SOCKADDR t; int nSize = sizeof(SOCKADDR); //后面两个参数为可选 SOCKET clnt = accept(servSock, \u0026t, \u0026nSize); if (clnt \u003c= 0)error_die(\"accept\"); return clnt; } //返回的是发送到缓冲区的字节长度 int TCP_SOCKET_SERVER::Send(SOCKET clnt, const void *buf, const int buflen) { return send(clnt, (const char *) buf, buflen, 0); } //返回已经接收的字节长度 int TCP_SOCKET_SERVER::Recv(SOCKET clnt, void *buf, const int buflen) { return recv(clnt, (char *) buf, buflen, 0); } //析构函数关闭socket TCP_SOCKET_SERVER::~TCP_SOCKET_SERVER() { if (servSock != 0)closesocket(servSock); } void TCP_SOCKET_SERVER::Close(SOCKET clnt) { if (closesocket(clnt) != 0) { error_die(\"closesocket\"); } } void TCP_SOCKET_SERVER::error_die(const char *str) { printf(\"[hint]%s failed:%d\", str, WSAGetLastError()); exit(-1); } ","date":"2022-01-20","objectID":"/posts/socket%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9Cc++%E5%B0%81%E8%A3%85/:1:2","tags":["socket通信"],"title":"Socket基本操作的C++封装","uri":"/posts/socket%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9Cc++%E5%B0%81%E8%A3%85/"},{"categories":["C++实战"],"content":"客户端的封装 TCP_SOCKET_CLIENT.h 增加了利用域名查询ip地址的成员函数gethostbyname(),挺好玩的！此次增加了erro_die函数，且发送和接收都操作套接字。在类的内部还是保留了套接字的备份，用于忘记关闭套接字时，析构函数进行关闭。 // // Created by Alone on 2021/8/18. // #ifndef MY_TINY_STL_TCP_SOCKET_CLIENT_H #define MY_TINY_STL_TCP_SOCKET_CLIENT_H #include \"TCP_INTERFACE.h\"#include \u003ciostream\u003e class TCP_SOCKET_CLIENT : public TCP_INTERFACE { public: TCP_SOCKET_CLIENT(); ~TCP_SOCKET_CLIENT(); SOCKET Connect(const char *IPAdrr, u_short port); //用于利用URL(域名)查询IP地址 void Gethostbyname(const char *URL); //接口必须实现的函数 int Send(SOCKET clnt,const void *buf, const int bufSize); int Recv(SOCKET clnt,void *buf, const int bufSize); void Close(SOCKET clnt); void error_die(const char *str); private: //由于一般客户端只需要一个套接字实现连接,然后还需要一个socketadrr_in用于连接内容的赋值 SOCKET clntSock; sockaddr_in sockAddr; }; #endif //MY_TINY_STL_TCP_SOCKET_CLIENT_H TCP_SOCKET_CLIENT.cpp // // Created by Alone on 2021/8/17. // #include \"TCP_SOCKET_CLIENT.h\" //初始化 TCP_SOCKET_CLIENT::TCP_SOCKET_CLIENT() : clntSock(0) {} //关闭套接字操作 void TCP_SOCKET_CLIENT::Close(SOCKET clnt) { if (closesocket(clnt) != 0) error_die(\"close\"); clntSock = 0; } //连接服务器操作 SOCKET TCP_SOCKET_CLIENT::Connect(const char *IPAdrr, u_short port) { memset(\u0026sockAddr, 0, sizeof sockAddr); clntSock = socket(PF_INET, SOCK_STREAM, IPPROTO_TCP); sockAddr.sin_family = PF_INET; sockAddr.sin_addr.s_addr = inet_addr(IPAdrr); sockAddr.sin_port = htons(port); if (connect(clntSock, (SOCKADDR *) \u0026sockAddr, sizeof(sockAddr)) != 0) { error_die(\"connect\"); } return clntSock; } //发送信息操作 int TCP_SOCKET_CLIENT::Send(SOCKET clnt,const void *buf, const int bufSize) { return send(clnt, (const char *) buf, bufSize, 0); } //接收信息操作 int TCP_SOCKET_CLIENT::Recv(SOCKET clnt,void *buf, const int bufSize) { return recv(clnt, (char *) buf, bufSize, 0); } //根据域名获取ip地址等信息 void TCP_SOCKET_CLIENT::Gethostbyname(const char *URL) { hostent *host = gethostbyname(URL); if (!host) { std::cout \u003c\u003c \"Get IP address error!\\n\"; return; } //打印本命 std::cout \u003c\u003c URL \u003c\u003c std::endl; //别名 for (int i = 0; host-\u003eh_aliases[i]; i++) { printf(\"Aliases %d: %s\\n\", i + 1, host-\u003eh_aliases[i]); } //地址类型 printf(\"Address type: %s\\n\", (host-\u003eh_addrtype == AF_INET) ? \"AF_INET\" : \"AF_INET6\"); //IP地址,其中inet_ntoa()函数是将网络字节序转为本地的字节序，方便打印看懂 for (int i = 0; host-\u003eh_addr_list[i]; i++) { printf(\"IP addr %d: %s\\n\", i + 1, inet_ntoa(*(struct in_addr *) host-\u003eh_addr_list[i])); } } //析构时需要确保所有东西已经关闭 TCP_SOCKET_CLIENT::~TCP_SOCKET_CLIENT() { if (clntSock != 0) closesocket(clntSock); } void TCP_SOCKET_CLIENT::error_die(const char *str) { printf(\"[hint]%s failed:%d\", str, WSAGetLastError()); exit(-1); } ","date":"2022-01-20","objectID":"/posts/socket%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9Cc++%E5%B0%81%E8%A3%85/:1:3","tags":["socket通信"],"title":"Socket基本操作的C++封装","uri":"/posts/socket%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9Cc++%E5%B0%81%E8%A3%85/"},{"categories":["C++实战"],"content":"实例讲解 ","date":"2022-01-20","objectID":"/posts/socket%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9Cc++%E5%B0%81%E8%A3%85/:2:0","tags":["socket通信"],"title":"Socket基本操作的C++封装","uri":"/posts/socket%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9Cc++%E5%B0%81%E8%A3%85/"},{"categories":["C++实战"],"content":"实例一：回声程序通信 服务器回声程序 绑定本地1234端口，进入监听状态等待请求，如果通信对象关闭了通信，也不慌，重新goto到等待请求得到新的通信套接字 #include \u003ciostream\u003e#include \"TCP_SOCKET_SERVER.h\" #define BUF_SIZE 1000 using namespace std; int main() { TCP_SOCKET_SERVER a; a.Bind(1234); a.Listen(); restart: SOCKET clnt = a.Accept(); while (1) { char *x = new char[BUF_SIZE]; memset(x, 0, BUF_SIZE); int size = a.Recv(clnt,x, BUF_SIZE); if (size \u003c= 0) break; if (a.Send(clnt,x, size) \u003c= 0) break; } a.Close(clnt); cout \u003c\u003c \"connect is over.Waiting for a new connection!\\n\"; goto restart; } 客户端通信程序 为保持持续通信，一旦客户端拒绝了请求，那么弹出循环重新连接，并设置连接超时操作。 #include \"TCP_SOCKET_CLIENT.h\"#define BUF_SIZE 100 int main(){ TCP_SOCKET_CLIENT t; const char* to = \"127.0.0.1\"; restart: SOCKET clnt = t.Connect(to,1234); while(1){ std::cout\u003c\u003c\"\\nInput your message:\\n\"; char buf[BUF_SIZE] = {0}; std::cin.getline(buf,99); int size = t.Send(clnt,buf,BUF_SIZE); if(size\u003c=0) break; memset(buf,0,sizeof buf); if(t.Recv(clnt,buf,size)\u003c=0) break; printf(\"received from %s is:\\n\",to); std::cout\u003c\u003cbuf; } t.Close(clnt); std::cout\u003c\u003c\"The Server is disconnected,and socket has been cleaned up,socket connection has been re-established\\n\"; goto restart; return 0; } 回声效果 客户端收到的结果 服务器端一直运行着，只要不关闭，但每次只能和一个客户端进行通信，通信完后重新等待连接。 ","date":"2022-01-20","objectID":"/posts/socket%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9Cc++%E5%B0%81%E8%A3%85/:2:1","tags":["socket通信"],"title":"Socket基本操作的C++封装","uri":"/posts/socket%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9Cc++%E5%B0%81%E8%A3%85/"},{"categories":["C++实战"],"content":"实例二：文件操作，传送图片(掌握重复传包) 分析待传图片 看看这百万大小的字节，一次肯定是传不完的，所以我们需要发送端不断的续传，直到传送完毕。 发送端程序 #include \"TCP_SOCKET_CLIENT.h\"#include \u003cfstream\u003eint main(){ TCP_SOCKET_CLIENT t; const char* to = \"127.0.0.1\"; restart: SOCKET clnt = t.Connect(to,1234); //图片写入buf(这几百万字节大小，得亏是new动态分配 std::ifstream img(\"D:/DesktopBackground/L-69.png\",std::ios::in|std::ios::binary); //设置文件指针用于求文件内容长度 img.seekg(0,std::ios::end); int len = img.tellg(); img.seekg(0,std::ios::beg); if(len\u003e0){printf(\"read OK\\n\");} else {printf(\"file is empty!\");return 0;} //填补buf char * buf = new char[len]; img.read(buf,len); //发送数据到服务器,一次肯定发送不完，所以多次 int sum = 0; while(sum\u003clen){ int sendlen = t.Send(clnt,buf,len); if(sendlen\u003c=0){ printf(\"Send Erro!\"); return 0; } sum += sendlen; } t.Close(clnt); printf(\"Send OK!\"); return 0; } 接收端程序 #include \u003ciostream\u003e#include \"TCP_SOCKET_SERVER.h\"#include \u003cfstream\u003e#define BUF_SIZE 100 using namespace std; int main() { TCP_SOCKET_SERVER a; a.Bind(1234); a.Listen(); //等待连接，连接成功便可建立通讯 SOCKET clnt = a.Accept(); //创建文件用于写入图片数据 ofstream t(\"test.png\",ios::binary|ios::out); //由于要接收的图片文件较大，需要分多次包进行传输数据，所以需要不断循环接收 while(1){ char buf[BUF_SIZE]; int sz = a.Recv(clnt,buf,BUF_SIZE); //直到发送端发送数据完毕断开连接后，便可判断为接收完毕 if(sz\u003c=0){ cout\u003c\u003c\"Finish !\"; return 0; } //每次调整文件指针位置到最后续写 t.seekp(0,ios::end); t.write(buf,sz); } a.Close(clnt); } 接收结果 一模一样毫无偏差 ","date":"2022-01-20","objectID":"/posts/socket%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9Cc++%E5%B0%81%E8%A3%85/:2:2","tags":["socket通信"],"title":"Socket基本操作的C++封装","uri":"/posts/socket%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9Cc++%E5%B0%81%E8%A3%85/"},{"categories":["C++实战"],"content":"实例三：Web通信(浏览器访问服务器) ","date":"2022-01-20","objectID":"/posts/socket%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9Cc++%E5%B0%81%E8%A3%85/:3:0","tags":["socket通信"],"title":"Socket基本操作的C++封装","uri":"/posts/socket%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9Cc++%E5%B0%81%E8%A3%85/"},{"categories":["C++实战"],"content":"Web服务器程序 我这个web服务器也算是及其简单了。。并没有对客户端的http请求进行解析然后发送对应的文件给客户端，而是单纯的我客户端想怎么发就怎么发。。另外这个程序虽然是对图片进行了判断，但并未写出对应的图片发送程序(二进制文件读写是不一样的)，所以实际只能发送文本文件，如html代码。所以后面看到的课程表都无法显示图片的原因是客户端程序压根就没在乎过客户端的请求🤣 #include \u003ciostream\u003e#include \u003cfstream\u003e#include \"TCP_SOCKET_SERVER.h\" void sendfileToWeb(SOCKET clnt, TCP_SOCKET_SERVER \u0026a, const char *filename); int main() { TCP_SOCKET_SERVER a; a.Bind(8086); a.Listen(); SOCKET clnt = a.Accept(); while (1) { sendfileToWeb(clnt, a, \"D:/Html/schedule/schedule.html\"); a.Close(clnt); clnt = a.Accept(); } } //反馈请求，发送文件代码或者图片等二进制信息。 void sendfileToWeb(SOCKET clnt, TCP_SOCKET_SERVER \u0026a, const char *filename) { //写入返回头信息：包括状态和内容类型 char *type = nullptr; if (strstr(filename, \".html\")) type = \"text/html\"; else if (strstr(filename, \".jpg\")) type = \"image/jpg\"; else if (strstr(filename, \".png\")) type = \"image/png\"; char x[100] = {0}; sprintf(x, \"HTTP/1.1 200 ok\\r\\nContent-Type: %s\\r\\n\\r\\n\", type); //发送返回头信息,每次发送间隔需要一定时间，否则浏览器可能接收没这么快 int sz1 = a.Send(clnt, x, strlen(x)); if (sz1 \u003c= 0)return; //发送文件内容到客户端 std::ifstream ss(filename, std::ios::in); char html[1024] = {0}; while (ss.getline(html, 1024)) { int szz = a.Send(clnt, html, strlen(html)); if (szz \u003c= 0) return; Sleep(1); } ss.close(); } ","date":"2022-01-20","objectID":"/posts/socket%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9Cc++%E5%B0%81%E8%A3%85/:3:1","tags":["socket通信"],"title":"Socket基本操作的C++封装","uri":"/posts/socket%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9Cc++%E5%B0%81%E8%A3%85/"},{"categories":["C++实战"],"content":"接收结果 ","date":"2022-01-20","objectID":"/posts/socket%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9Cc++%E5%B0%81%E8%A3%85/:3:2","tags":["socket通信"],"title":"Socket基本操作的C++封装","uri":"/posts/socket%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9Cc++%E5%B0%81%E8%A3%85/"},{"categories":["C++实战"],"content":"总结 收获： 了解到网络通讯过程到底是怎么样的。 了解到底层socket通信是如何进行的。 封装了socket操作，增强了代码的复用性。 对基本的http请求过程有所了解： 基本上就是浏览器(客户端)对相应的IP地址发起请求，其对应的服务器返回给你这个网页的主页，然后根据你鼠标的点击，又会触发http请求，其对应的服务器对你的请求进行解析，得出你想要的文件，然后发送给你，循环往复一直如此。。。 ","date":"2022-01-20","objectID":"/posts/socket%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9Cc++%E5%B0%81%E8%A3%85/:4:0","tags":["socket通信"],"title":"Socket基本操作的C++封装","uri":"/posts/socket%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9Cc++%E5%B0%81%E8%A3%85/"},{"categories":["C++实战"],"content":"”简单学习下基本的类封装“","date":"2022-01-20","objectID":"/posts/%E5%A4%A7%E6%95%B4%E6%95%B0%E5%8A%A0%E5%87%8F/","tags":["C++类的封装"],"title":"大数加减类的实现(C++实现)✨","uri":"/posts/%E5%A4%A7%E6%95%B4%E6%95%B0%E5%8A%A0%E5%87%8F/"},{"categories":["C++实战"],"content":"为什么需要大数加减类？ 对于计算机而言，基本的数据类型一般最多为64位数据表示范围，这个范围是有限的，没法无限的表示所有的数据，那么有没有一种方式能够表示所有的大数，并完成加减乘除呢？ 答案肯定是有的，由于数据都是由一位一位的数字所组成，我们只需要用数组中的每一位表示一位数字，便可完成对大数的模拟了。 那么我们说明时候需要用到大数模拟呢？对竞赛人而言，有很多题目实际上就是高精度大数模拟类型，而对于普通的程序员而言，大数模拟也仅是在做某个逻辑运算而保证不会溢出的最佳策略，那么大家难道不好奇如何实现一个大数模拟类吗？ 现在就从封装一个简单的加减类开始了解这样一个大数模拟是怎么实现的👀 ","date":"2022-01-20","objectID":"/posts/%E5%A4%A7%E6%95%B4%E6%95%B0%E5%8A%A0%E5%87%8F/:1:0","tags":["C++类的封装"],"title":"大数加减类的实现(C++实现)✨","uri":"/posts/%E5%A4%A7%E6%95%B4%E6%95%B0%E5%8A%A0%E5%87%8F/"},{"categories":["C++实战"],"content":"大数加减类实现详解 ","date":"2022-01-20","objectID":"/posts/%E5%A4%A7%E6%95%B4%E6%95%B0%E5%8A%A0%E5%87%8F/:2:0","tags":["C++类的封装"],"title":"大数加减类的实现(C++实现)✨","uri":"/posts/%E5%A4%A7%E6%95%B4%E6%95%B0%E5%8A%A0%E5%87%8F/"},{"categories":["C++实战"],"content":"一、流程图总览 如图总体来说分为五部分： 静态成员函数：属于类的公共接口(核心) 构造和析构函数：构造对象以及析构对象 成员数据：用于运算的数据以及表示对象的数据 运算符重载：用于自定义运算方式(核心) 内部成员函数：属于对象的公共接口 ","date":"2022-01-20","objectID":"/posts/%E5%A4%A7%E6%95%B4%E6%95%B0%E5%8A%A0%E5%87%8F/:2:1","tags":["C++类的封装"],"title":"大数加减类的实现(C++实现)✨","uri":"/posts/%E5%A4%A7%E6%95%B4%E6%95%B0%E5%8A%A0%E5%87%8F/"},{"categories":["C++实战"],"content":"二、成员数据和构造函数详解 成员数据 bool f; //是否是负数的标记 char *nums; //存储非符号的大数各个位 int length; //nums的数据长度 int capacity; //nums的可用容量 构造和析构 //缺省构造函数 BigInteger() : length(0), capacity(1), f(false) { nums = new char[capacity]; } //用于转化普通字符串的构造函数 BigInteger(const char *n) : length(strlen(n)), f(false) { int start = 0; if (n[0] == '-') { f = true; start++; } while (start\u003clength\u0026\u0026n[start] == '0')start++; capacity = length * 10; nums = new char[capacity]; std::copy(n + start, n + length, nums); length = length - start; } //拷贝构造函数 BigInteger(BigInteger \u0026a) { capacity = a.capacity; length = a.length; f = a.f; nums = new char[capacity]; std::copy(a.nums, a.nums + length, nums); } //移动构造函数：这里调用了等于号，根据a的类型来决定用哪个等于号 BigInteger(BigInteger \u0026\u0026a) :length(0){ *this = a; } //析构函数 ~BigInteger() { delete[] nums; } ","date":"2022-01-20","objectID":"/posts/%E5%A4%A7%E6%95%B4%E6%95%B0%E5%8A%A0%E5%87%8F/:2:2","tags":["C++类的封装"],"title":"大数加减类的实现(C++实现)✨","uri":"/posts/%E5%A4%A7%E6%95%B4%E6%95%B0%E5%8A%A0%E5%87%8F/"},{"categories":["C++实战"],"content":"三、(算法核心)静态成员函数和运算符重载详解 static Swap() //调用std的swap实现对基本数据的交换 static void Swap(BigInteger \u0026a, BigInteger \u0026b) { std::swap(a.length, b.length); std::swap(a.capacity, b.capacity); std::swap(a.f, b.f); std::swap(a.nums, b.nums); } static compare() //不看符号比较nums的大小：表示a是否比b大 static bool compare(const BigInteger \u0026a,const BigInteger \u0026b) { //比较纯nums大小(不看符号 int n1 = a.length; int n2 = b.length; if (n1 != n2)return n1 \u003e n2; //返回a和b哪个大，true则位a大 int i = 0; while (i \u003c n1 \u0026\u0026 a.nums[i] == b.nums[i])i++; //a b一样长的情况下，比较两个的值 if (i == n1) return false; return a.nums[i] \u003e b.nums[i]; } static isEqual() //表示a和b是否相等 bool isEqual(BigInteger \u0026a, BigInteger \u0026b) { if (a.f != b.f || (a.length != b.length))return false; int i = 0; while (i \u003c a.length \u0026\u0026 a.nums[i] == b.nums[i])i++; return i == a.length \u0026\u0026 a.f == b.f; } (*核心算法)static add() 不看符号的加法，符号这方面由重载加法运算符控制。 static BigInteger add(BigInteger \u0026a, BigInteger \u0026b) { //不看符号的加法 a.reverse();//尾端对齐 b.reverse(); BigInteger t; int up = 0; int len = a.length \u003e b.length ? a.length : b.length; for (int i = 0; i \u003c len; i++) { int ta = i \u003c a.length ? a[i] - '0' : 0; int tb = i \u003c b.length ? b[i] - '0' : 0; int base = ta + tb + up; t.push_back(base % 10 + '0'); up = base / 10; } if (up) t.push_back(up + '0'); t.reverse();//返回原位 a.reverse(); b.reverse(); return t; } (*核心算法)static minus() 不看符号的减法,默认了a的nums大小(不看符号)是比b大的。 static BigInteger minus(BigInteger \u0026a, BigInteger \u0026b) { a.reverse(); b.reverse(); BigInteger t; int len = a.length \u003e b.length ? a.length : b.length; for (int i = 0; i \u003c len; i++) { int ta = i \u003c a.length ? a[i] - '0' : 0; int tb = i \u003c b.length ? b[i] - '0' : 0; int base = ta - tb; if (base \u003c 0) { base += 10; a[i + 1]--; } t.push_back(base + '0'); } t.reverse(); a.reverse(); b.reverse(); return t; } char \u0026operator[] char \u0026operator[](int i) { return nums[i]; } BigInteger \u0026operator= 用了两个版本–右值引用和左值引用版本 右值引用延长寿命，用交换的方式实现(毕竟是将亡值 BigInteger \u0026operator=(BigInteger\u0026\u0026 a) { //Swap\u0026Copy方式实现右值赋值重载 Swap(*this, a); return *this; } 左值引用深拷贝 BigInteger \u0026operator=(const BigInteger \u0026a) {//深拷贝 if (length != 0)//如果不是初始化调用的 = ，则肯定需要先把原来的内存delete掉 delete[]nums; capacity = a.capacity; length = a.length; f = a.f; nums = new char[capacity]; std::copy(a.nums, a.nums + length, nums); return *this; } bool operator\u003c 重载了小于号，好处在于可以直接利用stl进行各种排序操作了。 注意：一定要写成const版本的成员函数，不然STL库无法调用，因为STL库中的所有比较都是基于const对象。 bool operator\u003c(const BigInteger \u0026a) const { if (f \u0026\u0026 !a.f) { //其中一个为负数，则那个是更小的 return true; } else if (!f \u0026\u0026 a.f) return false; if (f) { //两者都为负数的情况，左边的值要更大则为true return compare(*this, a); }//两者均为正数，则值更小的在左边为true return compare(a, *this); } (*核心算法)BigInteger operator+ 利用静态成员函数完成无符号的加减，然后在这里进行判断各种符号情况，根据不同的符号情况进行不同的加法处理。 注意在调用minus之前需要比较两个数的nums谁更大，更大的放在第一个参数上！ BigInteger operator+(BigInteger \u0026a) { BigInteger res; bool flag; if (a.f \u0026\u0026 f) { //同为负数情况，直接相加，再改符号 res = add(*this, a); flag = true; } else if (a.f \u0026\u0026 !f) {//左正右负 if (compare(a, *this)) { //看负数对应的nums是否比正数大 flag = true; res = minus(a, *this); } else { flag = false; res = minus(*this, a); } } else if (!a.f \u0026\u0026 f) { if (compare(*this, a)) { //与上一个相同 flag = true; res = minus(*this, a); } else { flag = false; res = minus(a, *this); } } else { //同时为正数就是最简单的加法 flag = false; res = add(*this, a); } res.f = flag; return res; } (*核心算法)BigInteger operator- 同样是分类讨论，同样是根据不同的类型调用minus和add函数。 与正数不同的处理在于对符号的处理，如果同为负数，则需要判断两者是否相等，防止两数相等相减后减为 0，而被处理为 -0 。 BigInteger operator-(BigInteger \u0026a) { BigInteger res; bool flag; if (a.f \u0026\u0026 f) { //同为负数情况--左边-右边==(不看符号)右边-(不看符号)左边 if (compare(a, *this)) { flag = false; res = minus(a, *this); } else { if (isEqual(*this, a)) flag = false; else flag = true; res = minus(*this, a); } } else if (a.f \u0026\u0026 !f) { //左边为正，右边为负--左边-右边==左边+右边 flag = false; res = add(a, *this); } else if (!a.f \u0026\u0026 f) { //右边为正，左边为负--左边-右边==两边为负的加法 flag = true; res = add(a, *this); } else { //同时为正数--左边-右边==左边-右边(分类讨论正负 if (compare(a, *this)) { //右边\u003e左边,符号为负 res = minus(a, *this); flag = true; } else { //右边\u003c左边，符号为正 res = minus(*this, a); flag = false; } } res.f = flag; return res; } ","date":"2022-01-20","objectID":"/posts/%E5%A4%A7%E6%95%B4%E6%95%B0%E5%8A%A0%E5%87%8F/:2:3","tags":["C++类的封装"],"title":"大数加减类的实现(C++实现)✨","uri":"/posts/%E5%A4%A7%E6%95%B4%E6%95%B0%E5%8A%A0%E5%87%8F/"},{"categories":["C++实战"],"content":"四、其他内部成员函数详解 向外提供的get接口 int getCap() { return capacity; } int getLength() { return length; } bool isNegative() { return f; } bool isEmpty() { return length == 0; } 进行赋值操作所必备的push_back和reverse函数 void push_back(char x) { if (length \u003e= capacity) {//扩容操作 capacity *= 2; char *t = nums; nums = new char[capacity]; std::copy(t, t + length, nums); delete[]t; } nums[length++] = x; } void reverse() {//反转操作 int l = 0, r = length - 1; while (l \u003c r) { std::swap(nums[l], nums[r]); l++; r--; } } 无关紧要的 read() 输入接口 和 print() 输出测试接口 void print() { if (f) printf(\"-\"); nums[length] = '\\0'; int i = 0; while (nums[i] == '0')i++; printf(\"%s\", nums + i); } void read() {//利用getchar()给对象赋上数据 char c = getchar(); if (c == '-') { f = true; c = getchar(); } while (c == '0') c = getchar();//将前导0消耗掉 while (c != '\\n') { push_back(c);//不断的调用push_back即可 c = getchar(); } } ","date":"2022-01-20","objectID":"/posts/%E5%A4%A7%E6%95%B4%E6%95%B0%E5%8A%A0%E5%87%8F/:2:4","tags":["C++类的封装"],"title":"大数加减类的实现(C++实现)✨","uri":"/posts/%E5%A4%A7%E6%95%B4%E6%95%B0%E5%8A%A0%E5%87%8F/"},{"categories":["C++实战"],"content":"整理代码 ","date":"2022-01-20","objectID":"/posts/%E5%A4%A7%E6%95%B4%E6%95%B0%E5%8A%A0%E5%87%8F/:3:0","tags":["C++类的封装"],"title":"大数加减类的实现(C++实现)✨","uri":"/posts/%E5%A4%A7%E6%95%B4%E6%95%B0%E5%8A%A0%E5%87%8F/"},{"categories":["C++实战"],"content":".h声明文件 如果在声明类的同时进行定义，则内部的成员函数默认就是内联的。所以我们一般把短小的代码进行内联，以下的实现均是以该规律进行。 // // Created by Alone on 2021/10/7. // #ifndef MY_TINY_STL_BIGINTEGER_H #define MY_TINY_STL_BIGINTEGER_H #include \u003calgorithm\u003e#include \u003ciostream\u003e#include \u003ccstring\u003e class BigInteger { bool f; char *nums; int length; int capacity; public: //构造函数 BigInteger() : length(0), capacity(1), f(false) { //缺省构造函数 nums = new char[capacity]; } BigInteger(const char *n); BigInteger(const BigInteger \u0026a); BigInteger(BigInteger \u0026\u0026a); ~BigInteger() { //析构函数 delete[] nums; } public: //静态函数 static void Swap(BigInteger \u0026a, BigInteger \u0026b); static bool compare(const BigInteger \u0026a, const BigInteger \u0026b); bool isEqual(BigInteger \u0026a, BigInteger \u0026b); static BigInteger add(BigInteger \u0026a, BigInteger \u0026b); static BigInteger minus(BigInteger \u0026a, BigInteger \u0026b); public: //运算符重载 char \u0026operator[](int i) { return nums[i]; } BigInteger \u0026operator=(BigInteger \u0026\u0026a) { //Swap\u0026Copy方式实现右值赋值重载 Swap(*this, a); return *this; } BigInteger \u0026operator=(const BigInteger \u0026a); bool operator\u003c(const BigInteger \u0026a) const; BigInteger operator+(BigInteger \u0026a); BigInteger operator-(BigInteger \u0026a); public: //对象的基本成员函数 int getCap() { return capacity; } int getLength() { return length; } bool isNegative() { return f; } bool isEmpty() { return length == 0; } void reverse(); void push_back(char x); void print(); void read(); }; #endif //MY_TINY_STL_BIGINTEGER_H ","date":"2022-01-20","objectID":"/posts/%E5%A4%A7%E6%95%B4%E6%95%B0%E5%8A%A0%E5%87%8F/:3:1","tags":["C++类的封装"],"title":"大数加减类的实现(C++实现)✨","uri":"/posts/%E5%A4%A7%E6%95%B4%E6%95%B0%E5%8A%A0%E5%87%8F/"},{"categories":["C++实战"],"content":".cpp定义并实现 // // Created by Alone on 2021/10/7. // #include \"BigInteger.h\" //@构造函数实现 BigInteger::BigInteger(const char *n) : length(strlen(n)), f(false) { //用于初始值的构造函数 int start = 0; if (n[0] == '-') { f = true; start++; } while (start \u003c length \u0026\u0026 n[start] == '0')start++; capacity = length * 10; nums = new char[capacity]; std::copy(n + start, n + length, nums); length = length - start; } BigInteger::BigInteger(const BigInteger \u0026a) { //拷贝构造函数 capacity = a.capacity; length = a.length; f = a.f; nums = new char[capacity]; std::copy(a.nums, a.nums + length, nums); } BigInteger::BigInteger(BigInteger \u0026\u0026a) : length(0) { //移动构造函数 *this = a; } //@静态函数实现 void BigInteger::Swap(BigInteger \u0026a, BigInteger \u0026b) { std::swap(a.length, b.length); std::swap(a.capacity, b.capacity); std::swap(a.f, b.f); std::swap(a.nums, b.nums); } bool BigInteger::compare(const BigInteger \u0026a, const BigInteger \u0026b) { int n1 = a.length; int n2 = b.length; if (n1 != n2)return n1 \u003e n2; //返回a和b哪个大，true则位a大 int i = 0; while (i \u003c n1 \u0026\u0026 a.nums[i] == b.nums[i])i++; //a b一样长的情况下，比较两个的值 if (i == n1) return false; return a.nums[i] \u003e b.nums[i]; } bool BigInteger::isEqual(BigInteger \u0026a, BigInteger \u0026b) { if (a.f != b.f || (a.length != b.length))return false; int i = 0; while (i \u003c a.length \u0026\u0026 a.nums[i] == b.nums[i])i++; return i == a.length \u0026\u0026 a.f == b.f; } BigInteger BigInteger::add(BigInteger \u0026a, BigInteger \u0026b) { a.reverse();//尾端对齐 b.reverse(); BigInteger t; int up = 0; int len = a.length \u003e b.length ? a.length : b.length; for (int i = 0; i \u003c len; i++) { int ta = i \u003c a.length ? a[i] - '0' : 0; int tb = i \u003c b.length ? b[i] - '0' : 0; int base = ta + tb + up; t.push_back(base % 10 + '0'); up = base / 10; } if (up) t.push_back(up + '0'); t.reverse();//返回原位 a.reverse(); b.reverse(); return t; } BigInteger BigInteger::minus(BigInteger \u0026a, BigInteger \u0026b) { a.reverse(); b.reverse(); BigInteger t; int len = a.length \u003e b.length ? a.length : b.length; for (int i = 0; i \u003c len; i++) { int ta = i \u003c a.length ? a[i] - '0' : 0; int tb = i \u003c b.length ? b[i] - '0' : 0; int base = ta - tb; if (base \u003c 0) { base += 10; a[i + 1]--; } t.push_back(base + '0'); } t.reverse(); a.reverse(); b.reverse(); return t; } //@运算符重载实现 BigInteger \u0026BigInteger::operator=(const BigInteger \u0026a) { if (length != 0)//如果不是初始化调用的 = ，则肯定需要先把原来的内存delete掉 delete[]nums; capacity = a.capacity; length = a.length; f = a.f; nums = new char[capacity]; std::copy(a.nums, a.nums + length, nums); return *this; } BigInteger BigInteger::operator+(BigInteger \u0026a) { BigInteger res; bool flag; if (a.f \u0026\u0026 f) { //同为负数情况，直接相加，再改符号 res = add(*this, a); flag = true; } else if (a.f \u0026\u0026 !f) {//左正右负 if (compare(a, *this)) { //看负数对应的nums是否比正数大 flag = true; res = minus(a, *this); } else { flag = false; res = minus(*this, a); } } else if (!a.f \u0026\u0026 f) { if (compare(*this, a)) { //与上一个相同 flag = true; res = minus(*this, a); } else { flag = false; res = minus(a, *this); } } else { //同时为正数就是最简单的加法 flag = false; res = add(*this, a); } res.f = flag; return res; } BigInteger BigInteger::operator-(BigInteger \u0026a) { BigInteger res; bool flag; if (a.f \u0026\u0026 f) { //同为负数情况--左边-右边==(不看符号)右边-(不看符号)左边 if (compare(a, *this)) { flag = false; res = minus(a, *this); } else { if (isEqual(*this, a)) flag = false; else flag = true; res = minus(*this, a); } } else if (a.f \u0026\u0026 !f) { //左边为正，右边为负--左边-右边==左边+右边 flag = false; res = add(a, *this); } else if (!a.f \u0026\u0026 f) { //右边为正，左边为负--左边-右边==两边为负的加法 flag = true; res = add(a, *this); } else { //同时为正数--左边-右边==左边-右边(分类讨论正负 if (compare(a, *this)) { //右边\u003e左边,符号为负 res = minus(a, *this); flag = true; } else { //右边\u003c左边，符号为正 res = minus(*this, a); flag = false; } } res.f = flag; return res; } bool BigInteger::operator\u003c(const BigInteger \u0026a) const { if (f \u0026\u0026 !a.f) { //其中一个为负数，则那个是更小的 return true; } else if (!f \u0026\u0026 a.f) return false; if (f) { //两者都为负数的情况，左边的值要更大则为true return compare(*this, a); }//两者均为正数，则值更小的在左边为true return compare(a, *this); } //@基本成员函数 void BigInteger::reverse() { int l = 0, r = length - 1; while (l \u003c r) { std::swap(nums[l], nums[r]); l++","date":"2022-01-20","objectID":"/posts/%E5%A4%A7%E6%95%B4%E6%95%B0%E5%8A%A0%E5%87%8F/:3:2","tags":["C++类的封装"],"title":"大数加减类的实现(C++实现)✨","uri":"/posts/%E5%A4%A7%E6%95%B4%E6%95%B0%E5%8A%A0%E5%87%8F/"},{"categories":["C++实战"],"content":"功能测试 ","date":"2022-01-20","objectID":"/posts/%E5%A4%A7%E6%95%B4%E6%95%B0%E5%8A%A0%E5%87%8F/:4:0","tags":["C++类的封装"],"title":"大数加减类的实现(C++实现)✨","uri":"/posts/%E5%A4%A7%E6%95%B4%E6%95%B0%E5%8A%A0%E5%87%8F/"},{"categories":["C++实战"],"content":"一、基本的加减测试 运行的测试代码： 打印输出 python输出 总结 与python输出无异，故通过测试。但碍于测试数据太过少，不是很有说服力，还有后面的解题测试。 ","date":"2022-01-20","objectID":"/posts/%E5%A4%A7%E6%95%B4%E6%95%B0%E5%8A%A0%E5%87%8F/:4:1","tags":["C++类的封装"],"title":"大数加减类的实现(C++实现)✨","uri":"/posts/%E5%A4%A7%E6%95%B4%E6%95%B0%E5%8A%A0%E5%87%8F/"},{"categories":["C++实战"],"content":"二、存储个人输入的数据+排序测试 测试代码(方便测试只输入了10个数据)： 排序输出： ","date":"2022-01-20","objectID":"/posts/%E5%A4%A7%E6%95%B4%E6%95%B0%E5%8A%A0%E5%87%8F/:4:2","tags":["C++类的封装"],"title":"大数加减类的实现(C++实现)✨","uri":"/posts/%E5%A4%A7%E6%95%B4%E6%95%B0%E5%8A%A0%E5%87%8F/"},{"categories":["C++实战"],"content":"三、解题测试 正好最近刷的PAT甲级就涉及到大数的加减hhh！ 题目描述 OJ平台 解题代码 #include \"bits/stdc++.h\" class BigInteger { bool f; char *nums; int length; int capacity; public://构造函数 BigInteger() : length(0), capacity(1), f(false) { //缺省构造函数 nums = new char[capacity]; } BigInteger(const char *n) : length(strlen(n)), f(false) { //用于初始值的构造函数 int start = 0; if (n[0] == '-') { f = true; start++; } while (start \u003c length \u0026\u0026 n[start] == '0')start++; capacity = length * 10; nums = new char[capacity]; std::copy(n + start, n + length, nums); length = length - start; } BigInteger(const BigInteger \u0026a) { //拷贝构造函数 capacity = a.capacity; length = a.length; f = a.f; nums = new char[capacity]; std::copy(a.nums, a.nums + length, nums); } BigInteger(BigInteger \u0026\u0026a) : length(0) { //移动构造函数 *this = a; } ~BigInteger() { //析构函数 delete[] nums; } public://静态成员函数 static void Swap(BigInteger \u0026a, BigInteger \u0026b) { std::swap(a.length, b.length); std::swap(a.capacity, b.capacity); std::swap(a.f, b.f); std::swap(a.nums, b.nums); } static bool compare(const BigInteger \u0026a, const BigInteger \u0026b) { //比较纯nums大小(不看符号 int n1 = a.length; int n2 = b.length; if (n1 != n2)return n1 \u003e n2; //返回a和b哪个大，true则位a大 int i = 0; while (i \u003c n1 \u0026\u0026 a.nums[i] == b.nums[i])i++; //a b一样长的情况下，比较两个的值 if (i == n1) return false; return a.nums[i] \u003e b.nums[i]; } bool isEqual(BigInteger \u0026a, BigInteger \u0026b) { if (a.f != b.f || (a.length != b.length))return false; int i = 0; while (i \u003c a.length \u0026\u0026 a.nums[i] == b.nums[i])i++; return i == a.length \u0026\u0026 a.f == b.f; } static BigInteger add(BigInteger \u0026a, BigInteger \u0026b) { //不看符号的加法 a.reverse();//尾端对齐 b.reverse(); BigInteger t; int up = 0; int len = a.length \u003e b.length ? a.length : b.length; for (int i = 0; i \u003c len; i++) { int ta = i \u003c a.length ? a[i] - '0' : 0; int tb = i \u003c b.length ? b[i] - '0' : 0; int base = ta + tb + up; t.push_back(base % 10 + '0'); up = base / 10; } if (up) t.push_back(up + '0'); t.reverse();//返回原位 a.reverse(); b.reverse(); return t; } static BigInteger minus(BigInteger \u0026a, BigInteger \u0026b) { //不看符号的减法,默认了a的长度或者大小是比b要大的(所以外界不要乱调用 a.reverse(); b.reverse(); BigInteger t; int len = a.length \u003e b.length ? a.length : b.length; for (int i = 0; i \u003c len; i++) { int ta = i \u003c a.length ? a[i] - '0' : 0; int tb = i \u003c b.length ? b[i] - '0' : 0; int base = ta - tb; if (base \u003c 0) { base += 10; a[i + 1]--; } t.push_back(base + '0'); } t.reverse(); a.reverse(); b.reverse(); return t; } public://成员函数和重载运算符 char \u0026operator[](int i) { return nums[i]; } BigInteger \u0026operator=(BigInteger \u0026\u0026a) { //Swap\u0026Copy方式实现右值赋值重载 Swap(*this, a); return *this; } BigInteger \u0026operator=(const BigInteger \u0026a) {//深拷贝 if (length != 0)//如果不是初始化调用的 = ，则肯定需要先把原来的内存delete掉 delete[]nums; capacity = a.capacity; length = a.length; f = a.f; nums = new char[capacity]; std::copy(a.nums, a.nums + length, nums); return *this; } int getCap() { return capacity; } int getLength() { return length; } bool isNegative() { return f; } bool isEmpty() { return length == 0; } void reverse() { int l = 0, r = length - 1; while (l \u003c r) { std::swap(nums[l], nums[r]); l++; r--; } } void push_back(char x) { if (length \u003e= capacity) { capacity *= 2; char *t = nums; nums = new char[capacity]; std::copy(t, t + length, nums); delete[]t; } nums[length++] = x; } bool operator\u003c(const BigInteger \u0026a) const { if (f \u0026\u0026 !a.f) { //其中一个为负数，则那个是更小的 return true; } else if (!f \u0026\u0026 a.f) return false; if (f) { //两者都为负数的情况，左边的值要更大则为true return compare(*this, a); }//两者均为正数，则值更小的在左边为true return compare(a, *this); } BigInteger operator+(BigInteger \u0026a) { BigInteger res; bool flag; if (a.f \u0026\u0026 f) { //同为负数情况，直接相加，再改符号 res = add(*this, a); flag = true; } else if (a.f \u0026\u0026 !f) {//左正右负 if (compare(a, *this)) { //看负数对应的nums是否比正数大 flag = true; res = minus(a, *this); } else { flag = false; res = minus(*this, a); } } else if (!a.f \u0026\u0026 f) { if (compare(*this, a)) { //与上一个相同 flag = true; res = minus(*this, a); } else { flag = false; res = minus(a, *this); } } else { //同时为正数就是最简单的加法 flag = false; res = add(*this, a); } res.f = flag; return res; } BigInteger operator-(BigInteger \u0026a","date":"2022-01-20","objectID":"/posts/%E5%A4%A7%E6%95%B4%E6%95%B0%E5%8A%A0%E5%87%8F/:4:3","tags":["C++类的封装"],"title":"大数加减类的实现(C++实现)✨","uri":"/posts/%E5%A4%A7%E6%95%B4%E6%95%B0%E5%8A%A0%E5%87%8F/"},{"categories":["C++实战"],"content":"总结 很多人，可能觉得做项目一定得是那种高大上，又或者是那种贪吃蛇小游戏、扫雷小游戏类型，实际上只要你有兴趣，任何一个东西都能成为你的练手项目，并且收获收获也许比你跟风去弄几个小游戏更大。 做这个小项目，我的收获是，对C++的语法更加的了解了，关于移动构造器、拷贝构造器、赋值重载这块弄得更清楚了，最大的收获在于强化了一个类的设计思路，这个是最重要的。 多写一些类的实现，不仅有利于对算法和语言语法的理解，更大的收获在于对各个功能的设计思路，作为程序员，我们最需要的就是这样的逻辑思维，从接到需求开始，我们应该能迅速的抽象出各种实现方案，然后进行不断的优化，得出属于自己的代码！ ","date":"2022-01-20","objectID":"/posts/%E5%A4%A7%E6%95%B4%E6%95%B0%E5%8A%A0%E5%87%8F/:5:0","tags":["C++类的封装"],"title":"大数加减类的实现(C++实现)✨","uri":"/posts/%E5%A4%A7%E6%95%B4%E6%95%B0%E5%8A%A0%E5%87%8F/"},{"categories":["C++实战"],"content":"矩阵快速幂的C++封装","date":"2022-01-20","objectID":"/posts/%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82%E7%9A%84c++%E5%B0%81%E8%A3%85/","tags":["矩阵快速幂"],"title":"矩阵快速幂的C++封装","uri":"/posts/%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82%E7%9A%84c++%E5%B0%81%E8%A3%85/"},{"categories":["C++实战"],"content":"实现源码在线查看 如果对于类的设计已经非常清楚，只是进来想看看我的这个泛型模板源代码，那么直接点到下面这个链接进行查看： 源码链接 ","date":"2022-01-20","objectID":"/posts/%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82%E7%9A%84c++%E5%B0%81%E8%A3%85/:0:0","tags":["矩阵快速幂"],"title":"矩阵快速幂的C++封装","uri":"/posts/%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82%E7%9A%84c++%E5%B0%81%E8%A3%85/"},{"categories":["C++实战"],"content":"什么是矩阵快速幂？ 关于快速幂，就是利用二进制进行求解某个数的幂的快速方法。 后面会对快速幂的原理进行简单讲解，如果还是不懂，请自行百度。 相信有很多小伙伴是初入大学的世界，可能还没学过线性代数（比如我），于是乎不知道矩阵是什么，我推荐一个网站去看看矩阵的乘法是怎么运算的，下面是网站链接：（话说how to这个网站还真是牛批，什么东西都有教程，而且质量还贼高！😂） 矩阵乘法的计算方式 那么如何用代码表示矩阵以及他的乘法呢？ 其实很简单，就是三层循环进行控制即可。 如：我这里是C++的重载运算符 Matrix 是我定义的一个类。 Matrix\u0026 operator*(Matrix\u0026 b){ assert(b.date!=NULL \u0026\u0026 date!=NULL \u0026\u0026 m==b.n); ll tmp[n][b.m]; for(int i=0;i\u003cn;i++){ for(int j=0;j\u003cb.m;j++){ ll sum = 0; for(int k=0;k\u003cm;k++){ sum = (sum + date[i][k]*b.date[k][j])%MOD; } tmp[i][j] = sum; } } this-\u003em = b.m; for(int i=0;i\u003cn;i++){ for (int j = 0; j \u003c m; ++j) { date[i][j] = tmp[i][j]; } } return *this; } ","date":"2022-01-20","objectID":"/posts/%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82%E7%9A%84c++%E5%B0%81%E8%A3%85/:1:0","tags":["矩阵快速幂"],"title":"矩阵快速幂的C++封装","uri":"/posts/%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82%E7%9A%84c++%E5%B0%81%E8%A3%85/"},{"categories":["C++实战"],"content":"怎么进行矩阵快速幂的运算？ 关于如何矩阵快速幂，我们先了解一下简单的快速幂。 说是快速幂就是通过位运算实现快速的同数累乘。 简述一下快速幂的原理： 原理就是，如果要求x的3次幂，那么可以转化为求 x*x 的 2 次幂，而求一个数的 2^n 幂是很简单的，比如进行一次 x *= x 便得到 x 的二次方。而再进行一次 x *= x 就得到了 4 次方，继续便可得到 8/16... 总之是 log2N 的时间。 代码如下： int QuickPow(int x,int n){ int c = n; int res = 1; while(c!=0){ if(c\u00261!=0){ res *= x; } c \u003e\u003e= 1; x *= x; } return res; } 那么矩阵的快速幂如何进行？ 把上述的 int 类型换成自己定义的矩阵就是矩阵的快速幂了。 我直接贴上C++实现的重载运算符后的类的快速幂写法： 这里的quickPow表示的是一个类的成员函数，所以可以直接用到这个矩阵里的数据进行运算。this表示指向这个对象的指针。init() 成员函数表示初始化为单位矩阵。 void quickPow(ll c){ if(c==1||c\u003c0)return; if(c==0){ init(); return; } Matrix tmp(*this); init(); while (c){ if(c\u00261){ *this = *this * tmp; } c \u003e\u003e= 1; tmp = tmp*tmp; } } ","date":"2022-01-20","objectID":"/posts/%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82%E7%9A%84c++%E5%B0%81%E8%A3%85/:1:1","tags":["矩阵快速幂"],"title":"矩阵快速幂的C++封装","uri":"/posts/%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82%E7%9A%84c++%E5%B0%81%E8%A3%85/"},{"categories":["C++实战"],"content":"为什么突然想写这个模板？ 主要是因为最近做了几道快速幂的题目，被坑的很惨，然后就突然想设计一个模板了，主要是 my_tiny_stl 这个仓库也好久没更新了😂 ","date":"2022-01-20","objectID":"/posts/%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82%E7%9A%84c++%E5%B0%81%E8%A3%85/:2:0","tags":["矩阵快速幂"],"title":"矩阵快速幂的C++封装","uri":"/posts/%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82%E7%9A%84c++%E5%B0%81%E8%A3%85/"},{"categories":["C++实战"],"content":"题目 OJ网站 ","date":"2022-01-20","objectID":"/posts/%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82%E7%9A%84c++%E5%B0%81%E8%A3%85/:2:1","tags":["矩阵快速幂"],"title":"矩阵快速幂的C++封装","uri":"/posts/%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82%E7%9A%84c++%E5%B0%81%E8%A3%85/"},{"categories":["C++实战"],"content":"我是如何被坑的 首先拿到这道题，我便马上开始简单的O(n)递推法实现，然后提交，然后。。超时。。 定眼一看，数据量原来这么大！ 后面一想，肯定是矩阵快速幂了，先想出以下矩阵的递推式子： 进而题目便可得到求解。 然后我就利用 C++ 的类简单的封装了一个矩阵类，里面重载了乘法和 quickpow 方法，然后比较悠闲的准备提交，还没提交前就遇到C++的语法陷阱、、 语法陷阱（建议非C++党绕道） 由于类用的都是堆内存，所以我写了析构函数，我遇到的问题出在重载乘法时我返回的是左值，而且我也没有对 ‘=’ 进行重载，所以 ‘=’ 就是直接的成员变量拷贝，这导致一个结果就是两个对象的 date 指向同一片内存空间，而之前的那片内存空间泄露了，且最后这两个对象肯定都会调用析构函数，这又导致了析构函数调用了两次！ 如何解决这个问题？如果是 C++98 ，那么这个问题很大，基本上就是两种方法解决： 逃避问题，乘法的左操作数必须是当前赋值对象，这样就避免了最后赋值语句将原本对象内的指针直接改变。 解决问题，解决这类问题无论是 C++11 还是 C++98 最直接的方式就是重载 ‘=’ 号，重载 '=' 号的实现根据具体的情况进行，而具体实现赋值的重载，我们需要考虑两件事：第一，需尽可能的减少内存的申请和使用（具体而言就是判断两个对象的指针所指向的是否为同一片空间，即便不是同一片空间，为了增加空间利用率还可以判断两个空间是否大小一致，然后进行拷贝即可）。第二，如果是临时对象则需要把它的指针置空（防止编译器未优化临时变量的析构函数，从而调用了析构函数多次析构同一内存）。 由于 C++11 开始有了右值引用和它配套的移动赋值构造器，所以可以把临时变量直接调用移动构造器变成具名对象，然后进行操作，一般就是把它的指针所有权进行转移，然后把它的指针置空防止析构错误，在我的理解下，右值引用的出现就是为了捕捉到匿名对象然后给程序员进行适当的性能优化操作，没有右值引用前，匿名对象的内存根本就没法去使用，只能用来简单的赋值拷贝操作后才能使用，这样就很消耗内存了，右值引用出现后，我们可以通过右值引用对匿名对象进行捕捉，然后操作它的底层内存。还有一个很大的内存相关的更新就是有了一个 nullptr 关键字，这个关键字使得空指针不再会有歧义，所以 delete nullptr 是安全的。所以防止多次 delete 同一片空间产生错误可以将它赋值为 nullptr 即可。 那么基于 C++11 这个问题该如何解决呢？解决方法和C++98没差，就是能够更加得心应手的进行内存的管理了，如果等号右边是一个右值，那么它肯定是一个临时对象，所以我们可以在 ‘=’ 号的重载中直接了当的用它的内存，并把它的指针置空。如果没有右值类型进行捕获，编译器默认也是会对临时对象进行优化的，也能防止产生多个对象的赋值拷贝，但只能在对象初始化的时候进行优化！而在其他时候则还是会调用析构函数，这个时候如果还是用编译器默认产生的 ‘=’ 重载，则会发生被析构的空间的指针被赋值的情况，而我们的右值引用版本的赋值重载便是针对此现象的。这样便于内存管理，将右值和左值进行分开处理。右值是临时变量只需要用一会儿，所以可以直接把它的内存拿过来继续用，也不会对程序逻辑造成影响，而左值则不一样，它还需要存活很长一段时间，所以我们需要另创空间进行拷贝。 特别提醒：如果是做算法题，则完全不用去考虑内存的管理，析构函数也不要去写，毕竟只需要单次调用使用，对象最多也就存在一会儿。 做题陷阱 在必要的时候千万不要舍不得开long long！！！！ 这道题的数据量无论是幂的次方还是整个记录过程的数据都要开long long！！！ 我被这个陷阱坑了无数回了，这一次也不另外😅 开始写完这种之后过了前5个，然后后面5个报错，我还以为我设计的这个类有问题，还特意去写了好几个普通C语言版本😂最后发现原来的没开long long。以下为更改long long后的代码通过版本，我用宏定义写了几个版本。。。 这个Matrix类的设计还是很多地方没有考虑到位，比如上一个陷阱的问题只是通过方法一得到解决，并未去重载赋值操作符。。。所以后面痛定思痛，设计一个较为可用的Matrix类！ 效率时快时慢的，这主要取决于编译器是否进行优化。 // // Created by Alone on 2021/11/19. // #include \u003cbits/stdc++.h\u003eusing namespace std; //#define ELSE_MAIN #define MY_MAIN #define MAT #ifdef MAT typedef long long ll; class Matrix{ ll** date; int m; int n; public: static const int MOD; public: Matrix(ll** rec,int n,int m):date(rec),n(n),m(m){}//C风格的初始化 Matrix():date(NULL),m(0),n(0){} //缺省 Matrix(Matrix\u0026 b):n(b.n),m(b.m){//拷贝构造 assert(b.date!=NULL \u0026\u0026 b.n\u003e0 \u0026\u0026 b.m\u003e0); date = new ll*[n]; copy(b.date,b.date+n,date); for(int i=0;i\u003cn;i++){ date[i] = new ll[m]; copy(b.date[i],b.date[i]+m,date[i]); } } ~Matrix(){//析构函数实现 assert(date!=NULL \u0026\u0026 n\u003e0 \u0026\u0026 m\u003e0); for (int i = n-1; i \u003e=0 ; --i) { delete [] date[i]; } delete[] date; } Matrix\u0026 operator*(Matrix\u0026 b){ assert(b.date!=NULL \u0026\u0026 date!=NULL \u0026\u0026 m==b.n); ll tmp[n][b.m]; for(int i=0;i\u003cn;i++){ for(int j=0;j\u003cb.m;j++){ ll sum = 0; for(int k=0;k\u003cm;k++){ sum = (sum + date[i][k]*b.date[k][j])%MOD; } tmp[i][j] = sum; } } this-\u003em = b.m; for(int i=0;i\u003cn;i++){ for (int j = 0; j \u003c m; ++j) { date[i][j] = tmp[i][j]; } } return *this; } void init(){//重新初始化为单位矩阵 assert(date!=NULL \u0026\u0026 n\u003e0 \u0026\u0026 m\u003e0); for (int i = 0; i \u003c n; ++i) { for (int j = 0; j \u003c m; ++j) { if(i==j)date[i][j] = 1; else date[i][j] = 0; } } } void quickPow(ll c){ if(c==1||c\u003c0)return; if(c==0){ init(); return; } Matrix tmp(*this); init(); while (c){ if(c\u00261){ *this = *this * tmp; } c \u003e\u003e= 1; tmp = tmp*tmp; } } void print(){ for(int i=0;i\u003cn;i++){ for(int j=0;j\u003cm;j++){ cout\u003c\u003cdate[i][j]\u003c\u003c' '; } cout\u003c\u003cendl; } } int get(int x,int y){ assert(date!=NULL \u0026\u0026 x\u003cn \u0026\u0026 y\u003cm); return date[x][y]; } }; const int Matrix::MOD = 1e9+7; #endif #ifdef MY_MAIN int main(){ ll c; cin\u003e\u003ec; ll** matrix = new ll*[2]; matrix[0] = new ll[2]{1,1}; matrix[1] = new ll[2]{1,0}; Matrix mat(matrix,2,2); mat.quickPow(c-1); //mat.print(); ll** res = new ll*[2]; res[0] = new ll[1]; res[1] = new ll[1]; res[0][0] = res[1][0] = 1; Matrix fib(res,2,1); //这里有个内存分配错误，mat*fib返回的是左值，而=没有重载默认直接赋值成员变量。 //直接导致了fib失去了之前的变量所有权，和mat共同有一个内存空间，这样导致同一片空间被free两次 //通过重载 = 号解决，防止直接的内存没有被释放就重新绑定同一片内存 Matrix ret(mat*fib); cout\u003c\u003cret.get(0,0); return 0; } #endif #ifdef TEST_MAIN typedef long long ll ; const int MOD = 1e9+7; ll a[2][2]{{1,1},{1,0}};ll b[2]{1,1}; void selfMut(){ ll tmp[2][2]; for(int i=0;i\u003c2;i","date":"2022-01-20","objectID":"/posts/%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82%E7%9A%84c++%E5%B0%81%E8%A3%85/:2:2","tags":["矩阵快速幂"],"title":"矩阵快速幂的C++封装","uri":"/posts/%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82%E7%9A%84c++%E5%B0%81%E8%A3%85/"},{"categories":["C++实战"],"content":"教你设计Matrix类 ","date":"2022-01-20","objectID":"/posts/%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82%E7%9A%84c++%E5%B0%81%E8%A3%85/:3:0","tags":["矩阵快速幂"],"title":"矩阵快速幂的C++封装","uri":"/posts/%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82%E7%9A%84c++%E5%B0%81%E8%A3%85/"},{"categories":["C++实战"],"content":"如何设计一个类？ 结构： 内部数据抽象：对象的运算数据存储 用二级指针 date 进行矩阵的二维空间的内存管理，以及n和m表示矩阵的行高和列宽。 行为抽象：对对象的行为描述 构造函数（缺省、自定义、拷贝、移动） 和 析构函数（调用destory成员函数）。 setter 和 getter。提供函数接口去设置和得到数据。 功能函数：比如重载的乘法运算符和快速幂函数这些都算功能函数。 对象的属性抽象： 数据和行为是否对外，对外封装数据的意义在于防止对对象行为描述的破坏，而对外开放的某个行为通常需要内部多个函数进行重复调用来实现。这个时候需要用到 public 和 private 关键字进行修饰。 数据和行为是否可继承，对于某些行为（函数），我们不想被外部调用，但是对子类又很有用，这个时候我们可以采取 protect 关键字进行修饰。 数据和行为是否能重复利用，为了节省不必要的内存开销，可以设计不需要产生具体对象的通用型函数，可以使用 static 关键字进行修饰，这样可以避免我想使用某个函数前还得去申请一片毫不相关的内存空间，而对于某个对象的数据也可以采用 static 进行修饰，这样一来，这个数据在对象的创建过程中就不需要再进行申请和赋值了。 那么接下来就来确定行为（函数）的属性了，数据肯定是不对外开放的（private），否则面向对象将毫无意义。 构造函数 和 析构函数，这两个是对象的创建和销毁的关键，所以如果不是希望对象不被创建或者是不被销毁，都应该使用 public 修饰。 setter 和 getter。很明显是对外开放的接口函数，所以肯定也是 public 修饰。 功能函数：矩阵快速幂的函数，很明显我们希望设置一个对外通用的情况，那么这个时候就应该不需要创建对象便可进行调用，所以最好用 static 进行修饰（这个一般为外部通用接口，内部还需实现一个方便类调用的版本，这也很简单，直接传参调用该函数即可），重载的乘法肯定也是对外的所以需要 public 修饰，destroy 函数用于处理内存的回收，很明显这是一个内部通用的函数，但是外界完全是不需要它的！所以把它设置为 private 属性即可。 以上便是对整个类的设计思路，当然真正动手设计的时候，还需要具体到函数的参数和返回值类型，因为这牵扯到 C++ 的具体语法了，比如我应该在重载乘法的时候返回一个什么样的类型？最好是返回一个右值！而重载赋值运算符则最好是返回一个左值。一般需要考虑返回值类型的取舍时，最难的就是如果返回一个对象，我该返回左值还是右值。 写了这么久C++，我感觉用C++写的Java屏蔽重载运算符的特性主要就是重载运算符时需要考虑的过程太多了，C++菜鸡（我就是这个菜鸟😂）写出及其低效且不安全的代码，而只有老鸟才能写出优雅高效的代码。 ","date":"2022-01-20","objectID":"/posts/%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82%E7%9A%84c++%E5%B0%81%E8%A3%85/:3:1","tags":["矩阵快速幂"],"title":"矩阵快速幂的C++封装","uri":"/posts/%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82%E7%9A%84c++%E5%B0%81%E8%A3%85/"},{"categories":["C++实战"],"content":"类的具体抽象结构（代码的具体规划图） 按照属性对类的各个部分进行分类的，毕竟属性也基本就代表了这个方法的使用场景了。 最后可以利用基本的断言或者异常，让代码变得更为健壮，使得更容易定位错误发生的位置和原因。 ","date":"2022-01-20","objectID":"/posts/%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82%E7%9A%84c++%E5%B0%81%E8%A3%85/:3:2","tags":["矩阵快速幂"],"title":"矩阵快速幂的C++封装","uri":"/posts/%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82%E7%9A%84c++%E5%B0%81%E8%A3%85/"},{"categories":["C++实战"],"content":"实现矩阵泛型模板类 源代码实现 我先是画出规划图进行实现，然后在实现的过程中，发现可以新增一些特性，比如重载下标运算符，比如用print函数打印出来方便验证。 具体实现过程，为了方便简单的定位可能发生的错误，使用了大量的assert进行断言检查。如果想代码的健壮性更强，可以使用抛出异常的方式。 源代码对应的GitHub仓库地址：仓库链接，还有更多模板的实现，包括少量STL 更好的源码阅读体验：源码在线阅读 直接阅读下面的代码有点不太好查看，推荐去上面的GitHub1s里面查看源码。 // // Created by L_B__ on 2021/11/20. // #ifndef LQTEST_MATRIX_H #define LQTEST_MATRIX_H #include \u003ccassert\u003e#include \u003calgorithm\u003e#include \u003ciostream\u003e #define _MOD template\u003ctypename T\u003e class Matrix { /*Type define*/ typedef T data_t; typedef int ssize_t; /*data source*/ data_t **data; ssize_t n; ssize_t m; public: static const data_t MOD; public: /*default construct*/ Matrix() : m(0), n(0), data(nullptr) {} /*custom construct*/ Matrix(data_t **mat, ssize_t n, ssize_t m) : data(mat), n(n), m(m) {}//外部申请内存传入内部 Matrix(ssize_t n, ssize_t m) : data(nullptr), n(n), m(m) {//外部指定矩阵的行和列即可，内存初始化在内部进行 assert(n \u003e 0 \u0026\u0026 m \u003e 0); data = new data_t *[n]; for (int i = 0; i \u003c n; i++) { data[i] = new data_t[m]; } init(data, n, m); } /*copy construct*/ Matrix(Matrix \u0026src) : data(nullptr), n(src.n), m(src.m)//也可用const \u0026引用类型，但这样很多右值的情况都不会调用移动构造了 { assert(n \u003e 0 \u0026\u0026 m \u003e 0); data = new data_t *[n]; for (int i = 0; i \u003c n; ++i) { data[i] = new data_t[m]; std::copy(src.data[i], src.data[i] + m, data[i]); } } /*move construct*/ Matrix(Matrix\u003cdata_t\u003e \u0026\u0026src) : n(src.n), m(src.m), data(nullptr) { assert(src.data != nullptr \u0026\u0026 n \u003e 0 \u0026\u0026 m \u003e 0); data = src.data; src.data = nullptr; src.n = src.m = 0; } /*destruct*/ ~Matrix() { destroy(); } /*overload*/ //加上MOD的特殊版本 #ifdef _MOD Matrix operator*(const Matrix\u003cdata_t\u003e \u0026src)//建议返回右值，返回左值的后续坑比较多，参数const \u0026既可以接受左值也可接受右值 { assert(data != nullptr \u0026\u0026 src.data != nullptr \u0026\u0026 m == src.n \u0026\u0026 m \u003e 0 \u0026\u0026 n \u003e 0 \u0026\u0026 src.m \u003e 0);//进行矩阵乘法的必要条件 data_t **tmp = new data_t *[n]; //为tmp申请动态内存，因为是传出参数 for (int i = 0; i \u003c n; ++i) { tmp[i] = new data_t[m]; } for (int i = 0; i \u003c n; ++i)//开始更新tmp { for (int j = 0; j \u003c src.m; ++j) { data_t sum = 0; for (int k = 0; k \u003c m; ++k) { sum = (sum + data[i][k] * src.data[k][j]) % MOD; } tmp[i][j] = sum; } } //直接构造匿名对象返回 return Matrix(tmp, n, src.m);; } Matrix \u0026operator*=(const Matrix\u003cdata_t\u003e \u0026src)//*= 想一想我们平时的使用，就是返回一个左值 { assert(data != nullptr \u0026\u0026 src.data != nullptr \u0026\u0026 m == src.n \u0026\u0026 m \u003e 0 \u0026\u0026 n \u003e 0 \u0026\u0026 src.m \u003e 0);//进行矩阵乘法的必要条件 data_t tmp[n][src.m];//静态内存就行，毕竟只是临时存数据的 for (int i = 0; i \u003c n; ++i)//开始更新tmp { for (int j = 0; j \u003c src.m; ++j) { data_t sum = 0; for (int k = 0; k \u003c m; ++k) { sum = (sum + data[i][k] * src.data[k][j]) % MOD; } tmp[i][j] = sum; } } //由于此时的date内存可能不够容下tmp数据，所以可能需要重新进行内存申请 //注意重新申请列内存的时候，需要把之前的内存释放 if (m != src.m) { for (int i = 0; i \u003c n; ++i) { delete[]data[i]; data[i] = nullptr; data[i] = new data_t[src.m]; } } for (int i = 0; i \u003c n; ++i) { assert(data[i] != nullptr); std::copy(tmp[i], tmp[i] + src.m, data[i]); } return *this; } #endif #ifndef _MOD Matrix operator*(const Matrix\u003cdata_t\u003e\u0026src)//建议返回右值，返回左值的后续坑比较多，参数const \u0026既可以接受左值也可接受右值 { assert(data!= nullptr\u0026\u0026src.data!= nullptr\u0026\u0026m==src.n\u0026\u0026m\u003e0\u0026\u0026n\u003e0\u0026\u0026src.m\u003e0);//进行矩阵乘法的必要条件 data_t** tmp = new data_t *[n]; //为tmp申请动态内存，因为是传出参数 for (int i = 0; i \u003c n; ++i) { tmp[i] = new data_t [m]; } for(int i=0;i\u003cn;++i)//开始更新tmp { for (int j = 0; j \u003c src.m; ++j) { data_t sum = 0; for (int k = 0; k \u003c m; ++k) { sum = sum + data[i][k]*src.data[k][j]; } tmp[i][j] = sum; } } //直接构造匿名对象返回 return Matrix (tmp,n,src.m); } /*与乘法的唯一区别在于乘法是构造一个新的对象，而*=返回的是this*/ Matrix \u0026operator*=(const Matrix\u003cdata_t\u003e \u0026src)//*= 想一想我们平时的使用，就是返回一个左值 { assert(data!= nullptr\u0026\u0026src.data!= nullptr\u0026\u0026m==src.n\u0026\u0026m\u003e0\u0026\u0026n\u003e0\u0026\u0026src.m\u003e0);//进行矩阵乘法的必要条件 data_t tmp[n][src.m];//静态内存就行，毕竟只是临时存数据的 for(int i=0;i\u003cn;++i)//开始更新tmp { for (int j = 0; j \u003c src.m; ++j) { data_t sum = 0; for (int k = 0; k \u003c m; ++k) { sum = sum + data[i][k]*src.data[k][j]; } tmp[i][j] = sum; } } //由于此时的date内存可能不够容下tmp数据，所以可能需要重新进行内存申请 //注意重新申请列内存的时候，需要把之前的内存释放 if(m!=src.m){ for (int i = 0; i \u003c n; ++i) { delete []data[i]; data[i] = nullptr; data[i] = new data_t [src.m]; } } for (int i = 0; i \u003c n; ++i) { assert(data[i] != nullptr); std::copy(tmp[i],tmp[i]+src.m,data[i]); } return *this; } #endif //赋值号的重载","date":"2022-01-20","objectID":"/posts/%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82%E7%9A%84c++%E5%B0%81%E8%A3%85/:3:3","tags":["矩阵快速幂"],"title":"矩阵快速幂的C++封装","uri":"/posts/%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82%E7%9A%84c++%E5%B0%81%E8%A3%85/"},{"categories":["C++实战"],"content":"总结 由于用的是 C++11 的语法进行实现的模板类，所以低于这个版本的编译器都无法正常使用。我查阅了相关资料，实际上蓝桥杯比赛的时候可以用 C++11，而acm更是不用说，早就能用C++11了。 简单复盘： 实现一个这样的类，主要能学到以下几点： 类的设计技巧。 对C++的左右值有了更深入的理解。 各种构造器的设计和实现已经达到炉火纯青的地步了。 ","date":"2022-01-20","objectID":"/posts/%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82%E7%9A%84c++%E5%B0%81%E8%A3%85/:4:0","tags":["矩阵快速幂"],"title":"矩阵快速幂的C++封装","uri":"/posts/%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82%E7%9A%84c++%E5%B0%81%E8%A3%85/"}]