[{"categories":["操作系统"],"content":"[CS原理]多级页表到底如何节约内存？","date":"2022-10-07","objectID":"/posts/cs%E5%8E%9F%E7%90%86%E5%A4%9A%E7%BA%A7%E9%A1%B5%E8%A1%A8%E5%88%B0%E5%BA%95%E5%A6%82%E4%BD%95%E8%8A%82%E7%BA%A6%E5%86%85%E5%AD%98/","tags":["[CS原理]多级页表到底如何节约内存？"],"title":"[CS原理]多级页表到底如何节约内存？","uri":"/posts/cs%E5%8E%9F%E7%90%86%E5%A4%9A%E7%BA%A7%E9%A1%B5%E8%A1%A8%E5%88%B0%E5%BA%95%E5%A6%82%E4%BD%95%E8%8A%82%E7%BA%A6%E5%86%85%E5%AD%98/"},{"categories":["操作系统"],"content":"前言 在学习计算机组成原理时，书中谈到，“使用多级页表可以压缩页表占用的内存”，在了解了多级页表的原理后，恐怕对这句话还是理解不了：把页表换成多级页表了就能节约内存了？不是还是得映射所有的虚拟地址空间么？ 比如做个简单的数学计算，假如虚拟地址空间为32位（即4GB）、每个页面映射4KB以及每条页表项占4B，则进程需要1M个页表项（4GB / 4KB = 1M），即页表（每个进程都有一个页表）占用4MB（1M * 4B = 4MB）的内存空间。而假如我们使用二级页表，还是上述条件，但一级页表映射4MB、二级页表映射4KB，则需要1K个一级页表项（4GB / 4MB = 1K）、每个一级页表项对应1K个二级页表项（4MB / 4KB = 1K），这样页表占用4.004MB（1K * 4B + 1K * 1K * 4B = 4.004MB）的内存空间。多级页表的内存空间占用反而变大了？ 其实我们应该换个角度来看问题，还记得计算机组成原理里面无处不在的局部性原理么？ ","date":"2022-10-07","objectID":"/posts/cs%E5%8E%9F%E7%90%86%E5%A4%9A%E7%BA%A7%E9%A1%B5%E8%A1%A8%E5%88%B0%E5%BA%95%E5%A6%82%E4%BD%95%E8%8A%82%E7%BA%A6%E5%86%85%E5%AD%98/:1:0","tags":["[CS原理]多级页表到底如何节约内存？"],"title":"[CS原理]多级页表到底如何节约内存？","uri":"/posts/cs%E5%8E%9F%E7%90%86%E5%A4%9A%E7%BA%A7%E9%A1%B5%E8%A1%A8%E5%88%B0%E5%BA%95%E5%A6%82%E4%BD%95%E8%8A%82%E7%BA%A6%E5%86%85%E5%AD%98/"},{"categories":["操作系统"],"content":"如何节约内存 我们分两方面来谈这个问题：第一，二级页表可以不存在；第二，二级页表可以不在主存。 ","date":"2022-10-07","objectID":"/posts/cs%E5%8E%9F%E7%90%86%E5%A4%9A%E7%BA%A7%E9%A1%B5%E8%A1%A8%E5%88%B0%E5%BA%95%E5%A6%82%E4%BD%95%E8%8A%82%E7%BA%A6%E5%86%85%E5%AD%98/:2:0","tags":["[CS原理]多级页表到底如何节约内存？"],"title":"[CS原理]多级页表到底如何节约内存？","uri":"/posts/cs%E5%8E%9F%E7%90%86%E5%A4%9A%E7%BA%A7%E9%A1%B5%E8%A1%A8%E5%88%B0%E5%BA%95%E5%A6%82%E4%BD%95%E8%8A%82%E7%BA%A6%E5%86%85%E5%AD%98/"},{"categories":["操作系统"],"content":"二级页表可以不存在 我们反过来想，每个进程都有4GB的虚拟地址空间，而显然对于大多数程序来说，其使用到的空间远未达到4GB，何必去映射不可能用到的空间呢？ 也就是说，一级页表覆盖了整个4GB虚拟地址空间，但如果某个一级页表的页表项没有被用到，也就不需要创建这个页表项对应的二级页表了，即可以在需要时才创建二级页表。做个简单的计算，假设只有20%的一级页表项被用到了，那么页表占用的内存空间就只有0.804MB（1K * 4B + 0.2 * 1K * 1K * 4B = 0.804MB），对比单级页表的4M是不是一个巨大的节约？ 那么为什么不分级的页表就做不到这样节约内存呢？我们从页表的性质来看，保存在主存中的页表承担的职责是将虚拟地址翻译成物理地址；假如虚拟地址在页表中找不到对应的页表项，计算机系统就不能工作了。所以页表一定要覆盖全部虚拟地址空间，不分级的页表就需要有1M个页表项来映射，而二级页表则最少只需要1K个页表项（此时一级页表覆盖到了全部虚拟地址空间，二级页表在需要时创建）。 ","date":"2022-10-07","objectID":"/posts/cs%E5%8E%9F%E7%90%86%E5%A4%9A%E7%BA%A7%E9%A1%B5%E8%A1%A8%E5%88%B0%E5%BA%95%E5%A6%82%E4%BD%95%E8%8A%82%E7%BA%A6%E5%86%85%E5%AD%98/:2:1","tags":["[CS原理]多级页表到底如何节约内存？"],"title":"[CS原理]多级页表到底如何节约内存？","uri":"/posts/cs%E5%8E%9F%E7%90%86%E5%A4%9A%E7%BA%A7%E9%A1%B5%E8%A1%A8%E5%88%B0%E5%BA%95%E5%A6%82%E4%BD%95%E8%8A%82%E7%BA%A6%E5%86%85%E5%AD%98/"},{"categories":["操作系统"],"content":"二级页表可以不在主存 其实这就像是把页表当成了页面。回顾一下请求分页存储管理，当需要用到某个页面时，将此页面从磁盘调入到内存；当内存中页面满了时，将内存中的页面调出到磁盘，这是利用到了程序运行的局部性原理。我们可以很自然发现，虚拟内存地址存在着局部性，那么负责映射虚拟内存地址的页表项当然也存在着局部性了！这样我们再来看二级页表，根据局部性原理，1024个第二级页表中，只会有很少的一部分在某一时刻正在使用，我们岂不是可以把二级页表都放在磁盘中，在需要时才调入到内存？我们考虑极端情况，只有一级页表在内存中，二级页表仅有一个在内存中，其余全在磁盘中（虽然这样效率非常低），则此时页表占用了8KB（1K * 4B + 1 * 1K * 4B = 8KB），对比上一步的0.804MB，占用空间又缩小了好多倍！ ","date":"2022-10-07","objectID":"/posts/cs%E5%8E%9F%E7%90%86%E5%A4%9A%E7%BA%A7%E9%A1%B5%E8%A1%A8%E5%88%B0%E5%BA%95%E5%A6%82%E4%BD%95%E8%8A%82%E7%BA%A6%E5%86%85%E5%AD%98/:2:2","tags":["[CS原理]多级页表到底如何节约内存？"],"title":"[CS原理]多级页表到底如何节约内存？","uri":"/posts/cs%E5%8E%9F%E7%90%86%E5%A4%9A%E7%BA%A7%E9%A1%B5%E8%A1%A8%E5%88%B0%E5%BA%95%E5%A6%82%E4%BD%95%E8%8A%82%E7%BA%A6%E5%86%85%E5%AD%98/"},{"categories":["操作系统"],"content":"总结 我们把二级页表再推广到多级页表，就会发现页表占用的内存空间更少了，这一切都要归功于对局部性原理的充分应用。 回头想想，这么大幅度地解决内存空间，我们失去了什么呢？计算机的很多问题无外乎就是时间换空间和空间换时间了，而多级页表就是典型的时间换空间的例子了，动态创建二级页表、调入和调出二级页表都是需要花费额外时间的，远没有不分级的页表来的直接；而我们也仅仅是利用局部性原理让这个额外时间开销降得比较低了而已。 ","date":"2022-10-07","objectID":"/posts/cs%E5%8E%9F%E7%90%86%E5%A4%9A%E7%BA%A7%E9%A1%B5%E8%A1%A8%E5%88%B0%E5%BA%95%E5%A6%82%E4%BD%95%E8%8A%82%E7%BA%A6%E5%86%85%E5%AD%98/:3:0","tags":["[CS原理]多级页表到底如何节约内存？"],"title":"[CS原理]多级页表到底如何节约内存？","uri":"/posts/cs%E5%8E%9F%E7%90%86%E5%A4%9A%E7%BA%A7%E9%A1%B5%E8%A1%A8%E5%88%B0%E5%BA%95%E5%A6%82%E4%BD%95%E8%8A%82%E7%BA%A6%E5%86%85%E5%AD%98/"},{"categories":["操作系统"],"content":"参考 Bryant R, David Richard O H. 深入理解计算机系统[M]. 机械工业出版社, 2016. ","date":"2022-10-07","objectID":"/posts/cs%E5%8E%9F%E7%90%86%E5%A4%9A%E7%BA%A7%E9%A1%B5%E8%A1%A8%E5%88%B0%E5%BA%95%E5%A6%82%E4%BD%95%E8%8A%82%E7%BA%A6%E5%86%85%E5%AD%98/:4:0","tags":["[CS原理]多级页表到底如何节约内存？"],"title":"[CS原理]多级页表到底如何节约内存？","uri":"/posts/cs%E5%8E%9F%E7%90%86%E5%A4%9A%E7%BA%A7%E9%A1%B5%E8%A1%A8%E5%88%B0%E5%BA%95%E5%A6%82%E4%BD%95%E8%8A%82%E7%BA%A6%E5%86%85%E5%AD%98/"},{"categories":["个人项目"],"content":"C++高可用日志库实现","date":"2022-09-05","objectID":"/posts/c++%E9%AB%98%E6%98%93%E7%94%A8%E6%97%A5%E5%BF%97%E5%BA%93%E5%AE%9E%E7%8E%B0/","tags":["C++高易用日志库实现"],"title":"C++高易用日志库实现","uri":"/posts/c++%E9%AB%98%E6%98%93%E7%94%A8%E6%97%A5%E5%BF%97%E5%BA%93%E5%AE%9E%E7%8E%B0/"},{"categories":["个人项目"],"content":"使用教程 ","date":"2022-09-05","objectID":"/posts/c++%E9%AB%98%E6%98%93%E7%94%A8%E6%97%A5%E5%BF%97%E5%BA%93%E5%AE%9E%E7%8E%B0/:0:0","tags":["C++高易用日志库实现"],"title":"C++高易用日志库实现","uri":"/posts/c++%E9%AB%98%E6%98%93%E7%94%A8%E6%97%A5%E5%BF%97%E5%BA%93%E5%AE%9E%E7%8E%B0/"},{"categories":["个人项目"],"content":"如何添加到项目中使用 输入以下命令得到项目文件 git clone https://github.com/ACking-you/my-logger.git 项目目录如下： dependencies：整个项目的外部依赖，以源码形式存在（比如fmt库）。 lib：整个项目已经打包好的库文件，我打包的是动态库，如有静态库需要请自行编译。库的名称为logger和fmt。 其余均为项目关键源码，就Logger.cpp和Logger.h两个。main.cc是项目运行测试代码。 ","date":"2022-09-05","objectID":"/posts/c++%E9%AB%98%E6%98%93%E7%94%A8%E6%97%A5%E5%BF%97%E5%BA%93%E5%AE%9E%E7%8E%B0/:1:0","tags":["C++高易用日志库实现"],"title":"C++高易用日志库实现","uri":"/posts/c++%E9%AB%98%E6%98%93%E7%94%A8%E6%97%A5%E5%BF%97%E5%BA%93%E5%AE%9E%E7%8E%B0/"},{"categories":["个人项目"],"content":"CMake配置 由于本人对 cmake 的 install 指令了解的并不深入，所以本库并不支持最后的 make install ，为了防止大伙编译库的长时间等待，我已经编译好了动态库版本，所以直接拿去用即可（当然不排除环境的不兼容，所以可能还是需要手动编译）。 如果你clone本项目和你的项目为同级目录，请在你的cmake文件中添加下面的代码，然后再链接这两个库便可得到本库的所有支持。 include_directories(../my-logger)#具体为本项目的根目录，可用相对路径也可用绝对。此处是为了方便搜索头文件 link_directories(../my-logger/lib)#路径说明同上，该路径为链接库的目录 .... target_link_libraries(${CMAKE_PROJECT_NAME} logger fmt)#添加对应的链接库 注意：如果你不需要使用fmt库中的高级功能，那么你可以不链接fmt库，如果需要使用其高级功能进行打印（比如支持打印std::map等标准库容器），那么请链接fmt库。 ","date":"2022-09-05","objectID":"/posts/c++%E9%AB%98%E6%98%93%E7%94%A8%E6%97%A5%E5%BF%97%E5%BA%93%E5%AE%9E%E7%8E%B0/:1:1","tags":["C++高易用日志库实现"],"title":"C++高易用日志库实现","uri":"/posts/c++%E9%AB%98%E6%98%93%E7%94%A8%E6%97%A5%E5%BF%97%E5%BA%93%E5%AE%9E%E7%8E%B0/"},{"categories":["个人项目"],"content":"库的编译 下面为logger库的编译命令： mkdir build-logger cd build-logger cmake .. -DCMAKE_BUILD_TYPE=Release -DBUILD_SHARED_LIBS=ON make 输入上面的命令后，会在 build-logger 文件夹中生成对应的动态库（不定义第二个变量时默认编译静态库）。建议把这个生成的动态库移动到这个项目 lib 目录中，方便在使用时只需添加之前的cmake代码。 下面为fmt库的编译命令（由于该库较大，编译时间可能较久，我的电脑用了将近十分钟）： mkdir build-fmt cd build-fmt cmake ../dependencies/fmt/ -DCMAKE_BUILD_TYPE=Release -DBUILD_SHARED_LIBS=ON 同样会在 build-fmt 目录生成对应的动态库，建议同样放入该项目lib目录中，注意 fmt 库的动态库是由多个文件构成，这多个文件都需要被放在一起。 ","date":"2022-09-05","objectID":"/posts/c++%E9%AB%98%E6%98%93%E7%94%A8%E6%97%A5%E5%BF%97%E5%BA%93%E5%AE%9E%E7%8E%B0/:1:2","tags":["C++高易用日志库实现"],"title":"C++高易用日志库实现","uri":"/posts/c++%E9%AB%98%E6%98%93%E7%94%A8%E6%97%A5%E5%BF%97%E5%BA%93%E5%AE%9E%E7%8E%B0/"},{"categories":["个人项目"],"content":"如何使用库 ","date":"2022-09-05","objectID":"/posts/c++%E9%AB%98%E6%98%93%E7%94%A8%E6%97%A5%E5%BF%97%E5%BA%93%E5%AE%9E%E7%8E%B0/:2:0","tags":["C++高易用日志库实现"],"title":"C++高易用日志库实现","uri":"/posts/c++%E9%AB%98%E6%98%93%E7%94%A8%E6%97%A5%E5%BF%97%E5%BA%93%E5%AE%9E%E7%8E%B0/"},{"categories":["个人项目"],"content":"如何配置 如下，为整个日志的所有配置项目，当然你也可以不进行配置，也有对应的默认值 #include\"Logger.h\" int main(){ Config::Set({ .print_flag = LstdFlags | lblog::LthreadId, //设置打印的内容，有日期、时间、文件名（长、短）、行号、线程id这些选项可选 （默认为LstdFlags包含Ldata | Ltime | Lshortname | Lline .output_prefix = \"my\", //设置输出日志的前缀名，默认为空 .output_file = \"./log.txt\", //设置输出日志的文件，默认为空 .is_console = true //设置是否输出到控制台，默认为true }); } 注意：如果需要调用此配置函数进行配置，需要在所有打印日志宏调用之前，且同一个进程请不要使用两次配置（因为整个配置是一个单例，配置的更改在同一个进程中会是非线程安全的行为）。 ","date":"2022-09-05","objectID":"/posts/c++%E9%AB%98%E6%98%93%E7%94%A8%E6%97%A5%E5%BF%97%E5%BA%93%E5%AE%9E%E7%8E%B0/:2:1","tags":["C++高易用日志库实现"],"title":"C++高易用日志库实现","uri":"/posts/c++%E9%AB%98%E6%98%93%E7%94%A8%E6%97%A5%E5%BF%97%E5%BA%93%E5%AE%9E%E7%8E%B0/"},{"categories":["个人项目"],"content":"精确控制输出等级 我们的库共提供以下五种宏来进行日志的打印： debug、info、warn、error、fatal 使用debug进行日志输出的，在release模式下将不再进行输出。 我们同样也可以通过手动定义对应的宏控制日志输出等级。 如下： #define LOG_LIMIT_WARN #include \"Logger.h\" int main(){ debug(\"hhh\"); //无效 info(\"hhh\"); //无效 warn(\"hhh\"); //有效 error(\"hhh\"); //有效 fatal(\"hhh\"); //有效 } 同理也可以通过 LOG_LIMIT_ERROR 控制至少是error等级才输出日志。 ","date":"2022-09-05","objectID":"/posts/c++%E9%AB%98%E6%98%93%E7%94%A8%E6%97%A5%E5%BF%97%E5%BA%93%E5%AE%9E%E7%8E%B0/:2:2","tags":["C++高易用日志库实现"],"title":"C++高易用日志库实现","uri":"/posts/c++%E9%AB%98%E6%98%93%E7%94%A8%E6%97%A5%E5%BF%97%E5%BA%93%E5%AE%9E%E7%8E%B0/"},{"categories":["个人项目"],"content":"日志输出介绍 前面介绍了基本的日志的控制，接下来介绍打印输出的功能，以debug和info为例： 本日志的最终输出使用的是C++第三方库 fmt ，虽然在C++20中它已经入标准库了，但是距离我们真正的使用还需要一段时间，下面是简单输出方式，更多的输出方式可以查看fmt官方文档： fmt官方文档 #include\"Logger.h\" int main(){ debug(\"hello {}\",\"world\"); info(\"world {}\",\"hello\"); } 注意：{} 是支持所有的C++标准库容器的，包括vector和string等等容器的直接打印，如 debug(\"{}\",vector\u003cint\u003e{1,3,32,432,432}); 是可行的。但不要忘了链接 fmt 库。 上面的默认输出效果如下：（控制台内是带颜色的，文件就没有颜色了） 整体架构 ","date":"2022-09-05","objectID":"/posts/c++%E9%AB%98%E6%98%93%E7%94%A8%E6%97%A5%E5%BF%97%E5%BA%93%E5%AE%9E%E7%8E%B0/:2:3","tags":["C++高易用日志库实现"],"title":"C++高易用日志库实现","uri":"/posts/c++%E9%AB%98%E6%98%93%E7%94%A8%E6%97%A5%E5%BF%97%E5%BA%93%E5%AE%9E%E7%8E%B0/"},{"categories":["个人项目"],"content":"驾考软件实现文档","date":"2022-09-05","objectID":"/posts/%E9%A9%BE%E8%80%83%E8%BD%AF%E4%BB%B6%E5%AE%9E%E7%8E%B0%E6%96%87%E6%A1%A3/","tags":["驾考软件实现文档"],"title":"驾考软件实现文档","uri":"/posts/%E9%A9%BE%E8%80%83%E8%BD%AF%E4%BB%B6%E5%AE%9E%E7%8E%B0%E6%96%87%E6%A1%A3/"},{"categories":["个人项目"],"content":"整体架构 ","date":"2022-09-05","objectID":"/posts/%E9%A9%BE%E8%80%83%E8%BD%AF%E4%BB%B6%E5%AE%9E%E7%8E%B0%E6%96%87%E6%A1%A3/:0:0","tags":["驾考软件实现文档"],"title":"驾考软件实现文档","uri":"/posts/%E9%A9%BE%E8%80%83%E8%BD%AF%E4%BB%B6%E5%AE%9E%E7%8E%B0%E6%96%87%E6%A1%A3/"},{"categories":["个人项目"],"content":"1.软件后台架构 采用标准的三层架构： Models层用于底层获取数据和对应的序列化过程 Service层用于包装数据提供接口 Controller层用于提供良好易用的接口 后台采用Python语言的fastapi框架编写，数据采用request库请求再用beautifulsoup库解析得到（网络爬虫获得）。 ","date":"2022-09-05","objectID":"/posts/%E9%A9%BE%E8%80%83%E8%BD%AF%E4%BB%B6%E5%AE%9E%E7%8E%B0%E6%96%87%E6%A1%A3/:0:1","tags":["驾考软件实现文档"],"title":"驾考软件实现文档","uri":"/posts/%E9%A9%BE%E8%80%83%E8%BD%AF%E4%BB%B6%E5%AE%9E%E7%8E%B0%E6%96%87%E6%A1%A3/"},{"categories":["个人项目"],"content":"2.软件前台架构 如下图： 整个前台采用跨平台方案flutter框架进行编写 界面如下： 数据流传递 从Api网络调用层级请求得到对应的Future数据 。 传递Future到Service层级。 Service根据UI的需求返回对应的 Future\u003cQuestionResponse\u003e ，且封装默认数据（用于不存在的时的数据）。 在UI层的 MyHomePage 主界面点击按钮后，通过await同步得到Future里的 QuestionResponse 数据并将该数据用于构建一个新的 QuestionPage 界面。 QuestionPage 中通过封装好各个方法通过对应的动作来操作数据生成新的界面。比如题目通过更新 _index 下标再 setState 来实现重建，答案则通过 showAnswer 这个bool标志来判断是否需要显示… 由于每次答案都是得到的Future数据，所以可以在界面中使用 FutureBuilder 来实现数据的展示。 坑点： 注意Future数据不能在底层进行await同步，否则界面层进行调用时数据会得不到，所以网络数据最好是直接传毒Future或者Stream。 注意每个异常的处理，否则它将会导致处理数据的底层完全崩溃（异常不被处理将不再往下走，UI界面表现正常，但是数据无），Flutter很多地方都很容易发生异常，比如类型的强制转化不成功将导致异常（如int转Int64），或者空安全将导致异常（采用?则表示断言会告诉你出现错误的地方，而如果采用!则表示一定不为空，则直接抛出异常很难察觉发生在哪）。 ","date":"2022-09-05","objectID":"/posts/%E9%A9%BE%E8%80%83%E8%BD%AF%E4%BB%B6%E5%AE%9E%E7%8E%B0%E6%96%87%E6%A1%A3/:0:2","tags":["驾考软件实现文档"],"title":"驾考软件实现文档","uri":"/posts/%E9%A9%BE%E8%80%83%E8%BD%AF%E4%BB%B6%E5%AE%9E%E7%8E%B0%E6%96%87%E6%A1%A3/"},{"categories":["C++多线程"],"content":"细粒度锁线程安全队列实现","date":"2022-08-20","objectID":"/posts/%E7%BB%86%E7%B2%92%E5%BA%A6%E9%94%81%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0/","tags":["细粒度锁线程安全队列实现"],"title":"细粒度锁线程安全队列实现","uri":"/posts/%E7%BB%86%E7%B2%92%E5%BA%A6%E9%94%81%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0/"},{"categories":["C++多线程"],"content":"包含同步语义的简单实现 template \u003ctypename T\u003e class ThreadSafeQueue { public: void Push(T new_value) { std::lock_guard\u003cstd::mutex\u003e lk(m_mtx); m_queue.push(std::move(new_value)); m_cond.notify_one(); // 1 } void WaitAndPop(T \u0026value) // 2 { std::unique_lock\u003cstd::mutex\u003e lk(m_mtx); m_cond.wait(lk, [this] { return !m_queue.empty(); }); value = std::move(m_queue.front()); m_queue.pop(); } std::shared_ptr\u003cT\u003e WaitAndPop() // 3 { std::unique_lock\u003cstd::mutex\u003e lk(m_mtx); m_cond.wait(lk, [this] { return !m_queue.empty(); }); // 4 std::shared_ptr\u003cT\u003e res( std::make_shared\u003cT\u003e(std::move(m_queue.front()))); m_queue.pop(); return res; } bool TryPop(T \u0026value) { std::lock_guard\u003cstd::mutex\u003e lk(m_mtx); if (m_queue.empty()) return false; value = std::move(m_queue.front()); m_queue.pop(); return true; } std::shared_ptr\u003cT\u003e TryPop() { std::lock_guard\u003cstd::mutex\u003e lk(m_mtx); if (m_queue.empty()) return std::shared_ptr\u003cT\u003e(); // 5 std::shared_ptr\u003cT\u003e res( std::make_shared\u003cT\u003e(std::move(m_queue.front()))); m_queue.pop(); return res; } bool Empty() const { std::lock_guard\u003cstd::mutex\u003e lk(m_mtx); return m_queue.empty(); } private: mutable mutex m_mtx; queue\u003cT\u003e m_queue; condition_variable m_cond; }; 这个版本是最为简单的实现版本，直接用的stl库中的队列来实现，所有成员函数公用一把锁来实现线程安全，需要注意的点有以下几点： 条件变量产生的虚假唤醒，你可以通过手动while循环来避免，也可以通过在wait后面加上谓词条件（lamda表达式） 锁需要设置为mutable，保证const版本的成员函数可用 但这个实现有非常大的隐患和不足！ ","date":"2022-08-20","objectID":"/posts/%E7%BB%86%E7%B2%92%E5%BA%A6%E9%94%81%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0/:1:0","tags":["细粒度锁线程安全队列实现"],"title":"细粒度锁线程安全队列实现","uri":"/posts/%E7%BB%86%E7%B2%92%E5%BA%A6%E9%94%81%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0/"},{"categories":["C++多线程"],"content":"隐患 如果在调用WaitAndPop函数时发生了异常，由于可能有其他的线程也在调用WaitAndPop发生等待，而由于每次notify一个线程，一旦构造 std::shared_ptr的过程中发生异常，那么其他的线程将会陷入永久的等待！ 解决方法： 由于异常发生在内存的申请过程中，我们如果把 std::queue 中直接存入 shared_ptr 那么就不会有这个问题。 改写后的代码如下： template \u003ctypename T\u003e class ThreadSafeQueue { public: void Push(T new_value) { auto data = std::make_shared(std::move(new_value)); std::lock_guard\u003cstd::mutex\u003e lk(m_mtx); m_queue.push(data); m_cond.notify_one(); // 1 } void WaitAndPop(T \u0026value) // 2 { std::unique_lock\u003cstd::mutex\u003e lk(m_mtx); m_cond.wait(lk, [this] { return !m_queue.empty(); }); value = std::move(*m_queue.front()); m_queue.pop(); } std::shared_ptr\u003cT\u003e WaitAndPop() // 3 { std::unique_lock\u003cstd::mutex\u003e lk(m_mtx); m_cond.wait(lk, [this] { return !m_queue.empty(); }); // 4 std::shared_ptr\u003cT\u003e res = m_queue.front(); m_queue.pop(); return res; } bool TryPop(T \u0026value) { std::lock_guard\u003cstd::mutex\u003e lk(m_mtx); if (m_queue.empty()) return false; value = std::move(*m_queue.front()); m_queue.pop(); return true; } std::shared_ptr\u003cT\u003e TryPop() { std::lock_guard\u003cstd::mutex\u003e lk(m_mtx); if (m_queue.empty()) return std::shared_ptr\u003cT\u003e(); // 5 std::shared_ptr\u003cT\u003e res = m_queue.front(); m_queue.pop(); return res; } bool Empty() const { std::lock_guard\u003cstd::mutex\u003e lk(m_mtx); return m_queue.empty(); } private: mutable mutex m_mtx; queue\u003cstd::shared_ptr\u003cT\u003e\u003e m_queue; condition_variable m_cond; }; 这个版本的代码不仅是预防了异常安全，同样性能也得到了很好的优化，Push 过程的内存申请过程可以放到临界区以外，提高了并发度。 ","date":"2022-08-20","objectID":"/posts/%E7%BB%86%E7%B2%92%E5%BA%A6%E9%94%81%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0/:1:1","tags":["细粒度锁线程安全队列实现"],"title":"细粒度锁线程安全队列实现","uri":"/posts/%E7%BB%86%E7%B2%92%E5%BA%A6%E9%94%81%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0/"},{"categories":["C++多线程"],"content":"设计细粒度锁队列提高并发 前面的简单版本，有个非常明显的不足，几乎没有任何并发的性能，因为所有的成员函数都必须加锁，临界区非常的大，这哪里是并发，这都强行变成了同步执行，那这样肯定不行啊，我们找找原因。 这个原因很简单，由于我们是通过stl内部的queue封装所实现的，我们的任何的成员函数操作实现都必须访问到这个共享变量，一旦变量被共享，要实现线程安全那就必须加锁同步，这便是原因所在了。 这就是我们现在要做的事情，把锁的粒度减少，实际就是把变量的共享和操作细分。 ","date":"2022-08-20","objectID":"/posts/%E7%BB%86%E7%B2%92%E5%BA%A6%E9%94%81%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0/:2:0","tags":["细粒度锁线程安全队列实现"],"title":"细粒度锁线程安全队列实现","uri":"/posts/%E7%BB%86%E7%B2%92%E5%BA%A6%E9%94%81%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0/"},{"categories":["C++多线程"],"content":"细粒度锁队列实现 实现简单队列 在这之前我们先自己实现一个简单的队列，如下： template\u003ctypename T\u003e class Queue { private: struct node { T data_; std::unique_ptr \u003cnode\u003e next_; node(T data) : data_(std::move(data)) {} }; std::unique_ptr \u003cnode\u003e m_head; node *m_tail{}; public: Queue() = default; Queue(const Queue \u0026other) = delete; Queue \u0026operator=(const Queue \u0026other) = delete; std::shared_ptr \u003cT\u003e TryPop() { if (!m_head) { return nullptr; } auto ret = std::make_shared\u003cT\u003e(std::move(m_head-\u003edata_)); auto oldHead = std::move(m_head); m_head = std::move(oldHead-\u003enext_); //这里把next资源进行转移，防止oldHead析构后导致整个链表析构 return ret; } void Push(T new_value) { auto p = std::make_unique\u003cnode\u003e(new_value); auto *new_tail = p.get(); if (m_tail) {//如果队列不为空 m_tail-\u003enext_ = std::move(p); } else {//队列为空则需要特殊处理 m_head = std::move(p); } m_tail = new_tail; } }; next指针为啥不用原始指针？嗯，其实应该要用原始指针的，这里偷个懒，为了不写delete语句，用的unique_ptr，在使用这个独占指针的时候记得要转移所有权，否则会出现连环析构的现象！ 由于使用了unique_ptr管理next_指针，那么析构的时候会自动完成，但是会有个问题，如果队列中的数据量大的话，整个函数栈会爆掉，我亲自测试了下，大概存入的数据量达到1e4级别就会爆栈。。。但是没关系，我们将他用作并发编程中的队列时，用于生产消费的队列里的空闲任务一般也不会到达这个量级，当然有空的话也可以改进然后优化。 分析并发设计 我们再来简单分析下这个内存共享的情况pop操作需要用到head，push操作需要用到head和tail。但是有个严重的问题：除了这两个内存被共享外，由于未采用空头节点，两个成员函数内用 next_ 指针访问到的内存都可能发生共享（对应 m_tail-\u003enext_ 与 oldHead-\u003enext_）。这样的话很难在保证细粒度的情况下实现线程安全了。。。这样下去的实现还不如之前的。 通过分离数据实现并发 前面的隐患已经分析清楚了，如何解决它？你可以使用预分配一个虚拟节点(无数据)，确保这个节点永远在队列的最后，用来分离头尾指针能访问的节点”的办法，走出这个困境。这样通过 pop 和 push 操作通过 next_ 指针访问到的数据就永远不可能是同一个数据了。 代码如下： template\u003ctypename T\u003e class Queue { private: struct node { std::shared_ptr\u003cT\u003e data_; std::unique_ptr \u003cnode\u003e next_; }; std::unique_ptr \u003cnode\u003e m_head; node *m_tail; public: Queue():m_head(new node),m_tail(m_head.get()){}; //初始化空节点 Queue(const Queue \u0026other) = delete; Queue \u0026operator=(const Queue \u0026other) = delete; std::shared_ptr \u003cT\u003e TryPop() { if (m_head.get() == m_tail) { return nullptr; } auto ret = m_head-\u003edata_; auto oldHead = std::move(m_head); m_head = std::move(oldHead-\u003enext_); return ret; } void Push(T new_value) { auto data = std::make_shared\u003cT\u003e(std::move(new_value)); auto p = std::make_unique\u003cnode\u003e(new_value); //新的空节点 m_tail-\u003edata_ = data; //开始移动补充最后的空节点 auto* new_tail = p.get(); m_tail-\u003enext_ = std::move(p); m_tail = new_tail; } }; 现在两个操作共享的内存就只有 m_head 和 m_tail 了，而且在 Push 操作中只使用到了共享内存 m_tail，那么接下来的并发安全实现可以开始细粒度化了，我们用两个互斥锁来实现它。一个互斥锁用于锁住访问m_head的行为，一个用于锁住访问m_tail的行为，具体到代码可以因使用时间的长短对临界区进行进一步缩小。 具体代码如下： template\u003ctypename T\u003e class ThreadSafeQueue { struct node { std::shared_ptr \u003cT\u003e data; std::unique_ptr \u003cnode\u003e next; }; std::mutex m_headMtx; std::unique_ptr \u003cnode\u003e m_head; std::mutex m_tailMtx; node *m_tail; public: ThreadSafeQueue() : m_head(new node), m_tail(m_head.get()) {} ThreadSafeQueue(const ThreadSafeQueue \u0026other) = delete; ThreadSafeQueue \u0026operator=(const ThreadSafeQueue \u0026other) = delete; std::shared_ptr \u003cT\u003e TryPop() { std::unique_ptr \u003cnode\u003e old_head = pop_head(); return old_head ? old_head-\u003edata : std::shared_ptr\u003cT\u003e(); } void Push(T new_value) { std::shared_ptr \u003cT\u003e new_data( std::make_shared\u003cT\u003e(std::move(new_value))); std::unique_ptr \u003cnode\u003e p(new node); node *const new_tail = p.get(); //开始锁临界区 std::lock_guard \u003cstd::mutex\u003e tail_lock(m_tailMtx); m_tail-\u003edata = new_data; m_tail-\u003enext = std::move(p); m_tail = new_tail; } private: node *get_tail() { std::lock_guard \u003cstd::mutex\u003e tail_lock(m_tailMtx); return m_tail; } std::unique_ptr \u003cnode\u003e pop_head() { //这里head一定要先被锁 std::lock_guard \u003cstd::mutex\u003e head_lock(m_headMtx); if (m_head.get() == get_tail()) { return nullptr; } std::unique_ptr \u003cnode\u003e old_head = std::move(m_head); m_head = std::move(old_head-\u003enext); return old_head; } }; 注意： 当get_tail()调用前，请确保 m_headMtx 已经上锁，这一步也是很重要的哦。如果不这样，调用pop_head()时，就无法确保 get_tail 得到的数据在使用的时候为最新，如下代码，如果进入head_lock临界区后，old_tail被其他线程改了，那么整个操作就不对了。 std::unique_ptr\u003cnode\u003e pop_head() // 这是个有缺陷的实现 { node* const old_tail=get_tail(); // ① 在m_headMtx范围外获取旧尾节点的值 std::lock_guard\u003cstd::mutex\u003e head_lock(head_mutex); if(head.get()==old_tail) // ② { return nullptr; } std::unique_ptr\u003cnode\u003e old_head=std::move(head); head=std::move(old_head-\u003enext); // ③ return old_head; } 再来看看异常安全是否有保证，","date":"2022-08-20","objectID":"/posts/%E7%BB%86%E7%B2%92%E5%BA%A6%E9%94%81%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0/:2:1","tags":["细粒度锁线程安全队列实现"],"title":"细粒度锁线程安全队列实现","uri":"/posts/%E7%BB%86%E7%B2%92%E5%BA%A6%E9%94%81%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0/"},{"categories":["C++多线程"],"content":"添加条件变量实现同步等待 现在已经实现了细粒度锁的线程安全队列，不过只有TryPop()可以并发访问(且只有一个重载存在)。那么方便的同步的WaitAndPop()呢？ Push实现 向队列中添加新节点是相当简单的——下面的实现与上面的代码差不多。 template\u003ctypename T\u003e void ThreadSafe\u003cT\u003e::Push(T new_value) { auto new_data = std::make_shared\u003cT\u003e(std::move(new_value)); std::unique_ptr\u003cnode\u003e p(new node); {//生产临界区 std::lock_guard\u003cstd::mutex\u003e tail_lock(tail_mutex); tail-\u003edata=new_data; auto* new_tail=p.get(); tail-\u003enext=std::move(p); tail=new_tail; } data_cond.notify_one(); } WaitAndPop实现 template\u003ctypename T\u003e class ThreadSafeQueue { private: node* get_tail() { std::lock_guard\u003cstd::mutex\u003e tail_lock(tail_mutex); return tail; } std::unique_ptr\u003cnode\u003e pop_head() // 1 { std::unique_ptr\u003cnode\u003e old_head=std::move(head); head=std::move(old_head-\u003enext); return old_head; } std::unique_lock\u003cstd::mutex\u003e wait_for_data() // 2 { std::unique_lock\u003cstd::mutex\u003e head_lock(head_mutex); data_cond.wait(head_lock,[\u0026]{return head.get()!=get_tail();}); return std::move(head_lock); // 3 } std::unique_ptr\u003cnode\u003e wait_pop_head() { std::unique_lock\u003cstd::mutex\u003e head_lock(wait_for_data()); // 4 return pop_head(); } std::unique_ptr\u003cnode\u003e wait_pop_head(T\u0026 value) { std::unique_lock\u003cstd::mutex\u003e head_lock(wait_for_data()); // 5 value=std::move(*head-\u003edata); return pop_head(); } public: std::shared_ptr\u003cT\u003e WaitAndPop() { std::unique_ptr\u003cnode\u003e const old_head=wait_pop_head(); return old_head-\u003edata; } void WaitAndPop(T\u0026 value) { auto _ = wait_pop_head(value); } }; 可能大家看到代码好像有点多，实际上都只是为了代码的重用，例如pop_head()①和wait_for_data()②，这些函数分别是删除头结点和等待队列中有数据弹出的。wait_for_data()特别值得关注，因为其不仅等待使用lambda函数对条件变量进行等待，而且它还会将锁的实例返回给调用者③。这就确保了wait_pop_head的线程安全。pop_head()是对TryPop()代码的复用。 TryPop和Empty实现 template\u003ctypename T\u003e class ThreadSafeQueue { private: std::unique_ptr\u003cnode\u003e try_pop_head() { std::lock_guard\u003cstd::mutex\u003e head_lock(head_mutex); if(head.get()==get_tail()) { return std::unique_ptr\u003cnode\u003e(); } return pop_head(); } std::unique_ptr\u003cnode\u003e try_pop_head(T\u0026 value) { std::lock_guard\u003cstd::mutex\u003e head_lock(head_mutex); if(head.get()==get_tail()) { return std::unique_ptr\u003cnode\u003e(); } value=std::move(*head-\u003edata); return pop_head(); } public: std::shared_ptr\u003cT\u003e TryPop() { std::unique_ptr\u003cnode\u003e old_head=try_pop_head(); return old_head?old_head-\u003edata:std::shared_ptr\u003cT\u003e(); } bool TryPop(T\u0026 value) { std::unique_ptr\u003cnode\u003e const old_head=try_pop_head(value); return old_head; } void Empty() { std::lock_guard\u003cstd::mutex\u003e head_lock(head_mutex); return (head.get()==get_tail()); } }; ","date":"2022-08-20","objectID":"/posts/%E7%BB%86%E7%B2%92%E5%BA%A6%E9%94%81%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0/:2:2","tags":["细粒度锁线程安全队列实现"],"title":"细粒度锁线程安全队列实现","uri":"/posts/%E7%BB%86%E7%B2%92%E5%BA%A6%E9%94%81%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0/"},{"categories":["C++多线程"],"content":"简单测试 一个生产者，三个消费者，数据量15000 次数 v1版本 v3版本 v3原始指针版 第一次 7.31ms 8.51 8.53 第二次 6.61ms 9.26 7.25 第三次 7.60ms 8.90 7.95 一个生产者，三个同时消费生产，一个消费，数据量1500000 次数 v1版本 v3版本 v3原始指针版 第一次 397.90 爆栈 399.68 第二次 398.0 爆栈 362.06 第三次 319.28 爆栈 355.62 我的测试仅限于少量线程，而且任务负担也不重，故测出来的结果竟然是直接封装标准库的队列性能最好（都是在release模式下），我猜大概率是标准库的内存分配器优于我这个简单的内存管理，再加上我测试的线程数量非常少，细粒度的锁并未体现出它的优势。。。 ","date":"2022-08-20","objectID":"/posts/%E7%BB%86%E7%B2%92%E5%BA%A6%E9%94%81%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0/:3:0","tags":["细粒度锁线程安全队列实现"],"title":"细粒度锁线程安全队列实现","uri":"/posts/%E7%BB%86%E7%B2%92%E5%BA%A6%E9%94%81%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0/"},{"categories":["C++多线程"],"content":"完整代码 代码仓库：thread_safe_queue ","date":"2022-08-20","objectID":"/posts/%E7%BB%86%E7%B2%92%E5%BA%A6%E9%94%81%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0/:4:0","tags":["细粒度锁线程安全队列实现"],"title":"细粒度锁线程安全队列实现","uri":"/posts/%E7%BB%86%E7%B2%92%E5%BA%A6%E9%94%81%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0/"},{"categories":["C++多线程"],"content":"async、packaged_task、promise、future的区别与使用","date":"2022-08-17","objectID":"/posts/asyncpackage_task%E7%9A%84%E5%8C%BA%E5%88%AB%E4%B8%8E%E4%BD%BF%E7%94%A8/","tags":["async、packaged_task、promise、future的区别与使用"],"title":"async、packaged_task、promise、future的区别与使用","uri":"/posts/asyncpackage_task%E7%9A%84%E5%8C%BA%E5%88%AB%E4%B8%8E%E4%BD%BF%E7%94%A8/"},{"categories":["C++多线程"],"content":"使用方法 想要更详尽的介绍可以看看这本书，这几个函数牵扯到的内容是并发操作的同步，对应《C++并发编程实战》的第四章，这本书很难啃，有很多地方我也是断断续续看了几遍才有体会。 首先我们来看看让人迷惑的地方：std::aync、std::package_task、std::promise 这几个调用都能获得 std::future，那到底有什么区别呢？下面我们挨个来看看基本使用方法，再进行一个小总结。 ","date":"2022-08-17","objectID":"/posts/asyncpackage_task%E7%9A%84%E5%8C%BA%E5%88%AB%E4%B8%8E%E4%BD%BF%E7%94%A8/:1:0","tags":["async、packaged_task、promise、future的区别与使用"],"title":"async、packaged_task、promise、future的区别与使用","uri":"/posts/asyncpackage_task%E7%9A%84%E5%8C%BA%E5%88%AB%E4%B8%8E%E4%BD%BF%E7%94%A8/"},{"categories":["C++多线程"],"content":"std::async 前言 async 这个词在其他语言中想必也不陌生，比如 js 里有await和async关键字用于执行异步任务等等，C++中的这个词表示一个函数，实际上也是用于异步执行。但是与js那个实现原理有很大的不同，简单的说就是js那个更加的上层，而C++这个偏底层。导致的区别就是js那两个关键字配合起来只为达到并发的效果，而其中的实现细节是非常复杂的，比如js实际上始终只用到了一个线程来实现了并发，这点类似于协程，具体到内部js是通过事件循环队列来实现的，所以你始终无法确切的理解到它的底层工作。 而C++的async与之相比，就好像一个原始人，需要你传递参数来确定它的工作机制，但和C++标准库的其他api相比，它却是非常高级的存在。 使用 在此之前先简单了解下C++的async使用方式，一个简单的代码如下： #include \u003cfuture\u003e#include \u003ciostream\u003eint find_the_answer_to_ltuae(); void do_other_stuff(); int main() { std::future\u003cint\u003e the_answer=std::async(find_the_answer_to_ltuae); do_other_stuff(); std::cout\u003c\u003c\"The answer is \"\u003c\u003cthe_answer.get()\u003c\u003cstd::endl; } 这个函数会返回一个future用于将异步的任务和主线程同步。也就是当你调用future的get方法时，它会等待异步任务完成，并得到对应的返回值。 关于 std::future 也有三个重要的api：wait、wait_for、get，前面两个不返回结果，只等待任务，wait_for可以设置等待的时间限制。 但是请注意，这个任务不一定是按照你想的那样异步执行的，它可能在你调用get方法的时候才执行，这个取决于你传递的第一个参数。 std::launch::async：表示会开启一个线程去执行任务。 std::launch::deferred：表示延迟调用，只有在外界需要得到结果的时候才调用。 不传参数或者两者相与：表示由C++底层去调度，可能是async也可能是defferred。 实际上async函数在这几个C++的api里是最高级的，它同时拥有了异步与同步的能力。 ","date":"2022-08-17","objectID":"/posts/asyncpackage_task%E7%9A%84%E5%8C%BA%E5%88%AB%E4%B8%8E%E4%BD%BF%E7%94%A8/:2:0","tags":["async、packaged_task、promise、future的区别与使用"],"title":"async、packaged_task、promise、future的区别与使用","uri":"/posts/asyncpackage_task%E7%9A%84%E5%8C%BA%E5%88%AB%E4%B8%8E%E4%BD%BF%E7%94%A8/"},{"categories":["C++多线程"],"content":"std::packaged_task 这个api与线程是没有任何关系的，它只是负责把普通的函数或者仿函数包装成方便异步转同步的任务。 比如我们开启一个线程去执行任务，我们又想对外界保有同步获取任务结果的能力，这个时候就需要用 std::package_task 来对现有的任务进行封装了。 如下代码： 以抖音用户的一次点赞行为对应的数据库底层需要调用的api举例子： plusVideoLike:增加对应视频的点赞数目，返回值为自定义的error类型 plusUserLikeList:增加用户喜欢的视频，返回值为自定义的error类型 很明显，这个两个过程互相并不影响，可以使用并发操作进行。 UserService::addLike(int uid,int vid){ auto task1 = std::package_task\u003cerror(int)\u003e{plusVideoLike}; auto task2 = std::package_task\u003cerror(int,int)\u003e{plusUserLikeList}; auto f1 = task1.get_future(); auto f2 = task2.get_future(); std::thread t1([\u0026](){ task1(vid); //video点赞+1 }); std::thread t2([\u0026](){ task2(uid,vid); //用户点赞视频+1 }); //得到返回值的同时完成同步操作 if(f1.get() == 某错误){ } if(f2.get()== 某错误{ } } ","date":"2022-08-17","objectID":"/posts/asyncpackage_task%E7%9A%84%E5%8C%BA%E5%88%AB%E4%B8%8E%E4%BD%BF%E7%94%A8/:3:0","tags":["async、packaged_task、promise、future的区别与使用"],"title":"async、packaged_task、promise、future的区别与使用","uri":"/posts/asyncpackage_task%E7%9A%84%E5%8C%BA%E5%88%AB%E4%B8%8E%E4%BD%BF%E7%94%A8/"},{"categories":["C++多线程"],"content":"std::promise 从上面看下来，我们其实不难发现，async和packaged_task好像有某种联系？似乎async是封装了packaged_task的方便操作的api，没错大概就是这样。同样promise也是packaged_task中不可缺少的一环。 std::promise算是C++中提供的方便线程间通信的纽带之一，它的行为有些类似于管道，熟悉Go的朋友，你可以把这个类似于无缓冲的管道，通过promise我们存入数据，通过它的future我们读取数据，这里就类似于管道的读写了，只不过不能通过一个类型进行双向读写，这一点还是没有Golang的方便啊。 线程间通信我们一般都是通过共享内存，而共享内存写起来就很麻烦，为了线程安全以及事件完成的通知还要手动去封装一大堆的东西（用条件变量、信号量之类的去封装），我们大部分场景并不需要这么高的控制粒度，所以标准库帮你封装了一个promise和对应的future进行线程间的通信也是一个选择，当然如果能再进化成Golang中的channl模样，那就更好了（似乎C++20有协程又有管道😁）。 说了这么多，来一个简单的例子吧。 我们再切换到一个场景：实现一个聊天程序的后台服务器，我们举其中较为契合的地方，比如一个聊天室的消息收发，当聊天室里的一个人发送消息后，需要将该消息对聊天室里的其他人进行广播，这个广播的过程，我们可以用并发来进行，但是最好建议不要把每个任务都开启一个新线程去执行，这样服务器迟早崩溃，最好的做法是使用线程池或者直接上协程无所畏惧。这里的执行成功或者失败需要传递到外界，这时我们可以使用promise当然你也可以用package_task将任务进行封装，只不过没有promise灵活（但大部分时候比promise好用，比如这里我还是用package_task好些） 我们把该类命名为ChatRoom类，方法如下： broadcast(int userId,Message msg);用于对消息进行广播 房间内有非常多的用户对应User类，而user有对应的接收消息的方法： receive(Message msg); 接收对应的消息 broadcast(int userId,Message msg){ vector\u003cfuture\u003cerror\u003e\u003e futures; for(auto\u0026\u0026 user:Users){ if(user.id != userId){ thread_pool.submit([\u0026]{ package_task\u003cbool(Message)\u003etask{std::bind(User::recive,\u0026user)}; futures.push_back(task.get_future()); task(msg); }); } } bool f; do{ //主线程等待完成并进行对应的错误处理，当全都完成任务执行完成 f = true; for(auto\u0026\u0026 f:futures){ if(f.wait_for(std::chrono::seconds(1) == std::future_status::ready){ ... //对应的错误处理 continue; } f = false; } }while(f); } 其实这里的线程池返回一个 future 是最好，否则同步操作将不那么优雅。 ","date":"2022-08-17","objectID":"/posts/asyncpackage_task%E7%9A%84%E5%8C%BA%E5%88%AB%E4%B8%8E%E4%BD%BF%E7%94%A8/:4:0","tags":["async、packaged_task、promise、future的区别与使用"],"title":"async、packaged_task、promise、future的区别与使用","uri":"/posts/asyncpackage_task%E7%9A%84%E5%8C%BA%E5%88%AB%E4%B8%8E%E4%BD%BF%E7%94%A8/"},{"categories":["C++多线程"],"content":"自顶向下 看完上面的内容，相信你对这些线程同步的api应该有了一定的了解，我们会发现这几个api的应用场景都非常相似，实际上是一层套一层的往上进行封装起来得到对应的功能的。 有了promise，我们可以封装出package_task，有了package_task我们可以封装出async，这都是一环套一环，使用的复杂度不断降低的同时，线程同步的灵活性也在不断降低。当我们需要自己封装一套工具的时候，大概率是用的promise和package_task比较多，而我们只管简单使用时，则最好时使用已经封装好的上层api。比如我们如果要自己实现一个返回future的线程池，那么封装packaged_task是最好的选择。 现在我们自顶向下，来简单看看如何实现（以下代码非原创，如有雷同，那就是我抄的😥）。 ","date":"2022-08-17","objectID":"/posts/asyncpackage_task%E7%9A%84%E5%8C%BA%E5%88%AB%E4%B8%8E%E4%BD%BF%E7%94%A8/:5:0","tags":["async、packaged_task、promise、future的区别与使用"],"title":"async、packaged_task、promise、future的区别与使用","uri":"/posts/asyncpackage_task%E7%9A%84%E5%8C%BA%E5%88%AB%E4%B8%8E%E4%BD%BF%E7%94%A8/"},{"categories":["C++多线程"],"content":"用packaged_task实现async std::future\u003cint\u003e my_async(function\u003cint(int i)\u003e task, int i) { std::packaged_task\u003cint(int)\u003e package{task}; std::future\u003cint\u003e f = package.get_future(); std::thread t(std::move(package), i); t.detach(); return f; } int main() { auto task = [](int i) { std::this_thread::sleep_for(std::chrono::seconds(5)); return i+100; }; std::future\u003cint\u003e f = my_async(task, 5); std::cout \u003c\u003c f.get() \u003c\u003c std::endl; return 0; } ","date":"2022-08-17","objectID":"/posts/asyncpackage_task%E7%9A%84%E5%8C%BA%E5%88%AB%E4%B8%8E%E4%BD%BF%E7%94%A8/:5:1","tags":["async、packaged_task、promise、future的区别与使用"],"title":"async、packaged_task、promise、future的区别与使用","uri":"/posts/asyncpackage_task%E7%9A%84%E5%8C%BA%E5%88%AB%E4%B8%8E%E4%BD%BF%E7%94%A8/"},{"categories":["C++多线程"],"content":"使用promise实现packaged_task template \u003ctypename\u003e class my_task; template \u003ctypename R, typename ...Args\u003e class my_task\u003cR(Args...)\u003e { std::function\u003cR(Args...)\u003e fn; std::promise\u003cR\u003e pr; // the promise of the result public: template \u003ctypename ...Ts\u003e explicit my_task(Ts \u0026\u0026... ts) : fn(std::forward\u003cTs\u003e(ts)...) { } template \u003ctypename ...Ts\u003e void operator()(Ts \u0026\u0026... ts) { pr.set_value(fn(std::forward\u003cTs\u003e(ts)...)); // fulfill the promise } std::future\u003cR\u003e get_future() { return pr.get_future(); } // disable copy, default move }; ","date":"2022-08-17","objectID":"/posts/asyncpackage_task%E7%9A%84%E5%8C%BA%E5%88%AB%E4%B8%8E%E4%BD%BF%E7%94%A8/:5:2","tags":["async、packaged_task、promise、future的区别与使用"],"title":"async、packaged_task、promise、future的区别与使用","uri":"/posts/asyncpackage_task%E7%9A%84%E5%8C%BA%E5%88%AB%E4%B8%8E%E4%BD%BF%E7%94%A8/"},{"categories":["C++多线程"],"content":"总结 如果需要封装自己的api方便使用，那么packaged_task和promise可能是你最常用的。 如果想要开箱即用，那么直接async也挺好。 ","date":"2022-08-17","objectID":"/posts/asyncpackage_task%E7%9A%84%E5%8C%BA%E5%88%AB%E4%B8%8E%E4%BD%BF%E7%94%A8/:6:0","tags":["async、packaged_task、promise、future的区别与使用"],"title":"async、packaged_task、promise、future的区别与使用","uri":"/posts/asyncpackage_task%E7%9A%84%E5%8C%BA%E5%88%AB%E4%B8%8E%E4%BD%BF%E7%94%A8/"},{"categories":["面试相关"],"content":"C++面试一条龙","date":"2022-08-05","objectID":"/posts/c++%E9%9D%A2%E8%AF%95%E4%B8%80%E6%9D%A1%E8%B7%AF/","tags":["C++面试一条龙"],"title":"C++面试面试一条龙","uri":"/posts/c++%E9%9D%A2%E8%AF%95%E4%B8%80%E6%9D%A1%E8%B7%AF/"},{"categories":["面试相关"],"content":"面试题的学习（八股文 cpp面试题1 cpp面试题2 面向企业刷题的刷题网站 ","date":"2022-08-05","objectID":"/posts/c++%E9%9D%A2%E8%AF%95%E4%B8%80%E6%9D%A1%E8%B7%AF/:1:0","tags":["C++面试一条龙"],"title":"C++面试面试一条龙","uri":"/posts/c++%E9%9D%A2%E8%AF%95%E4%B8%80%E6%9D%A1%E8%B7%AF/"},{"categories":["面试相关"],"content":"计算机系统和计算机网络视频学习 ","date":"2022-08-05","objectID":"/posts/c++%E9%9D%A2%E8%AF%95%E4%B8%80%E6%9D%A1%E8%B7%AF/:2:0","tags":["C++面试一条龙"],"title":"C++面试面试一条龙","uri":"/posts/c++%E9%9D%A2%E8%AF%95%E4%B8%80%E6%9D%A1%E8%B7%AF/"},{"categories":["面试相关"],"content":"计算机系统 准备面试用 深入学习用 ","date":"2022-08-05","objectID":"/posts/c++%E9%9D%A2%E8%AF%95%E4%B8%80%E6%9D%A1%E8%B7%AF/:2:1","tags":["C++面试一条龙"],"title":"C++面试面试一条龙","uri":"/posts/c++%E9%9D%A2%E8%AF%95%E4%B8%80%E6%9D%A1%E8%B7%AF/"},{"categories":["面试相关"],"content":"计算机网络 准备面试用 深入学习用 ","date":"2022-08-05","objectID":"/posts/c++%E9%9D%A2%E8%AF%95%E4%B8%80%E6%9D%A1%E8%B7%AF/:2:2","tags":["C++面试一条龙"],"title":"C++面试面试一条龙","uri":"/posts/c++%E9%9D%A2%E8%AF%95%E4%B8%80%E6%9D%A1%E8%B7%AF/"},{"categories":["面试相关"],"content":"项目准备 项目我的建议是看书+动手敲+解决问题 ","date":"2022-08-05","objectID":"/posts/c++%E9%9D%A2%E8%AF%95%E4%B8%80%E6%9D%A1%E8%B7%AF/:3:0","tags":["C++面试一条龙"],"title":"C++面试面试一条龙","uri":"/posts/c++%E9%9D%A2%E8%AF%95%E4%B8%80%E6%9D%A1%E8%B7%AF/"},{"categories":["面试相关"],"content":"书籍推荐 入门+浅浅实战 深入实战 ","date":"2022-08-05","objectID":"/posts/c++%E9%9D%A2%E8%AF%95%E4%B8%80%E6%9D%A1%E8%B7%AF/:3:1","tags":["C++面试一条龙"],"title":"C++面试面试一条龙","uri":"/posts/c++%E9%9D%A2%E8%AF%95%E4%B8%80%E6%9D%A1%E8%B7%AF/"},{"categories":["面试相关"],"content":"视频推荐 零基础相关视频学习、 这个视频基本上可以平替第一本书，但是第一本书里面的系统调用讲解的更为丰富和全面，这个视频讲解的是用到最多的。 视频链接 muduo网络库相关 这两个视频都是围绕第二本书的库进行讲解 muduo网络库源码解析 这个视频不全 muduo网络库从0知识解析 ","date":"2022-08-05","objectID":"/posts/c++%E9%9D%A2%E8%AF%95%E4%B8%80%E6%9D%A1%E8%B7%AF/:3:2","tags":["C++面试一条龙"],"title":"C++面试面试一条龙","uri":"/posts/c++%E9%9D%A2%E8%AF%95%E4%B8%80%E6%9D%A1%E8%B7%AF/"},{"categories":["个人轮子计划"],"content":"JSON解析器实现","date":"2022-07-27","objectID":"/posts/json%E8%A7%A3%E6%9E%90%E5%99%A8%E5%AE%9E%E7%8E%B0/","tags":["JSON解析器实现"],"title":"JSON解析器实现","uri":"/posts/json%E8%A7%A3%E6%9E%90%E5%99%A8%E5%AE%9E%E7%8E%B0/"},{"categories":["个人轮子计划"],"content":" 代码开源仓库：cpp造轮子项目–实现json解析器 ","date":"2022-07-27","objectID":"/posts/json%E8%A7%A3%E6%9E%90%E5%99%A8%E5%AE%9E%E7%8E%B0/:0:0","tags":["JSON解析器实现"],"title":"JSON解析器实现","uri":"/posts/json%E8%A7%A3%E6%9E%90%E5%99%A8%E5%AE%9E%E7%8E%B0/"},{"categories":["个人轮子计划"],"content":"JSON格式介绍 JSON(JavaScript Object Notation)，是一种序列化的格式，最大的优点在于可读性极强，以及可直接嵌入到js代码中，所以广泛运用于web数据的收发。 JSON格式有以下基本类型： null类型：值为null，表示为空 bool类型：值为true和false number类型：值为int、double（即整数或小数 string类型：形如 “abc” 以及以下复合类型： list类型（也称array类型） [\"abc\",3.2,323,\"sdaf\"] dict类型（也称object类型） { \"id\":32, \"name\":\"hhh\" } ","date":"2022-07-27","objectID":"/posts/json%E8%A7%A3%E6%9E%90%E5%99%A8%E5%AE%9E%E7%8E%B0/:1:0","tags":["JSON解析器实现"],"title":"JSON解析器实现","uri":"/posts/json%E8%A7%A3%E6%9E%90%E5%99%A8%E5%AE%9E%E7%8E%B0/"},{"categories":["个人轮子计划"],"content":"解析json字符串 整套解析流程如下： ","date":"2022-07-27","objectID":"/posts/json%E8%A7%A3%E6%9E%90%E5%99%A8%E5%AE%9E%E7%8E%B0/:2:0","tags":["JSON解析器实现"],"title":"JSON解析器实现","uri":"/posts/json%E8%A7%A3%E6%9E%90%E5%99%A8%E5%AE%9E%E7%8E%B0/"},{"categories":["个人轮子计划"],"content":"创建JObject类 我们需要把json的类型对应到计算机语言的类型。 由于json的数据在我们看来都是字符串，那么有如下对应关系： “null\"对应我们构造的null类型 “true”,“false\"对应内部的bool类型即可 number类型数据对应int、double类型 string类型数据对应string即可 list类型对应C++中的vector dict类型对应C++中的map或unordered_map 我们在计算机语言中，需要构造一个对象类型，用于将以上类型全部涵盖。 在C++中我们通过std::variant来进行，还需要一个枚举tag来表示当前对象内存储的数据类型。 当然如果做的更绝的话，可以通过一个void* + 申请堆内存来解决，然后再强转为对应类型来操作。 对应的代码如下：（中间的类方法就暂时省略了 enum TYPE { T_NULL, T_BOOL, T_INT, T_DOUBLE, T_STR, T_LIST, T_DICT }; using null_t = string; using int_t = int32_t; using bool_t = bool; using double_t = double; using str_t = string; using list_t = vector\u003cJObject\u003e; using dict_t = map\u003cstring, JObject\u003e; class JObject { public: using value_t = variant\u003cbool_t, int_t, double_t, str_t, list_t, dict_t\u003e; ... private: TYPE m_type; value_t m_value; }; ","date":"2022-07-27","objectID":"/posts/json%E8%A7%A3%E6%9E%90%E5%99%A8%E5%AE%9E%E7%8E%B0/:2:1","tags":["JSON解析器实现"],"title":"JSON解析器实现","uri":"/posts/json%E8%A7%A3%E6%9E%90%E5%99%A8%E5%AE%9E%E7%8E%B0/"},{"categories":["个人轮子计划"],"content":"创建Parser类 我们有了JObject，可以把所有的JSON数据接收起来，现在要做的就是扫描JSON字符串，对其中的数据进行读取处理，然后转化为JObject。 关键代码如下： JObject Parser::parse() { char token = get_next_token(); if (token == 'n') { return parse_null(); } if (token == 't' || token == 'f') { return parse_bool(); } if (token == '-' || std::isdigit(token)) { return parse_number(); } if (token == '\\\"') { return parse_string(); } if (token == '[') { return parse_list(); } if (token == '{') { return parse_dict(); } throw std::logic_error(\"unexpected character in parse json\"); } 以上就是整个字符串的解析过程，每次通过get_next_token这个方法得到整个字符串的下一个token，根据token决定解析对应的数据类型。 get_next_token方法 跳过空白符号，以及跳过注释（标准的JSON格式不支持注释，我这里硬加的，为了vscode的JSON格式配置文件解析 char Parser::get_next_token() { while (std::isspace(m_str[m_idx])) m_idx++; if (m_idx \u003e= m_str.size()) throw std::logic_error(\"unexpected character in parse json\"); //如果是注释，记得跳过 skip_comment(); return m_str[m_idx]; } parse_null和parse_bool 由于这两个很简单，就放在一起了。 parse_null JObject Parser::parse_null() { if (m_str.compare(m_idx, 4, \"null\") == 0) { m_idx += 4; return {}; } throw std::logic_error(\"parse null error\"); } parse_bool bool Parser::parse_bool() { if (m_str.compare(m_idx, 4, \"true\") == 0) { m_idx += 4; return \"true\"; } if (m_str.compare(m_idx, 5, \"false\") == 0) { m_idx += 5; return \"false\"; } throw std::logic_error(\"parse bool error\"); } parse_number JObject Parser::parse_number() { auto pos = m_idx; //integer part if (m_str[m_idx] == '-') { m_idx++; } if (isdigit(m_str[m_idx])) while (isdigit(m_str[m_idx])) m_idx++; else { throw std::logic_error(\"invalid character in number\"); } if (m_str[m_idx] != '.') { return (int) strtol(m_str.c_str() + pos, nullptr, 10); } //decimal part if (m_str[m_idx] == '.') { m_idx++; if (!std::isdigit(m_str[m_idx])) { throw std::logic_error(\"at least one digit required in parse float part!\"); } while (std::isdigit(m_str[m_idx])) m_idx++; } return strtof64(m_str.c_str() + pos, nullptr); } parse_list JObject Parser::parse_list() { JObject arr((list_t()));//得到list类型的JObject m_idx++; char ch = get_next_token(); if (ch == ']') { m_idx++; return arr; } while (true) { arr.push_back(parse()); ch = get_next_token(); if (ch == ']') { m_idx++; break; } if (ch != ',') //如果不是逗号 { throw std::logic_error(\"expected ',' in parse list\"); } //跳过逗号 m_idx++; } return arr; } parse_dict JObject Parser::parse_dict() { JObject dict((dict_t()));//得到dict类型的JObject m_idx++; char ch = get_next_token(); if (ch == '}') { m_idx++; return dict; } while (true) { //解析key string key = std::move(parse().Value\u003cstring\u003e()); ch = get_next_token(); if (ch != ':') { throw std::logic_error(\"expected ':' in parse dict\"); } m_idx++; //解析value dict[key] = parse(); ch = get_next_token(); if (ch == '}') { m_idx++; break; //解析完毕 } if (ch != ',')//没有结束，此时必须为逗号 { throw std::logic_error(\"expected ',' in parse dict\"); } //跳过逗号 m_idx++; } return dict; } ","date":"2022-07-27","objectID":"/posts/json%E8%A7%A3%E6%9E%90%E5%99%A8%E5%AE%9E%E7%8E%B0/:2:2","tags":["JSON解析器实现"],"title":"JSON解析器实现","uri":"/posts/json%E8%A7%A3%E6%9E%90%E5%99%A8%E5%AE%9E%E7%8E%B0/"},{"categories":["个人轮子计划"],"content":"完善JObject类 很明显，我们需要为JObject类提供一个方法，此方法可以让调用者直接访问到std::variant里面对应的数据，并且我们也需要提供一个方法能让JObject快速初始化为对应的类型。 ","date":"2022-07-27","objectID":"/posts/json%E8%A7%A3%E6%9E%90%E5%99%A8%E5%AE%9E%E7%8E%B0/:3:0","tags":["JSON解析器实现"],"title":"JSON解析器实现","uri":"/posts/json%E8%A7%A3%E6%9E%90%E5%99%A8%E5%AE%9E%E7%8E%B0/"},{"categories":["个人轮子计划"],"content":"初始化接口 添加好下面这些方法后，外界可通过调用方法把JObject的内部状态改变。 void Null() { m_type = T_NULL; m_value = \"null\"; } void Int(int_t value) { m_value = value; m_type = T_INT; } void Bool(bool_t value) { m_value = value; m_type = T_BOOL; } void Double(double_t value) { m_type = T_DOUBLE; m_value = value; } void Str(string_view value) { m_value = string(value); m_type = T_STR; } void List(list_t value) { m_value = std::move(value); m_type = T_LIST; } void Dict(dict_t value) { m_value = std::move(value); m_type = T_DICT; } 为了方便平时的赋值时候的隐式转化，我们应该再添加对应的构造函数，如下：（隐式转化在C++里有个坑，只能为类提供一种方向的隐式转化，比如提供了int把转为JObject的隐式转化后，就不能再提供把JObject转为int的隐式转化了，这两种必须要有一个是explicit，否则报错 JObject()//默认为null类型 { m_type = T_NULL; m_value = \"null\"; } JObject(int_t value) { Int(value); } JObject(bool_t value) { Bool(value); } JObject(double_t value) { Double(value); } JObject(str_t const \u0026value) { Str(value); } JObject(list_t value) { List(std::move(value)); } JObject(dict_t value) { Dict(std::move(value)); } ","date":"2022-07-27","objectID":"/posts/json%E8%A7%A3%E6%9E%90%E5%99%A8%E5%AE%9E%E7%8E%B0/:3:1","tags":["JSON解析器实现"],"title":"JSON解析器实现","uri":"/posts/json%E8%A7%A3%E6%9E%90%E5%99%A8%E5%AE%9E%E7%8E%B0/"},{"categories":["个人轮子计划"],"content":"请求值接口 设计思路：本人不喜欢一大堆的get/set，那样真的是麻烦。我通过提供一个Value方法，该方法为泛型，其内部有调用value()方法得到对应的数据指针，而Value方法则负责将指针强转，其内部也实现了强大的错误处理，防止处理指针的意外宕机。。。 value方法如下，用于调用get_if得到对应的数据指针，关于怎么获取std::variant的数据，有get和get_if两种方式，get得到的是对象的引用，如果获取不到，则抛出异常，get_if获取对象的指针，如果获取不到则返回nullptr。我选择使用get_if的原因是，这个异常的处理可以由你自己来设定提示，而不是对着底层的get提示而摸不着头脑。 void *JObject::value() { switch (m_type) { case T_NULL: return get_if\u003cstr_t\u003e(\u0026m_value); case T_BOOL: return get_if\u003cbool_t\u003e(\u0026m_value); case T_INT: return get_if\u003cint_t\u003e(\u0026m_value); case T_DOUBLE: return get_if\u003cdouble_t\u003e(\u0026m_value); case T_LIST: return get_if\u003clist_t\u003e(\u0026m_value); case T_DICT: return get_if\u003cdict_t\u003e(\u0026m_value); case T_STR: return std::get_if\u003cstr_t\u003e(\u0026m_value); default: return nullptr; } } Value方法： #define THROW_GET_ERROR(erron) throw std::logic_error(\"type error in get \"#erron\" value!\") template\u003cclass V\u003e V \u0026Value() { //添加安全检查 if constexpr(IS_TYPE(V, str_t)) { if (m_type != T_STR) THROW_GET_ERROR(string); } else if constexpr(IS_TYPE(V, bool_t)) { if (m_type != T_BOOL) THROW_GET_ERROR(BOOL); } else if constexpr(IS_TYPE(V, int_t)) { if (m_type != T_INT) THROW_GET_ERROR(INT); } else if constexpr(IS_TYPE(V, double_t)) { if (m_type != T_DOUBLE) THROW_GET_ERROR(DOUBLE); } else if constexpr(IS_TYPE(V, list_t)) { if (m_type != T_LIST) THROW_GET_ERROR(LIST); } else if constexpr(IS_TYPE(V, dict_t)) { if (m_type != T_DICT) THROW_GET_ERROR(DICT); } void *v = value(); if (v == nullptr) throw std::logic_error(\"unknown type in JObject::Value()\"); return *((V *) v); //强转即可 } ","date":"2022-07-27","objectID":"/posts/json%E8%A7%A3%E6%9E%90%E5%99%A8%E5%AE%9E%E7%8E%B0/:3:2","tags":["JSON解析器实现"],"title":"JSON解析器实现","uri":"/posts/json%E8%A7%A3%E6%9E%90%E5%99%A8%E5%AE%9E%E7%8E%B0/"},{"categories":["个人轮子计划"],"content":"重载方法让对象更好用 当JObject为dict类型时，我们可以直接用下标运算符进行key-value的赋值（得益于隐式转化和运算符重载 JObject \u0026operator[](string const \u0026key) { if (m_type == T_DICT) { auto \u0026dict = Value\u003cdict_t\u003e(); return dict[key]; } throw std::logic_error(\"not dict type! JObject::opertor[]()\"); } 同样如果为list对象，我们也准备了push_back等方法 void push_back(JObject item) { if (m_type == T_LIST) { auto \u0026list = Value\u003clist_t\u003e(); list.push_back(std::move(item)); return; } throw std::logic_error(\"not a list type! JObjcct::push_back()\"); } 当然，为了让类更好用，你也可以重载很多其他方法，但是注意别忘了类型的安全检查！ ","date":"2022-07-27","objectID":"/posts/json%E8%A7%A3%E6%9E%90%E5%99%A8%E5%AE%9E%E7%8E%B0/:3:3","tags":["JSON解析器实现"],"title":"JSON解析器实现","uri":"/posts/json%E8%A7%A3%E6%9E%90%E5%99%A8%E5%AE%9E%E7%8E%B0/"},{"categories":["个人轮子计划"],"content":"完善Parser类 我们之前是完成了整个字符串到JObject的解析过程，但是每次都需要创建一个Parser类，然后调用方法，这样的过程未免有些繁琐，我们可以对外提供FromString的静态方法，然后充分利用一个对象便可完成整个解析过程。 如下： JObject Parser::FromString(string_view content) { static Parser instance; instance.init(content); return instance.parse(); } ","date":"2022-07-27","objectID":"/posts/json%E8%A7%A3%E6%9E%90%E5%99%A8%E5%AE%9E%E7%8E%B0/:4:0","tags":["JSON解析器实现"],"title":"JSON解析器实现","uri":"/posts/json%E8%A7%A3%E6%9E%90%E5%99%A8%E5%AE%9E%E7%8E%B0/"},{"categories":["个人轮子计划"],"content":"完成序列化和反序列化过程 我们前面所做的工作其实已经把这个过程相当于完成了，当然还差一个把JObject变为JSON字符串的方法，现在添加上就是，也不是很难，按照相似的逻辑反推一遍就行。如下给JObject添加一个to_string方法： string JObject::to_string() { void *value = this-\u003evalue(); std::ostringstream os; switch (m_type) { case T_NULL: os \u003c\u003c \"null\"; break; case T_BOOL: if (GET_VALUE(bool)) os \u003c\u003c \"true\"; else os \u003c\u003c \"false\"; break; case T_INT: os \u003c\u003c GET_VALUE(int); break; case T_DOUBLE: os \u003c\u003c GET_VALUE(double); break; case T_STR: os \u003c\u003c '\\\"' \u003c\u003c GET_VALUE(string) \u003c\u003c '\\\"'; break; case T_LIST: { list_t \u0026list = GET_VALUE(list_t); os \u003c\u003c '['; for (auto i = 0; i \u003c list.size(); i++) { if (i != list.size() - 1) { os \u003c\u003c ((list[i]).to_string()); os \u003c\u003c ','; } else os \u003c\u003c ((list[i]).to_string()); } os \u003c\u003c ']'; break; } case T_DICT: { dict_t \u0026dict = GET_VALUE(dict_t); os \u003c\u003c '{'; for (auto it = dict.begin(); it != dict.end(); ++it) { if (it != dict.begin()) //为了保证最后的json格式正确 os \u003c\u003c ','; os \u003c\u003c '\\\"' \u003c\u003c it-\u003efirst \u003c\u003c \"\\\":\" \u003c\u003c it-\u003esecond.to_string(); } os \u003c\u003c '}'; break; } default: return \"\"; } return os.str(); } 有关JObject的方法也都补充的差不多了，那么我们现在要考虑的是如何通过JObject这个中间对象将我们自定义的任何一个类给序列化和反序列化？ 如图： 所有的序列化和反序列化的过程都依托于JObject进行。而Parser这个类在中间作为一个方便使用的对外接口。 ","date":"2022-07-27","objectID":"/posts/json%E8%A7%A3%E6%9E%90%E5%99%A8%E5%AE%9E%E7%8E%B0/:5:0","tags":["JSON解析器实现"],"title":"JSON解析器实现","uri":"/posts/json%E8%A7%A3%E6%9E%90%E5%99%A8%E5%AE%9E%E7%8E%B0/"},{"categories":["个人轮子计划"],"content":"序列化接口设计 在Parser类中添加一个ToJSON的静态方法，用来对任意类型进行序列化，这个方法使用模板。 代码如下： template\u003cclass T\u003e static string ToJSON(T const \u0026src) { //如果是基本类型 if constexpr(IS_TYPE(T, int_t)) { JObject object(src); return object.to_string(); } else if constexpr(IS_TYPE(T, bool_t)) { JObject object(src); return object.to_string(); } else if constexpr(IS_TYPE(T, double_t)) { JObject object(src); return object.to_string(); } else if constexpr(IS_TYPE(T, str_t)) { JObject object(src); return object.to_string(); } //如果是自定义类型调用方法完成dict的赋值，然后to_string即可 json::JObject obj((json::dict_t())); src.FUNC_TO_NAME(obj); return obj.to_string(); } 如上代码如果是基本类型则直接初始化JObject调用to_string方法，如果是自定义类型，则需要在该类型中嵌入一个方法，这个方法名字我们用FUNC_TO_NAME这个宏代替。 也就是说，如果是自定义的类型，那么肯定就是对应JSON数据的dict类型，所以只需要你对该类型定义对应的方法，该方法需要将值传递给JObject，为了简化这个过程我们用宏来替代。 宏定义如下： #define FUNC_TO_NAME _to_json #define FUNC_FROM_NAME _from_json #define START_TO_JSON void FUNC_TO_NAME(json::JObject \u0026 obj) const{ #define to(key) obj[key] //push一个自定义类型的成员 #define to_struct(key, struct_member) json::JObject tmp((json::dict_t())); struct_member.FUNC_TO_NAME(tmp); obj[key] = tmp #define END_TO_JSON } #define START_FROM_JSON void FUNC_FROM_NAME(json::JObject\u0026 obj) { #define from(key, type) obj[key].Value\u003ctype\u003e() #define from_struct(key, struct_member) struct_member.FUNC_FROM_NAME(obj[key]) #define END_FROM_JSON } 基本使用如下： struct Base { int pp; string qq; START_FROM_JSON //生成反序列化相关的方法 pp = from(\"pp\", int); qq = from(\"qq\", string); END_FROM_JSON START_TO_JSON //生成序列化相关的代码 to(\"pp\") = pp; to(\"qq\") = qq; END_TO_JSON }; struct Mytest { int id; std::string name; Base q; START_TO_JSON //序列化相关代码 to_struct(\"base\", q); to(\"id\") = id; to(\"name\") = name; END_TO_JSON START_FROM_JSON //反序列化相关代码 id = from(\"id\", int); name = from(\"name\", string); from_struct(\"base\", q); END_FROM_JSON }; 实际上上面代码等效于下面的代码，以Base类为例： struct Base { int pp; string qq; void _from_json(json::JObject\u0026 obj){ //反序列化 pp = obj.Value\u003cint\u003e(); qq = obj.Value\u003cstring\u003e(); } void _to_json(json::JObject\u0026 obj){//序列化代码 obj[\"pp\"] = pp; obj[\"qq\"] = qq; } }; ","date":"2022-07-27","objectID":"/posts/json%E8%A7%A3%E6%9E%90%E5%99%A8%E5%AE%9E%E7%8E%B0/:5:1","tags":["JSON解析器实现"],"title":"JSON解析器实现","uri":"/posts/json%E8%A7%A3%E6%9E%90%E5%99%A8%E5%AE%9E%E7%8E%B0/"},{"categories":["个人轮子计划"],"content":"简单使用 #include\u003ciostream\u003e#include \"JObject.h\"#include \"Parser.h\"#include \u003cfstream\u003e#include \"../benchmark/Timer.hpp\" using namespace json; struct Base { int pp; string qq; START_FROM_JSON pp = from(\"pp\", int); qq = from(\"qq\", string); END_FROM_JSON START_TO_JSON to(\"pp\") = pp; to(\"qq\") = qq; END_TO_JSON }; struct Mytest { int id; std::string name; Base q; START_TO_JSON to_struct(\"base\", q); to(\"id\") = id; to(\"name\") = name; END_TO_JSON START_FROM_JSON id = from(\"id\", int); name = from(\"name\", string); from_struct(\"base\", q); END_FROM_JSON }; void test_class_serialization() { Mytest test{.id=32, .name=\"fda\"}; auto item = Parser::FromJson\u003cMytest\u003e(R\"({\"base\":{\"pp\":0,\"qq\":\"\"},\"id\":32,\"name\":\"fda\"} )\"); //serialization std::cout \u003c\u003c Parser::ToJSON(item); //deserialization } void test_string_parser() { { Timer t; std::ifstream fin(\"../../test_source/test.json\"); std::string text((std::istreambuf_iterator\u003cchar\u003e(fin)), std::istreambuf_iterator\u003cchar\u003e()); json::Parser p; p.init(text); auto q = p.parse(); std::ofstream fout(\"../../test_source/test_out.json\"); fout \u003c\u003c q.to_string(); } } int main() { test_class_serialization(); test_string_parser(); } ","date":"2022-07-27","objectID":"/posts/json%E8%A7%A3%E6%9E%90%E5%99%A8%E5%AE%9E%E7%8E%B0/:6:0","tags":["JSON解析器实现"],"title":"JSON解析器实现","uri":"/posts/json%E8%A7%A3%E6%9E%90%E5%99%A8%E5%AE%9E%E7%8E%B0/"},{"categories":["个人轮子计划"],"content":"Logger日志库的实现","date":"2022-07-24","objectID":"/posts/logger%E6%97%A5%E5%BF%97%E5%BA%93%E7%9A%84%E5%AE%9E%E7%8E%B0/","tags":["Logger日志库的实现"],"title":"Logger日志库的实现","uri":"/posts/logger%E6%97%A5%E5%BF%97%E5%BA%93%E7%9A%84%E5%AE%9E%E7%8E%B0/"},{"categories":["个人轮子计划"],"content":" 代码仓库：https://github.com/ACking-you/MyUtil/tree/master/my-logger ","date":"2022-07-24","objectID":"/posts/logger%E6%97%A5%E5%BF%97%E5%BA%93%E7%9A%84%E5%AE%9E%E7%8E%B0/:0:0","tags":["Logger日志库的实现"],"title":"Logger日志库的实现","uri":"/posts/logger%E6%97%A5%E5%BF%97%E5%BA%93%E7%9A%84%E5%AE%9E%E7%8E%B0/"},{"categories":["个人轮子计划"],"content":"日志的重要性以及概述 一个理想的日志库，至少需要满足以下三点： 支持高度自定义。 拓展性好。 使用方便，且有安全性保证。 当然要是能在输出的时候出现彩色那就再好不过了🥳 ","date":"2022-07-24","objectID":"/posts/logger%E6%97%A5%E5%BF%97%E5%BA%93%E7%9A%84%E5%AE%9E%E7%8E%B0/:1:0","tags":["Logger日志库的实现"],"title":"Logger日志库的实现","uri":"/posts/logger%E6%97%A5%E5%BF%97%E5%BA%93%E7%9A%84%E5%AE%9E%E7%8E%B0/"},{"categories":["个人轮子计划"],"content":"具体实现 ","date":"2022-07-24","objectID":"/posts/logger%E6%97%A5%E5%BF%97%E5%BA%93%E7%9A%84%E5%AE%9E%E7%8E%B0/:2:0","tags":["Logger日志库的实现"],"title":"Logger日志库的实现","uri":"/posts/logger%E6%97%A5%E5%BF%97%E5%BA%93%E7%9A%84%E5%AE%9E%E7%8E%B0/"},{"categories":["个人轮子计划"],"content":"以模块拆分 ","date":"2022-07-24","objectID":"/posts/logger%E6%97%A5%E5%BF%97%E5%BA%93%E7%9A%84%E5%AE%9E%E7%8E%B0/:2:1","tags":["Logger日志库的实现"],"title":"Logger日志库的实现","uri":"/posts/logger%E6%97%A5%E5%BF%97%E5%BA%93%E7%9A%84%E5%AE%9E%E7%8E%B0/"},{"categories":["个人轮子计划"],"content":"代码逻辑 日志输出逻辑（省去了标志位的判断 日志状态的初始化逻辑 ","date":"2022-07-24","objectID":"/posts/logger%E6%97%A5%E5%BF%97%E5%BA%93%E7%9A%84%E5%AE%9E%E7%8E%B0/:3:0","tags":["Logger日志库的实现"],"title":"Logger日志库的实现","uri":"/posts/logger%E6%97%A5%E5%BF%97%E5%BA%93%E7%9A%84%E5%AE%9E%E7%8E%B0/"},{"categories":["个人轮子计划"],"content":"后期拓展展望 支持分布式日志存储 ","date":"2022-07-24","objectID":"/posts/logger%E6%97%A5%E5%BF%97%E5%BA%93%E7%9A%84%E5%AE%9E%E7%8E%B0/:4:0","tags":["Logger日志库的实现"],"title":"Logger日志库的实现","uri":"/posts/logger%E6%97%A5%E5%BF%97%E5%BA%93%E7%9A%84%E5%AE%9E%E7%8E%B0/"},{"categories":["Linux网络编程"],"content":"select、poll、epoll浅析","date":"2022-06-22","objectID":"/posts/selectpollepoll%E6%B5%85%E6%9E%90/","tags":["select、poll、epoll浅析"],"title":"select、poll、epoll浅析","uri":"/posts/selectpollepoll%E6%B5%85%E6%9E%90/"},{"categories":["Linux网络编程"],"content":" 整篇博客的完整示例代码在：github ","date":"2022-06-22","objectID":"/posts/selectpollepoll%E6%B5%85%E6%9E%90/:0:0","tags":["select、poll、epoll浅析"],"title":"select、poll、epoll浅析","uri":"/posts/selectpollepoll%E6%B5%85%E6%9E%90/"},{"categories":["Linux网络编程"],"content":"select ","date":"2022-06-22","objectID":"/posts/selectpollepoll%E6%B5%85%E6%9E%90/:1:0","tags":["select、poll、epoll浅析"],"title":"select、poll、epoll浅析","uri":"/posts/selectpollepoll%E6%B5%85%E6%9E%90/"},{"categories":["Linux网络编程"],"content":"介绍与使用 一、介绍： select系统调用的目的是：在一段指定时间内，监听用户感兴趣的文件描述符上的可读、可写和异常事件。poll和select应该被归类为这样的系统 调用，它们可以阻塞地同时探测一组支持非阻塞的IO设备，直至某一个设备触发了事件或者超过了指定的等待时间——也就是说它们的职责不是做IO，而是帮助 调用者寻找当前就绪的设备。 原理图： 二、使用 需要的系统调用API如下： #include \u003csys/time.h\u003e#include \u003csys/types.h\u003e#include \u003cunistd.h\u003eint select(int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout); 一般经过以下三个过程： 定义bitmap结构，就是定义fd_set类型变量，内部实现是一个int数组，整个数组的bit位长 FD_SETSIZE，这个宏默认为1024。 根据文件描述符大小设置bitmap，该步骤调用FD_SET宏进行设置。 调用select函数，并传入bitmap，select内部会根据bitmap上的标记进行轮询，一旦有文件描述符触发事件就将其重新标记到用户态的bitmap里，select除了第一个参数外（第一个参数传入fd的最大值+1），后面连续三个传入的指针参数分别代表：监听读取事件的bitmap、监听写入事件的bitmap、监听异常事件的bitmap，最后一个参数表示延迟时间。 根据bitmap得到已经准备好的文件描述符，并对其执行相应的操作。（Reactor模型 一个文件描述符是否准备就绪，有以下判断： 在网络编程中， 下列情况下socket可读： a) socket内核接收缓冲区的字节数大于或等于其低水位标记SO_RCVLOWAT； b) socket通信的对方关闭连接，此时该socket可读，但是一旦读该socket，会立即返回0（可以用这个方法判断client端是否断开连接）； c) 监听socket上有新的连接请求； d) socket上有未处理的错误。 下列情况下socket可写： a) socket内核发送缓冲区的可用字节数大于或等于其低水位标记SO_SNDLOWAT； b) socket的读端关闭，此时该socket可写，一旦对该socket进行操作，该进程会收到SIGPIPE信号； c) socket使用connect连接成功之后； d) socket上有未处理的错误。 关键代码如下： //1.定义bitmap结构。 fd_set，是一个bitmap，大小为1024位，是一个长度为1024/32的int数组 fd_set rset; char buffer[MAXBUF]; while (1) { FD_ZERO(\u0026rset); //重置为0 for (int i = 0; i \u003c 5; ++i) { FD_SET(fds[i],\u0026rset); //2.根据文件描述符标记bitmap } puts(\"round again\\n\"); select(max+1,\u0026rset,NULL,NULL,NULL); //3.调用select进行轮询 for(auto \u0026fd:fds){ if(FD_ISSET(fd,\u0026rset)){ //4.获取已经准备好的描述符进行相应操作 memset(buffer, 0, MAXBUF); read(fd, buffer, MAXBUF); puts(buffer); } } } ","date":"2022-06-22","objectID":"/posts/selectpollepoll%E6%B5%85%E6%9E%90/:1:1","tags":["select、poll、epoll浅析"],"title":"select、poll、epoll浅析","uri":"/posts/selectpollepoll%E6%B5%85%E6%9E%90/"},{"categories":["Linux网络编程"],"content":"优缺点 从以下三个角度来评析： 支持的最大连接数：与 FD_SETSIZE 宏的大小有关，一般为1024。 内核态到用户态的拷贝消耗：非常高，每次select调用都会重新copy一次。 内核态扫描的数据结构：线性扫描，FD剧增后会造成很大的效率问题 我们发现上面所说的都是它的各方面特性，同时也体现出了它的缺点。 缺点：支持的最大文件描述符不够大、每次select调用需要进行大量拷贝且bitmap每次都需要重新set值、内部逻辑是线性扫描不适合大量描述符的情况。 同样在某些条件下，这种简单模型反而会成为优点。 优点：如果是连接数特别少的情况下，线性扫描反而可能是最优的选择。 ","date":"2022-06-22","objectID":"/posts/selectpollepoll%E6%B5%85%E6%9E%90/:1:2","tags":["select、poll、epoll浅析"],"title":"select、poll、epoll浅析","uri":"/posts/selectpollepoll%E6%B5%85%E6%9E%90/"},{"categories":["Linux网络编程"],"content":"poll ","date":"2022-06-22","objectID":"/posts/selectpollepoll%E6%B5%85%E6%9E%90/:2:0","tags":["select、poll、epoll浅析"],"title":"select、poll、epoll浅析","uri":"/posts/selectpollepoll%E6%B5%85%E6%9E%90/"},{"categories":["Linux网络编程"],"content":"介绍与使用 一、介绍 poll本质上和select没有区别，它将用户传入的数组拷贝到内核空间，然后查询每个fd对应的设备状态，如果设备就绪则在设备等待队列中加入一项并继续遍历，如果遍历完所有fd后没有发现就绪设备，则挂起当前进程，直到设备就绪或者主动超时，被唤醒后它又要再次遍历fd。 二、使用 经过以下过程： 创建pollfd结构，并设置好fd和events。 调用poll函数进行轮询，第一个参数传入需要轮询的pollfd数组，第二个参数传入数组长度，第三个是超时时间。 遍历pollfd数组检测就绪fd并对其进行相应的处理。 代码如下： //1.创建pollfd结构，并设置好要管理的文件描述符以及对应的事件 pollfd pollfds[5]; for(auto\u0026 pollfd: pollfds){ pollfd.fd = accept(server_fd,(sockaddr*)\u0026client,\u0026socklen); if(pollfd.fd\u003c0) ERR_EXIT(\"fd accept error\"); pollfd.events = POLLIN; //检测读取事件 } while (1){ puts(\"round again\"); //2.开始进行poll轮询 if(poll(pollfds,5,5000)\u003c0) //通过把需要监听的fd拷贝到内核态，如果有事件可读，则设置revents ERR_EXIT(\"poll error\"); //3.遍历pollfd数组检测已经就绪的事件，并执行对应的操作 for(auto \u0026 pollfd:pollfds){ if(pollfd.revents\u0026POLLIN){ pollfd.revents = 0; //重新设置 char buffer[1024]{}; int len; if((len= read(pollfd.fd,buffer,1024))\u003c0) ERR_EXIT(\"pollfd read error\"); if(write(pollfd.fd,buffer,len)\u003c0){ ERR_EXIT(\"pollfd write error\"); } } } } ","date":"2022-06-22","objectID":"/posts/selectpollepoll%E6%B5%85%E6%9E%90/:2:1","tags":["select、poll、epoll浅析"],"title":"select、poll、epoll浅析","uri":"/posts/selectpollepoll%E6%B5%85%E6%9E%90/"},{"categories":["Linux网络编程"],"content":"优缺点 三个角度剖析 支持的最大连接数：非常多（具体根据系统调度和创建的结构来。 内核态到用户态的拷贝消耗：非常高，每次poll调用都会将整个数组重新从用户态到内核态copy一次，且只支持水平触发。 内核态扫描的数据结构：线性扫描，FD剧增后会造成很大的效率问题。 优点：解决了select因为采取bitmap的连接数限制，且利用的是事件与fd绑定的结构体，用起来会更顺手。 缺点：仍然没有解决关键的效率问题，同时每次还是通过循环所有结构体来判断事件是否产生的方式来进行，所以本质上和select没有什么不同。 ","date":"2022-06-22","objectID":"/posts/selectpollepoll%E6%B5%85%E6%9E%90/:2:2","tags":["select、poll、epoll浅析"],"title":"select、poll、epoll浅析","uri":"/posts/selectpollepoll%E6%B5%85%E6%9E%90/"},{"categories":["Linux网络编程"],"content":"epoll 前面的讲解都只是为epoll铺路。 具体而言epoll解决了前面的IO复用模型的很多问题。 特点： IO事件和监视的fd只需要添加一次。epoll_ctl 轮询操作是直接将已经就绪的fd赋值到用户态的数组，返回就绪的长度，也就是不需要再遍历所有的fd来判断是否就绪。epoll_wait 底层采用红黑树进行轮询，即使有大量fd需要检测，效率也不会太差。 支持水平触发和边缘触发。 技术点： 数据结构优化：底层采取红黑树+就绪队列。 零拷贝优化：使用mmap进行内存映射实现内存共享。 多种触发形式优化：支持EPOLLLT和EPOLLET两种触发模式，也就是支持水平触发和边缘触发。 关于水平触发与边缘触发： 水平触发是只要符合触发条件，就会一直触发可读信号，而边缘触发仅仅在状态转变的时候触发一次。 这个和数字电路里面的概念类似：你可以把当前是否符合触发条件想象成一个张图，这张图上有两个状态符合触发条件和不符合触发条件，水平触发是只要状态符合就触发，边缘触发是状态发生改变就触发，而在IO事件里这里的触发状态指的是前面select中讲的socket可读可写等状态。 使用： 调用epoll_create创建结构并返回描述符。（需要传入一个参数，Linux 2.6.8后，传入的参数只要大于0即可，在此之前，表示最大的文件描述符 调用epoll_ctl加入需要监听的文件描述符以及对应事件（epoll_event结构体）。（需要传入四个参数：1.需要操作的epoll结构的描述符。2.需要进行的操作。3.需要操作的文件描述符。4.需要加入的结构体。 调用epoll_wait等待事件的到来，并返回就绪的文件描述符数量。（需要传入四个参数：1.需要操作的epoll结构的描述符。2.用于存放就绪的文件描述符的数组。3.数组的最大长度。4.超时时间。）返回值：就绪的文件描述符数量。 代码如下： //1.在内核中创建结构并返回描述符 epoll_create主要是将内核态的数据结构创建出来并初始化，然后再将它加入进程文件表，得到文件描述符 auto epfd = epoll_create(1); //Linux 2.6.8后，传入的参数只要大于0即可，在此之前，表示最大的文件描述符 //2.调用epoll_ctl加入需要监听的文件描述符以及对应事件 epoll_event evs[5]; for(int i=0;i\u003c5;i++){ sockaddr_in client{}; socklen_t socklen; evs[i].data.fd = accept(server_fd,(sockaddr*)\u0026client,\u0026socklen); evs[i].events = EPOLLIN; //需要读取的事件 if(epoll_ctl(epfd,EPOLL_CTL_ADD,evs[i].data.fd,\u0026evs[i])\u003c0) //添加或删除内核数据结构中指定的文件描述符对应的结点 ERR_EXIT(\"epoll_ctl\"); } while(1){ puts(\"round again\"); //3.调用epoll_wait等待事件的到来，并返回就绪的文件描述符数量 //查询就绪队列，并将已经ok的文件描述符，从左到右写入数组，返回写入的长度，返回-1表示轮询超时 auto nfds = epoll_wait(epfd,evs,5,10000); //查询就绪队列，然后把就绪到位的文件描述符和对应的情况写入用户空间中的数组 //遍历数组，执行最后的动作 for(int i=0;i\u003cnfds;i++){ char buffer[1024]{}; int len{}; if((len = read(evs[i].data.fd,buffer,1024))\u003c0){ ERR_LOG(\"read error\"); }else{ if(write(evs[i].data.fd,buffer,len)\u003c0){ ERR_LOG(\"write error\"); } } } } 对epoll实现原理更为具体的描述有以下链接： epoll 原理是如何实现的？ 图解 | 深入揭秘 epoll 是如何实现 IO 多路复用的！ ","date":"2022-06-22","objectID":"/posts/selectpollepoll%E6%B5%85%E6%9E%90/:3:0","tags":["select、poll、epoll浅析"],"title":"select、poll、epoll浅析","uri":"/posts/selectpollepoll%E6%B5%85%E6%9E%90/"},{"categories":["面试相关"],"content":"C++面试题1","date":"2022-06-20","objectID":"/posts/c++%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%981/","tags":["C++面试题1"],"title":"C++面试题1","uri":"/posts/c++%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%981/"},{"categories":["面试相关"],"content":"1、 在main执行之前和之后执行的代码可能是什么？ main函数执行之前，主要就是初始化系统相关资源： 设置栈指针 初始化静态static变量和global全局变量，即.data段的内容 将未初始化部分的全局变量赋初值：数值型short，int，long等为0，bool为FALSE，指针为NULL等等，即.bss段的内容 全局对象初始化，在main之前调用构造函数，这是可能会执行前的一些代码 将main函数的参数argc，argv等传递给main函数，然后才真正运行main函数 __attribute__((constructor))这是gnu C里面的东西，可修饰函数，控制它在main函数之前执行，它不跨平台。 main函数执行之后： 全局对象的析构函数会在main函数之后执行； 可以用 atexit 注册一个函数，它会在main 之后执行;（跨平台，是标准库里的东西 __attribute__((destructor))同上面的construct，只不过是在main函数执行后。 ","date":"2022-06-20","objectID":"/posts/c++%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%981/:1:0","tags":["C++面试题1"],"title":"C++面试题1","uri":"/posts/c++%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%981/"},{"categories":["面试相关"],"content":"2、结构体内存对齐问题？ 结构体内成员按照声明顺序存储，第一个成员地址和整个结构体地址相同。 未特殊说明时，按结构体中size最大的成员对齐（若有double成员，按8字节对齐。） c++11以后引入两个关键字 alignas (opens new window)与 alignof (opens new window)。其中alignof可以计算出类型的对齐方式，alignas可以指定结构体的对齐方式。 但是alignas在某些情况下是不能使用的，具体见下面的例子: // alignas 生效的情况 struct Info { uint8_t a; uint16_t b; uint8_t c; }; std::cout \u003c\u003c sizeof(Info) \u003c\u003c std::endl; // 6 2 + 2 + 2 std::cout \u003c\u003c alignof(Info) \u003c\u003c std::endl; // 2 struct alignas(4) Info2 { uint8_t a; uint16_t b; uint8_t c; }; std::cout \u003c\u003c sizeof(Info2) \u003c\u003c std::endl; // 8 4 + 4 std::cout \u003c\u003c alignof(Info2) \u003c\u003c std::endl; // 4 alignas将内存对齐调整为4个字节。所以sizeof(Info2)的值变为了8。 // alignas 失效的情况 struct Info { uint8_t a; uint32_t b; uint8_t c; }; std::cout \u003c\u003c sizeof(Info) \u003c\u003c std::endl; // 12 4 + 4 + 4 std::cout \u003c\u003c alignof(Info) \u003c\u003c std::endl; // 4 struct alignas(2) Info2 { uint8_t a; uint32_t b; uint8_t c; }; std::cout \u003c\u003c sizeof(Info2) \u003c\u003c std::endl; // 12 4 + 4 + 4 std::cout \u003c\u003c alignof(Info2) \u003c\u003c std::endl; // 4 若alignas小于自然对齐的最小单位，则被忽略。 如果想使用单字节对齐的方式，使用alignas是无效的。应该使用#pragma pack(push,1)或者使用__attribute__((packed))。 #if defined(__GNUC__) || defined(__GNUG__) #define ONEBYTE_ALIGN __attribute__((packed)) #elif defined(_MSC_VER) #define ONEBYTE_ALIGN #pragma pack(push,1) #endif struct Info { uint8_t a; uint32_t b; uint8_t c; } ONEBYTE_ALIGN; #if defined(__GNUC__) || defined(__GNUG__) #undef ONEBYTE_ALIGN #elif defined(_MSC_VER) #pragma pack(pop) #undef ONEBYTE_ALIGN #endif std::cout \u003c\u003c sizeof(Info) \u003c\u003c std::endl; // 6 1 + 4 + 1 std::cout \u003c\u003c alignof(Info) \u003c\u003c std::endl; // 6 确定结构体中每个元素大小可以通过下面这种方法: #if defined(__GNUC__) || defined(__GNUG__) #define ONEBYTE_ALIGN __attribute__((packed)) #elif defined(_MSC_VER) #define ONEBYTE_ALIGN #pragma pack(push,1) #endif /** * 0 1 3 6 8 9 15 * +-+---+-----+---+-+-------------+ * | | | | | | | * |a| b | c | d |e| pad | * | | | | | | | * +-+---+-----+---+-+-------------+ */ struct Info { uint16_t a : 1; uint16_t b : 2; uint16_t c : 3; uint16_t d : 2; uint16_t e : 1; uint16_t pad : 7; } ONEBYTE_ALIGN; #if defined(__GNUC__) || defined(__GNUG__) #undef ONEBYTE_ALIGN #elif defined(_MSC_VER) #pragma pack(pop) #undef ONEBYTE_ALIGN #endif std::cout \u003c\u003c sizeof(Info) \u003c\u003c std::endl; // 2 std::cout \u003c\u003c alignof(Info) \u003c\u003c std::endl; // 1 这种处理方式是alignas处理不了的。 ","date":"2022-06-20","objectID":"/posts/c++%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%981/:2:0","tags":["C++面试题1"],"title":"C++面试题1","uri":"/posts/c++%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%981/"},{"categories":["面试相关"],"content":"3、指针和引用的区别 指针是一个变量，存储的是一个地址，引用跟原来的变量实质上是同一个东西，是原变量的别名 指针可以有多级，引用只有一级 指针可以为空，引用不能为NULL且在定义时必须初始化 指针在初始化后可以改变指向，而引用在初始化之后不可再改变 sizeof指针得到的是本指针的大小，sizeof引用得到的是引用所指向变量的大小 当把指针作为参数进行传递时，也是将实参的一个拷贝传递给形参，两者指向的地址相同，但不是同一个变量，在函数中改变这个变量的指向不影响实参，而引用却可以。 引用本质是一个指针，同样会占4字节内存；指针是具体变量，需要占用存储空间（，具体情况还要具体分析）。 引用在声明时必须初始化为另一变量，一旦出现必须为typename refname \u0026varname形式；指针声明和定义可以分开，可以先只声明指针变量而不初始化，等用到时再指向具体变量。 引用一旦初始化之后就不可以再改变（变量可以被引用为多次，但引用只能作为一个变量引用）；指针变量可以重新指向别的变量。 不存在指向空值的引用，必须有具体实体；但是存在指向空值的指针。 参考代码： void test(int *p) { int a=1; p=\u0026a; cout\u003c\u003cp\u003c\u003c\" \"\u003c\u003c*p\u003c\u003cendl; } int main(void) { int *p=NULL; test(p); if(p==NULL) cout\u003c\u003c\"指针p为NULL\"\u003c\u003cendl; return 0; } //运行结果为： //0x22ff44 1 //指针p为NULL void testPTR(int* p) { int a = 12; p = \u0026a; } void testREFF(int\u0026 p) { int a = 12; p = a; } void main() { int a = 10; int* b = \u0026a; testPTR(b);//改变指针指向，但是没改变指针的所指的内容 cout \u003c\u003c a \u003c\u003c endl;// 10 cout \u003c\u003c *b \u003c\u003c endl;// 10 a = 10; testREFF(a); cout \u003c\u003c a \u003c\u003c endl;//12 } 在编译器看来, int a = 10; int \u0026b = a; 等价于 int * const b = \u0026a; 而 b = 20; 等价于 *b = 20; 自动转换为指针和自动解引用. ","date":"2022-06-20","objectID":"/posts/c++%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%981/:3:0","tags":["C++面试题1"],"title":"C++面试题1","uri":"/posts/c++%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%981/"},{"categories":["面试相关"],"content":"4、在传递函数参数时，什么时候该使用指针，什么时候该使用引用呢？ 需要返回函数内局部变量的内存的时候用指针。使用指针传参需要开辟内存，用完要记得释放指针，不然会内存泄漏。而返回局部变量的引用是没有意义的 对栈空间大小比较敏感（比如递归）的时候使用引用。使用引用传递不需要创建临时变量，开销要更小 类对象作为参数传递的时候使用引用，这是C++类对象传递的标准方式 ","date":"2022-06-20","objectID":"/posts/c++%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%981/:4:0","tags":["C++面试题1"],"title":"C++面试题1","uri":"/posts/c++%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%981/"},{"categories":["面试相关"],"content":"5、堆和栈的区别 申请方式不同。 栈由系统自动分配。 堆是自己申请和释放的。 申请大小限制不同。 栈顶和栈底是之前预设好的，栈是向栈底扩展，大小固定，可以通过ulimit -a查看，由ulimit -s修改。 堆向高地址扩展，是不连续的内存区域，大小可以灵活调整。 申请效率不同。 栈由系统分配，速度快，不会有碎片。 堆由程序员分配，速度慢，且会有碎片。 栈空间默认是4M, 堆区一般是 1G - 4G 堆 栈 管理方式 堆中资源由程序员控制（容易产生memory leak） 栈资源由编译器自动管理，无需手工控制 内存管理机制 系统有一个记录空闲内存地址的链表，当系统收到程序申请时，遍历该链表，寻找第一个空间大于申请空间的堆结点，删 除空闲结点链表中的该结点，并将该结点空间分配给程序（大多数系统会在这块内存空间首地址记录本次分配的大小，这样delete才能正确释放本内存空间，另外系统会将多余的部分重新放入空闲链表中） 只要栈的剩余空间大于所申请空间，系统为程序提供内存，否则报异常提示栈溢出。（这一块理解一下链表和队列的区别，不连续空间和连续空间的区别，应该就比较好理解这两种机制的区别了） 空间大小 堆是不连续的内存区域（因为系统是用链表来存储空闲内存地址，自然不是连续的），堆大小受限于计算机系统中有效的虚拟内存（32bit 系统理论上是4G），所以堆的空间比较灵活，比较大 栈是一块连续的内存区域，大小是操作系统预定好的，windows下栈大小是2M（也有是1M，在 编译时确定，VC中可设置） 碎片问题 对于堆，频繁的new/delete会造成大量碎片，使程序效率降低 对于栈，它是有点类似于数据结构上的一个先进后出的栈，进出一一对应，不会产生碎片。（看到这里我突然明白了为什么面试官在问我堆和栈的区别之前先问了我栈和队列的区别） 生长方向 堆向上，向高地址方向增长。 栈向下，向低地址方向增长。 分配方式 堆都是动态分配（没有静态分配的堆） 栈有静态分配和动态分配，静态分配由编译器完成（如局部变量分配），动态分配由alloca函数分配，但栈的动态分配的资源由编译器进行释放，无需程序员实现。 分配效率 堆由C/C++函数库提供，机制很复杂。所以堆的效率比栈低很多。 栈是其系统提供的数据结构，计算机在底层对栈提供支持，分配专门 寄存器存放栈地址，栈操作有专门指令。 形象的比喻 栈就像我们去饭馆里吃饭，只管点菜（发出申请）、付钱、和吃（使用），吃饱了就走，不必理会切菜、洗菜等准备工作和洗碗、刷锅等扫尾工作，他的好处是快捷，但是自由度小。 堆就象是自己动手做喜欢吃的菜肴，比较麻烦，但是比较符合自己的口味，而且自由度大。 ","date":"2022-06-20","objectID":"/posts/c++%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%981/:5:0","tags":["C++面试题1"],"title":"C++面试题1","uri":"/posts/c++%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%981/"},{"categories":["面试相关"],"content":"6、你觉得堆快一点还是栈快一点？ 毫无疑问是栈快一点。 因为操作系统会在底层对栈提供支持，会分配专门的寄存器存放栈的地址，栈的入栈出栈操作也十分简单，并且有专门的指令执行，所以栈的效率比较高也比较快。 而堆的操作是由C/C++函数库提供的，在分配堆内存的时候需要一定的算法寻找合适大小的内存。并且获取堆的内容需要两次访问，第一次访问指针，第二次根据指针保存的地址访问内存，因此堆比较慢。 ","date":"2022-06-20","objectID":"/posts/c++%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%981/:6:0","tags":["C++面试题1"],"title":"C++面试题1","uri":"/posts/c++%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%981/"},{"categories":["面试相关"],"content":"7、区别以下指针类型？ int *p[10] int (*p)[10] int *p(int) int (*p)(int) int *p[10]表示指针数组，强调数组概念，是一个数组变量，数组大小为10，数组内每个元素都是指向int类型的指针变量。 int (*p)[10]表示数组指针，强调是指针，只有一个变量，是指针类型，不过指向的是一个int类型的数组，这个数组大小是10。 int *p(int)是函数声明，函数名是p，参数是int类型的，返回值是int *类型的。 int (*p)(int)是函数指针，强调是指针，该指针指向的函数具有int类型参数，并且返回值是int类型的。 ","date":"2022-06-20","objectID":"/posts/c++%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%981/:7:0","tags":["C++面试题1"],"title":"C++面试题1","uri":"/posts/c++%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%981/"},{"categories":["面试相关"],"content":"8、new / delete 与 malloc / free的异同 相同点 都可用于内存的动态申请和释放 不同点 前者是C++运算符，后者是C/C++语言标准库函数 new自动计算要分配的空间大小，malloc需要手工计算 new是类型安全的，malloc不是。例如： int *p = new float[2]; //编译错误 int *p = (int*)malloc(2 * sizeof(double));//编译无错误 new调用名为operator new的标准库函数分配足够空间并调用相关对象的构造函数，delete对指针所指对象运行适当的析构函数；然后通过调用名为operator delete的标准库函数释放该对象所用内存。后者均没有相关调用 后者需要库文件支持，前者不用 new是封装了malloc，直接free不会报错，但是这只是释放内存，而不会析构对象 ","date":"2022-06-20","objectID":"/posts/c++%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%981/:8:0","tags":["C++面试题1"],"title":"C++面试题1","uri":"/posts/c++%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%981/"},{"categories":["面试相关"],"content":"9、new和delete是如何实现的？ new的实现过程是：首先调用名为operator new的标准库函数，分配足够大的原始为类型化的内存，以保存指定类型的一个对象；接下来运行该类型的一个构造函数，用指定初始化构造对象；最后返回指向新分配并构造后的的对象的指针 delete的实现过程：对指针指向的对象运行适当的析构函数；然后通过调用名为operator delete的标准库函数释放该对象所用内存 ","date":"2022-06-20","objectID":"/posts/c++%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%981/:9:0","tags":["C++面试题1"],"title":"C++面试题1","uri":"/posts/c++%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%981/"},{"categories":["面试相关"],"content":"10、malloc和new的区别？ malloc和free是标准库函数，支持覆盖；new和delete是运算符，不重载。 malloc仅仅分配内存空间，free仅仅回收空间，不具备调用构造函数和析构函数功能，用malloc分配空间存储类的对象存在风险；new和delete除了分配回收功能外，还会调用构造函数和析构函数。 malloc和free返回的是void类型指针（必须进行类型转换），new和delete返回的是具体类型指针。 update1:感谢微信好友“猿六学算法”指出错误，已修正！ ","date":"2022-06-20","objectID":"/posts/c++%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%981/:10:0","tags":["C++面试题1"],"title":"C++面试题1","uri":"/posts/c++%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%981/"},{"categories":["面试相关"],"content":"11、既然有了malloc/free，C++中为什么还需要new/delete呢？直接用malloc/free不好吗？ malloc/free和new/delete都是用来申请内存和回收内存的。 在对非基本数据类型的对象使用的时候，对象创建的时候还需要执行构造函数，销毁的时候要执行析构函数。而malloc/free是库函数，是已经编译的代码，所以不能把构造函数和析构函数的功能强加给malloc/free，所以new/delete是必不可少的。 ","date":"2022-06-20","objectID":"/posts/c++%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%981/:11:0","tags":["C++面试题1"],"title":"C++面试题1","uri":"/posts/c++%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%981/"},{"categories":["面试相关"],"content":"12、被free回收的内存是立即返还给操作系统吗？ 不是的，被free回收的内存会首先被ptmalloc使用双链表保存起来，当用户下一次申请内存的时候，会尝试从这些内存中寻找合适的返回。这样就避免了频繁的系统调用，占用过多的系统资源。同时ptmalloc也会尝试对小块内存进行合并，避免过多的内存碎片。 ","date":"2022-06-20","objectID":"/posts/c++%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%981/:12:0","tags":["C++面试题1"],"title":"C++面试题1","uri":"/posts/c++%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%981/"},{"categories":["面试相关"],"content":"13、宏定义和函数有何区别？ 宏在预处理阶段完成替换，之后被替换的文本参与编译，相当于直接插入了代码，运行时不存在函数调用，执行起来更快；函数调用在运行时需要跳转到具体调用函数。 宏定义属于在结构中插入代码，没有返回值；函数调用具有返回值。 宏定义参数没有类型，不进行类型检查；函数参数具有类型，需要检查类型。 宏定义不要在最后加分号。 ","date":"2022-06-20","objectID":"/posts/c++%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%981/:13:0","tags":["C++面试题1"],"title":"C++面试题1","uri":"/posts/c++%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%981/"},{"categories":["面试相关"],"content":"14、宏定义和typedef区别？ 宏主要用于定义常量及书写复杂的内容；typedef主要用于定义类型别名。 宏替换发生在编译阶段之前，属于文本插入替换；typedef是编译的一部分。 宏不检查类型；typedef会检查数据类型。 宏不是语句，不在在最后加分号；typedef是语句，要加分号标识结束。 注意对指针的操作，typedef char * p_char和#define p_char char *区别巨大。 ","date":"2022-06-20","objectID":"/posts/c++%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%981/:14:0","tags":["C++面试题1"],"title":"C++面试题1","uri":"/posts/c++%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%981/"},{"categories":["面试相关"],"content":"15、变量声明和定义区别？ 声明仅仅是把变量的声明的位置及类型提供给编译器，并不分配内存空间；定义要在定义的地方为其分配存储空间。 相同变量可以在多处声明（外部变量extern），但只能在一处定义。 ","date":"2022-06-20","objectID":"/posts/c++%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%981/:15:0","tags":["C++面试题1"],"title":"C++面试题1","uri":"/posts/c++%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%981/"},{"categories":["面试相关"],"content":"16、strlen和sizeof区别？ sizeof是运算符，并不是函数，结果在编译时得到而非运行中获得；strlen是字符处理的库函数。 sizeof参数可以是任何数据的类型或者数据（sizeof参数不退化）；strlen的参数只能是字符指针且结尾是'\\0’的字符串。 因为sizeof值在编译时确定，所以不能用来得到动态分配（运行时分配）存储空间的大小。 int main(int argc, char const *argv[]){ const char* str = \"name\"; sizeof(str); // 取的是指针str的长度，是8 strlen(str); // 取的是这个字符串的长度，不包含结尾的 \\0。大小是4 return 0; } ","date":"2022-06-20","objectID":"/posts/c++%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%981/:16:0","tags":["C++面试题1"],"title":"C++面试题1","uri":"/posts/c++%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%981/"},{"categories":["面试相关"],"content":"16.2、（补充题）一个指针占多少字节？ 在16题中有提到sizeof（str）的值为8，是在64位的编译环境下的，指针的占用大小为8字节； 而在32位环境下，指针占用大小为4字节。 一个指针占内存的大小跟编译环境有关，而与机器的位数无关。 还有疑问的，可以自行打开Visual Studio编译器自己实验一番。 ","date":"2022-06-20","objectID":"/posts/c++%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%981/:16:1","tags":["C++面试题1"],"title":"C++面试题1","uri":"/posts/c++%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%981/"},{"categories":["面试相关"],"content":"17、常量指针和指针常量区别？ 指针常量是一个指针，读成常量的指针，指向一个只读变量，也就是后面所指明的int const 和 const int，都是一个常量，可以写作int const *p或const int *p。 常量指针是一个不能给改变指向的指针。指针是个常量，必须初始化，一旦初始化完成，它的值（也就是存放在指针中的地址）就不能在改变了，即不能中途改变指向，如int *const p。 ","date":"2022-06-20","objectID":"/posts/c++%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%981/:17:0","tags":["C++面试题1"],"title":"C++面试题1","uri":"/posts/c++%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%981/"},{"categories":["面试相关"],"content":"18、a和\u0026a有什么区别？ 假设数组int a[10]; int (*p)[10] = \u0026a;其中： a是数组名，是数组首元素地址，+1表示地址值加上一个int类型的大小，如果a的值是0x00000001，加1操作后变为0x00000005。*(a + 1) = a[1]。 \u0026a是数组的指针，其类型为int (*)[10]（就是前面提到的数组指针），其加1时，系统会认为是数组首地址加上整个数组的偏移（10个int型变量），值为数组a尾元素后一个元素的地址。 若(int *)p ，此时输出 *p时，其值为a[0]的值，因为被转为int *类型，解引用时按照int类型大小来读取。 ","date":"2022-06-20","objectID":"/posts/c++%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%981/:18:0","tags":["C++面试题1"],"title":"C++面试题1","uri":"/posts/c++%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%981/"},{"categories":["面试相关"],"content":"19、C++和Python的区别 包括但不限于： Python是一种脚本语言，是解释执行的，而C++是编译语言，是需要编译后在特定平台运行的。python可以很方便的跨平台，但是效率没有C++高。 Python使用缩进来区分不同的代码块，C++使用花括号来区分 C++中需要事先定义变量的类型，而Python不需要，Python的基本数据类型只有数字，布尔值，字符串，列表，元组等等 Python的库函数比C++的多，调用起来很方便 ","date":"2022-06-20","objectID":"/posts/c++%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%981/:19:0","tags":["C++面试题1"],"title":"C++面试题1","uri":"/posts/c++%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%981/"},{"categories":["面试相关"],"content":"20、C++和C语言的区别 C++中new和delete是对内存分配的运算符，取代了C中的malloc和free。 标准C++中的字符串类取代了标准C函数库头文件中的字符数组处理函数（C中没有字符串类型）。 C++中用来做控制态输入输出的iostream类库替代了标准C中的stdio函数库。 C++中的try/catch/throw异常处理机制取代了标准C中的setjmp()和longjmp()函数。 在C++中，允许有相同的函数名，不过它们的参数类型不能完全相同，这样这些函数就可以相互区别开来。而这在C语言中是不允许的。也就是C++可以重载，C语言不允许。 C++语言中，允许变量定义语句在程序中的任何地方，只要在是使用它之前就可以；而C语言中，必须要在函数开头部分。而且C++不允许重复定义变量，C语言也是做不到这一点的 在C++中，除了值和指针之外，新增了引用。引用型变量是其他变量的一个别名，我们可以认为他们只是名字不相同，其他都是相同的。 C++相对与C增加了一些关键字，如：bool、using、dynamic_cast、namespace等等 ","date":"2022-06-20","objectID":"/posts/c++%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%981/:20:0","tags":["C++面试题1"],"title":"C++面试题1","uri":"/posts/c++%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%981/"},{"categories":["面试相关"],"content":"面试八股——计算机网络1","date":"2022-06-20","objectID":"/posts/%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C1/","tags":["面试八股——计算机网络1"],"title":"面试八股——计算机网络1","uri":"/posts/%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C1/"},{"categories":["面试相关"],"content":"1、OSI 的七层模型分别是？各自的功能是什么？ ","date":"2022-06-20","objectID":"/posts/%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C1/:1:0","tags":["面试八股——计算机网络1"],"title":"面试八股——计算机网络1","uri":"/posts/%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C1/"},{"categories":["面试相关"],"content":"简要概括 物理层：底层数据传输，如网线；网卡标准。 数据链路层：定义数据的基本格式，如何传输，如何标识；如网卡MAC地址。 网络层：定义IP编址，定义路由功能；如不同设备的数据转发。 传输层：端到端传输数据的基本功能；如 TCP、UDP。 会话层：控制应用程序之间会话能力；如不同软件数据分发给不同软件。 表示层：数据格式标识，基本压缩加密功能。 应用层：各种应用软件，包括 Web 应用。 ","date":"2022-06-20","objectID":"/posts/%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C1/:1:1","tags":["面试八股——计算机网络1"],"title":"面试八股——计算机网络1","uri":"/posts/%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C1/"},{"categories":["面试相关"],"content":"说明 在四层，既传输层数据被称作段（Segments）； 三层网络层数据被称做包（Packages）； 二层数据链路层时数据被称为帧（Frames）； 一层物理层时数据被称为比特流（Bits）。 ","date":"2022-06-20","objectID":"/posts/%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C1/:1:2","tags":["面试八股——计算机网络1"],"title":"面试八股——计算机网络1","uri":"/posts/%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C1/"},{"categories":["面试相关"],"content":"总结 网络七层模型是一个标准，而非实现。 网络四层模型是一个实现的应用模型。 网络四层模型由七层模型简化合并而来。 ","date":"2022-06-20","objectID":"/posts/%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C1/:1:3","tags":["面试八股——计算机网络1"],"title":"面试八股——计算机网络1","uri":"/posts/%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C1/"},{"categories":["面试相关"],"content":"2、说一下一次完整的HTTP请求过程包括哪些内容？ ","date":"2022-06-20","objectID":"/posts/%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C1/:2:0","tags":["面试八股——计算机网络1"],"title":"面试八股——计算机网络1","uri":"/posts/%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C1/"},{"categories":["面试相关"],"content":"第一种回答 建立起客户机和服务器连接。 建立连接后，客户机发送一个请求给服务器。 服务器收到请求给予响应信息。 客户端浏览器将返回的内容解析并呈现，断开连接。 ","date":"2022-06-20","objectID":"/posts/%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C1/:2:1","tags":["面试八股——计算机网络1"],"title":"面试八股——计算机网络1","uri":"/posts/%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C1/"},{"categories":["面试相关"],"content":"第二种回答 域名解析 –\u003e 发起TCP的3次握手 –\u003e 建立TCP连接后发起http请求 –\u003e 服务器响应http请求，浏览器得到html代码 –\u003e 浏览器解析html代码，并请求html代码中的资源（如js、css、图片等） –\u003e 浏览器对页面进行渲染呈现给用户。 ","date":"2022-06-20","objectID":"/posts/%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C1/:2:2","tags":["面试八股——计算机网络1"],"title":"面试八股——计算机网络1","uri":"/posts/%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C1/"},{"categories":["面试相关"],"content":"3、你知道DNS是什么？ 官方解释：DNS（Domain Name System，域名系统），因特网上作为域名和IP地址相互映射的一个分布式数据库，能够使用户更方便的访问互联网，而不用去记住能够被机器直接读取的IP数串。 通过主机名，最终得到该主机名对应的IP地址的过程叫做域名解析（或主机名解析）。 通俗的讲，我们更习惯于记住一个网站的名字，比如www.baidu.com,而不是记住它的ip地址，比如：167.23.10.2。 ","date":"2022-06-20","objectID":"/posts/%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C1/:3:0","tags":["面试八股——计算机网络1"],"title":"面试八股——计算机网络1","uri":"/posts/%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C1/"},{"categories":["面试相关"],"content":"4、DNS的工作原理？ 将主机域名转换为ip地址，属于应用层协议，使用UDP传输。（DNS应用层协议，以前有个考官问过） 总结： 浏览器缓存，系统缓存，路由器缓存，IPS服务器缓存，根域名服务器缓存，顶级域名服务器缓存，主域名服务器缓存。 一、主机向本地域名服务器的查询一般都是采用递归查询。 二、本地域名服务器向根域名服务器的查询的迭代查询。 过程如下： 当用户输入域名时，浏览器先检查自己的缓存中是否 这个域名映射的ip地址，有解析结束。 若没命中，则检查操作系统缓存（如Windows的hosts）中有没有解析过的结果，有解析结束。 若无命中，则请求本地域名服务器解析（ LDNS）。 若LDNS没有命中就直接跳到根域名服务器请求解析。根域名服务器返回给LDNS一个 主域名服务器地址。 此时LDNS再发送请求给上一步返回的gTLD（ 通用顶级域）， 接受请求的gTLD查找并返回这个域名对应的Name Server的地址 Name Server根据映射关系表找到目标ip，返回给LDNS 。 LDNS缓存这个域名和对应的ip， 把解析的结果返回给用户，用户根据TTL值缓存到本地系统缓存中，域名解析过程至此结束。 ","date":"2022-06-20","objectID":"/posts/%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C1/:4:0","tags":["面试八股——计算机网络1"],"title":"面试八股——计算机网络1","uri":"/posts/%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C1/"},{"categories":["面试相关"],"content":"5、为什么域名解析用UDP协议？ 因为UDP快啊！UDP的DNS协议只要一个请求、一个应答就好了。 而使用基于TCP的DNS协议要三次握手、发送数据以及应答、四次挥手，但是UDP协议传输内容不能超过512字节。 不过客户端向DNS服务器查询域名，一般返回的内容都不超过512字节，用UDP传输即可。 ","date":"2022-06-20","objectID":"/posts/%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C1/:5:0","tags":["面试八股——计算机网络1"],"title":"面试八股——计算机网络1","uri":"/posts/%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C1/"},{"categories":["面试相关"],"content":"6、为什么区域传送用TCP协议？ 因为TCP协议可靠性好啊！ 你要从主DNS上复制内容啊，你用不可靠的UDP？ 因为TCP协议传输的内容大啊，你用最大只能传512字节的UDP协议？万一同步的数据大于512字节，你怎么办？所以用TCP协议比较好！ ","date":"2022-06-20","objectID":"/posts/%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C1/:6:0","tags":["面试八股——计算机网络1"],"title":"面试八股——计算机网络1","uri":"/posts/%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C1/"},{"categories":["面试相关"],"content":"7、HTTP长连接和短连接的区别 在HTTP/1.0中默认使用短连接。也就是说，客户端和服务器每进行一次HTTP操作，就建立一次连接，任务结束就中断连接。 而从HTTP/1.1起，默认使用长连接，用以保持连接特性。 ","date":"2022-06-20","objectID":"/posts/%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C1/:7:0","tags":["面试八股——计算机网络1"],"title":"面试八股——计算机网络1","uri":"/posts/%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C1/"},{"categories":["面试相关"],"content":"8、什么是TCP粘包/拆包？发生的原因？ 一个完整的业务可能会被TCP拆分成多个包进行发送，也有可能把多个小的包封装成一个大的数据包发送，这个就是TCP的拆包和粘包问题。 原因 应用程序写入数据的字节大小大于套接字发送缓冲区的大小. 进行MSS大小的TCP分段。( MSS=TCP报文段长度-TCP首部长度) 以太网的payload大于MTU进行IP分片。（ MTU指：一种通信协议的某一层上面所能通过的最大数据包大小。） 解决方案 消息定长。 在包尾部增加回车或者空格符等特殊字符进行分割 将消息分为消息头和消息尾。 使用其它复杂的协议，如RTMP协议等。 ","date":"2022-06-20","objectID":"/posts/%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C1/:8:0","tags":["面试八股——计算机网络1"],"title":"面试八股——计算机网络1","uri":"/posts/%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C1/"},{"categories":["面试相关"],"content":"9、为什么服务器会缓存这一项功能?如何实现的？ 原因 缓解服务器压力； 降低客户端获取资源的延迟：缓存通常位于内存中，读取缓存的速度更快。并且缓存服务器在地理位置上也有可能比源服务器来得近，例如浏览器缓存。 实现方法 让代理服务器进行缓存； 让客户端浏览器进行缓存。 ","date":"2022-06-20","objectID":"/posts/%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C1/:9:0","tags":["面试八股——计算机网络1"],"title":"面试八股——计算机网络1","uri":"/posts/%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C1/"},{"categories":["面试相关"],"content":"10、HTTP请求方法你知道多少？ 客户端发送的 请求报文 第一行为请求行，包含了方法字段。 根据 HTTP 标准，HTTP 请求可以使用多种请求方法。 HTTP1.0 定义了三种请求方法： GET, POST 和 HEAD方法。 HTTP1.1 新增了六种请求方法：OPTIONS、PUT、PATCH、DELETE、TRACE 和 CONNECT 方法。 序 号 方法 描述 1 GET 请求指定的页面信息，并返回实体主体。 2 HEAD 类似于 GET 请求，只不过返回的响应中没有具体的内容，用于获取报头 3 POST 向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST 请求可能会导致新的资源的建立和/或已有资源的修改。 4 PUT 从客户端向服务器传送的数据取代指定的文档的内容。 5 DELETE 请求服务器删除指定的页面。 6 CONNECT HTTP/1.1 协议中预留给能够将连接改为管道方式的代理服务器。 7 OPTIONS 允许客户端查看服务器的性能。 8 TRACE 回显服务器收到的请求，主要用于测试或诊断。 9 PATCH 是对 PUT 方法的补充，用来对已知资源进行局部更新 。 ","date":"2022-06-20","objectID":"/posts/%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C1/:10:0","tags":["面试八股——计算机网络1"],"title":"面试八股——计算机网络1","uri":"/posts/%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C1/"},{"categories":["面试相关"],"content":"11、GET 和 POST 的区别，你知道哪些？ get是获取数据，post是修改数据 get把请求的数据放在url上， 以?分割URL和传输数据，参数之间以\u0026相连，所以get不太安全。而post把数据放在HTTP的包体内（requrest body） get提交的数据最大是2k（ 限制实际上取决于浏览器）， post理论上没有限制。 GET产生一个TCP数据包，浏览器会把http header和data一并发送出去，服务器响应200(返回数据); POST产生两个TCP数据包，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok(返回数据)。 GET请求会被浏览器主动缓存，而POST不会，除非手动设置。 本质区别：GET是幂等的，而POST不是幂等的 这里的幂等性：幂等性是指一次和多次请求某一个资源应该具有同样的副作用。简单来说意味着对同一URL的多个请求应该返回同样的结果。 正因为它们有这样的区别，所以不应该且不能用get请求做数据的增删改这些有副作用的操作。因为get请求是幂等的，在网络不好的隧道中会尝试重试。如果用get请求增数据，会有重复操作的风险，而这种重复操作可能会导致副作用（浏览器和操作系统并不知道你会用get请求去做增操作）。 ","date":"2022-06-20","objectID":"/posts/%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C1/:11:0","tags":["面试八股——计算机网络1"],"title":"面试八股——计算机网络1","uri":"/posts/%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C1/"},{"categories":["面试相关"],"content":"12、一个TCP连接可以对应几个HTTP请求？ 一般来讲http协议是建立连接发送完消息后就会关闭连接，但如果维持TCP长连接，那么肯定是可以发送多个HTTP请求的。 ","date":"2022-06-20","objectID":"/posts/%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C1/:12:0","tags":["面试八股——计算机网络1"],"title":"面试八股——计算机网络1","uri":"/posts/%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C1/"},{"categories":["面试相关"],"content":"13、一个 TCP 连接中 HTTP 请求发送可以一起发送么（比如一起发三个请求，再三个响应一起接收）？ HTTP/1.1 存在一个问题，单个 TCP 连接在同一时刻只能处理一个请求，意思是说：两个请求的生命周期不能重叠，任意两个 HTTP 请求从开始到结束的时间在同一个 TCP 连接里不能重叠。 在 HTTP/1.1 存在 Pipelining 技术可以完成这个多个请求同时发送，但是由于浏览器默认关闭，所以可以认为这是不可行的。在 HTTP2 中由于 Multiplexing 特点的存在，多个 HTTP 请求可以在同一个 TCP 连接中并行进行。 那么在 HTTP/1.1 时代，浏览器是如何提高页面加载效率的呢？主要有下面两点： 维持和服务器已经建立的 TCP 连接，在同一连接上顺序处理多个请求。 和服务器建立多个 TCP 连接。 ","date":"2022-06-20","objectID":"/posts/%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C1/:13:0","tags":["面试八股——计算机网络1"],"title":"面试八股——计算机网络1","uri":"/posts/%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C1/"},{"categories":["面试相关"],"content":"14、浏览器对同一 Host 建立 TCP 连接到的数量有没有限制？ 假设我们还处在 HTTP/1.1 时代，那个时候没有多路传输，当浏览器拿到一个有几十张图片的网页该怎么办呢？肯定不能只开一个 TCP 连接顺序下载，那样用户肯定等的很难受，但是如果每个图片都开一个 TCP 连接发 HTTP 请求，那电脑或者服务器都可能受不了，要是有 1000 张图片的话总不能开 1000 个TCP 连接吧，你的电脑同意 NAT 也不一定会同意。 有。Chrome 最多允许对同一个 Host 建立六个 TCP 连接。不同的浏览器有一些区别。 如果图片都是 HTTPS 连接并且在同一个域名下，那么浏览器在 SSL 握手之后会和服务器商量能不能用 HTTP2，如果能的话就使用 Multiplexing 功能在这个连接上进行多路传输。不过也未必会所有挂在这个域名的资源都会使用一个 TCP 连接去获取，但是可以确定的是 Multiplexing 很可能会被用到。 如果发现用不了 HTTP2 呢？或者用不了 HTTPS（现实中的 HTTP2 都是在 HTTPS 上实现的，所以也就是只能使用 HTTP/1.1）。那浏览器就会在一个 HOST 上建立多个 TCP 连接，连接数量的最大限制取决于浏览器设置，这些连接会在空闲的时候被浏览器用来发送新的请求，如果所有的连接都正在发送请求呢？那其他的请求就只能等等了。 update1：微信好友“卷轴”提出勘误“连接到”-》“连接到的” ","date":"2022-06-20","objectID":"/posts/%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C1/:14:0","tags":["面试八股——计算机网络1"],"title":"面试八股——计算机网络1","uri":"/posts/%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C1/"},{"categories":["面试相关"],"content":"15、在浏览器中输入url地址后显示主页的过程? 根据域名，进行DNS域名解析； 拿到解析的IP地址，建立TCP连接； 向IP地址，发送HTTP请求； 服务器处理请求； 返回响应结果； 关闭TCP连接； 浏览器解析HTML； 浏览器布局渲染； ","date":"2022-06-20","objectID":"/posts/%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C1/:15:0","tags":["面试八股——计算机网络1"],"title":"面试八股——计算机网络1","uri":"/posts/%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C1/"},{"categories":["面试相关"],"content":"16、在浏览器地址栏输入一个URL后回车，背后会进行哪些技术步骤？ ","date":"2022-06-20","objectID":"/posts/%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C1/:16:0","tags":["面试八股——计算机网络1"],"title":"面试八股——计算机网络1","uri":"/posts/%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C1/"},{"categories":["面试相关"],"content":"第一种回答 1、查浏览器缓存，看看有没有已经缓存好的，如果没有 2 、检查本机host文件， 3、调用API，Linux下Scoket函数 gethostbyname 4、向DNS服务器发送DNS请求，查询本地DNS服务器，这其中用的是UDP的协议 5、如果在一个子网内采用ARP地址解析协议进行ARP查询如果不在一个子网那就需要对默认网关进行DNS查询，如果还找不到会一直向上找根DNS服务器，直到最终拿到IP地址（全球400多个根DNS服务器，由13个不同的组织管理） 6、这个时候我们就有了服务器的IP地址 以及默认的端口号了，http默认是80 https是 443 端口号，会，首先尝试http然后调用Socket建立TCP连接， 7、经过三次握手成功建立连接后，开始传送数据，如果正是http协议的话，就返回就完事了， 8、如果不是http协议，服务器会返回一个5开头的的重定向消息，告诉我们用的是https，那就是说IP没变，但是端口号从80变成443了，好了，再四次挥手，完事， 9、再来一遍，这次除了上述的端口号从80变成443之外，还会采用SSL的加密技术来保证传输数据的安全性，保证数据传输过程中不被修改或者替换之类的， 10、这次依然是三次握手，沟通好双方使用的认证算法，加密和检验算法，在此过程中也会检验对方的CA安全证书。 11、确认无误后，开始通信，然后服务器就会返回你所要访问的网址的一些数据，在此过程中会将界面进行渲染，牵涉到ajax技术之类的，直到最后我们看到色彩斑斓的网页 update1:为微信好友”卷轴“提出勘误”缺少5“-》现已加上 ","date":"2022-06-20","objectID":"/posts/%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C1/:16:1","tags":["面试八股——计算机网络1"],"title":"面试八股——计算机网络1","uri":"/posts/%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C1/"},{"categories":["面试相关"],"content":"第二种回答 浏览器检查域名是否在缓存当中（要查看 Chrome 当中的缓存， 打开 chrome://net-internals/#dns）。 如果缓存中没有，就去调用 gethostbyname 库函数（操作系统不同函数也不同）进行查询。 如果 gethostbyname 没有这个域名的缓存记录，也没有在hosts 里找到，它将会向 DNS 服务器发送一条 DNS 查询请求。DNS 服务器是由网络通信栈提供的，通常是本地路由器或者 ISP 的缓存 DNS 服务器。 查询本地 DNS 服务器 如果 DNS 服务器和我们的主机在同一个子网内，系统会按照下面的 ARP 过程对 DNS 服务器进行 ARP查询 如果 DNS 服务器和我们的主机在不同的子网，系统会按照下面的 ARP 过程对默认网关进行查询 ","date":"2022-06-20","objectID":"/posts/%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C1/:16:2","tags":["面试八股——计算机网络1"],"title":"面试八股——计算机网络1","uri":"/posts/%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C1/"},{"categories":["面试相关"],"content":"17、谈谈DNS解析过程，具体一点 请求一旦发起，若是chrome浏览器，先在浏览器找之前有没有缓存过的域名所对应的ip地址，有的话，直接跳过dns解析了，若是没有，就会找硬盘的hosts文件，看看有没有，有的话，直接找到hosts文件里面的ip 如果本地的hosts文件没有能得到对应的ip地址，浏览器会发出一个dns请求到本地dns服务器，本地dns服务器一般都是你的网络接入服务器商提供，比如中国电信，中国移动等。 查询你输入的网址的DNS请求到达本地DNS服务器之后，本地DNS服务器会首先查询它的缓存记录，如果缓存中有此条记录，就可以直接返回结果，此过程是递归的方式进行查询。如果没有，本地DNS服务器还要向DNS根服务器进行查询。 本地DNS服务器继续向域服务器发出请求，在这个例子中，请求的对象是.com域服务器。.com域服务器收到请求之后，也不会直接返回域名和IP地址的对应关系，而是告诉本地DNS服务器，你的域名的解析服务器的地址。 最后，本地DNS服务器向域名的解析服务器发出请求，这时就能收到一个域名和IP地址对应关系，本地DNS服务器不仅要把IP地址返回给用户电脑，还要把这个对应关系保存在缓存中，以备下次别的用户查询时，可以直接返回结果，加快网络访问。 ","date":"2022-06-20","objectID":"/posts/%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C1/:17:0","tags":["面试八股——计算机网络1"],"title":"面试八股——计算机网络1","uri":"/posts/%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C1/"},{"categories":["面试相关"],"content":"18、DNS负载均衡是什么策略？ 当一个网站有足够多的用户的时候，假如每次请求的资源都位于同一台机器上面，那么这台机器随时可能会崩掉。处理办法就是用DNS负载均衡技术，它的原理是在DNS服务器中为同一个主机名配置多个IP地址,在应答DNS查询时,DNS服务器对每个查询将以DNS文件中主机记录的IP地址按顺序返回不同的解析结果,将客户端的访问引导到不同的机器上去,使得不同的客户端访问不同的服务器,从而达到负载均衡的目的｡例如可以根据每台机器的负载量，该机器离用户地理位置的距离等等。 ","date":"2022-06-20","objectID":"/posts/%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C1/:18:0","tags":["面试八股——计算机网络1"],"title":"面试八股——计算机网络1","uri":"/posts/%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C1/"},{"categories":["面试相关"],"content":"19、HTTPS和HTTP的区别 1、HTTP协议传输的数据都是未加密的，也就是明文的，因此使用HTTP协议传输隐私信息非常不安全， HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比http协议安全。 2、https协议需要到ca申请证书，一般免费证书较少，因而需要一定费用。 3、http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。 ","date":"2022-06-20","objectID":"/posts/%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C1/:19:0","tags":["面试八股——计算机网络1"],"title":"面试八股——计算机网络1","uri":"/posts/%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C1/"},{"categories":["面试相关"],"content":"20、什么是SSL/TLS ？ SSL代表安全套接字层。它是一种用于加密和验证应用程序（如浏览器）和Web服务器之间发送的数据的协议。 身份验证 ， 加密Https的加密机制是一种共享密钥加密和公开密钥加密并用的混合加密机制。 SSL/TLS协议作用：认证用户和服务，加密数据，维护数据的完整性的应用层协议加密和解密需要两个不同的密钥，故被称为非对称加密；加密和解密都使用同一个密钥的对称加密：优点在于加密、解密效率通常比较高 ，HTTPS 是基于非对称加密的， 公钥是公开的。 关于对称加密和非对称加密，可以自己再具体搜索看看。 ","date":"2022-06-20","objectID":"/posts/%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C1/:20:0","tags":["面试八股——计算机网络1"],"title":"面试八股——计算机网络1","uri":"/posts/%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C1/"},{"categories":["JavaWeb笔记"],"content":"redis的介绍与使用","date":"2022-06-11","objectID":"/posts/redis%E7%9A%84%E4%BB%8B%E7%BB%8D%E4%B8%8E%E4%BD%BF%E7%94%A8/","tags":["redis的介绍与使用"],"title":"redis的介绍与使用","uri":"/posts/redis%E7%9A%84%E4%BB%8B%E7%BB%8D%E4%B8%8E%E4%BD%BF%E7%94%A8/"},{"categories":["JavaWeb笔记"],"content":"视频讲解链接 Redis数据库 灵魂拷问：不是学了MySQL吗，存数据也能存了啊，又学一个数据库干嘛？ 在前面我们学习了MySQL数据库，它是一种传统的关系型数据库，我们可以使用MySQL来更好地管理和组织我们的数据，虽然在小型Web应用下，只需要一个MySQL+Mybatis自带的缓存系统就可以胜任大部分的数据存储工作。但是MySQL的缺点也很明显，它的数据始终是存储在硬盘上的，对于我们的用户信息这种不需要经常发生修改的内容，使用MySQL存储确实可以，但是如果是快速更新或是频繁使用的数据，比如微博热搜、双十一秒杀，这些数据不仅要求服务器需要提供更高的响应速度，而且还需要面对短时间内上百万甚至上千万次访问，而MySQL的磁盘IO读写性能完全不能满足上面的需求，能够满足上述需求的只有内存，因为速度远高于磁盘IO。 因此，我们需要寻找一种更好的解决方案，来存储上述这类特殊数据，弥补MySQL的不足，以应对大数据时代的重重考验。 ","date":"2022-06-11","objectID":"/posts/redis%E7%9A%84%E4%BB%8B%E7%BB%8D%E4%B8%8E%E4%BD%BF%E7%94%A8/:0:0","tags":["redis的介绍与使用"],"title":"redis的介绍与使用","uri":"/posts/redis%E7%9A%84%E4%BB%8B%E7%BB%8D%E4%B8%8E%E4%BD%BF%E7%94%A8/"},{"categories":["JavaWeb笔记"],"content":"NoSQL概论 NoSQL全称是Not Only SQL（不仅仅是SQL）它是一种非关系型数据库，相比传统SQL关系型数据库，它： 不保证关系数据的ACID特性 并不遵循SQL标准 消除数据之间关联性 乍一看，这玩意不比MySQL垃圾？我们再来看看它的优势： 远超传统关系型数据库的性能 非常易于扩展 数据模型更加灵活 高可用 这样，NoSQL的优势一下就出来了，这不就是我们正要寻找的高并发海量数据的解决方案吗！ NoSQL数据库分为以下几种： **键值存储数据库：**所有的数据都是以键值方式存储的，类似于我们之前学过的HashMap，使用起来非常简单方便，性能也非常高。 **列存储数据库：**这部分数据库通常是用来应对分布式存储的海量数据。键仍然存在，但是它们的特点是指向了多个列。 **文档型数据库：**它是以一种特定的文档格式存储数据，比如JSON格式，在处理网页等复杂数据时，文档型数据库比传统键值数据库的查询效率更高。 **图形数据库：**利用类似于图的数据结构存储数据，结合图相关算法实现高速访问。 其中我们要学习的Redis数据库，就是一个开源的键值存储数据库，所有的数据全部存放在内存中，它的性能大大高于磁盘IO，并且它也可以支持数据持久化，他还支持横向扩展、主从复制等。 实际生产中，我们一般会配合使用Redis和MySQL以发挥它们各自的优势，取长补短。 ","date":"2022-06-11","objectID":"/posts/redis%E7%9A%84%E4%BB%8B%E7%BB%8D%E4%B8%8E%E4%BD%BF%E7%94%A8/:1:0","tags":["redis的介绍与使用"],"title":"redis的介绍与使用","uri":"/posts/redis%E7%9A%84%E4%BB%8B%E7%BB%8D%E4%B8%8E%E4%BD%BF%E7%94%A8/"},{"categories":["JavaWeb笔记"],"content":"Redis安装和部署 我们这里还是使用Windows安装Redis服务器，但是官方指定是安装到Linux服务器上，我们后面学习了Linux之后，再来安装到Linux服务器上。由于官方并没有提供Windows版本的安装包，我们需要另外寻找： 官网地址：https://redis.io GitHub Windows版本维护地址：https://github.com/tporadowski/redis/releases ","date":"2022-06-11","objectID":"/posts/redis%E7%9A%84%E4%BB%8B%E7%BB%8D%E4%B8%8E%E4%BD%BF%E7%94%A8/:2:0","tags":["redis的介绍与使用"],"title":"redis的介绍与使用","uri":"/posts/redis%E7%9A%84%E4%BB%8B%E7%BB%8D%E4%B8%8E%E4%BD%BF%E7%94%A8/"},{"categories":["JavaWeb笔记"],"content":"基本操作 在我们之前使用MySQL时，我们需要先在数据库中创建一张表，并定义好表的每个字段内容，最后再通过insert语句向表中添加数据，而Redis并不具有MySQL那样的严格的表结构，Redis是一个键值数据库，因此，可以像Map一样的操作方式，通过键值对向Redis数据库中添加数据（操作起来类似于向一个HashMap中存放数据） 在Redis下，数据库是由一个整数索引标识，而不是由一个数据库名称。 默认情况下，我们连接Redis数据库之后，会使用0号数据库，我们可以通过Redis配置文件中的参数来修改数据库总数，默认为16个。 我们可以通过select语句进行切换： select序号;","date":"2022-06-11","objectID":"/posts/redis%E7%9A%84%E4%BB%8B%E7%BB%8D%E4%B8%8E%E4%BD%BF%E7%94%A8/:3:0","tags":["redis的介绍与使用"],"title":"redis的介绍与使用","uri":"/posts/redis%E7%9A%84%E4%BB%8B%E7%BB%8D%E4%B8%8E%E4%BD%BF%E7%94%A8/"},{"categories":["JavaWeb笔记"],"content":"数据操作 我们来看看，如何向Redis数据库中添加数据： set\u003ckey\u003e\u003cvalue\u003e-- 一次性多个 mset[\u003ckey\u003e\u003cvalue\u003e]...所有存入的数据默认会以字符串的形式保存，键值具有一定的命名规范，以方便我们可以快速定位我们的数据属于哪一个部分，比如用户的数据： -- 使用冒号来进行板块分割，比如下面表示用户XXX的信息中的name属性，值为lbw setuser:info:用户ID:namelbw我们可以通过键值获取存入的值： get\u003ckey\u003e你以为Redis就仅仅只是存取个数据吗？它还支持数据的过期时间设定： set\u003ckey\u003e\u003cvalue\u003eEX秒set\u003ckey\u003e\u003cvalue\u003ePX毫秒当数据到达指定时间时，会被自动删除。我们也可以单独为其他的键值对设置过期时间： expire\u003ckey\u003e秒通过下面的命令来查询某个键值对的过期时间还剩多少： ttl\u003ckey\u003e-- 毫秒显示 pttl\u003ckey\u003e-- 转换为永久 persist\u003ckey\u003e那么当我们想直接删除这个数据时呢？直接使用： del\u003ckey\u003e...删除命令可以同时拼接多个键值一起删除。 当我们想要查看数据库中所有的键值时： keys*也可以查询某个键是否存在： exists\u003ckey\u003e...还可以随机拿一个键： randomkey我们可以将一个数据库中的内容移动到另一个数据库中： move\u003ckey\u003e数据库序号修改一个键为另一个键： rename\u003ckey\u003e\u003c新的名称\u003e-- 下面这个会检查新的名称是否已经存在 renamex\u003ckey\u003e\u003c新的名称\u003e如果存放的数据是一个数字，我们还可以对其进行自增自减操作： -- 等价于a = a + 1 incr\u003ckey\u003e-- 等价于a = a + b incrby\u003ckey\u003eb-- 等价于a = a - 1 decr\u003ckey\u003e最后就是查看值的数据类型： type\u003ckey\u003eRedis数据库也支持多种数据类型，但是它更偏向于我们在Java中认识的那些数据类型。 ","date":"2022-06-11","objectID":"/posts/redis%E7%9A%84%E4%BB%8B%E7%BB%8D%E4%B8%8E%E4%BD%BF%E7%94%A8/:3:1","tags":["redis的介绍与使用"],"title":"redis的介绍与使用","uri":"/posts/redis%E7%9A%84%E4%BB%8B%E7%BB%8D%E4%B8%8E%E4%BD%BF%E7%94%A8/"},{"categories":["JavaWeb笔记"],"content":"数据类型介绍 一个键值对除了存储一个String类型的值以外，还支持多种常用的数据类型。 ","date":"2022-06-11","objectID":"/posts/redis%E7%9A%84%E4%BB%8B%E7%BB%8D%E4%B8%8E%E4%BD%BF%E7%94%A8/:4:0","tags":["redis的介绍与使用"],"title":"redis的介绍与使用","uri":"/posts/redis%E7%9A%84%E4%BB%8B%E7%BB%8D%E4%B8%8E%E4%BD%BF%E7%94%A8/"},{"categories":["JavaWeb笔记"],"content":"Hash 这种类型本质上就是一个HashMap，也就是嵌套了一个HashMap罢了，在Java中就像这样： #Redis默认存String类似于这样： Map\u003cString, String\u003e hash = new HashMap\u003c\u003e(); #Redis存Hash类型的数据类似于这样： Map\u003cString, Map\u003cString, String\u003e\u003e hash = new HashMap\u003c\u003e(); 它比较适合存储类这样的数据，由于值本身又是一个Map，因此我们可以在此Map中放入类的各种属性和值，以实现一个Hash数据类型存储一个类的数据。 我们可以像这样来添加一个Hash类型的数据： hset\u003ckey\u003e[\u003c字段\u003e\u003c值\u003e]...我们可以直接获取： hget\u003ckey\u003e\u003c字段\u003e-- 如果想要一次性获取所有的字段和值 hgetall\u003ckey\u003e同样的，我们也可以判断某个字段是否存在： hexists\u003ckey\u003e\u003c字段\u003e删除Hash中的某个字段： hdel\u003ckey\u003e我们发现，在操作一个Hash时，实际上就是我们普通操作命令前面添加一个h，这样就能以同样的方式去操作Hash里面存放的键值对了，这里就不一一列出所有的操作了。我们来看看几个比较特殊的。 我们现在想要知道Hash中一共存了多少个键值对： hlen\u003ckey\u003e我们也可以一次性获取所有字段的值： hvals\u003ckey\u003e唯一需要注意的是，Hash中只能存放字符串值，不允许出现嵌套的的情况。 ","date":"2022-06-11","objectID":"/posts/redis%E7%9A%84%E4%BB%8B%E7%BB%8D%E4%B8%8E%E4%BD%BF%E7%94%A8/:4:1","tags":["redis的介绍与使用"],"title":"redis的介绍与使用","uri":"/posts/redis%E7%9A%84%E4%BB%8B%E7%BB%8D%E4%B8%8E%E4%BD%BF%E7%94%A8/"},{"categories":["JavaWeb笔记"],"content":"List 我们接着来看List类型，实际上这个猜都知道，它就是一个列表，而列表中存放一系列的字符串，它支持随机访问，支持双端操作，就像我们使用Java中的LinkedList一样。 我们可以直接向一个已存在或是不存在的List中添加数据，如果不存在，会自动创建： -- 向列表头部添加元素 lpush\u003ckey\u003e\u003celement\u003e...-- 向列表尾部添加元素 rpush\u003ckey\u003e\u003celement\u003e...-- 在指定元素前面/后面插入元素 linsert\u003ckey\u003ebefore/after\u003c指定元素\u003e\u003celement\u003e同样的，获取元素也非常简单： -- 根据下标获取元素 lindex\u003ckey\u003e\u003c下标\u003e-- 获取并移除头部元素 lpop\u003ckey\u003e-- 获取并移除尾部元素 rpop\u003ckey\u003e-- 获取指定范围内的 lrange\u003ckey\u003estartstop注意下标可以使用负数来表示从后到前数的数字（Python：搁这儿抄呢是吧）: -- 获取列表a中的全部元素 lrangea0-1没想到吧，push和pop还能连着用呢： -- 从前一个数组的最后取一个数出来放到另一个数组的头部，并返回元素 rpoplpush当前数组目标数组它还支持阻塞操作，类似于生产者和消费者，比如我们想要等待列表中有了数据后再进行pop操作： -- 如果列表中没有元素，那么就等待，如果指定时间（秒）内被添加了数据，那么就执行pop操作，如果超时就作废，支持同时等待多个列表，只要其中一个列表有元素了，那么就能执行 blpop\u003ckey\u003e...timeout","date":"2022-06-11","objectID":"/posts/redis%E7%9A%84%E4%BB%8B%E7%BB%8D%E4%B8%8E%E4%BD%BF%E7%94%A8/:4:2","tags":["redis的介绍与使用"],"title":"redis的介绍与使用","uri":"/posts/redis%E7%9A%84%E4%BB%8B%E7%BB%8D%E4%B8%8E%E4%BD%BF%E7%94%A8/"},{"categories":["JavaWeb笔记"],"content":"Set和SortedSet Set集合其实就像Java中的HashSet一样（我们在JavaSE中已经讲解过了，HashSet本质上就是利用了一个HashMap，但是Value都是固定对象，仅仅是Key不同）它不允许出现重复元素，不支持随机访问，但是能够利用Hash表提供极高的查找效率。 向Set中添加一个或多个值： sadd\u003ckey\u003e\u003cvalue\u003e...查看Set集合中有多少个值： scard\u003ckey\u003e判断集合中是否包含： -- 是否包含指定值 sismember\u003ckey\u003e\u003cvalue\u003e-- 列出所有值 smembers\u003ckey\u003e集合之间的运算： -- 集合之间的差集 sdiff\u003ckey1\u003e\u003ckey2\u003e-- 集合之间的交集 sinter\u003ckey1\u003e\u003ckey2\u003e-- 求并集 sunion\u003ckey1\u003e\u003ckey2\u003e-- 将集合之间的差集存到目标集合中 sdiffstore目标\u003ckey1\u003e\u003ckey2\u003e-- 同上 sinterstore目标\u003ckey1\u003e\u003ckey2\u003e-- 同上 sunionstore目标\u003ckey1\u003e\u003ckey2\u003e移动指定值到另一个集合中： smove\u003ckey\u003e目标value移除操作： -- 随机移除一个幸运儿 spop\u003ckey\u003e-- 移除指定 srem\u003ckey\u003e\u003cvalue\u003e...那么如果我们要求Set集合中的数据按照我们指定的顺序进行排列怎么办呢？这时就可以使用SortedSet，它支持我们为每个值设定一个分数，分数的大小决定了值的位置，所以它是有序的。 我们可以添加一个带分数的值： zadd\u003ckey\u003e[\u003cvalue\u003e\u003cscore\u003e]...同样的： -- 查询有多少个值 zcard\u003ckey\u003e-- 移除 zrem\u003ckey\u003e\u003cvalue\u003e...-- 获取区间内的所有 zrange\u003ckey\u003estartstop由于所有的值都有一个分数，我们也可以根据分数段来获取： -- 通过分数段查看 zrangebyscore\u003ckey\u003estartstop[withscores][limit]-- 统计分数段内的数量 zcount\u003ckey\u003estartstop-- 根据分数获取指定值的排名 zrank\u003ckey\u003e\u003cvalue\u003ehttps://www.jianshu.com/p/32b9fe8c20e1 有关Bitmap、HyperLogLog和Geospatial等数据类型，这里暂时不做介绍，感兴趣可以自行了解。 ","date":"2022-06-11","objectID":"/posts/redis%E7%9A%84%E4%BB%8B%E7%BB%8D%E4%B8%8E%E4%BD%BF%E7%94%A8/:4:3","tags":["redis的介绍与使用"],"title":"redis的介绍与使用","uri":"/posts/redis%E7%9A%84%E4%BB%8B%E7%BB%8D%E4%B8%8E%E4%BD%BF%E7%94%A8/"},{"categories":["JavaWeb笔记"],"content":"持久化 我们知道，Redis数据库中的数据都是存放在内存中，虽然很高效，但是这样存在一个非常严重的问题，如果突然停电，那我们的数据不就全部丢失了吗？它不像硬盘上的数据，断电依然能够保存。 这个时候我们就需要持久化，我们需要将我们的数据备份到硬盘上，防止断电或是机器故障导致的数据丢失。 持久化的实现方式有两种方案：一种是直接保存当前已经存储的数据，相当于复制内存中的数据到硬盘上，需要恢复数据时直接读取即可；还有一种就是保存我们存放数据的所有过程，需要恢复数据时，只需要将整个过程完整地重演一遍就能保证与之前数据库中的内容一致。 ","date":"2022-06-11","objectID":"/posts/redis%E7%9A%84%E4%BB%8B%E7%BB%8D%E4%B8%8E%E4%BD%BF%E7%94%A8/:5:0","tags":["redis的介绍与使用"],"title":"redis的介绍与使用","uri":"/posts/redis%E7%9A%84%E4%BB%8B%E7%BB%8D%E4%B8%8E%E4%BD%BF%E7%94%A8/"},{"categories":["JavaWeb笔记"],"content":"RDB RDB就是我们所说的第一种解决方案，那么如何将数据保存到本地呢？我们可以使用命令： save-- 注意上面这个命令是直接保存，会占用一定的时间，也可以单独开一个子进程后台执行保存 bgsave执行后，会在服务端目录下生成一个dump.rdb文件，而这个文件中就保存了内存中存放的数据，当服务器重启后，会自动加载里面的内容到对应数据库中。保存后我们可以关闭服务器： shutdown重启后可以看到数据依然存在。 虽然这种方式非常方便，但是由于会完整复制所有的数据，如果数据库中的数据量比较大，那么复制一次可能就需要花费大量的时间，所以我们可以每隔一段时间自动进行保存；还有就是，如果我们基本上都是在进行读操作，而没有进行写操作，实际上只需要偶尔保存一次即可，因为数据几乎没有怎么变化，可能两次保存的都是一样的数据。 我们可以在配置文件中设置自动保存，并设定在一段时间内写入多少数据时，执行一次保存操作： save 300 10 # 300秒（5分钟）内有10个写入\rsave 60 10000 # 60秒（1分钟）内有10000个写入\r配置的save使用的都是bgsave后台执行。 ","date":"2022-06-11","objectID":"/posts/redis%E7%9A%84%E4%BB%8B%E7%BB%8D%E4%B8%8E%E4%BD%BF%E7%94%A8/:5:1","tags":["redis的介绍与使用"],"title":"redis的介绍与使用","uri":"/posts/redis%E7%9A%84%E4%BB%8B%E7%BB%8D%E4%B8%8E%E4%BD%BF%E7%94%A8/"},{"categories":["JavaWeb笔记"],"content":"AOF 虽然RDB能够很好地解决数据持久化问题，但是它的缺点也很明显：每次都需要去完整地保存整个数据库中的数据，同时后台保存过程中也会产生额外的内存开销，最严重的是它并不是实时保存的，如果在自动保存触发之前服务器崩溃，那么依然会导致少量数据的丢失。 而AOF就是另一种方式，它会以日志的形式将我们每次执行的命令都进行保存，服务器重启时会将所有命令依次执行，通过这种重演的方式将数据恢复，这样就能很好解决实时性存储问题。 但是，我们多久写一次日志呢？我们可以自己配置保存策略，有三种策略： always：每次执行写操作都会保存一次 everysec：每秒保存一次（默认配置），这样就算丢失数据也只会丢一秒以内的数据 no：看系统心情保存 可以在配置文件中配置： #注意得改成也是appendonlyyes#appendfsyncalwaysappendfsynceverysec#appendfsyncno重启服务器后，可以看到服务器目录下多了一个appendonly.aof文件，存储的就是我们执行的命令。 AOF的缺点也很明显，每次服务器启动都需要进行过程重演，相比RDB更加耗费时间，并且随着我们的操作变多，不断累计，可能到最后我们的aof文件会变得无比巨大，我们需要一个改进方案来优化这些问题。 Redis有一个AOF重写机制进行优化，比如我们执行了这样的语句： lpush test 666\rlpush test 777\rlpush test 888\r实际上用一条语句也可以实现： lpush test 666 777 888\r正是如此，只要我们能够保证最终的重演结果和原有语句的结果一致，无论语句如何修改都可以，所以我们可以通过这种方式将多条语句进行压缩。 我们可以输入命令来手动执行重写操作： bgrewriteaof或是在配置文件中配置自动重写： # 百分比计算，这里不多介绍\rauto-aof-rewrite-percentage 100\r# 当达到这个大小时，触发自动重写\rauto-aof-rewrite-min-size 64mb\r至此，我们就完成了两种持久化方案的介绍，最后我们再来进行一下总结： AOF： 优点：存储速度快、消耗资源少、支持实时存储 缺点：加载速度慢、数据体积大 RDB： 优点：加载速度快、数据体积小 缺点：存储速度慢大量消耗资源、会发生数据丢失 ","date":"2022-06-11","objectID":"/posts/redis%E7%9A%84%E4%BB%8B%E7%BB%8D%E4%B8%8E%E4%BD%BF%E7%94%A8/:5:2","tags":["redis的介绍与使用"],"title":"redis的介绍与使用","uri":"/posts/redis%E7%9A%84%E4%BB%8B%E7%BB%8D%E4%B8%8E%E4%BD%BF%E7%94%A8/"},{"categories":["JavaWeb笔记"],"content":"事务和锁机制 和MySQL一样，在Redis中也有事务机制，当我们需要保证多条命令一次性完整执行而中途不受到其他命令干扰时，就可以使用事务机制。 我们可以使用命令来直接开启事务： multi当我们输入完所有要执行的命令时，可以使用命令来立即执行事务： exec我们也可以中途取消事务： discard实际上整个事务是创建了一个命令队列，它不像MySQL那种在事务中也能单独得到结果，而是我们提前将所有的命令装在队列中，但是并不会执行，而是等我们提交事务的时候再统一执行。 ","date":"2022-06-11","objectID":"/posts/redis%E7%9A%84%E4%BB%8B%E7%BB%8D%E4%B8%8E%E4%BD%BF%E7%94%A8/:6:0","tags":["redis的介绍与使用"],"title":"redis的介绍与使用","uri":"/posts/redis%E7%9A%84%E4%BB%8B%E7%BB%8D%E4%B8%8E%E4%BD%BF%E7%94%A8/"},{"categories":["JavaWeb笔记"],"content":"锁 又提到锁了，实际上这个概念对我们来说已经不算是陌生了。实际上在Redis中也会出现多个命令同时竞争同一个数据的情况，比如现在有两条命令同时执行，他们都要去修改a的值，那么这个时候就只能动用锁机制来保证同一时间只能有一个命令操作。 虽然Redis中也有锁机制，但是它是一种乐观锁，不同于MySQL，我们在MySQL中认识的锁是悲观锁，那么什么是乐观锁什么是悲观锁呢？ 悲观锁：时刻认为别人会来抢占资源，禁止一切外来访问，直到释放锁，具有强烈的排他性质。 乐观锁：并不认为会有人来抢占资源，所以会直接对数据进行操作，在操作时再去验证是否有其他人抢占资源。 Redis中可以使用watch来监视一个目标，如果执行事务之前被监视目标发生了修改，则取消本次事务： watch我们可以开两个客户端进行测试。 取消监视可以使用： unwatch至此，Redis的基础内容就讲解完毕了，在之后的SpringCloud阶段，我们还会去讲解集群相关的知识，包括主从复制、哨兵模式等。 ","date":"2022-06-11","objectID":"/posts/redis%E7%9A%84%E4%BB%8B%E7%BB%8D%E4%B8%8E%E4%BD%BF%E7%94%A8/:6:1","tags":["redis的介绍与使用"],"title":"redis的介绍与使用","uri":"/posts/redis%E7%9A%84%E4%BB%8B%E7%BB%8D%E4%B8%8E%E4%BD%BF%E7%94%A8/"},{"categories":["JavaWeb笔记"],"content":"使用Java与Redis交互 既然了解了如何通过命令窗口操作Redis数据库，那么我们如何使用Java来操作呢？ 这里我们需要使用到Jedis框架，它能够实现Java与Redis数据库的交互，依赖： \u003cdependencies\u003e \u003cdependency\u003e \u003cgroupId\u003eredis.clients\u003c/groupId\u003e \u003cartifactId\u003ejedis\u003c/artifactId\u003e \u003cversion\u003e4.0.0\u003c/version\u003e \u003c/dependency\u003e \u003c/dependencies\u003e ","date":"2022-06-11","objectID":"/posts/redis%E7%9A%84%E4%BB%8B%E7%BB%8D%E4%B8%8E%E4%BD%BF%E7%94%A8/:7:0","tags":["redis的介绍与使用"],"title":"redis的介绍与使用","uri":"/posts/redis%E7%9A%84%E4%BB%8B%E7%BB%8D%E4%B8%8E%E4%BD%BF%E7%94%A8/"},{"categories":["JavaWeb笔记"],"content":"基本操作 我们来看看如何连接Redis数据库，非常简单，只需要创建一个对象即可： public static void main(String[] args) { //创建Jedis对象 Jedis jedis = new Jedis(\"localhost\", 6379); //使用之后关闭连接 jedis.close(); } 通过Jedis对象，我们就可以直接调用命令的同名方法来执行Redis命令了，比如： public static void main(String[] args) { //直接使用try-with-resouse，省去close try(Jedis jedis = new Jedis(\"192.168.10.3\", 6379)){ jedis.set(\"test\", \"lbwnb\"); //等同于 set test lbwnb 命令 System.out.println(jedis.get(\"test\")); //等同于 get test 命令 } } Hash类型的数据也是这样： public static void main(String[] args) { try(Jedis jedis = new Jedis(\"192.168.10.3\", 6379)){ jedis.hset(\"hhh\", \"name\", \"sxc\"); //等同于 hset hhh name sxc jedis.hset(\"hhh\", \"sex\", \"19\"); //等同于 hset hhh age 19 jedis.hgetAll(\"hhh\").forEach((k, v) -\u003e System.out.println(k+\": \"+v)); } } 我们接着来看看列表操作： public static void main(String[] args) { try(Jedis jedis = new Jedis(\"192.168.10.3\", 6379)){ jedis.lpush(\"mylist\", \"111\", \"222\", \"333\"); //等同于 lpush mylist 111 222 333 命令 jedis.lrange(\"mylist\", 0, -1) .forEach(System.out::println); //等同于 lrange mylist 0 -1 } } 实际上我们只需要按照对应的操作去调用同名方法即可，所有的类型封装Jedis已经帮助我们完成了。 ","date":"2022-06-11","objectID":"/posts/redis%E7%9A%84%E4%BB%8B%E7%BB%8D%E4%B8%8E%E4%BD%BF%E7%94%A8/:7:1","tags":["redis的介绍与使用"],"title":"redis的介绍与使用","uri":"/posts/redis%E7%9A%84%E4%BB%8B%E7%BB%8D%E4%B8%8E%E4%BD%BF%E7%94%A8/"},{"categories":["JavaWeb笔记"],"content":"SpringBoot整合Redis 我们接着来看如何在SpringBoot项目中整合Redis操作框架，只需要一个starter即可，但是它底层没有用Jedis，而是Lettuce： \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-data-redis\u003c/artifactId\u003e \u003c/dependency\u003e starter提供的默认配置会去连接本地的Redis服务器，并使用0号数据库，当然你也可以手动进行修改： spring:redis:#Redis服务器地址host:192.168.10.3#端口port:6379#使用几号数据库database:0starter已经给我们提供了两个默认的模板类： @Configuration( proxyBeanMethods = false ) @ConditionalOnClass({RedisOperations.class}) @EnableConfigurationProperties({RedisProperties.class}) @Import({LettuceConnectionConfiguration.class, JedisConnectionConfiguration.class}) public class RedisAutoConfiguration { public RedisAutoConfiguration() { } @Bean @ConditionalOnMissingBean( name = {\"redisTemplate\"} ) @ConditionalOnSingleCandidate(RedisConnectionFactory.class) public RedisTemplate\u003cObject, Object\u003e redisTemplate(RedisConnectionFactory redisConnectionFactory) { RedisTemplate\u003cObject, Object\u003e template = new RedisTemplate(); template.setConnectionFactory(redisConnectionFactory); return template; } @Bean @ConditionalOnMissingBean @ConditionalOnSingleCandidate(RedisConnectionFactory.class) public StringRedisTemplate stringRedisTemplate(RedisConnectionFactory redisConnectionFactory) { return new StringRedisTemplate(redisConnectionFactory); } } 那么如何去使用这两个模板类呢？我们可以直接注入StringRedisTemplate来使用模板： @SpringBootTest class SpringBootTestApplicationTests { @Autowired StringRedisTemplate template; @Test void contextLoads() { ValueOperations\u003cString, String\u003e operations = template.opsForValue(); operations.set(\"c\", \"xxxxx\"); //设置值 System.out.println(operations.get(\"c\")); //获取值 template.delete(\"c\"); //删除键 System.out.println(template.hasKey(\"c\")); //判断是否包含键 } } 实际上所有的值的操作都被封装到了ValueOperations对象中，而普通的键操作直接通过模板对象就可以使用了，大致使用方式其实和Jedis一致。 我们接着来看看事务操作，由于Spring没有专门的Redis事务管理器，所以只能借用JDBC提供的，只不过无所谓，正常情况下反正我们也要用到这玩意： \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-jdbc\u003c/artifactId\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003emysql\u003c/groupId\u003e \u003cartifactId\u003emysql-connector-java\u003c/artifactId\u003e \u003c/dependency\u003e @Service public class RedisService { @Resource StringRedisTemplate template; @PostConstruct public void init(){ template.setEnableTransactionSupport(true); //需要开启事务 } @Transactional //需要添加此注解 public void test(){ template.multi(); template.opsForValue().set(\"d\", \"xxxxx\"); template.exec(); } } 我们还可以为RedisTemplate对象配置一个Serializer来实现对象的JSON存储： @Test void contextLoad2() { //注意Student需要实现序列化接口才能存入Redis template.opsForValue().set(\"student\", new Student()); System.out.println(template.opsForValue().get(\"student\")); } ","date":"2022-06-11","objectID":"/posts/redis%E7%9A%84%E4%BB%8B%E7%BB%8D%E4%B8%8E%E4%BD%BF%E7%94%A8/:7:2","tags":["redis的介绍与使用"],"title":"redis的介绍与使用","uri":"/posts/redis%E7%9A%84%E4%BB%8B%E7%BB%8D%E4%B8%8E%E4%BD%BF%E7%94%A8/"},{"categories":["JavaWeb笔记"],"content":"使用Redis做缓存 我们可以轻松地使用Redis来实现一些框架的缓存和其他存储。 ","date":"2022-06-11","objectID":"/posts/redis%E7%9A%84%E4%BB%8B%E7%BB%8D%E4%B8%8E%E4%BD%BF%E7%94%A8/:8:0","tags":["redis的介绍与使用"],"title":"redis的介绍与使用","uri":"/posts/redis%E7%9A%84%E4%BB%8B%E7%BB%8D%E4%B8%8E%E4%BD%BF%E7%94%A8/"},{"categories":["JavaWeb笔记"],"content":"Mybatis二级缓存 还记得我们在学习Mybatis讲解的缓存机制吗，我们当时介绍了二级缓存，它是Mapper级别的缓存，能够作用与所有会话。但是当时我们提出了一个问题，由于Mybatis的默认二级缓存只能是单机的，如果存在多台服务器访问同一个数据库，实际上二级缓存只会在各自的服务器上生效，但是我们希望的是多台服务器都能使用同一个二级缓存，这样就不会造成过多的资源浪费。 我们可以将Redis作为Mybatis的二级缓存，这样就能实现多台服务器使用同一个二级缓存，因为它们只需要连接同一个Redis服务器即可，所有的缓存数据全部存储在Redis服务器上。我们需要手动实现Mybatis提供的Cache接口，这里我们简单编写一下： //实现Mybatis的Cache接口 public class RedisMybatisCache implements Cache { private final String id; private static RedisTemplate\u003cObject, Object\u003e template; //注意构造方法必须带一个String类型的参数接收id public RedisMybatisCache(String id){ this.id = id; } //初始化时通过配置类将RedisTemplate给过来 public static void setTemplate(RedisTemplate\u003cObject, Object\u003e template) { RedisMybatisCache.template = template; } @Override public String getId() { return id; } @Override public void putObject(Object o, Object o1) { //这里直接向Redis数据库中丢数据即可，o就是Key，o1就是Value，60秒为过期时间 template.opsForValue().set(o, o1, 60, TimeUnit.SECONDS); } @Override public Object getObject(Object o) { //这里根据Key直接从Redis数据库中获取值即可 return template.opsForValue().get(o); } @Override public Object removeObject(Object o) { //根据Key删除 return template.delete(o); } @Override public void clear() { //由于template中没封装清除操作，只能通过connection来执行 template.execute((RedisCallback\u003cVoid\u003e) connection -\u003e { //通过connection对象执行清空操作 connection.flushDb(); return null; }); } @Override public int getSize() { //这里也是使用connection对象来获取当前的Key数量 return template.execute(RedisServerCommands::dbSize).intValue(); } } 缓存类编写完成后，我们接着来编写配置类： @Configuration public class MainConfiguration { @Resource RedisTemplate\u003cObject, Object\u003e template; @PostConstruct public void init(){ //把RedisTemplate给到RedisMybatisCache RedisMybatisCache.setTemplate(template); } } 最后我们在Mapper上启用此缓存即可： //只需要修改缓存实现类implementation为我们的RedisMybatisCache即可 @CacheNamespace(implementation = RedisMybatisCache.class) @Mapper public interface MainMapper { @Select(\"select name from student where sid = 1\") String getSid(); } 最后我们提供一个测试用例来查看当前的二级缓存是否生效： @SpringBootTest class SpringBootTestApplicationTests { @Resource MainMapper mapper; @Test void contextLoads() { System.out.println(mapper.getSid()); System.out.println(mapper.getSid()); System.out.println(mapper.getSid()); } } 手动使用客户端查看Redis数据库，可以看到已经有一条Mybatis生成的缓存数据了。 ","date":"2022-06-11","objectID":"/posts/redis%E7%9A%84%E4%BB%8B%E7%BB%8D%E4%B8%8E%E4%BD%BF%E7%94%A8/:8:1","tags":["redis的介绍与使用"],"title":"redis的介绍与使用","uri":"/posts/redis%E7%9A%84%E4%BB%8B%E7%BB%8D%E4%B8%8E%E4%BD%BF%E7%94%A8/"},{"categories":["JavaWeb笔记"],"content":"Token持久化存储 我们之前使用SpringSecurity时，remember-me的Token是支持持久化存储的，而我们当时是存储在数据库中，那么Token信息能否存储在缓存中呢，当然也是可以的，我们可以手动实现一个： //实现PersistentTokenRepository接口 @Component public class RedisTokenRepository implements PersistentTokenRepository { //Key名称前缀，用于区分 private final static String REMEMBER_ME_KEY = \"spring:security:rememberMe:\"; @Resource RedisTemplate\u003cObject, Object\u003e template; @Override public void createNewToken(PersistentRememberMeToken token) { //这里要放两个，一个存seriesId-\u003eToken，一个存username-\u003eseriesId，因为删除时是通过username删除 template.opsForValue().set(REMEMBER_ME_KEY+\"username:\"+token.getUsername(), token.getSeries()); template.expire(REMEMBER_ME_KEY+\"username:\"+token.getUsername(), 1, TimeUnit.DAYS); this.setToken(token); } //先获取，然后修改创建一个新的，再放入 @Override public void updateToken(String series, String tokenValue, Date lastUsed) { PersistentRememberMeToken token = this.getToken(series); if(token != null) this.setToken(new PersistentRememberMeToken(token.getUsername(), series, tokenValue, lastUsed)); } @Override public PersistentRememberMeToken getTokenForSeries(String seriesId) { return this.getToken(seriesId); } //通过username找seriesId直接删除这两个 @Override public void removeUserTokens(String username) { String series = (String) template.opsForValue().get(REMEMBER_ME_KEY+\"username:\"+username); template.delete(REMEMBER_ME_KEY+series); template.delete(REMEMBER_ME_KEY+\"username:\"+username); } //由于PersistentRememberMeToken没实现序列化接口，这里只能用Hash来存储了，所以单独编写一个set和get操作 private PersistentRememberMeToken getToken(String series){ Map\u003cObject, Object\u003e map = template.opsForHash().entries(REMEMBER_ME_KEY+series); if(map.isEmpty()) return null; return new PersistentRememberMeToken( (String) map.get(\"username\"), (String) map.get(\"series\"), (String) map.get(\"tokenValue\"), new Date(Long.parseLong((String) map.get(\"date\")))); } private void setToken(PersistentRememberMeToken token){ Map\u003cString, String\u003e map = new HashMap\u003c\u003e(); map.put(\"username\", token.getUsername()); map.put(\"series\", token.getSeries()); map.put(\"tokenValue\", token.getTokenValue()); map.put(\"date\", \"\"+token.getDate().getTime()); template.opsForHash().putAll(REMEMBER_ME_KEY+token.getSeries(), map); template.expire(REMEMBER_ME_KEY+token.getSeries(), 1, TimeUnit.DAYS); } } 接着把验证Service实现了： @Service public class AuthService implements UserDetailsService { @Resource UserMapper mapper; @Override public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException { Account account = mapper.getAccountByUsername(username); if(account == null) throw new UsernameNotFoundException(\"\"); return User .withUsername(username) .password(account.getPassword()) .roles(account.getRole()) .build(); } } Mapper也安排上： @Data public class Account implements Serializable { int id; String username; String password; String role; } @CacheNamespace(implementation = MybatisRedisCache.class) @Mapper public interface UserMapper { @Select(\"select * from users where username = #{username}\") Account getAccountByUsername(String username); } 最后配置文件配一波： @Override protected void configure(HttpSecurity http) throws Exception { http .authorizeRequests() .anyRequest().authenticated() .and() .formLogin() .and() .rememberMe() .tokenRepository(repository); } @Override protected void configure(AuthenticationManagerBuilder auth) throws Exception { auth .userDetailsService(service) .passwordEncoder(new BCryptPasswordEncoder()); } OK，启动服务器验证一下吧。 ","date":"2022-06-11","objectID":"/posts/redis%E7%9A%84%E4%BB%8B%E7%BB%8D%E4%B8%8E%E4%BD%BF%E7%94%A8/:8:2","tags":["redis的介绍与使用"],"title":"redis的介绍与使用","uri":"/posts/redis%E7%9A%84%E4%BB%8B%E7%BB%8D%E4%B8%8E%E4%BD%BF%E7%94%A8/"},{"categories":["JavaWeb笔记"],"content":"三大缓存问题 **注意：**这部分内容作为选学内容。 虽然我们可以利用缓存来大幅度提升我们程序的数据获取效率，但是使用缓存也存在着一些潜在的问题。 ","date":"2022-06-11","objectID":"/posts/redis%E7%9A%84%E4%BB%8B%E7%BB%8D%E4%B8%8E%E4%BD%BF%E7%94%A8/:9:0","tags":["redis的介绍与使用"],"title":"redis的介绍与使用","uri":"/posts/redis%E7%9A%84%E4%BB%8B%E7%BB%8D%E4%B8%8E%E4%BD%BF%E7%94%A8/"},{"categories":["JavaWeb笔记"],"content":"缓存穿透 当我们去查询一个一定不存在的数据，比如Mybatis在缓存是未命中的情况下需要从数据库查询，查不到数据则不写入缓存，这将导致这个不存在的数据每次请求都要到数据库去查询，造成缓存穿透。 这显然是很浪费资源的，我们希望的是，如果这个数据不存在，为什么缓存这一层不直接返回空呢，这时就不必再去查数据库了，但是也有一个问题，缓存不去查数据库怎么知道数据库里面到底有没有这个数据呢？ 这时我们就可以使用布隆过滤器来进行判断。什么是布隆过滤器？（当然不是打辅助的那个布隆，只不过也挺像，辅助布隆也是挡子弹的） 使用布隆过滤器，能够告诉你某样东西一定不存在或是某样东西可能存在。 布隆过滤器本质是一个存放二进制位的bit数组，如果我们要添加一个值到布隆过滤器中，我们需要使用N个不同的哈希函数来生成N个哈希值，并对每个生成的哈希值指向的bit位置1，如上图所示，一共添加了三个值abc。 接着我们给一个d，那么这时就可以进行判断，如果说d计算的N个哈希值的位置上都是1，那么就说明d可能存在；这时候又来了个e，计算后我们发现有一个位置上的值是0，这时就可以直接断定e一定不存在。 ","date":"2022-06-11","objectID":"/posts/redis%E7%9A%84%E4%BB%8B%E7%BB%8D%E4%B8%8E%E4%BD%BF%E7%94%A8/:9:1","tags":["redis的介绍与使用"],"title":"redis的介绍与使用","uri":"/posts/redis%E7%9A%84%E4%BB%8B%E7%BB%8D%E4%B8%8E%E4%BD%BF%E7%94%A8/"},{"categories":["JavaWeb笔记"],"content":"缓存击穿 某个 Key 属于热点数据，访问非常频繁，同一时间很多人都在访问，在这个Key失效的瞬间，大量的请求到来，这时发现缓存中没有数据，就全都直接请求数据库，相当于击穿了缓存屏障，直接攻击整个系统核心。 这种情况下，最好的解决办法就是不让Key那么快过期，如果一个Key处于高频访问，那么可以适当地延长过期时间。 ","date":"2022-06-11","objectID":"/posts/redis%E7%9A%84%E4%BB%8B%E7%BB%8D%E4%B8%8E%E4%BD%BF%E7%94%A8/:9:2","tags":["redis的介绍与使用"],"title":"redis的介绍与使用","uri":"/posts/redis%E7%9A%84%E4%BB%8B%E7%BB%8D%E4%B8%8E%E4%BD%BF%E7%94%A8/"},{"categories":["JavaWeb笔记"],"content":"缓存雪崩 当你的Redis服务器炸了或是大量的Key在同一时间过期，这时相当于缓存直接GG了，那么如果这时又有很多的请求来访问不同的数据，同一时间内缓存服务器就得向数据库大量发起请求来重新建立缓存，很容易把数据库也搞GG。 解决这种问题最好的办法就是设置高可用，也就是搭建Redis集群，当然也可以采取一些服务熔断降级机制，这些内容我们会在SpringCloud阶段再进行探讨。 ","date":"2022-06-11","objectID":"/posts/redis%E7%9A%84%E4%BB%8B%E7%BB%8D%E4%B8%8E%E4%BD%BF%E7%94%A8/:9:3","tags":["redis的介绍与使用"],"title":"redis的介绍与使用","uri":"/posts/redis%E7%9A%84%E4%BB%8B%E7%BB%8D%E4%B8%8E%E4%BD%BF%E7%94%A8/"},{"categories":["个人项目"],"content":"[Java课设]Swing用分层思想浅写个管理系统课设","date":"2022-06-05","objectID":"/posts/java%E8%AF%BE%E8%AE%BEswing%E7%94%A8%E5%88%86%E5%B1%82%E6%80%9D%E6%83%B3%E6%B5%85%E5%86%99%E4%B8%AA%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E8%AF%BE%E8%AE%BE/","tags":["[Java课设]Swing用分层思想浅写个管理系统课设"],"title":"[Java课设]Swing用分层思想浅写个管理系统课设","uri":"/posts/java%E8%AF%BE%E8%AE%BEswing%E7%94%A8%E5%88%86%E5%B1%82%E6%80%9D%E6%83%B3%E6%B5%85%E5%86%99%E4%B8%AA%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E8%AF%BE%E8%AE%BE/"},{"categories":["个人项目"],"content":" 本为Java实验课设，为了不浪费时间，故用良好的构思，写出了这个管理系统。 项目仓库地址：已开源GitHub ","date":"2022-06-05","objectID":"/posts/java%E8%AF%BE%E8%AE%BEswing%E7%94%A8%E5%88%86%E5%B1%82%E6%80%9D%E6%83%B3%E6%B5%85%E5%86%99%E4%B8%AA%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E8%AF%BE%E8%AE%BE/:0:0","tags":["[Java课设]Swing用分层思想浅写个管理系统课设"],"title":"[Java课设]Swing用分层思想浅写个管理系统课设","uri":"/posts/java%E8%AF%BE%E8%AE%BEswing%E7%94%A8%E5%88%86%E5%B1%82%E6%80%9D%E6%83%B3%E6%B5%85%E5%86%99%E4%B8%AA%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E8%AF%BE%E8%AE%BE/"},{"categories":["个人项目"],"content":"项目需求 基本要求： 社团管理：具体完成社团的新增、修改、查询等功能； 人员管理：针对某一指定的社团完成其学员（学生编号、姓名、年龄、所学专业、兴趣爱好等）进行新增、修改、查询、删除等功能； 给定某一学员，查找其所参加的全部社团，并将相关社团信息进行显示输出; 必须要用面向对象设计思想编程实现 高级要求： 界面友好 实现对社团人数按大小排序的功能； 在新增学员过程中，实现给定一学生编号，若该学生编号在其他社团中存在，则将该学生的信息自动进行显示，若不存在，则需要录入该学生的所有详细数据信息； ","date":"2022-06-05","objectID":"/posts/java%E8%AF%BE%E8%AE%BEswing%E7%94%A8%E5%88%86%E5%B1%82%E6%80%9D%E6%83%B3%E6%B5%85%E5%86%99%E4%B8%AA%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E8%AF%BE%E8%AE%BE/:1:0","tags":["[Java课设]Swing用分层思想浅写个管理系统课设"],"title":"[Java课设]Swing用分层思想浅写个管理系统课设","uri":"/posts/java%E8%AF%BE%E8%AE%BEswing%E7%94%A8%E5%88%86%E5%B1%82%E6%80%9D%E6%83%B3%E6%B5%85%E5%86%99%E4%B8%AA%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E8%AF%BE%E8%AE%BE/"},{"categories":["个人项目"],"content":"项目实现 本项目采取前后端分离的思想，Swing仅仅负责前端页面的展示，数据由后端访问数据库提供。 代码结构如下： ","date":"2022-06-05","objectID":"/posts/java%E8%AF%BE%E8%AE%BEswing%E7%94%A8%E5%88%86%E5%B1%82%E6%80%9D%E6%83%B3%E6%B5%85%E5%86%99%E4%B8%AA%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E8%AF%BE%E8%AE%BE/:2:0","tags":["[Java课设]Swing用分层思想浅写个管理系统课设"],"title":"[Java课设]Swing用分层思想浅写个管理系统课设","uri":"/posts/java%E8%AF%BE%E8%AE%BEswing%E7%94%A8%E5%88%86%E5%B1%82%E6%80%9D%E6%83%B3%E6%B5%85%E5%86%99%E4%B8%AA%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E8%AF%BE%E8%AE%BE/"},{"categories":["个人项目"],"content":"后端实现 数据库设计 一共有四张表： users：用于存储用户的账户和密码 clubs：存储所有社团信息 club_members：存储每个成员的基本信息 club_member_relations：存储社团和社团成员的多对多关系 架构分层 架构分层如下： models：负责直接和数据库打交道初步的增删改查操作。 service：真正提供给前端界面的接口，进一步封装增删改查，对上层参数校验，或者将models层零散的数据再包装。 接口实现情况 所有接口如下： 关键设计模式：单例模式。 DAO类均为单例访问模式。 Club相关 public static void AddClub(Club club) throws RuntimeException; public static void AddClubList(List\u003cClub\u003e clubList) throws RuntimeException; public static void UpdateClub(Club club) throws RuntimeException; public static void DeleteClub(Club club) throws RuntimeException; public static List\u003cClub\u003e QueryClubsByName(String name) throws RuntimeException; public static List\u003cClub\u003e QueryClubByMemberId(int memberId) throws RuntimeException; public static List\u003cClub\u003e QueryAllClub(); //根据order值返回按memberCount排序的结果：true顺序，false逆序 public static List\u003cClub\u003e QueryAllClubByOrder(boolean order); ClubMember相关 public static void AddClubMember(int clubId, ClubMember member) throws RuntimeException; //把一堆人加入到一个社团中 public static void AddClubMemberList(int clubId, List\u003cClubMember\u003e clubMemberList) throws RuntimeException; public static void UpdateClubMember(ClubMember member) throws RuntimeException; public static List\u003cClubMember\u003e QueryClubMemberByName(int clubId, String name) throws RuntimeException; public static void DeleteClubMemberById(int clubId, int id) throws RuntimeException; public static List\u003cClubMember\u003e QueryClubMembersByClubId(int clubId) throws RuntimeException; ","date":"2022-06-05","objectID":"/posts/java%E8%AF%BE%E8%AE%BEswing%E7%94%A8%E5%88%86%E5%B1%82%E6%80%9D%E6%83%B3%E6%B5%85%E5%86%99%E4%B8%AA%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E8%AF%BE%E8%AE%BE/:2:1","tags":["[Java课设]Swing用分层思想浅写个管理系统课设"],"title":"[Java课设]Swing用分层思想浅写个管理系统课设","uri":"/posts/java%E8%AF%BE%E8%AE%BEswing%E7%94%A8%E5%88%86%E5%B1%82%E6%80%9D%E6%83%B3%E6%B5%85%E5%86%99%E4%B8%AA%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E8%AF%BE%E8%AE%BE/"},{"categories":["个人项目"],"content":"前端实现 架构分层情况 核心设计 所有的界面均采用单例模式进行操作，这样界面之间的交互就不存在任何问题，想要显示任意一个窗口，只需要如下代码，由于用的是一个单例，则每次获取单例时我们应该把它的状态先调整为0，也就是需要单独写一共reset成员函数来进行调整，具体用法如下： //此处演示为MainMenu窗口，任意窗口都是通过这种模式进行窗口之间的切换和显示，而不是会产生很多问题的new MainMenu.getInstance().reset(); 界面美化设计和特色 用定时器不断切换精美背景图片。 重写JLable实现自定义超链接。 Excel导入导出功能。 查询的排序算法，支持按照社团人数升序或者降序排序。 所有操作添加了快捷键。 还有一共看似不起眼，但我认为却非常重要的，那就是代码的健壮性，由于后端的分层逻辑使得数据之间的增删改查稳定性极佳。 最终界面效果 ","date":"2022-06-05","objectID":"/posts/java%E8%AF%BE%E8%AE%BEswing%E7%94%A8%E5%88%86%E5%B1%82%E6%80%9D%E6%83%B3%E6%B5%85%E5%86%99%E4%B8%AA%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E8%AF%BE%E8%AE%BE/:2:2","tags":["[Java课设]Swing用分层思想浅写个管理系统课设"],"title":"[Java课设]Swing用分层思想浅写个管理系统课设","uri":"/posts/java%E8%AF%BE%E8%AE%BEswing%E7%94%A8%E5%88%86%E5%B1%82%E6%80%9D%E6%83%B3%E6%B5%85%E5%86%99%E4%B8%AA%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E8%AF%BE%E8%AE%BE/"},{"categories":["个人项目"],"content":"项目运行 项目运行环境 JDK版本11，只用到了Java1.8的特性，故只需要JDK版本\u003e=1.8。 mybatis：版本3.5.7，用于快速实现和数据库和模型之间的映射。 JUnit：版本4.13.2，用于测试各个模块的功能。 lombok：用于快速生成getter和setter poi：版本3.11，用于导入导出Excel表格 界面的运行流程 界面中所有对数据的操作，都是直接调用后端接口实现。 ","date":"2022-06-05","objectID":"/posts/java%E8%AF%BE%E8%AE%BEswing%E7%94%A8%E5%88%86%E5%B1%82%E6%80%9D%E6%83%B3%E6%B5%85%E5%86%99%E4%B8%AA%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E8%AF%BE%E8%AE%BE/:2:3","tags":["[Java课设]Swing用分层思想浅写个管理系统课设"],"title":"[Java课设]Swing用分层思想浅写个管理系统课设","uri":"/posts/java%E8%AF%BE%E8%AE%BEswing%E7%94%A8%E5%88%86%E5%B1%82%E6%80%9D%E6%83%B3%E6%B5%85%E5%86%99%E4%B8%AA%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E8%AF%BE%E8%AE%BE/"},{"categories":["个人项目"],"content":"项目代码仓库 仓库链接 ","date":"2022-06-05","objectID":"/posts/java%E8%AF%BE%E8%AE%BEswing%E7%94%A8%E5%88%86%E5%B1%82%E6%80%9D%E6%83%B3%E6%B5%85%E5%86%99%E4%B8%AA%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E8%AF%BE%E8%AE%BE/:2:4","tags":["[Java课设]Swing用分层思想浅写个管理系统课设"],"title":"[Java课设]Swing用分层思想浅写个管理系统课设","uri":"/posts/java%E8%AF%BE%E8%AE%BEswing%E7%94%A8%E5%88%86%E5%B1%82%E6%80%9D%E6%83%B3%E6%B5%85%E5%86%99%E4%B8%AA%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E8%AF%BE%E8%AE%BE/"},{"categories":["青训营笔记"],"content":"消息队列","date":"2022-06-04","objectID":"/posts/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/","tags":["消息队列"],"title":"消息队列","uri":"/posts/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"},{"categories":["青训营笔记"],"content":"消息队列的应用场景 ","date":"2022-06-04","objectID":"/posts/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/:1:0","tags":["消息队列"],"title":"消息队列","uri":"/posts/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"},{"categories":["青训营笔记"],"content":"场景一：解耦 如上所述，如果记录用户行为的这个请求过程，和后台服务的记录过程直接耦合，将会产生很严重的后果，如果后台服务宕机或者直接删库跑路等等状况，那么前端的请求也不会得到正确的响应，这时前端的请求服务将会一直阻塞，这会严重影响用户体验。 此时如果我们在记录存储的前面引入消息队列，那么每次前端发送的请求只要到了消息队列就能正常返回了，这会大大提高响应的速度，后续的存储过程就不需要再关心了，这就是解耦的应用。 ","date":"2022-06-04","objectID":"/posts/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/:1:1","tags":["消息队列"],"title":"消息队列","uri":"/posts/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"},{"categories":["青训营笔记"],"content":"场景二：削峰 具体到生活中的业务就是，如果有一个抢购秒杀活动，这个时候，肯定会导致在某个时间段流量达到很大的峰值，而我们最终只需要寥寥10个名额甚至更少，那么我们该如何解决？ 这个时候可以利用到消息队列，可以在后端正式处理之前加上一个消息队列，便可达到以下效果： 可以控制活动的人数 可以缓解短时间内高流量压垮应用 用户的请求，服务器接收后，首先写入消息队列。假如消息队列长度超过最大数量，则直接抛弃用户请求或跳转到错误页面 后台只需消费队列中的内容即可 ","date":"2022-06-04","objectID":"/posts/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/:1:2","tags":["消息队列"],"title":"消息队列","uri":"/posts/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"},{"categories":["青训营笔记"],"content":"场景三：异步 如上图所示，这是一个串行的过程，很明显可以优化为并行过程，但如果还是像图中的直接将发起订单后的三个过程并行，那最终还是得等30s才能有结果！那么如何解决呢？ 这个时候可以加个消息队列，前端和消息队列接触后，直接返回，然后后台负责去消费这个消息队列即可（实际上这个过程更像是解耦的过程 ","date":"2022-06-04","objectID":"/posts/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/:1:3","tags":["消息队列"],"title":"消息队列","uri":"/posts/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"},{"categories":["青训营笔记"],"content":"场景四：日志处理 同样，如果是通过消息队列作为中间的过程来传递日志，那么不用担心真正后台记录日志的服务器宕机且后台日志丢失等严重问题。 ","date":"2022-06-04","objectID":"/posts/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/:1:4","tags":["消息队列"],"title":"消息队列","uri":"/posts/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"},{"categories":["青训营笔记"],"content":"消费队列的定义 其中的高并发和高吞吐都很清楚，而这里的高可用，指的就是不会随便发生异常行为而导致服务不可用！ ","date":"2022-06-04","objectID":"/posts/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/:1:5","tags":["消息队列"],"title":"消息队列","uri":"/posts/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"},{"categories":["青训营笔记"],"content":"业界的消息队列 业界常用消息队列对比 ","date":"2022-06-04","objectID":"/posts/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/:2:0","tags":["消息队列"],"title":"消息队列","uri":"/posts/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"},{"categories":["青训营笔记"],"content":"Kafka 以上为Kafka的使用流程。 创建集群。 需要在这个集群中创建一个Topic，并且设置好分片数量。 引入对应语言的SDK，配置好集群和Topic等参数，初始化一个生产者，调用Send方法，将你的Hello World发送出去。 引入对应语言的SDK，配置好集群和Topic等参数，初始化一个消费者，调用Poll方法，你将收到你刚刚发送的Hello World。 基本名词 Cluster Topic：Kakfa中的逻辑队列，可以理解成每一个不同的业务场景就是一个不同的topic，对于这个业务来说，所有的数据都存储在这个topic中。 Cluster：Kafka的物理集群，每个集群中可以新建多个不同的topic。 Producer：顾名思义，也就是消息的生产端，负责将业务消息发送到Topic当中。 Consumer：消息的消费端，负责消费已经发送到topic中的消息。 Partition：通常topic会有多个分片，不同分片直接消息是可以并发来处理的，这样提高单个Topic的吞吐。 Offset 对于每一个Partition来说，每一条消息都有一个唯一的Offset，消息在partition内的相对位置信息，并且严格递增。 Replica Replica：分片的副本，分布在不同的机器上，可用来容灾，Leader对外服务，Follower异步去拉取leader的数据进行一个同步，如果leader挂掉了，可以将Follower提升成leader再堆外进行服务 ISR：意思是同步中的副本，对于Follower来说，始终和leader是有一定差距的，但当这个差距比较小的时候，我们就可以将这个follower副本加入到ISR中，不在ISR中的副本是不允许提升成Leader的。 实际架构过程分析 Broker 注意看上图，每个broker代表一个节点，实际上对应一台机器，所有的Broker组成了一个集群，我们不要被每个框框束缚住，只需关注一共有哪些Topic和它对应的Partition即可。 整个图表示，图中整个集群，包含了4个Broker机器节点，集群有两个Topic，分别是Topic1和Topic2，Topic1有两个分片，Topic2有1个分片，每个分片都是三副本的状态。这里中间有一个Broker同时也扮演了Controller的角色，Controller是整个集群的大脑，负责对副本和Broker进行分配。 Zookeeper 而在集群的基础上，还有一个模块是ZooKeeper，这个模块其实是存储了集群的元数据信息，比如副本的分配信息等等，Controller计算好的方案都会放到这个地方。 Kafka高吞吐和稳定的秘诀 Producer 通过批量发送减少IO次数。 为了防止批量发送的数据包过大，使用压缩算法进行压缩。 Broker 采用以下三点进行优化： graph TB\ra[顺序写]\rb[消息索引]\rc[零拷贝]\rd[优化方式]\rd--\u003ea\rd--\u003eb\rd--\u003ec\r先来看看消息队列的的文件结构： 在每一个Broker，都分布着不同Topic的不同分片。 顺序写 顺序写：每条消息都是紧凑排列的顺序写入。 消息索引 由于文件名和第一条存储数据的索引相同，故可先通过二分查找找到小于offset的最大索引位置，然后再遍历这个文件内的索引记录，便可找到目标消息。 同理，也可通过时间戳二分查找。 零拷贝 通过操作系统的API，直接实现内核空间直接发送到网络。 Consumer 对于一个Consumer Group来说，多个分片可以并发的消费，这样可以大大提高消费的效率，但需要解决的问题是，Consumer和Partition的分配问题，也就是对于每一个Partition来讲，该由哪一个Consumer来消费的问题。对于这个问题，我们一般有两种解决方法，手动分配和自动分配。 手动分配 第一，手动分配，也就是Kafka中所说的Low Level消费方式进行消费，这种分配方式的一个好处就是启动比较快，因为对于每一个Consumer来说，启动的时候就已经知道了自己应该去消费哪个消费方式，就好比图中的Consumer Group1来说，Consumer1去消费Partition1,2,3 Consumer2，去消费456， Consumer3去消费78。这些Consumer再启动的时候就已经知道分配方案了，但这样这种方式的缺点又是什么呢，想象一下，如果我们的Consumer3挂掉了，我们的7,8分片是不是就停止消费了。又或者，如果我们新增了一台Consumer4，那是不是又需要停掉整个集群，重新修改配置再上线，保证Consumer4也可以消费数据，其实上面两个问题，有时候对于线上业务来说是致命的。 自动分配 所以Kafka也提供了自动分配的方式，这里也叫做High Level的消费方式，简单的来说，就是在我们的Broker集群中，对于不同的Consumer Group来讲，都会选取一台Broker当做Coordinator，而Coordinator的作用就是帮助Consumer Group进行分片的分配，也叫做分片的rebalance，使用这种方式，如果ConsumerGroup中有发生宕机，或者有新的Consumer加入，整个partition和Consumer都会重新进行分配来达到一个稳定的消费状态。 Kafka存在的问题 运维成本高 举个例子来说，如果我们对一个机器进行重启 首先，我们会关闭一个Broker，此时如果该Broker上存在副本的Leader，那么该副本将发生leader切换，切换到其他节点上面并且在ISR中的Follower副本，可以看到图中是切换到了第二个Broker上面 而此时，因为数据在不断的写入，对于刚刚关闭重启的Broker来说，和新Leader之间一定会存在数据的滞后，此时这个Broker会追赶数据，重新加入到ISR当中 当数据追赶完成之后，我们需要回切leader，这一步叫做prefer leader，这一步的目的是为了避免，在一个集群长期运行后，所有的leader都分布在少数节点上，导致数据的不均衡 通过上面的一个流程分析，我们可以发现对于一个Broker的重启来说，需要进行数据复制，所以时间成本会比较大，比如一个节点重启需要10分钟，一个集群有1000个节点，如果该集群需要重启升级，则需要10000分钟，那差不多就是一个星期，这样的时间成本是非常大的。 你可能会说，可以不可以并发多台重启呀，问的好，不可以。为什么呢，在一个两副本的集群中，重启了两台机器，对某一分片来讲，可能两个分片都在这台机器上面（可能这几个机器包含所有分片，则会导致该集群处于不可用的状态。这是更不能接受的。 负载不均衡场景解决方案复杂 这个场景当中，同一个Topic有4个分片，两副本，可以看到，对于分片1来说，数据量是明显比其他分片要大的，当我们机器IO达到瓶颈的时候，可能就需要把第一台Broker上面的Partition3迁移到其他负载小的Broker上面，但我们的数据复制又会引起Broker1的IO升高，所以问题就变成了，我为了去解决IO升高，但解决问题的过程又会带来更高的IO，所以就需要权衡IO设计出一个极其复杂的负载均衡策略。 没有自己的缓存 Kafka没有自己的缓存，在进行数据读取的时候，只有Page Cache可以用，所以不是很灵活。 Controller、Coordinator、Broker处于同一进程 Kafka的Controller和Coordinator都是和Broker部署在一起的，Broker因为承载大量IO的原因，会导致Controller和Coordinator的性能下降，如果到一定程度，可能会影响整个集群的可用性。 ","date":"2022-06-04","objectID":"/posts/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/:2:1","tags":["消息队列"],"title":"消息队列","uri":"/posts/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"},{"categories":["青训营笔记"],"content":"BMQ 架构模型（解决Kafka存在的问题 解决运维成本问题 实际上对于所有节点变更的操作，都仅仅只是集群元数据的变化，通常情况下都能秒级完成，而真正的数据已经移到下层分布式文件存储去了，所以运维操作不需要额外关心数据复制所带来的时间成本。 分布式系统的具体文件写入操作： 通过前面的介绍，我们知道了，同一个副本是由多个segment组成，我们来看看BMQ对于单个文件写入的机制是怎么样的，首先客户端写入前会选择一定数量的DataNode，这个数量是副本数，然后将一个文件写入到这三个节点上，切换到下一个segment之后，又会重新选择三个节点进行写入。这样一来，对于单个副本的所有segment来讲，会随机的分配到分布式文件系统的整个集群中。 解决负载均衡问题 对于Kafka分片数据的写入，是通过先在Leader上面写好文件，然后同步到Follower上，所以对于同一个副本的所有Segment都在同一台机器上面。就会存在之前我们所说到的单分片过大导致负载不均衡的问题，但在BMQ集群中，因为对于单个副本来讲，是随机分配到不同的节点上面的（分布式存储，因此不会存在Kafka的负载不均问题。 其实对于写入的逻辑来说，我们还有一个状态机的机制，用来保证不会出现同一个分片在两个Broker上同时启动的情况，另外也能够保证一个分片的正常运行。首先，Controller做好分片的分配之后，如果在该Broker分配到了Broker，首先会start这个分片，然后进入Recover状态，这个状态主要有两个目的获取分片写入权利，也就是说，对于hdfs来讲，只会允许我一个分片进行写入，只有拿到这个权利的分片我才能写入，第二一个目的是如果上次分片是异常中断的，没有进行save checkpoint，这里会重新进行一次save checkpoint，然后就进入了正常的写流程状态，创建文件，写入数据，到一定大小之后又开始建立新的文件进行写入。 读写流程 文件写入流程 数据校验：CRC , 参数是否合法 校验完成后，会把数据放入Buffer中 通过一个异步的Write Thread线程将数据最终写入到底层的存储系统当中。 这里有一个地方需要注意一下，就是对于业务的写入来说，可以配置返回方式，可以在写完缓存之后直接返回，另外我也可以数据真正写入存储系统后再返回，对于这两个来说前者损失了数据的可靠性，带来了吞吐性能的优势，因为只写入内存是比较快的，但如果在下一次flush前发生宕机了，这个时候数据就有可能丢失了，后者的话，因为数据已经写入了存储系统，这个时候也不需要担心数据丢失，相应的来说吞吐就会小一些 我们再来看看Thread的具体逻辑，首先会将Buffer中的数据取出来，调用底层写入逻辑，在一定的时间周期上去flush，flush完成后开始建立Index，也就是offset和timestamp对于消息具体位置的映射关系 Index建立好以后，会save一次checkpoint，也就表示，checkpoint后的数据是可以被消费的，我们想一下，如果没有checkpoint的情况下会发生什么问题，如果flush完成之后宕机，index还没有建立，这个数据是不应该被消费的 最后当文件到达一定大小之后，需要建立一个新的segment文件来写入。 文件获取流程 首先Consumer发送一个Fetch Request，然后会有一个Wait流程，那么他的左右是什么呢，想象一个Topic，如果一直没有数据写入，那么，此时consumer就会一直发送Fetch Request，如果Consumer数量过多，BMQ的server端是扛不住这个请求的，因此，我们设置了一个等待机制，如果没有fetch到指定大小的数据，那么proxy会等待一定的时间，再返回给用户侧，这样也就降低了fetch请求的IO次数，经过我们的wait流程后，我们会到我们的Cache里面去找到是否有存在我们想要的数据，如果有直接返回，如果没有，再开始去存储系统当中寻找，首先会Open这个文件，然后通过Index找到数据所在的具体位置，从这个位置开始读取数据。 高级特性 泳道 Databus 在直接的消息队列的客户端操作之中又封装了一层，客户端代码可用得到简化，可缓解集群压力。 Mirror 主要用于解决跨区域（不同国家）的读写问题。 Index 通过索引构建类似于数据库的表结构。 Parquet Parquet 是一种支持嵌套结构的列式存储格式 非常适用于 OLAP 场景，按列存储和扫描 ","date":"2022-06-04","objectID":"/posts/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/:2:2","tags":["消息队列"],"title":"消息队列","uri":"/posts/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"},{"categories":["青训营笔记"],"content":"RocketMQ 基本概念 Broker节点有Master和Slave的概念 NameServer为集群提供轻量级服务发现和路由。 根据我们刚刚的介绍，可以看到Producer，Consumer，Broker这三个部分，Kafka和RocketMQ是一样的，而Kafka中的Partition概念在这里叫做ConsumerQueue。 底层原理 存储模型 接下来我们来看看RocketMQ消息的存储模型，对于一个Broker来说所有的消息的会append到一个CommitLog上面，然后按照不同的Queue，重新Dispatch到不同的Consumer中，这样Consumer就可以按照Queue进行拉取消费，但需要注意的是，这里的ConsumerQueue所存储的并不是真实的数据，真实的数据其实只存在CommitLog中，这里存的仅仅是这个Queue所有消息在CommitLog上面的位置，相当于是这个Queue的一个密集索引。 高级特性 事务消息 先看一下我们最开始说的这个场景，正常情况下，这个下单的流程应该是这个样子，首先我保证库存足够能够顺利-1，这个时候再消息队列让我其他系统来处理，比如订单系统和商家系统，但这里有个比较重要的点，我库存服务和消息队列必须要是在同一个事务内的，大家还记不记得事务的基本特性是什么。ACID（原子性、一致性、隔离性、持久性），这里库存记录和往消息队列里面发的消息这两个事情，是需要有事务保证的，这样不至于发生，库存已经-1了，但我的订单没有增加，或者商家也没有收到通知要发货。因此RocketMQ提供事务消息来保证类似的场景。 ACID: 原子性（Atomicity） 原子性是指事务是一个不可分割的工作单位，事务中的操作要么都发生，要么都不发生。 一致性（Consistency） 事务前后数据的完整性必须保持一致。 隔离性（Isolation） 事务的隔离性是多个用户并发访问数据库时，数据库为每一个用户开启的事务，不能被其他事务的操作数据所干扰，多个并发事务之间要相互隔离。 持久性（Durability） 持久性是指一个事务一旦被提交，它对数据库中数据的改变就是永久性的，接下来即使数据库发生故障也不应该对其有任何影响。 延迟队列 执行原理： 重试和死信队列 对于处理失败的情况下，用充实和死信队列的方式处理。 特性说明 死信消息具有以下特性： 不会再被消费者正常消费。 有效期与正常消息相同，均为3天，3天后会被自动删除。因此，请在死信消息产生后的3天内及时处理。 死信队列具有以下特性： 一个死信队列对应一个Group ID， 而不是对应单个消费者实例。 如果一个Group ID未产生死信消息，消息队列RocketMQ版不会为其创建相应的死信队列。 一个死信队列包含了对应Group ID产生的所有死信消息，不论该消息属于哪个Topic。 消息队列RocketMQ版控制台提供对死信消息的查询、导出和重发的功能。 ","date":"2022-06-04","objectID":"/posts/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/:2:3","tags":["消息队列"],"title":"消息队列","uri":"/posts/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"},{"categories":["青训营笔记"],"content":"jwt","date":"2022-05-17","objectID":"/posts/jwt/","tags":["用户鉴权是什么？jwt是什么？"],"title":"【项目必会】用户鉴权是什么？jwt是什么？ | 青训营笔记","uri":"/posts/jwt/"},{"categories":["青训营笔记"],"content":"这是我参与「第三届青训营 -后端场」笔记创作活动的的第四篇笔记。 由于最近14周忙的焦头烂额，所以一直没有时间写笔记，而且也很久没有认真看青训营的课了（期末考试，所有专业课都放在了14周考试，考完这个周，后面就没有重要的考试了（6级英语和蓝桥杯国赛除外😭 我为什么突然将JWT鉴权，因为抖音项目里面的前后端身份识别就是通过传递JWT token进行身份验证的传递。 JSON Web Token（缩写 JWT）是目前最流行的跨域认证解决方案，本文介绍它的原理和用法。 ","date":"2022-05-17","objectID":"/posts/jwt/:0:0","tags":["用户鉴权是什么？jwt是什么？"],"title":"【项目必会】用户鉴权是什么？jwt是什么？ | 青训营笔记","uri":"/posts/jwt/"},{"categories":["青训营笔记"],"content":"用户认证 在服务端和客户端之间通信的过程中，服务端需要有效的识别出客户端的身份，才能进行对应的通信，毕竟大部分时候客户端和服务器并不是长连接，一般都是socket都是连接后收发一个包就断开了，所以这种情景下，每次请求肯定是需要重新经过认证过程的。 互联网服务离不开用户认证。一般流程是下面这样。 用户向服务器发送用户名和密码。 服务器验证通过后，在当前对话（session）里面保存相关数据，比如用户角色、登录时间等等。 服务器向用户返回一个 session_id，写入用户的 Cookie。 用户随后的每一次请求，都会通过 Cookie，将 session_id 传回服务器。 服务器收到 session_id，找到前期保存的数据，由此得知用户的身份。 这种模式的问题在于，扩展性不好。单机当然没有问题，如果是服务器集群，或者是跨域的服务导向架构，就要求 session 数据共享，每台服务器都能够读取 session。 举例来说，A 网站和 B 网站是同一家公司的关联服务。现在要求，用户只要在其中一个网站登录，再访问另一个网站就会自动登录，请问怎么实现？ 一种解决方案是 session 数据持久化，写入数据库或别的持久层。各种服务收到请求后，都向持久层请求数据。这种方案的优点是架构清晰，缺点是工程量比较大。另外，持久层万一挂了，就会单点失败。 另一种方案是服务器索性不保存 session 数据了，所有数据都保存在客户端，每次请求都发回服务器。JWT 就是这种方案的一个代表。 ","date":"2022-05-17","objectID":"/posts/jwt/:1:0","tags":["用户鉴权是什么？jwt是什么？"],"title":"【项目必会】用户鉴权是什么？jwt是什么？ | 青训营笔记","uri":"/posts/jwt/"},{"categories":["青训营笔记"],"content":"JWT到底是什么 ","date":"2022-05-17","objectID":"/posts/jwt/:2:0","tags":["用户鉴权是什么？jwt是什么？"],"title":"【项目必会】用户鉴权是什么？jwt是什么？ | 青训营笔记","uri":"/posts/jwt/"},{"categories":["青训营笔记"],"content":"JWT原理 为什么叫做JWT，从缩写中又json，就不难猜出，它的数据格式肯定和json格式有关联。 JWT 的原理是，服务器认证以后，生成一个 JSON 对象，发回给用户，就像下面这样。 { \"姓名\": \"张三\", \"角色\": \"管理员\", \"到期时间\": \"2022年5月27日0点0分\" } 之后，用户与服务端通信的时候，都要发回这个 JSON 对象。服务器完全只靠这个对象认定用户身份。为了防止用户篡改数据，服务器在生成这个对象的时候，会加上签名（详见后文）。 服务器就不保存任何 session 数据了，也就是说，服务器变成无状态了，从而比较容易实现扩展。 ","date":"2022-05-17","objectID":"/posts/jwt/:2:1","tags":["用户鉴权是什么？jwt是什么？"],"title":"【项目必会】用户鉴权是什么？jwt是什么？ | 青训营笔记","uri":"/posts/jwt/"},{"categories":["青训营笔记"],"content":"JWT数据结构 虽然如上文所说，发送的JWT是一个json对象是没错，但实际发送的并不是直接的明文，而应该是由 . 分割的三个字符串。如下图： 以上的三个部分的字符串，分别被称为以下三个组成部分： Header（头部） Payload（负载） Signature（签名） 即 Header.Paload.Signature 下面依次介绍这三个部分。 Header Header 部分是一个 JSON 对象，描述 JWT 的元数据，通常是下面的样子。 { \"alg\": \"HS256\", \"typ\": \"JWT\" } 上面代码中，alg属性表示签名的算法（algorithm），默认是 HMAC SHA256（写成 HS256）；typ属性表示这个令牌（token）的类型（type），JWT 令牌统一写为JWT。 Payload Payload 部分也是一个 JSON 对象，用来存放实际需要传递的数据。JWT 规定了7个官方字段，供选用。 iss (issuer)：签发人 exp (expiration time)：过期时间 sub (subject)：主题 aud (audience)：受众 nbf (Not Before)：生效时间 iat (Issued At)：签发时间 jti (JWT ID)：编号 除了官方字段，你还可以在这个部分定义私有字段，下面就是一个例子。 { \"sub\": \"1234567890\", \"name\": \"John Doe\", \"admin\": true } 注意：JWT 默认是不加密的（即便后面的签名也只是为了防止数据篡改），任何人都可以读到，所以不要把秘密信息放在这个部分。 Signature Signature 部分是对前两部分的签名，防止数据篡改。 首先，需要指定一个密钥（secret）。这个密钥只有服务器才知道，不能泄露给用户。然后，使用 Header 里面指定的签名算法（默认是 HMAC SHA256），按照下面的公式产生签名。 HMACSHA256(\rbase64UrlEncode(header) + \".\" +\rbase64UrlEncode(payload),\rsecret)\r算出签名以后，把 Header、Payload、Signature 三个部分拼成一个字符串，每个部分之间用\"点\"（.）分隔，就可以返回给用户。 ","date":"2022-05-17","objectID":"/posts/jwt/:2:2","tags":["用户鉴权是什么？jwt是什么？"],"title":"【项目必会】用户鉴权是什么？jwt是什么？ | 青训营笔记","uri":"/posts/jwt/"},{"categories":["青训营笔记"],"content":"JWT实战 根据前面的描述，我们对JWT的数据结构有了一定的了解。 现在转换到我们的Go语言中具体的使用它！ 首先go get一下我们处理JWT的包。 go get github.com/dgrijalva/jwt-go ","date":"2022-05-17","objectID":"/posts/jwt/:3:0","tags":["用户鉴权是什么？jwt是什么？"],"title":"【项目必会】用户鉴权是什么？jwt是什么？ | 青训营笔记","uri":"/posts/jwt/"},{"categories":["青训营笔记"],"content":"签发JWT的token 根据前面的讲解，我们已经了解到JWT的数据结构，它就是一个json文件，包含三个部分。 那么我们现在需要做的就是填写这三部分，最后通过base64UrlEncode编码得到字符串即为最终的token。 Header部分 这个部分包含两个字段，这两个字段都不用我们填，会由你选择的签名算法自动填写好。 Payload部分 我们查看 jwt.StandardClaims 类型的字段，可以发现它包含如下的类型： 这正好就是Payload部分默认填写的几个字段，我们自定义一个结构体，将该结构体类型嵌入。如下，我定义了Claims类型： type Claims struct { UserId int64 jwt.StandardClaims } 然后我们把这些字段填充完整，来用它得到token。 claims := \u0026Claims{ UserId: user.UserInfoId, StandardClaims: jwt.StandardClaims{ ExpiresAt: expirationTime.Unix(), IssuedAt: time.Now().Unix(), Issuer: \"douyin_pro_131\", Subject: \"L_B__\", }} token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims) jwt.NewWithClaims() 将返回一个 Token 对象。 看看源码，我们发现它仅仅构造了Token对象并返回，里面包含了你已经确认的签名方法回调。 Signature部分 最后通过得到的 Token 对象调用它的 SignedString 方法并传入产生签名需要的密钥(自定义byte[]类型的数据)，将会自动完成token的整个编码过程：包括对 Signature 字段的填写，以及将上述三个部分json数据通过base64url进行最后的编码返回最终的token字符串。 完整源码 ","date":"2022-05-17","objectID":"/posts/jwt/:3:1","tags":["用户鉴权是什么？jwt是什么？"],"title":"【项目必会】用户鉴权是什么？jwt是什么？ | 青训营笔记","uri":"/posts/jwt/"},{"categories":["青训营笔记"],"content":"解析JWT的token 解析过程就非常的简单了，这相当于一个反序列化的过程，和json的解析过程类似，jwt提供的函数需要传入对象的指针，然后在内部帮你完整反序列化操作绑定到这个对象，唯一的不一样就是我们还需要传入一个回调，这个回调返回密钥以便最终的签名判断防止数据篡改。 代码如下： 注意：JWT解析过程中，它是会判断token是否过期了，如果过期，那么就会返回err。 最后我们服务端得到claims后，便可得到其中包含的用户信息了，然后对该用户执行对应的操作，比如得到该用户喜欢的视频列表。 以上所有代码均出自我写的抖音项目里的 jwt.go 目录中。 源码链接 ","date":"2022-05-17","objectID":"/posts/jwt/:3:2","tags":["用户鉴权是什么？jwt是什么？"],"title":"【项目必会】用户鉴权是什么？jwt是什么？ | 青训营笔记","uri":"/posts/jwt/"},{"categories":["青训营笔记"],"content":"JWT的几个特点总结 （1）JWT 默认是不加密，但也是可以加密的。生成原始 Token 以后，可以用密钥再加密一次。 （2）JWT 不加密的情况下，不能将秘密数据写入 JWT。 （3）JWT 不仅可以用于认证，也可以用于交换信息。有效使用 JWT，可以降低服务器查询数据库的次数。 （4）JWT 的最大缺点是，由于服务器不保存 session 状态，因此无法在使用过程中废止某个 token，或者更改 token 的权限。也就是说，一旦 JWT 签发了，在到期之前就会始终有效，除非服务器部署额外的逻辑。 （5）JWT 本身包含了认证信息，一旦泄露，任何人都可以获得该令牌的所有权限。为了减少盗用，JWT 的有效期应该设置得比较短。对于一些比较重要的权限，使用时应该再次对用户进行认证。 （6）为了减少盗用，JWT 不应该使用 HTTP 协议明码传输，要使用 HTTPS 协议传输。 参考链接： https://jwt.io/introduction/ learn how to use jwt? ","date":"2022-05-17","objectID":"/posts/jwt/:4:0","tags":["用户鉴权是什么？jwt是什么？"],"title":"【项目必会】用户鉴权是什么？jwt是什么？ | 青训营笔记","uri":"/posts/jwt/"},{"categories":["JavaWeb笔记"],"content":"一文进入JavaWeb后端","date":"2022-05-13","objectID":"/posts/%E4%B8%80%E6%96%87%E8%BF%9B%E5%85%A5javaweb/","tags":["一文进入JavaWeb后端"],"title":"一文进入JavaWeb后端","uri":"/posts/%E4%B8%80%E6%96%87%E8%BF%9B%E5%85%A5javaweb/"},{"categories":["JavaWeb笔记"],"content":"前端基础 整个前端基础详细介绍看下面这个链接，这里直接讲里面的实践。 前端基础 ","date":"2022-05-13","objectID":"/posts/%E4%B8%80%E6%96%87%E8%BF%9B%E5%85%A5javaweb/:1:0","tags":["一文进入JavaWeb后端"],"title":"一文进入JavaWeb后端","uri":"/posts/%E4%B8%80%E6%96%87%E8%BF%9B%E5%85%A5javaweb/"},{"categories":["JavaWeb笔记"],"content":"css实践编写一个漂亮的登录界面 html文件 \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003cmeta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"\u003e \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e \u003ctitle\u003elbwnb\u003c/title\u003e \u003clink rel=\"icon\" href=\"icon.png\" type=\"image/x-icon\"\u003e \u003clink rel=\"stylesheet\" href=\"style.css\"\u003e \u003c/head\u003e \u003cbody\u003e \u003ch1\u003e登录系统\u003c/h1\u003e \u003cform\u003e \u003chr\u003e \u003cdiv id=\"username\"\u003e \u003clabel\u003e \u003cinput type=\"text\" placeholder=\"用户名\" oninput=\"\"\u003e \u003c/label\u003e \u003c/div\u003e \u003cdiv id=\"password\"\u003e \u003clabel\u003e \u003cinput type=\"password\" placeholder=\"密码\"\u003e \u003c/label\u003e \u003c/div\u003e \u003cdiv\u003e \u003cbutton\u003e登录\u003c/button\u003e \u003c/div\u003e \u003c/form\u003e \u003c/body\u003e \u003c/html\u003e css文件 body{ margin: 0; text-align: center; } h1:hover { color: rgb(45, 150, 189); } input{ border: none; background: #e0e0e0; line-height: 48px; border-radius: 20px; padding: 0 20px 0 20px; width: 250px; font-size: 15px; margin-top: 20px; outline: 0; } input:focus{ box-shadow: 0 2px 10px gray; } button { margin-top: 60px; background: #4174e3; border: 0; border-radius: 20px; height: 50px; width: 200px; color: white; font-size: 18px; box-shadow: 0 2px 10px #63b9f6; } button:focus{ outline: 0; background: #3b4f72; } ","date":"2022-05-13","objectID":"/posts/%E4%B8%80%E6%96%87%E8%BF%9B%E5%85%A5javaweb/:1:1","tags":["一文进入JavaWeb后端"],"title":"一文进入JavaWeb后端","uri":"/posts/%E4%B8%80%E6%96%87%E8%BF%9B%E5%85%A5javaweb/"},{"categories":["JavaWeb笔记"],"content":"前端数据交互和动态的关键 JavaScript事件 事件就是各种动作会触发的信号，这个信号可以添加一个回调给他来调用，在每次触发的时候会调用对应的回调。 事件有很多种类。 常用的有： onclick：点击事件 oninput：内容输入事件 onsubmit：内容提交事件 如何为事件添加一个回调呢？ 直接在属性值里面添加js代码，如下：（注意代码里不要用双引号 \u003cinput type=\"password\" oninput=\"console.log('正在输入文本')\" 引入js文件，然后直接能调用js里的函数。如下： \u003cscript type=\"text/javascript\" src=\"test.js\"\u003e\u003c/script\u003e 然后如下进行使用： \u003cinput type=\"password\" placeholder=\"密码\" oninput=\"f()\"\u003e js文件如下： function f(){ console.log('正在输入文本') } Document Object Model(DOM) 当网页被加载时，浏览器会创建页面的文档对象模型（Document Object Model），它将整个页面的所有元素全部映射为JS对象，这样我们就可以在JS中操纵页面中的元素。 这个对象的名字就叫做document。 比如我现在想要读取页面中某个输入框中的内容，那么我们就需要从DOM中获取此输入框元素的对象： document.getElementById(\"pwd\").value //通过控件的id获取 DOM实践 我们通过DOM实现这样一个功能：我们结合事件，来进行密码长度的校验，密码长度小于6则不合法，不合法的密码，会让密码框边框变红。 输入框变红的css样式： .illegal-pwd{ border: red 1px solid !important; box-shadow: 0 0 5px red; } 对应的js代码，此函数接受一个参数（元素本身的对象）检测输入的长度是否大于6，否则就将当前元素的class属性设定为css指定的class： function checkIllegal(e) { if(e.value.length \u003c 6) { e.setAttribute(\"class\", \"illegal-pwd\") }else { e.removeAttribute(\"class\") } } html最终使用：注意参数传this表示这个组件 \u003cinput type=\"password\" placeholder=\"密码\" oninput=\"checkIllegal(this)\"\u003e 完成以上修改后，会自动检查密码是否合法了。 既然oninput本身也是一个属性，那么实际上我们可以动态进行修改： document.getElementById(\"pwd\").oninput = () =\u003e console.info(\"???\") 那么，我们前面提及的window对象又是什么东西呢？ 实际上Window对象范围更加广阔，它甚至直接代表了整个窗口，当然也包含我们的Document对象，我们一般通过Window对象来弹出提示框之类的东西。 window.document可以得到当前的DOM。 js发送XHR请求 通过使用XMLHttpRequest对象，来向服务器发送一个HTTP请求，下面是一个最简单的请求格式： let xhr = new XMLHttpRequest(); xhr.open('GET', 'https://www.baidu.com'); xhr.send(); 上面的例子中，我们向服务器发起了一次网络请求，但是我们请求的是百度的服务器，并且此请求的方法为GET请求。 我们现在将其绑定到一个按钮上作为事件触发： function http() { let xhr = new XMLHttpRequest(); xhr.open('GET', 'https://www.baidu.com'); xhr.send(); } \u003cinput id=\"button\" type=\"button\" onclick=\"http()\"\u003e 我们可以在网络中查看我们发起的HTTP请求并且查看请求的响应结果，比如上面的请求，会返回百度这个页面的全部HTML代码。 实际上，我们的浏览器在我们输入网址后，也会向对应网站的服务器发起一次HTTP的GET请求。 在浏览器得到页面响应后，会加载当前页面，如果当前页面还引用了其他资源文件，那么会继续向服务器发起请求，直到页面中所有的资源文件全部加载完成后，才会停止。 ","date":"2022-05-13","objectID":"/posts/%E4%B8%80%E6%96%87%E8%BF%9B%E5%85%A5javaweb/:1:2","tags":["一文进入JavaWeb后端"],"title":"一文进入JavaWeb后端","uri":"/posts/%E4%B8%80%E6%96%87%E8%BF%9B%E5%85%A5javaweb/"},{"categories":["JavaWeb笔记"],"content":"JavaWeb后端 ","date":"2022-05-13","objectID":"/posts/%E4%B8%80%E6%96%87%E8%BF%9B%E5%85%A5javaweb/:2:0","tags":["一文进入JavaWeb后端"],"title":"一文进入JavaWeb后端","uri":"/posts/%E4%B8%80%E6%96%87%E8%BF%9B%E5%85%A5javaweb/"},{"categories":["JavaWeb笔记"],"content":"HTTP协议简介 Web通信使用的上层协议都是HTTP协议，更准确一点应该是HTTPS，但是HTTPS仅仅只是对HTTP协议的通信过程进行加密，而报文的内容是完全一致的。 需要注意两点： http不是长连接，请求完得到结果后，会立马断开连接。若要保持长连接，应该使用websocket。 http是应用层协议，流量的传输过程和他是无关的，他只负责规定双方如何建立聊天，他采取的底层传输协层协议是TCP协议。 如果对底层的TCP/IP协议发送流量的过程感兴趣，可以看下我之前的博客：TCP协议详解 http请求的报文 请求头报文 响应头报文 ","date":"2022-05-13","objectID":"/posts/%E4%B8%80%E6%96%87%E8%BF%9B%E5%85%A5javaweb/:2:1","tags":["一文进入JavaWeb后端"],"title":"一文进入JavaWeb后端","uri":"/posts/%E4%B8%80%E6%96%87%E8%BF%9B%E5%85%A5javaweb/"},{"categories":["JavaWeb笔记"],"content":"搭建Tomcat服务器 bin目录：Tomcat服务器的可执行二进制文件等。 conf目录：配置文件。 lib目录：Tomcat服务端运行的一些依赖，不用关心。 logs目录：所有的日志信息都在这里。 temp目录：存放运行时产生的一些临时文件，不用关心。 work目录：工作目录，Tomcat会将jsp文件转换为java文件（我们后面会讲到，这里暂时不提及） webapp目录：所有的Web项目都在这里，每个文件夹都是一个Web应用程序： 启动服务器：进入bin目录运行startup.bat即可。 结束服务器：运行shutdown.bat 登录后台GUI管理 打开conf目录下的tomcat-users.xml文件，添加以下代码用来创建管理GUI的用户名和密码（添加到最后\u003c/tomcat-users\u003e之前。 \u003crole rolename=\"manager-gui\"/\u003e \u003cuser username=\"root\" password=\"123\" roles=\"manager-gui\"/\u003e 开启服务器，然后用浏览器输入URL：http://localhost:8080/manager，输入上述的用户名和密码便可进入后台。 后台如下： 将之前的前端页面部署到tomcat服务器 到webapps目录下创建一个文件夹，我这里创建了一个名为test的文件夹。 进入test文件夹，把需要加载的前端页面的文件copy到里面。 经过以上步骤，打开本地浏览器，输入http://localhost:8080/test便可完成访问。 注意整个主页面的html的命名格式，应该名为index.html。 ","date":"2022-05-13","objectID":"/posts/%E4%B8%80%E6%96%87%E8%BF%9B%E5%85%A5javaweb/:2:2","tags":["一文进入JavaWeb后端"],"title":"一文进入JavaWeb后端","uri":"/posts/%E4%B8%80%E6%96%87%E8%BF%9B%E5%85%A5javaweb/"},{"categories":["JavaWeb笔记"],"content":"使用Maven创建Web项目 虽然我们已经可以在Tomcat上部署我们的前端页面了，但是依然只是一个静态页面（每次访问都是同样的样子），那么如何向服务器请求一个动态的页面呢（比如显示我们访问当前页面的时间）这时就需要我们编写一个Web应用程序来实现了，我们需要在用户向服务器发起页面请求时，进行一些处理，再将结果发送给用户的浏览器。 **注意：**这里需要使用终极版IDEA，如果你的还是社区版，就很难受了。 我们打开IDEA，新建一个项目，选择Java Enterprise（社区版没有此选项！）项目名称随便，项目模板选择Web应用程序，然后我们需要配置Web应用程序服务器，将我们的Tomcat服务器集成到IDEA中。配置很简单，首先点击新建，然后设置Tomcat主目录即可，配置完成后，点击下一步即可，依赖项使用默认即可，然后点击完成，之后IDEA会自动帮助我们创建Maven项目。 创建完成后，直接点击右上角即可运行此项目了，但是我们发现，有一个Servlet页面不生效。 需要注意的是，Tomcat10以上的版本比较新，Servlet API包名发生了一些变化，因此我们需要修改一下依赖： \u003cdependency\u003e \u003cgroupId\u003ejakarta.servlet\u003c/groupId\u003e \u003cartifactId\u003ejakarta.servlet-api\u003c/artifactId\u003e \u003cversion\u003e5.0.0\u003c/version\u003e \u003cscope\u003eprovided\u003c/scope\u003e \u003c/dependency\u003e 注意包名全部从javax改为jakarta，我们需要手动修改一下。 现在我们手动点击运行，可以发现网页已经可以跑起来了。 为什么整个项目能够通过tomcat跑起来？ 实际上因为tomcat支持Servlet的标准，然后可以调用Servlet实现动态页面加载。 当然也可以静态加载网站。我们可以通过maven把项目打包成war包，然后把target里面的war后缀的文件复制到tomcat的webApps目录下，然后重启启动tomcat服务器，你会发现他会被解压为一个文件夹，然后这就是一个可以被服务的新项目了。 ","date":"2022-05-13","objectID":"/posts/%E4%B8%80%E6%96%87%E8%BF%9B%E5%85%A5javaweb/:2:3","tags":["一文进入JavaWeb后端"],"title":"一文进入JavaWeb后端","uri":"/posts/%E4%B8%80%E6%96%87%E8%BF%9B%E5%85%A5javaweb/"},{"categories":["JavaWeb笔记"],"content":"Servlet类介绍 ","date":"2022-05-13","objectID":"/posts/%E4%B8%80%E6%96%87%E8%BF%9B%E5%85%A5javaweb/:2:4","tags":["一文进入JavaWeb后端"],"title":"一文进入JavaWeb后端","uri":"/posts/%E4%B8%80%E6%96%87%E8%BF%9B%E5%85%A5javaweb/"},{"categories":["JavaWeb笔记"],"content":"前端基础","date":"2022-05-13","objectID":"/posts/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/","tags":["前端基础"],"title":"前端基础","uri":"/posts/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/"},{"categories":["JavaWeb笔记"],"content":"前端基础 本章节会讲解前端基础内容（如果已经学习过，可以直接跳到下一个大章节了）那么什么是前端，什么又是后端呢？ 前端：我们网站的页面，包括网站的样式、图片、视频等一切用户可见的内容都是前端的内容。 后端：处理网站的所有数据来源，比如我们之前从数据库中查询数据，而我们查询的数据经过处理最终会被展示到前端，而用于处理前端数据的工作就是由后端来完成的。 相当于，前端仅仅是一层皮，它直接决定了整个网站的美观程度，我们可以自由地编排页面的布局，甚至可以编写好看的特效；而灵魂则是后端，如何处理用户的交互、如何处理数据查询是后端的职责所在，我们前面学习的都是后端内容，而Java也是一门专注于后端开发的语言。 对于前端开发我们需要学习一些新的内容，只有了解了它们，我们才能编写出美观的页面。 本教程并不会过多地去讲解前端知识，我们只会提及一些必要的内容，我们主要学习的是JavaWeb，更倾向于后端开发，学习前端的目的只是为了让同学们了解前后端的交互方式，在进行后端开发时思路能够更加清晰，有关前端的完整内容学习，可以浏览其他前端知识教程。 我们在最开始讲解网络编程时，提到了浏览器访问服务器，实际上浏览器访问服务器就是一种B/S结构，而我们使用Java代码编写的客户端连接服务器就是一种C/S结构。 Web开发还要从HTML开始讲起，这个语言非常简单，很好学习，看完视频如果你觉得前端简单自己更喜欢一些，建议马上转前端吧，还来得及，工资还比后端高，不像后端那么枯燥乏味。 ","date":"2022-05-13","objectID":"/posts/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/:0:0","tags":["前端基础"],"title":"前端基础","uri":"/posts/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/"},{"categories":["JavaWeb笔记"],"content":"HTML页面 我们前面学习了XML语言，它是一种标记语言，我们需要以成对标签的格式进行填写，但是它是专用于保存数据，而不是展示数据，而HTML恰恰相反，它专用于展示数据，由于我们前面已经学习过XML语言了，HTML语言和XML很相似，所以我们学习起来会很快。 ","date":"2022-05-13","objectID":"/posts/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/:1:0","tags":["前端基础"],"title":"前端基础","uri":"/posts/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/"},{"categories":["JavaWeb笔记"],"content":"第一个HTML页面 我们前面知道，通过浏览器可以直接浏览XML文件，而浏览器一般是用于浏览HTML文件的，以HTML语言编写的内容，会被浏览器识别为一个页面，并根据我们编写的内容，将对应的组件添加到浏览器窗口中。 我们一般使用Chrome、Safari、Microsoft Edge等浏览器进行测试，IE浏览器已经彻底淘汰了！ 比如我们可以创建一个Html文件来看看浏览器会如何识别，使用IDEA也能编写HTML页面，我们在IDEA中新建一个Web模块，进入之后我们发现，项目中没有任何内容，我们右键新建一个HTML文件，选择HTML5文件，并命名为index，创建后出现： \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003ctitle\u003eTitle\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003c/body\u003e \u003c/html\u003e 我们发现，它和XML基本长得一样，并且还自带了一些标签，那么现在我们通过浏览器来浏览这个HTML文件（这里推荐使用内置预览，不然还得来回切换窗口） 我们发现现在什么东西都没有，但是在浏览器的标签位置显示了网页的名称为Title，并且显示了一个IDEA的图标作为网页图标。 现在我们稍微进行一些修改： \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003ctitle\u003elbw的直播间\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e 现在全体起立 \u003c/body\u003e \u003c/html\u003e 再次打开浏览器，我们发现页面中出现了我们输入的文本内容，并且标题也改为了我们自定义的标题。 我们可以在设置-\u003e工具-\u003eWeb浏览器和预览中将重新加载页面规则改为变更时，这样我们使用内置浏览器或是外部浏览器，可以自动更新我们编写的内容。 我们还可以在页面中添加一个图片，随便将一张图片放到html文件的同级目录下，命名为image.xxx，其中xxx是后缀名称，不要修改，我们在body节点中添加以下内容： \u003cimg width=\"300\" src=\"image.xxx\" alt=\"剑光如我，斩尽牛杂\"\u003e \u003c!-- 注意xxx替换成对应的后缀名称 --\u003e 我们发现，我们的页面中居然能够显示我们添加的图片内容。因此，我们只需要编写对应的标签，浏览器就能够自动识别为对应的组件，并将其展示到我们的浏览器窗口中。 我们再来看看插入一个B站的视频，很简单，只需要到对应的视频下方，找到分享，我们看到有一个嵌入代码： \u003ciframe src=\"//player.bilibili.com/player.html?aid=333231998\u0026bvid=BV1rA411g7q8\u0026cid=346917516\u0026page=1\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\" width=\"800\" height=\"500\"\u003e \u003c/iframe\u003e 每一个页面都是通过这些标签来编写的，几乎所有的网站都是使用HTML编写页面。 ","date":"2022-05-13","objectID":"/posts/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/:1:1","tags":["前端基础"],"title":"前端基础","uri":"/posts/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/"},{"categories":["JavaWeb笔记"],"content":"HTML语法规范 一个HTML文件中一般分为两个部分： 头部：一般包含页面的标题、页面的图标、还有页面的一些设置，也可以在这里导入css、js等内容。 主体：整个页面所有需要显示的内容全部在主体编写。 我们首先来看头部，我们之前使用的HTML文件中头部包含了这些内容： \u003cmeta charset=\"UTF-8\"\u003e \u003ctitle\u003elbw的直播间\u003c/title\u003e 首先meta标签用于定义页面的一些元信息，这里使用它来定义了一个字符集（编码格式），一般是UTF-8，下面的title标签就是页面的标题，会显示在浏览器的上方。我们现在来给页面设置一个图标，图标一般可以在字节跳动的IconPark网站找到：https://iconpark.oceanengine.com/home，选择一个自己喜欢的图标下载即可。 将图标放入到项目目录中，并命名为icon.png，在HTML头部添加以下内容： \u003clink rel=\"icon\" href=\"icon.png\" type=\"image/x-icon\" /\u003e link标签用于关联当前HTML页面与其他资源的关系，关系通过rel属性指定，这里使用的是icon表示这个文件是当前页面图标。 现在访问此页面，我们发现页面的图标已经变成我们指定的图标样式了。 现在我们再来看主体，我们可以在主体内部编写该页面要展示的所有内容，比如我们之前就用到了img标签来展示一个图片，其中每一个标签都称为一个元素： \u003cimg width=\"300\" src=\"image.xxx\" alt=\"当图片加载失败时，显示的文本\"\u003e 我们发现，这个标签只存在一个，并没有成对出现，HTML中有些标签是单标签，也就是说只有这一个，还有一些标签是双标签，必须成对出现，HTML中，也不允许交叉嵌套，但是出现交叉嵌套时，浏览器并不会提示错误，而是仍旧尝试去解析这些内容，甚至会帮助我们进行一定程度的修复，比如： \u003cbody\u003e \u003ciframe src=\"//player.bilibili.com/player.html?aid=333231998\u0026bvid=BV1rA411g7q8\u0026cid=346917516\u0026page=1\" width=\"800\" height=\"500\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\"\u003e \u003c/body\u003e \u003c/iframe\u003e 很明显上面的代码已经出现交叉嵌套的情况了，但是依然能够在浏览器中正确地显示。 在主体中，我们一般使用div标签来分割页面： \u003cbody\u003e \u003cdiv\u003e我是第一块\u003c/div\u003e \u003cdiv\u003e我是第二块\u003c/div\u003e \u003c/body\u003e 通过使用div标签，我们将整个页面按行划分，而高度就是内部元素的高度，那么如果只希望按元素划分，也就是说元素占多大就划分多大的空间，那么我们就可以使用span标签来划分： \u003cbody\u003e \u003cdiv\u003e \u003cspan\u003e我是第一块第一个部分\u003c/span\u003e \u003cspan\u003e我是第一块第二个部分\u003c/span\u003e \u003c/div\u003e \u003cdiv\u003e我是第二块\u003c/div\u003e \u003c/body\u003e 我们也可以使用p段落标签，它一般用于文章分段： \u003cbody\u003e \u003cp\u003e 你看这个彬彬啊，才喝几罐就醉了，真的太逊了。 这个彬彬就是逊呀！ 听你这么说，你很勇哦？ 开玩笑，我超勇的，超会喝的啦。 超会喝，很勇嘛。身材不错哦，蛮结实的嘛。 \u003c/p\u003e \u003cp\u003e 哎，杰哥，你干嘛啊。都几岁了，还那么害羞！我看你，完全是不懂哦！ 懂，懂什么啊？ 你想懂？我房里有一些好康的。 好康，是新游戏哦！ 什么新游戏，比游戏还刺激！ \u003c/p\u003e \u003cp\u003e 杰哥，这是什么啊？ 哎呦，你脸红啦！来，让我看看。 不要啦！！ 让我看看嘛。 不要啦，杰哥，你干嘛啊！ 让我看看你法语正不正常啊！ \u003c/p\u003e \u003c/body\u003e 那么如果遇到特殊字符该怎么办呢？和XML一样，我们可以使用转义字符： **注意：**多个连续的空格字符只能被识别为一个，如果需要连续多个必须使用转义字符，同时也不会识别换行，换行只会变成一个空格，需要换行必须使用br标签。 通过了解了HTML的一些基础语法，我们现在就知道一个页面大致是如何编写了。 ","date":"2022-05-13","objectID":"/posts/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/:1:2","tags":["前端基础"],"title":"前端基础","uri":"/posts/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/"},{"categories":["JavaWeb笔记"],"content":"HTML常用标签 前面我们已经了解了HTML的基本语法规范，那么现在我们就来看看，有哪些常用的标签吧，首先是换行和分割线： br 换行 hr 分割线 \u003cbody\u003e \u003cdiv\u003e 我是一段文字\u003cbr\u003e我是第二段文字 \u003c/div\u003e \u003chr\u003e \u003cdiv\u003e我是底部文字\u003c/div\u003e \u003c/body\u003e 标题一般用h1到h6表示，我们来看看效果： \u003cbody\u003e \u003ch1\u003e一级标题\u003c/h1\u003e \u003ch2\u003e二级标题\u003c/h2\u003e \u003ch3\u003e三级标题\u003c/h3\u003e \u003ch4\u003e四级标题\u003c/h4\u003e \u003ch5\u003e五级标题\u003c/h5\u003e \u003ch6\u003e六级标题\u003c/h6\u003e \u003cp\u003e我是正文内容，真不错。\u003c/p\u003e \u003c/body\u003e 现在我们来看看超链接，我们可以添加一个链接用于指向其他网站： \u003ca href=\"https://www.bilibili.com\"\u003e点击访问小破站\u003c/a\u003e 我们也可以指定页面上的一个锚点进行滚动： \u003cbody\u003e \u003ca href=\"#test\"\u003e跳转锚点\u003c/a\u003e \u003cimg src=\"image.jpeg\" width=\"500\"\u003e \u003cimg src=\"image.jpeg\" width=\"500\"\u003e \u003cimg src=\"image.jpeg\" width=\"500\"\u003e \u003cimg src=\"image.jpeg\" width=\"500\"\u003e \u003cdiv id=\"test\"\u003e我是锚点\u003c/div\u003e \u003cimg src=\"image.jpeg\" width=\"500\"\u003e \u003cimg src=\"image.jpeg\" width=\"500\"\u003e \u003cimg src=\"image.jpeg\" width=\"500\"\u003e \u003c/body\u003e 每个元素都可以有一个id属性，我们只需要给元素添加一个id属性，就使用a标签可以跳转到一个指定锚点。 我们接着来看看列表元素，这是一个无需列表，其中每一个li表示一个列表项： \u003cul\u003e \u003cli\u003e一号选项\u003c/li\u003e \u003cli\u003e二号选项\u003c/li\u003e \u003cli\u003e三号选项\u003c/li\u003e \u003cli\u003e四号选项\u003c/li\u003e \u003cli\u003e五号选项\u003c/li\u003e \u003c/ul\u003e 我们也可以使用ol来显示一个有序列表： \u003col\u003e \u003cli\u003e一号选项\u003c/li\u003e \u003cli\u003e二号选项\u003c/li\u003e \u003cli\u003e三号选项\u003c/li\u003e \u003cli\u003e四号选项\u003c/li\u003e \u003cli\u003e五号选项\u003c/li\u003e \u003c/ol\u003e 表格也是很重要的一种元素，但是它编写起来相对有一点麻烦： \u003ctable\u003e \u003cthead\u003e \u003ctr\u003e \u003cth\u003e学号\u003c/th\u003e \u003cth\u003e姓名\u003c/th\u003e \u003cth\u003e性别\u003c/th\u003e \u003cth\u003e年级\u003c/th\u003e \u003c/tr\u003e \u003c/thead\u003e \u003ctbody\u003e \u003ctr\u003e \u003ctd\u003e0001\u003c/td\u003e \u003ctd\u003e小明\u003c/td\u003e \u003ctd\u003e男\u003c/td\u003e \u003ctd\u003e2019\u003c/td\u003e \u003c/tr\u003e \u003ctr\u003e \u003ctd\u003e0002\u003c/td\u003e \u003ctd\u003e小红\u003c/td\u003e \u003ctd\u003e女\u003c/td\u003e \u003ctd\u003e2020\u003c/td\u003e \u003c/tr\u003e \u003c/tbody\u003e \u003c/table\u003e 虽然这样生成了一个表格，但是这个表格并没有分割线，并且格式也不符合我们想要的样式，那么如何才能修改这些基础属性的样式呢，我们就需要聊聊CSS了。 ","date":"2022-05-13","objectID":"/posts/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/:1:3","tags":["前端基础"],"title":"前端基础","uri":"/posts/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/"},{"categories":["JavaWeb笔记"],"content":"HTML表单 表单就像其名字一样，用户在页面中填写了对应的内容，点击按钮就可以提交到后台，比如登陆界面，就可以使用表单来实现： 一个网页中最重要的当属输入框和按钮了，那么我们来看看如何创建一个输入框和按钮： \u003clabel\u003e 我是输入框 \u003cinput type=\"text\"\u003e \u003c/label\u003e 对于一个输入框，我们一般会将其包括在一个lable标签中，它和span效果一样，但是我们点击前面文字也能快速获取输入框焦点。 \u003cbody\u003e \u003cdiv\u003e登陆我们的网站\u003c/div\u003e \u003chr\u003e \u003cdiv\u003e \u003clabel\u003e 账号： \u003cinput type=\"text\"\u003e \u003c/label\u003e \u003c/div\u003e \u003cdiv\u003e \u003clabel\u003e 密码： \u003cinput type=\"password\"\u003e \u003c/label\u003e \u003c/div\u003e \u003c/body\u003e 输入框可以有很多类型，我们来试试看password，现在输入内容就不会直接展示原文了。 创建一个按钮有以下几种方式，在学习JavaWeb时，我们更推荐第二种方式，我们后面进行登陆操作需要配合表单使用： \u003cbutton\u003e登陆\u003c/button\u003e \u003cinput type=\"submit\" value=\"登陆\"\u003e \u003cinput type=\"button\" value=\"登陆\"\u003e 现在我们就可以写一个大致的登陆页面了： \u003cbody\u003e \u003ch1\u003e登陆我们的网站\u003c/h1\u003e \u003cform\u003e \u003cdiv\u003e \u003clabel\u003e 账号： \u003cinput type=\"text\" placeholder=\"Username...\"\u003e \u003c/label\u003e \u003c/div\u003e \u003cdiv\u003e \u003clabel\u003e 密码： \u003cinput type=\"password\" placeholder=\"Password...\"\u003e \u003c/label\u003e \u003c/div\u003e \u003cbr\u003e \u003ca href=\"https://www.baidu.com\"\u003e忘记密码\u003c/a\u003e \u003cbr\u003e \u003cbr\u003e \u003cdiv\u003e \u003cinput type=\"submit\" value=\"登陆\"\u003e \u003c/div\u003e \u003c/form\u003e \u003c/body\u003e 表单一般使用form标签将其囊括，但是现在我们还用不到表单提交，因此之后我们再来讲解表单的提交。 input只能实现单行文本，那么如何实现多行文本呢？ \u003clabel\u003e 这是我们的文本框\u003cbr\u003e \u003ctextarea placeholder=\"文本内容...\" cols=\"10\" rows=\"10\"\u003e\u003c/textarea\u003e \u003c/label\u003e 我们还可以指定默认的行数和列数，拖动左下角可以自定义文本框的大小。 我们还可以在页面中添加勾选框： \u003clabel\u003e \u003cinput type=\"checkbox\"\u003e 我同意本网站的隐私政策 \u003c/label\u003e 上面演示的是一个多选框，那么我们来看看单选框： \u003clabel\u003e \u003cinput type=\"radio\" name=\"role\"\u003e 学生 \u003c/label\u003e \u003clabel\u003e \u003cinput type=\"radio\" name=\"role\"\u003e 教师 \u003c/label\u003e 这里需要使用name属性进行分组，同一个组内的选项只能选择一个。 我们也可以添加列表让用户进行选择，创建一个下拉列表： \u003clabel\u003e 登陆身份： \u003cselect\u003e \u003coption\u003e学生\u003c/option\u003e \u003coption\u003e教师\u003c/option\u003e \u003c/select\u003e \u003c/label\u003e 默认选取的是第一个选项，我们可以通过selected属性来决定默认使用的是哪个选项。 当然，HTML的元素远不止我们所提到的这些，有关更多HTML元素的内容，可以自行了解。 ","date":"2022-05-13","objectID":"/posts/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/:1:4","tags":["前端基础"],"title":"前端基础","uri":"/posts/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/"},{"categories":["JavaWeb笔记"],"content":"CSS样式 之前我们编写的页面非常基础，我们只能通过一些很基本的属性来排列我们的页面元素，那么如何实现更高度的自定义呢，我们就需要用到CSS来自定义样式，首先我们创建一个名为style.css的文件。 首先在我们HTML文件的头部添加： \u003clink href=\"style.css\" rel=\"stylesheet\"\u003e 我们在CSS文件中添加以下内容： body { text-align: center; } 我们发现，网页的内容全部变为居中显示了，这正是css在生效，相当于我们现在给页面添加了自定义的样式规则。 当然，我们也可以选择不使用CSS，而是直接对某个元素添加样式： \u003cbody style=\"text-align: center;\"\u003e ... 这样的效果其实是等同于上面的css文件的，相当于我们直接把样式定义在指定元素上。 也可以在头部直接定义样式，而不是使用外部文件： \u003cstyle\u003e body { text-align: center; } \u003c/style\u003e 使用以上三种方式都可以自定义页面的样式，我们推荐使用还是第一种，不然我们的代码会很繁杂。 样式的属性是非常多的，我们不可能一个一个全部讲完，视频中用到什么再来讲解什么，如果同学们感兴趣，可以自行下去了解。 ","date":"2022-05-13","objectID":"/posts/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/:2:0","tags":["前端基础"],"title":"前端基础","uri":"/posts/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/"},{"categories":["JavaWeb笔记"],"content":"CSS选择器 我们首先来了解一下选择器，那么什么是选择器呢？我们想要自定义一个元素的样式，那么我们肯定要去选择某个元素，只有先找到要自定义的元素，我们才能开始编写样式。 我们上面的例子中使用的就是标签名选择器，它可以快速选择页面中所有指定的的标签，比如我们之前使用的就是body标签，那么就相当于页面中所有的body元素全都使用此样式，那么我们现在来试试看选择页面中所有的input标签： input { width: 200px; } 我们发现，页面中所有的input元素宽度全部被设定为了200个像素（px是单位大小，代表像素，除了px还有em和rem，他们是根据当前元素字体大小决定的相对大小，一般用于适配各种大小的浏览器窗口，这里暂时不用） 样式编写完成后，如果只有一个属性，可以不带;若多个属性则每个属性后面都需要添加一个; 因此，一个标签选择器的格式为： 标签名称 { 属性名称: 属性值 } 我们还可以设定输入框的字体大小、行高等： input { width: 200px; font-size: 20px; line-height: 40px; } 我们现在可以通过选择器快速地去设置某个元素样式了，那么如何实现只设置某个元素的样式呢，现在我们来看看，id选择器，我们之前已经讲解过了，每个元素都可以有一个id属性，我们可以将其当做一个跳转的锚点使用，而现在，我们可以使用css来进行定位： 我们先为元素添加id属性： \u003ch1 id=\"title\"\u003e登陆我们的网站\u003c/h1\u003e 现在使用CSS选择我们的元素，并设定一个属性，选择某个id需要在前面加上一个#： #title { color: red; } 虽然id选择器已经可以很方便的指定某个元素，但是如果我们希望n个但不是元素都被选择，id选择器就无法实现了，因为每个元素的id是唯一的，不允许出现重复id的元素，因此接着我们来讲解一下类选择器。 每个元素都可以有一个class属性，表示当前元素属于某个类（注意这里的类和我们Java中的类概念完全不同）一个元素可以属于很多个类，一个类也可以被很多个元素使用： \u003cform\u003e \u003cdiv \u003e \u003clabel class=\"test\"\u003e 账号： \u003cinput type=\"text\" placeholder=\"Username...\"\u003e \u003c/label\u003e \u003c/div\u003e \u003cdiv\u003e \u003clabel class=\"test\"\u003e 密码： \u003cinput type=\"password\" placeholder=\"Password...\"\u003e \u003c/label\u003e \u003c/div\u003e \u003c/form\u003e 上面的例子中，两个label元素都使用了test类（类名称是我们自定义的），现在我们在css文件中编写以下内容来以类进行选择： .test{ color: blue; } 我们发现，两个标签的文本内容都变为了蓝色，因此使用类选择器，能够对所有为此类的元素添加样式。注意在进行类选择时，我们需要在类名前面加上.来表示。 ","date":"2022-05-13","objectID":"/posts/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/:2:1","tags":["前端基础"],"title":"前端基础","uri":"/posts/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/"},{"categories":["JavaWeb笔记"],"content":"组合选择器和优先级问题 我们也可以让多个选择器，共用一个css样式： .test, #title { color: red; } 只需要并排写即可，注意中间需要添加一个英文的逗号用于分割，我们也可以使用*来一次性选择所有的元素： * { color: red; } 我们还可以选择位于某个元素内的某个元素： div label { color: red; } 这样的话，就会选择所有位于div元素中的label元素。 当然，我们这里只介绍了一些常用的选择器，有关详细的CSS选择器可以查阅：https://www.runoob.com/cssref/css-selectors.html 我们接着来看一下选择器的优先级： 我们根据上面的信息，来测试一下，首先编写一下HTML文件： \u003cbody\u003e \u003cdiv class=\"test\" id=\"simple\" style=\"color: blue\"\u003e我是测试文本内容\u003c/div\u003e \u003c/body\u003e 现在我们来编写一下css文件： .test { color: yellow; } #simple { color: red; } * { color: palegreen; } 那么现在我们可以看到，实际上生效的是我们直接编写在标签内部的内联属性，那么现在我们依次进行移除，来看看它们的优先级。 那么如果我们希望某个属性无视任何的优先级，我们可以在属性后面添加!important标记，表示此属性是一个重要属性，它的优先级会被置为最高。 **思考：**那要是我每个选择器的这个属性后面都加一个!important会怎么样？ ","date":"2022-05-13","objectID":"/posts/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/:2:2","tags":["前端基础"],"title":"前端基础","uri":"/posts/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/"},{"categories":["JavaWeb笔记"],"content":"自定义边距 我们来看看，如何使用css控制一个div板块的样式，首先编写以下代码，相当于一个div嵌套了一个div元素： \u003cdiv id=\"outer\"\u003e \u003cdiv id=\"inner\"\u003e \u003c/div\u003e \u003c/div\u003e 现在编写一下自定义的css样式，我们将div设定为固定大小，并且背景颜色添加为绿色： #outer { background: palegreen; width: 300px; height: 300px; } 我们发现左侧快速预览页面存在空隙，这是因为浏览器给我们添加了一个边距属性，我们只需要覆盖此属性并将其设定为0即可： body { margin: 0; } 现在我们给内部嵌套的div也设定一个大小，并将颜色设定为橙色： #inner { background: darkorange; width: 100px; height: 100px; } 现在我们发现内部的div元素位于右上角，我们还可以以百分比的形式来指定大小： #inner { background: darkorange; width: 100%; height: 100%; } 百分比会依照当前可用大小来进行分配，比如当前位于一个div内部，并且外部div元素是固定大小300px，因此100%就相当于使用了外部的全部大小，也是300px，现在内部元素完全将外部元素覆盖了，整个元素现在呈现为橙色。 我们可以为一个元素设定边距，边距分为外边距和内边距，外部元素内边距决定了内部元素与外部元素之间的间隔，我们来修改一下css样式： #outer { background: palegreen; width: 300px; height: 300px; padding: 10px; } 我们发现，内部的div元素小了一圈，这是因为外部div元素设定了内边距，上下左右都被设定为10px大小。 而我们发现，实际上我们在一开始也是将body的外边距设定为了0，整个页面跟浏览器窗口直接间隔0px的宽度。 ","date":"2022-05-13","objectID":"/posts/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/:2:3","tags":["前端基础"],"title":"前端基础","uri":"/posts/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/"},{"categories":["JavaWeb笔记"],"content":"编写一个漂亮的登陆界面 现在我们就来尝试编写一个漂亮的登陆界面吧！ ","date":"2022-05-13","objectID":"/posts/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/:2:4","tags":["前端基础"],"title":"前端基础","uri":"/posts/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/"},{"categories":["JavaWeb笔记"],"content":"JavaScript语言 也称为js，是我们整个前端基础的重点内容，只有了解了JavaScript语言，我们才能了解前端如何与后端交互。 JavaScript与Java没有毛关系，仅仅只是名字中包含了Java而已，跟Java比起来，它更像Python，它是一门解释型语言，不需要进行编译，它甚至可以直接在浏览器的命令窗口中运行。 它相当于是前端静态页面的一个补充，它可以让一个普通的页面在后台执行一些程序，比如我们点击一个按钮，我们可能希望执行某些操作，比如下载文件、页面跳转、页面弹窗、进行登陆等，都可以使用JavaScript来帮助我们实现。 我们来看看一个简单的JavaScript程序： const arr = [0, 2, 1, 5, 9, 3, 4, 6, 7, 8] for (let i = 0; i \u003c arr.length; i++) { for (let j = 0; j \u003c arr.length - 1; j++) { if(arr[j] \u003e arr[j+1]){ const tmp = arr[j] arr[j] = arr[j+1] arr[j+1] = tmp } } } window.alert(arr) 这段代码实际上就是实现了一个冒泡排序算法，我们可以直接在页面的头部中引用此js文件，浏览器会在加载时自动执行js文件中编写的内容： \u003cscript src=\"test.js\"\u003e\u003c/script\u003e 我们发现JS的语法和Java非常相似，但是它还是和Java存在一些不同之处，而且存在很多阴间语法，那么我们来看看JS的语法。 ","date":"2022-05-13","objectID":"/posts/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/:3:0","tags":["前端基础"],"title":"前端基础","uri":"/posts/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/"},{"categories":["JavaWeb笔记"],"content":"JavaScript基本语法 在js中，定义变量和Java中有一些不同，定义一个变量可以使用let关键字或是var关键字，IDEA推荐我们使用let关键字，因为var存在一定的设计缺陷（这里就不做讲解了，之后一律使用let关键字进行变量声明）： let a = 10; a++; window.alert(a) 上面的结果中，我们得到了a的结果是11，也就是说自增和自减运算在JS中也是支持的，并且JS每一句结尾可以不用加分号。 js并不是Java那样的强类型语言（任意变量的类型一定是明确的），它是一门弱类型语言，变量的类型并不会在一开始确定，因此我们在定义变量时无需指定变量的确切类型，而是在运行时动态解析类型： let a = 10; a = \"HelloWorld！\" console.info(a) 我们发现，变量a已经被赋值为数字类型，但是我们依然在后续能将其赋值一个字符串，它的类型是随时可变的。 很多人说，这种变态的类型机制是JS的一大缺陷。 世界上只有两种语言：一种是很多人骂的，一种是没人用的。 我们接着来看看，JS中存在的基本数据类型： Number：数字类型（包括小数和整数） String：字符串类型（可以使用单引号或是双引号） Boolean：布尔类型（与Java一致） 还包括一些特殊值： undefined：未定义 - 变量声明但不赋值默认为undefined null：空值 - 等同于Java中的null NaN：非数字 - 值不是合法数字，比如： window.alert(100/'xx') 我们可以使用typeof关键字来查看当前变量值的类型： let a = 10; console.info(typeof a) a = 'Hello World' console.info(typeof a) ","date":"2022-05-13","objectID":"/posts/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/:3:1","tags":["前端基础"],"title":"前端基础","uri":"/posts/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/"},{"categories":["JavaWeb笔记"],"content":"JavaScript逻辑运算和流程控制 我们接着来看看js中的关系运算符，包括如下8个关系运算符：大于（\u003e）,小于（\u003c）,小于等于（\u003c=）,大于等于（\u003e=）,相等（==），不等（!=），全等（===），不全等（!==） 其实关系运算符大致和Java中的使用方法一致，不过它还可以进行字符串比较，有点像C++的语法： console.info(666 \u003e 777) console.info('aa' \u003e 'ab') 那么，相等和全等有什么区别呢？ console.info('10' == 10) console.info('10' === 10) 我们发现，在Java中，若运算符两边是不同的基本数据类型，会直接得到false，而JS中却不像这样，我们发现字符串的10居然等于数字10，而使用全等判断才是我们希望的结果。 ==的比较规则是：当操作数类型一样时，比较的规则和恒等运算符一样，都相等才相等，如果两个操作数是字符串，则进行字符串的比较，如果里面有一个操作数不是字符串，那两个操作数通过Number()方法进行转换，转成数字进行比较。 因此，我们上面进行的判断实际上是运算符两边都进行了数字转换的结果进行比较，自然也就得到了true，而全等判断才是我们在Java中认识的相等判断。 我们接着来看逻辑运算，JS中包括\u0026\u0026、||、\u0026、|、?:等，我们先来看看位运算符： console.info(4 \u0026 7) console.info(4 | 7) 实际上和Java中是一样的，那么我再来看看逻辑运算： console.info(true || false) 对于boolean变量的判断，是与Java一致的，但是JS也可以使用非Boolen类型变量进行判断： console.info(!0) console.info(!1) 和C/C++语言一样，0代表false，非0代表true，那么字符串呢？ console.info(!\"a\") console.info(!\"\") 我们发现，空串为false，非空串为true，我们再来看看： console.info(true || 7) console.info(7 || true) 我们发现，前者得到的结果为true，而后者得到的结果却是是7，真是滑天下之大稽，什么鬼玩意，实际上是因为，默认非0都是true，而后者又是先判断的7，因此会直接得到7而不是被转换为true 那么我们再来看看几个特殊值默认代表什么： console.info(!undefined) console.info(!null) console.info(!NaN) 最后来使用一下三元运算符，实际上和Java中是一样的： let a = true ? \"xx\" : 20 console.info(a) 得益于JS的动态类型，emmm，三元运算符不一定需要固定的返回值类型。 JS的分支结构，实际上和Java是一样的，也是使用if-else语句来进行： if(\"lbwnb\"){ //非空串为true console.info(\"!!!\") } else { console.info(\"???\") } 同理，多分支语句也能实现： if(\"\"){ console.info(\"!!!\") } else if(-666){ console.info(\"???\") } else { console.info(\"O.O\") } 当然，多分支语句也可以使用switch来完成： let a = \"a\" switch (a){ case \"a\": console.info(\"1\") break case \"b\": console.info(\"2\") break case \"c\": console.info(\"3\") break default: console.info(\"4\") } 接着我们来看看循环结构，其实循环结构也和Java相差不大： let i = 10 while(i--){ console.info(\"100\") } for (let i = 0; i \u003c 10; i++) { console.info(\"??\") } ","date":"2022-05-13","objectID":"/posts/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/:3:2","tags":["前端基础"],"title":"前端基础","uri":"/posts/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/"},{"categories":["JavaWeb笔记"],"content":"JavaScript函数定义 JS中的方法和Java中的方法定义不太一样，JS中一般称其为函数，我们来看看定义一个函数的格式是什么： function f() { console.info(\"有一个人前来买瓜\") } 定义一个函数，需要在前面加上function关键字表示这是一个函数，后面跟上函数名称和()，其中可以包含参数，在{}中编写函数代码。我们只需要直接使用函数名+()就能调用函数： f(); 我们接着来看一下，如何给函数添加形式参数以及返回值： function f(a) { console.info(\"得到的实参为：\"+a) return 666 } f(\"aa\"); 由于JS是动态类型，因此我们不必指明参数a的类型，同时也不必指明返回值的类型，一个函数可能返回不同类型的结果，因此直接编写return语句即可。同理，我们可以在调用函数时，不传参，那么默认会使用undefined： function f(a) { console.info(\"得到的实参为：\"+a) return 666 } f(); 那么如果我们希望不传参的时候使用我们自定义的默认值呢？ function f(a = \"6666\") { console.info(\"得到的实参为：\"+a) return 666 } f(); 我们可以直接在形参后面指定默认值。 函数本身也是一种类型，他可以被变量接收，所有函数类型的变量，也可以直接被调用： function f(a = \"6666\") { console.info(\"得到的实参为：\"+a) return 666 } let k = f; k(); 我们也可以直接将匿名函数赋值给变量： let f = function (str) { console.info(\"实参为：\"+str) } 既然函数是一种类型，那么函数也能作为一个参数进行传递： function f(test) { test(); } f(function () { console.info(\"这是一个匿名函数\") }) 对于所有的匿名函数，可以像Java的匿名接口实现一样编写lambda表达式： function f(test) { test(); } f(() =\u003e { console.info(\"可以，不跟你多bb\") }) function f(test) { test(\"这个是回调参数\"); } f(param =\u003e { console.info(\"接受到回调参数：\"+param) }) ","date":"2022-05-13","objectID":"/posts/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/:3:3","tags":["前端基础"],"title":"前端基础","uri":"/posts/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/"},{"categories":["JavaWeb笔记"],"content":"JavaScript数组和对象 JS中的数组定义与Java不同，它更像是Python中的列表，数组中的每个元素并不需要时同样的类型： let arr = [1, \"lbwnb\", false, undefined, NaN] 我们可以直接使用下标来访问： let arr = [1, \"lbwnb\", false, undefined, NaN] console.info(arr[1]) 我们一开始编写的排序算法，也是使用了数组。 数组还可以动态扩容，如果我们尝试访问超出数组长度的元素，并不会出现错误，而是得到undefined，同样的，我们也可以直接往超出数组长度的地方设置元素： let arr = [1, \"lbwnb\", false, undefined, NaN] arr[5] = \"???\" console.info(arr) 也可以使用push和pop来实现栈操作： let arr = [1, \"lbwnb\", false, undefined, NaN] arr.push(\"bbb\") console.info(arr.pop()) console.info(arr) 数组还包括一些其他的方法，这里就不一一列出了： let arr = [1, \"lbwnb\", false, undefined, NaN] arr.fill(1) console.info(arr.map(o =\u003e { return 'xxx'+o })) 我们接着来看对象，JS中也能定义对象，但是这里的对象有点颠覆我们的认知： let obj = new Object() let obj = {} 以上两种写法都能够创建一个对象，但是更推荐使用下面的一种。 JS中的对象也是非常随意的，我们可以动态为其添加属性： let obj = {} obj.name = \"伞兵一号\" console.info(obj) 同理，我们也可以给对象动态添加一个函数： let obj = {} obj.f = function (){ console.info(\"我是对象内部的函数\") } obj.f() 我们可以在函数内使用this关键字来指定对象内的属性： let name = \"我是外部变量\" let obj = {} obj.name = \"我是内部变量\" obj.f = function (){ console.info(\"name属性为：\"+this.name) } obj.f() **注意：**如果使用lambda表达式，那么this并不会指向对象。 除了动态添加属性，我们也可以在一开始的时候指定对象内部的成员： let obj = { name: \"我是内部的变量\", f: function (){ console.info(\"name属性为：\"+this.name) } } obj.f() 注意如果有多行属性，需要在属性定义后添加一个,进行分割！ ","date":"2022-05-13","objectID":"/posts/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/:3:4","tags":["前端基础"],"title":"前端基础","uri":"/posts/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/"},{"categories":["JavaWeb笔记"],"content":"JavaScript事件 当我们点击一个页面中的按钮之后，我们希望之后能够进行登陆操作，或是执行一些JS代码来实现某些功能，那么这个时候，就需要用到事件。 事件相当于一个通知，我们可以提前设定好事件发生时需要执行的内容，当事件发生时，就会执行我们预先设定好的JS代码。 事件有很多种类型，其中常用的有： onclick：点击事件 oninput：内容输入事件 onsubmit：内容提交事件 那么如何为事件添加一个动作呢？ \u003cinput type=\"password\" oninput=\"console.info('正在输入文本')\"\u003e 我们可以直接为一个元素添加对应事件的属性，比如oninput事件，我们可以直接在事件的值中编写js代码，但是注意，只能使用单引号，因为双引号用于囊括整个值。 我们也可以单独编写一个函数，当事件发生时直接调用我们的函数： function f() { window.alert(\"你输入了一个字符\") } \u003cinput type=\"password\" oninput=\"oninput()\"\u003e 仅仅了解了事件，还不足以实现高度自定义，我们接着来看DOM。 ","date":"2022-05-13","objectID":"/posts/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/:3:5","tags":["前端基础"],"title":"前端基础","uri":"/posts/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/"},{"categories":["JavaWeb笔记"],"content":"Document对象 当网页被加载时，浏览器会创建页面的文档对象模型（Document Object Model），它将整个页面的所有元素全部映射为JS对象，这样我们就可以在JS中操纵页面中的元素。 比如我现在想要读取页面中某个输入框中的内容，那么我们就需要从DOM中获取此输入框元素的对象： document.getElementById(\"pwd\").value 通过document对象就能够快速获取当前页面中对应的元素，并且我们也可以快速获取元素中的一些属性。 比如现在我们可以结合事件，来进行密码长度的校验，密码长度小于6则不合法，不合法的密码，会让密码框边框变红，那么首先我们先来编写一个css样式： .illegal-pwd{ border: red 1px solid !important; box-shadow: 0 0 5px red; } 接着我们来编写一下js代码，定义一个函数，此函数接受一个参数（元素本身的对象）检测输入的长度是否大于6，否则就将当前元素的class属性设定为css指定的class： function checkIllegal(e) { if(e.value.length \u003c 6) { e.setAttribute(\"class\", \"illegal-pwd\") }else { e.removeAttribute(\"class\") } } 最后我们将此函数绑定到oninput事件即可，注意传入了一个this，这里的this代表的是输入框元素本身： \u003cinput id=\"pwd\" oninput=\"checkIllegal(this)\" type=\"password\"\u003e 现在我们在输入的时候，会自动检查密码是否合法。 既然oninput本身也是一个属性，那么实际上我们可以动态进行修改： document.getElementById(\"pwd\").oninput = () =\u003e console.info(\"???\") 那么，我们前面提及的window对象又是什么东西呢？ 实际上Window对象范围更加广阔，它甚至直接代表了整个窗口，当然也包含我们的Document对象，我们一般通过Window对象来弹出提示框之类的东西。 ","date":"2022-05-13","objectID":"/posts/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/:3:6","tags":["前端基础"],"title":"前端基础","uri":"/posts/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/"},{"categories":["JavaWeb笔记"],"content":"发送XHR请求 JS的大致内容我们已经全部学习完成了，那么如何使用JS与后端进行交互呢？ 我们知道，如果我们需要提交表单，那么我们就需要将表单的信息全部发送给我们的服务器，那么，如何发送给服务器呢？ 通过使用XMLHttpRequest对象，来向服务器发送一个HTTP请求，下面是一个最简单的请求格式： let xhr = new XMLHttpRequest(); xhr.open('GET', 'https://www.baidu.com'); xhr.send(); 上面的例子中，我们向服务器发起了一次网络请求，但是我们请求的是百度的服务器，并且此请求的方法为GET请求。 我们现在将其绑定到一个按钮上作为事件触发： function http() { let xhr = new XMLHttpRequest(); xhr.open('GET', 'https://www.baidu.com'); xhr.send(); } \u003cinput id=\"button\" type=\"button\" onclick=\"http()\"\u003e 我们可以在网络中查看我们发起的HTTP请求并且查看请求的响应结果，比如上面的请求，会返回百度这个页面的全部HTML代码。 实际上，我们的浏览器在我们输入网址后，也会向对应网站的服务器发起一次HTTP的GET请求。 在浏览器得到页面响应后，会加载当前页面，如果当前页面还引用了其他资源文件，那么会继续向服务器发起请求，直到页面中所有的资源文件全部加载完成后，才会停止。 ","date":"2022-05-13","objectID":"/posts/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/:3:7","tags":["前端基础"],"title":"前端基础","uri":"/posts/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/"},{"categories":["青训营笔记"],"content":"Go语言编码规范和性能调优","date":"2022-05-11","objectID":"/posts/glang3/","tags":["Go语言编码规范和性能调优"],"title":"Go语言编码规范和性能调优","uri":"/posts/glang3/"},{"categories":["青训营笔记"],"content":"编码规范 ","date":"2022-05-11","objectID":"/posts/glang3/:1:0","tags":["Go语言编码规范和性能调优"],"title":"Go语言编码规范和性能调优","uri":"/posts/glang3/"},{"categories":["青训营笔记"],"content":"注释 Good code has lots of comments,bad code requires lots of comments. 不必要的注释 场景一 如上图所示，第一个Open函数应该解释代码作用，而第二个函数这样的作用解释则毫无必要，因为它的函数名就已经解释了。 场景二 第一个函数的逻辑较为复杂，很多情况没法看懂，需要注释，而第二个则完全没必要。 需要的注释 公共符号始终要注释 这里的公共符号包括全局可见的函数和变量，而方法则不包含在内。 小结 代码是最好的注释。 注释应提供代码未表达出的上下文信息。 变量命名 简洁 缩略词都大写，比如HTTP不要Http 变量定义的位置距离使用的地方越远，命名需要越详细，特别是全局变量，有时需要注释 函数内 例如for循环时： for i:=0; i\u003csize;i++{ //good ... } for index:=0;index\u003csize;index++{//bad ... } 而作为函数参数时： //good func (c *Client) send(req *Request, deadline time.Time) //bad func (c *Client) send(req *Request, t time.Time) 由于第一个变量仅在for循环这个作用域内，它的作用也很清晰，如果命名的更详细，反而会影响阅读。 第二个变量作为函数的参数，作用域很大，且需要作为提供给使用者的名字，这个需要带有详细信息描述。 包内 函数名应该不携带报名的上下文信息。 例如在http包中有个Serve方法和ServeHTTP方法这两个命名，我们应该选择Serve去命名而不是ServeHTTP。因为我们使用的时候会携带包名。类比于C++的命名空间，Java的包名。 包命名 只有小写字母组成（不包含下划线等字母 简短并包含一定的信息 不要和标准库的包冲突，标准库的很多包名喜欢用复数，我们应该避免使用复数形式为包名，比如strings是标准库的一个包名。 ","date":"2022-05-11","objectID":"/posts/glang3/:1:1","tags":["Go语言编码规范和性能调优"],"title":"Go语言编码规范和性能调优","uri":"/posts/glang3/"},{"categories":["青训营笔记"],"content":"控制流程 这里我用之前在其他地方学到的两个优化代码的方式来讲。 嵌套条件校验链 嵌套两层以上的if if a\u003e10 { if b\u003e10 { if c\u003e10 { ... } } } 优化如下： for { if !(a\u003e10) { break } if !(b\u003e10) { break } if !(c\u003e10) { break } ... } 互斥条件表驱动 比如有以下并列的if嵌套逻辑： func CalculateByCmd(cmd string,a,b int)(int,error){ if strings.EqualFold(cmd,\"add\"){ return a+b,nil } if strings.EqualFold(cmd,\"sub\"){ return a-b,nil } if strings.EqualFold(cmd,\"mul\"){ return a*b,nil } return 0,errors.New(\"cmd not exist\") } 这段代码是根据给出的字符串命令，得出对应的计算结果。但是我们发现，这个代码的可读性虽然还行，但由于最终的计算和这个函数的耦合性太强，实现功能拓展有点拖后腿。 我们通过表驱动做出以下优化： var mapCalculate = map[string]func(a,b int) int{ \"add\": func(a, b int) int { return a+b }, \"sub\": func(a, b int) int { return a-b }, \"mul\": func(a, b int) int { return a*b }, } func CalculateByCmd(cmd string,a,b int)(int,error){ if v,ok := mapCalculate[cmd];ok{ return v(a,b),nil } return 0,errors.New(\"cmd not exist\") } ","date":"2022-05-11","objectID":"/posts/glang3/:1:2","tags":["Go语言编码规范和性能调优"],"title":"Go语言编码规范和性能调优","uri":"/posts/glang3/"},{"categories":["青训营笔记"],"content":"错误处理 error相关的函数 errors.New() return errors.New(\"需要的错误信息描述\") errors.Is() 用于判断错误断言，不同于简单的==，它能够判断错误链中是否包含它。 errors.As() 从错误链中提取想要的错误。 panic和recover和defer 这几样东西，语法就那样，真要理解原理可以看看下面这些视频链接。 老版本go derfer实现 新版本go defer实现 panic和recover ","date":"2022-05-11","objectID":"/posts/glang3/:1:3","tags":["Go语言编码规范和性能调优"],"title":"Go语言编码规范和性能调优","uri":"/posts/glang3/"},{"categories":["青训营笔记"],"content":"性能调优 ","date":"2022-05-11","objectID":"/posts/glang3/:2:0","tags":["Go语言编码规范和性能调优"],"title":"Go语言编码规范和性能调优","uri":"/posts/glang3/"},{"categories":["青训营笔记"],"content":"benchmark测试 这个benchmark，之前在（二）里面讲了如何去使用，这里直接贴图看如何看懂测试结果。 ","date":"2022-05-11","objectID":"/posts/glang3/:2:1","tags":["Go语言编码规范和性能调优"],"title":"Go语言编码规范和性能调优","uri":"/posts/glang3/"},{"categories":["青训营笔记"],"content":"slice的阴暗面 对于之前使用C++的同学，这里slice的预分配应该不用多讲。主要就是学会避坑。 最大坑点 更新slice后持有的底层数组相同。 具体而言：有时我们只是想要底层数组的一小部分，结果因为简单切个片，然后就和他共用了同一片底层数组。go的垃圾回收机制在某种程度上和C++智能指针(引用计数)很相似，如果此时大的数组实际上已经没用了，而有用的只有小数组，而它们是共用同一片底层数组，此时这整个底层数组的空间会得不到释放，因为引用计数不为零！算是意外延长了生命周期。 更新slice后持有的底层数组不同。 具体而言：如果一个map映射的值是slice类型，那么我们每次更新这个slice里的元素时，我们还得更新map映射的这个slice，这是为了防止底层数组发生了变化。所以一般slice作为值最好是使用slice指针。 ","date":"2022-05-11","objectID":"/posts/glang3/:2:2","tags":["Go语言编码规范和性能调优"],"title":"Go语言编码规范和性能调优","uri":"/posts/glang3/"},{"categories":["青训营笔记"],"content":"关于string可变与不可变的优化 不可变string的优化 go语言和Java等等语言都把string设置为了不可变，我觉得这样设置是非常合理的，毕竟字符串在使用过程中，多数情况下都是传递，而且可以利用不可变做很多优化，比如内存池之类的。 string不可变的缺陷 一旦string不可变，就意味着，每次得到一个新的字符串就需要申请一片新的内存，那么这样的话，多次字符串拼接的过程中将会有严重的性能损失！ 如下，每次 += 右边的值都会引起内存的分配。 s := \"aa\" for i:=0;i\u003csize;i++{ s += \"ccc\" } 解决方案 使用strings.Builder。 var s strings.Builder for i:=0;i\u003csize;i++{ s.WriteString(\"cc\") } s.String() 使用bytes.Builder。 var s bytes.Buffer for i:=0;i\u003c10;i++{ s.WriteString(\"cc\") } s.String() 第一种解决方案比第二种要快。 因为在最后的String()阶段bytes包的处理方式是再进行一次切片处理。 而strings包则是直接指针强转。 可变string的优化 可变string的代表便是C++。 C++的string是可变的，而且因为实现了重载=号实现的深拷贝，导致很多情况下string的使用是需要进行拷贝的，但为了解决这个问题C++可以使用 const\u0026 来引用字符串以防止拷贝，但这就有一个问题：由于string是可变的万一我在使用的过程中string被外界改变了怎么办？这是可变string需要面临的最大问题，所以可变string一般都是会实现深拷贝，但使用起来大多数人还是会通过引用传递，毕竟拷贝太耗时了！但这时使用起来就得遵守编码规范唯唯诺诺了。 回到正题，即便是使用了 const\u0026 进行字符串的传递，从实践来看，它至少有以下几方面问题： 字符串字面值、字符数组、字符串指针的传递仍要数据拷贝 这三类低级数据类型与string类型不同，传入时，编译器需要做隐式转换，即需要拷贝这些数据生成string临时对象。const string\u0026指向的实际上是这个临时对象。通常字符串字面值较小，性能损耗可以忽略不计；但字符串指针和字符数组某些情况下可能会比较大（比如读取文件的内容），此时会引起频繁的内存分配和数据拷贝，会严重影响程序的性能。 substr O(n)复杂度 这是一个特别常用的函数，好在std::string提供了这个函数，美中不足的是其每次都返回一个新生成的子串，很容易引起性能热点。实际上我们本意并不是要改变原字符串，为什么不在原字符串基础上返回呢？ 说说可变字符串类型的好处，内存的开辟问题不会太多，因为虽然在拷贝，但基本上都是复用的同一片内存。 解决方案 方案一：SSO优化 SSO，全称为：小字符串优化。 这个优化简单粗暴，就是根据字符串的长度来决定内存的开辟情况。 比如字符串长度如果小于128字节，那么内存就开辟在栈上面，众所周知，栈内存开辟比堆内存开辟的代价小很多！ 方案二：string_view（C++17引入） 通过提供一个新的类型，这个类型和不可变的字符串的类型类似，它是不可变的，只能看，不然怎么叫view🤭 每次string赋值给它，代价都很小，不是直接拷贝字符串，而是指针的赋值而已。 而且string_view重写了substr，这个方法返回string_view而且你会发现通过它再构建string性能会比string调用substr快很多。 string_view虽然解决了拷贝问题，但是依旧没有解决C++的内存安全问题，string_view内部是原始指针，不会意外延长生命周期，所以要非常注意它所观察的字符串内存是否被释放了，如果被释放string_view将失效，将会产生严重的内存安全问题。 关于string_view，可以看看我的这篇博客string_view。 ","date":"2022-05-11","objectID":"/posts/glang3/:2:3","tags":["Go语言编码规范和性能调优"],"title":"Go语言编码规范和性能调优","uri":"/posts/glang3/"},{"categories":["青训营笔记"],"content":"空结构体的使用 空结构体，不占内存，仅作为占位符，所以可以作为map实现set的理想工具。 ","date":"2022-05-11","objectID":"/posts/glang3/:2:4","tags":["Go语言编码规范和性能调优"],"title":"Go语言编码规范和性能调优","uri":"/posts/glang3/"},{"categories":["青训营笔记"],"content":"atomic包 用atomic保护变量的并发安全，用sync.Mutex保护一段代码逻辑的并发安全。 对于非数值变量，可以使用atomic.Value来承载一个空接口。 ","date":"2022-05-11","objectID":"/posts/glang3/:2:5","tags":["Go语言编码规范和性能调优"],"title":"Go语言编码规范和性能调优","uri":"/posts/glang3/"},{"categories":["青训营笔记"],"content":"性能调优实战 ","date":"2022-05-11","objectID":"/posts/glang3/:3:0","tags":["Go语言编码规范和性能调优"],"title":"Go语言编码规范和性能调优","uri":"/posts/glang3/"},{"categories":["青训营笔记"],"content":"pprof工具的使用 这个东西暂时用不来，感觉暂时这个阶段也很难用上。用上了再研究（主要是感觉很多东西都还完全不会分析，只会工具操作很麻木的感觉 pprof ","date":"2022-05-11","objectID":"/posts/glang3/:3:1","tags":["Go语言编码规范和性能调优"],"title":"Go语言编码规范和性能调优","uri":"/posts/glang3/"},{"categories":["青训营笔记"],"content":"这是我参与「第三届青训营 -后端场」笔记创作活动的的第二篇笔记。","date":"2022-05-08","objectID":"/posts/golang-note2/","tags":["Go工程实践"],"title":"Go语言工程实践（二） | 青训营笔记","uri":"/posts/golang-note2/"},{"categories":["青训营笔记"],"content":"这是我参与「第三届青训营 -后端场」笔记创作活动的的第二篇笔记。 ","date":"2022-05-08","objectID":"/posts/golang-note2/:0:0","tags":["Go工程实践"],"title":"Go语言工程实践（二） | 青训营笔记","uri":"/posts/golang-note2/"},{"categories":["青训营笔记"],"content":"并发和Goroutine ","date":"2022-05-08","objectID":"/posts/golang-note2/:1:0","tags":["Go工程实践"],"title":"Go语言工程实践（二） | 青训营笔记","uri":"/posts/golang-note2/"},{"categories":["青训营笔记"],"content":"并发和并行的区别 并发可能更多的是精确到语言的逻辑，也就是直接的多线程，或者多进程。 而并行则是一种表述程序运行的方式，就如同异步和同步的描述。 并发程序不一定是并行的，这个看操作系统的调度。 ","date":"2022-05-08","objectID":"/posts/golang-note2/:1:1","tags":["Go工程实践"],"title":"Go语言工程实践（二） | 青训营笔记","uri":"/posts/golang-note2/"},{"categories":["青训营笔记"],"content":"线程与协程的区别 线程：是比进程更小粒度的运行单位，存在于内核态，需要操作系统来调度，内存消耗是MB级别。 协程：是比线程更小的粒度，通过m:n的比例在一个线程中再细分出来的单位，存在于用户态，用户可以自由调度，内存消耗是KB级别。 协程对比线程的优势： 存在于用户态，可操作性强，调度可由自己控制。 更轻量，所需资源更少。 ","date":"2022-05-08","objectID":"/posts/golang-note2/:1:2","tags":["Go工程实践"],"title":"Go语言工程实践（二） | 青训营笔记","uri":"/posts/golang-note2/"},{"categories":["青训营笔记"],"content":"Goroutine go语言的go关键字跑的就是协程，我们称为goroutine。 关于协程背后更多的故事，可以看这个视频 go协程实现原理 ，我们这里只讲简单使用。 用法 简单用法如下： package main import ( \"fmt\" \"sync\" ) func hello(i int) { println(\"hello world : \" + fmt.Sprint(i)) } func main() { //go的风格来说一般都喜欢运行一个闭包 go func(j int) { hello(j) }(i) } 并发的通信 并发程序之间的通信，一般都是通过共享内存的形式实现通信，临界区一般需要加锁保护。 而go语言采取的是通过通信来实现共享内存，这个过程是反过来的，但用起来更为直观。 Channel 通过内置函数 make 可以得到两种类型的 channel 。 注意：channel是类似于引用的一个类型，如果直接通过var声明定义是没法初始化得到内部内存的，故记得通过make创建channel。还有就是记得不用的时候关闭。 channel的使用 channel的简单使用如下： func main() { var src chan int src = make(chan int)//不带缓冲 dest := make(chan int, 3)//带缓冲 go func() { defer close(src) for i := 0; i \u003c 10; i++ { src \u003c- i//生产 } }() go func() { defer close(dest) for i := range src {//消费者1 dest \u003c- i * i } }() for i := range dest {//消费者2 println(i) } } 使用带缓冲channel的好处 在一个生产者消费者模型中，生产者的生产效率远高于消费者，那么可以使用带缓冲的channel，防止生产者因为等待消费者消费过程而产生阻塞。反之对消费者来说也是受用的。 并发安全 互斥锁 go语言并没有对加锁机制的弃用，标准库里面仍然有sync.Mutex。 以下为简单加锁实现并发安全： package main import ( \"fmt\" \"sync\" \"time\" ) var( x int mut sync.Mutex ) func AddWithLock() { mut.Lock() for i:=0;i\u003c2000;i++ { x++ } mut.Unlock() } func AddWithoutLock() { for i:=0;i\u003c2000;i++ { x++ } } func main() { //开五个协程的锁版本，再打印最终结果 for i := 0; i \u003c 5; i++ { go AddWithoutLock() } //等待上面的协程执行结束 time.Sleep(time.Second) fmt.Println(x) //有锁版本 x = 0 for i:=0;i\u003c5;i++{ go AddWithLock() } time.Sleep(time.Second) fmt.Println(x) } 计数器 WaitGroup，通过Add(a)计时器+a，通过Done()计数器-1，通过Wait()阻塞直到计数器为0。这个东西我觉得有些类似于操作系统的信号量。 以下为实例： package main import ( \"fmt\" \"sync\" ) func hello(){ fmt.Println(\"hello\") } func main() { var wg sync.WaitGroup wg.Add(5) for i := 0; i \u003c 5; i++ { go func() { defer wg.Done() hello() }() } wg.Wait() } ","date":"2022-05-08","objectID":"/posts/golang-note2/:1:3","tags":["Go工程实践"],"title":"Go语言工程实践（二） | 青训营笔记","uri":"/posts/golang-note2/"},{"categories":["青训营笔记"],"content":"依赖管理 Go依赖管理的演进： graph LR\ra[GOPATH]\rb[Go Vendor]\rc[Go Module]\ra--\u003eb--\u003ec\r","date":"2022-05-08","objectID":"/posts/golang-note2/:2:0","tags":["Go工程实践"],"title":"Go语言工程实践（二） | 青训营笔记","uri":"/posts/golang-note2/"},{"categories":["青训营笔记"],"content":"GOPATH go语言有一个内置的全局环境变量GOPATH，指定了GOPATH文件夹后，他会在这个文件夹内创建以下三个文件夹： |——bin：项目编译的二进制文件 |——pkg：项目编译的中间产物，加速编译 |——src：项目源码 项目直接依赖src下的代码，go get命令下载的软件包都会在src目录下。 GOPATH弊端 当我们对某个依赖进行升级后，则项目A依赖的版本可能无法实现兼容，这就是GOPATH无法解决的多版本控制问题。 ","date":"2022-05-08","objectID":"/posts/golang-note2/:2:1","tags":["Go工程实践"],"title":"Go语言工程实践（二） | 青训营笔记","uri":"/posts/golang-note2/"},{"categories":["青训营笔记"],"content":"Go Vendor 为了解决多版本控制问题，go又增加了Go Vendor的方式来管理依赖。 使用govendor init 在项目根目录会生成vendor文件夹，其中存放了当前项目依赖的副本。在Vendor机制下，如果当前项目存在Vendor目录，会优先使用该目录下的依赖，如果依赖不存在，会从GOPATH中寻找；这样解决了更新GOPATH依赖源码后之前的版本不兼容的问题。 Go Vendor弊端 弊端很明显，无法解决依赖的依赖。 同样还是无法解决依赖的冲突。 归根到底vendor不能很清晰的标识依赖的版本概念。 ","date":"2022-05-08","objectID":"/posts/golang-note2/:2:2","tags":["Go工程实践"],"title":"Go语言工程实践（二） | 青训营笔记","uri":"/posts/golang-note2/"},{"categories":["青训营笔记"],"content":"Go Module （最终解决方案 特点： 通过 go.mod 管理依赖包版本。 通过 go get/mod 工具管理依赖包。 最终目标：定义版本规则和管理项目的依赖关系。 依赖管理三要素 配置文件，描述依赖 （对应go.mod） 中心仓库管理依赖库 （GoProxy） 本地工具 go get/mod 配置文件 每个依赖单元用模块路径+版本来唯一标示。 版本规则 gopath和govendor都是源码副本方式依赖，没有版本规则概念，而gomod为了放方便管理则定义了版本规则。 对于语义化版本有如下规则： MAJOR：表示是不兼容的 API，所以即使是同一个库，MAJOR 版本不同也会被认为是不同的模块。 MINOR：通常是新增函数或功能，向后（向下）兼容。 PATCH：修复 bug。 杂项 版本号后面添加 //indirect 表示间接依赖。 选择题 选择1.4，因为它向后兼容。 中心仓库管理依赖库 依赖的分发 如果直接向代码托管平台进行依赖的请求，很快会发现有以下这些问题： 无法保证构建的稳定性（可能代码仓库的所有者更改删除了包版本 无法保证可用性 增加了平台压力 为了很好的解决以上依赖分发的问题，go采用Proxy进行代理分发。 Go Proxy 是一个服务站点，它会缓源站中的软件内容，缓存的软件版本不会改变，并且在源站软件删除之后依然可用。 较为神奇的地方 Go语言通过设置环境变量GOPROXY来设置具体的服务站点。可以通过逗号设置多个Proxy站点，最后如果这几个都没有找到，那么会通过direct进行回源，也就是回到本来的请求站点，而不是代理站。有意思的是，当你此时从源站下载好依赖后，你之前走过的Proxy站点也会将这个缓存下来。 有趣的实践 通过go mod init创建一个项目，写好后提交到GitHub仓库里，然后通过go get对你的代码进行请求，注意最后回源的direct要加上，否则肯定get不到，最后你会发现你的Proxy站上，也有了你的代码🥳 你会发现这样的过程，让go语言的代码仓库非常的繁荣，各种库都可以go get得到！ 本地工具 go get命令 go mod命令 ","date":"2022-05-08","objectID":"/posts/golang-note2/:2:3","tags":["Go工程实践"],"title":"Go语言工程实践（二） | 青训营笔记","uri":"/posts/golang-note2/"},{"categories":["青训营笔记"],"content":"测试 ","date":"2022-05-08","objectID":"/posts/golang-note2/:3:0","tags":["Go工程实践"],"title":"Go语言工程实践（二） | 青训营笔记","uri":"/posts/golang-note2/"},{"categories":["青训营笔记"],"content":"为什么要测试？ 测试是避免事故发生的最后一道关口！ ","date":"2022-05-08","objectID":"/posts/golang-note2/:3:1","tags":["Go工程实践"],"title":"Go语言工程实践（二） | 青训营笔记","uri":"/posts/golang-note2/"},{"categories":["青训营笔记"],"content":"测试类型 回归测试：是指修改了旧代码后，重新测试以确认修改没有引入新的错误或导致其他代码产生错误。 集成测试：集成测试的目的是在集成这些不同的软件模块时揭示它们之间交互中的缺陷。 单元测试：单元测试测试开发阶段，开发者对单独的函数、模块做功能验证。 层级从上至下，测试成本逐渐减低，而测试覆盖率确逐步上升，所以单元测试的覆盖率一定程度上决定这代码的质量。 ","date":"2022-05-08","objectID":"/posts/golang-note2/:3:2","tags":["Go工程实践"],"title":"Go语言工程实践（二） | 青训营笔记","uri":"/posts/golang-note2/"},{"categories":["青训营笔记"],"content":"单元测试 go单测的规则 go单测实例 写了一个json解析的单测 json.go package attention import ( \"bytes\" \"encoding/json\" \"fmt\" ) func NumUnmarshal() { jsonStr := `{\"id\":1,\"name\":\"Jerry\"}` var res map[string]interface{} _ = json.Unmarshal([]byte(jsonStr), \u0026res) fmt.Printf(\"%T\\n\", res[\"id\"]) i := res[\"id\"].(int64) fmt.Println(i) } func NumDecode() { jsonStr := `{\"id\":1,\"name\":\"Jerry\"}` var res map[string]interface{} decoder := json.NewDecoder(bytes.NewReader([]byte(jsonStr))) decoder.UseNumber() _ = decoder.Decode(\u0026res) i, _ := res[\"id\"].(json.Number).Int64() fmt.Println(i) } json_test.go package attention import \"testing\" func TestNumUnmarshal(t *testing.T) { NumUnmarshal() } func TestNumDecode(t *testing.T) { NumDecode() } 测试结果：通过 go test 会执行这个软件包里面所有的测试。如果需要执行特定的测试在后面跟上这个测试的go文件名以及对应的测试文件名。 单元测试框架 go语言常见的测试框架有testfy。在go mod文件里面的require部分填上以下代码便可通过go mod download进行下载。 github.com/stretchr/testify v1.7.1 或者直接 go get这个包也行。 这个包里包含测试常用的断言。 基础用法如下，更多用法请去查看官方文档。 衡量单元测试的标准 代码覆盖率 需要在测试时展示代码覆盖率可以通过添加–cover命令行参数。 下面是我的一次带代码覆盖率的单元测试结果： 我们可以看到百分比的覆盖率，也就是本次测试经过的代码块占比。 被测试到的代码都变成了绿色。 ","date":"2022-05-08","objectID":"/posts/golang-note2/:3:3","tags":["Go工程实践"],"title":"Go语言工程实践（二） | 青训营笔记","uri":"/posts/golang-note2/"},{"categories":["青训营笔记"],"content":"打桩测试 在打桩测试前，我们先了解单侧的稳定性和幂等性。 稳定：稳定是指相互隔离，能在任何时间，任何环境，运行测试。 幂等：幂等是指每一次测试运行都应该产生与之前一样的结果。 如果在有外部依赖的情况下进行单测，换一个测试环境，那么这个外部依赖信息可能会发生变化，比如需要打开某个文件，如果你把这个给别人测试，那么在他本地的文件路径肯定就不一致。这就完全没法符合稳定和幂等两个条件。 如下代码： 那么我们如何解决这样的问题呢？ 我们通过打桩来解决这个问题。 所谓打桩就是通过你指定的行为来对原本的行为替换，到计算机语言里面来讲就是通过你定义的桩函数把原本的函数进行替换，这就是打桩。 那打桩有什么用呢？ 隔离：将测试任务从产品项目中分离出来，使之能够独立编译、链接，并独立运行。 补齐：用桩来代替未实现的代码，例如，函数A调用了函数B，而函数B由其他程序员编写，且未实现，那么，可以用桩来代替函数B，使函数A能够运行并测试。 控制：控制是指在测试时，人为设定相关代码的行为，使之符合测试需求。 go语言的打桩实现原理： 在运行时通过通过 Go 的 unsafe 包，将内存中函数的地址替换为运行时函数的地址。 将待打桩函数或方法的实现跳转到。 打桩更改后的测试： ","date":"2022-05-08","objectID":"/posts/golang-note2/:3:4","tags":["Go工程实践"],"title":"Go语言工程实践（二） | 青训营笔记","uri":"/posts/golang-note2/"},{"categories":["青训营笔记"],"content":"基准测试（Benchmark） 很多时候我们需要清楚代码的运行效率，这个时候，我们就需要对代码进行基准测试了。 基准测试需要遵循以下语法规定： go语言中的基准测试也是基于单元测试，所以还是需要遵循 *_test.go 的命名规则。 用于基准测试的函数名必须以Benchmark开头。 函数的入参需要是 *testing.B 。 具体例子 代码分析 负载均衡中随机选择执行服务器。 server_select.go package benchmark import ( \"github.com/bytedance/gopkg/lang/fastrand\" \"math/rand\" ) var ServerIndex [10]int // InitServerIndex 初始化服务器的描述符 func InitServerIndex() { for i:=0;i\u003c10;i++{ ServerIndex[i] = i+100 } } // RandSelect 随机选择一个服务器 func RandSelect() int { return ServerIndex[rand.Intn(10)] } // FastRandSelect 用外部的fast包 func FastRandSelect()int{ return ServerIndex[fastrand.Intn(10)] } server_select_test.go package benchmark import \"testing\" func BenchmarkSelect(b *testing.B){ InitServerIndex() b.ResetTimer() for i:=0;i\u003cb.N;i++{ RandSelect() } } func BenchmarkSelectParallel(b *testing.B) { InitServerIndex() b.ResetTimer() b.RunParallel(func(pb *testing.PB) { for pb.Next(){ FastRandSelect() } }) } 我们对Benchmark的代码进行以下讲解： 对一个测试用例的默认测试时间是 1 秒，当测试用例函数返回时还不到 1 秒，那么 testing.B 中的 N 值将按 1、2、5、10、20、50……递增，并以递增后的值重新进行用例函数测试。 Resttimer重置计时器，我们在reset之前做了init或其他的准备操作，这些操作不应该作为基准测试的范围。 runparallel是多协程并发测试。 代码效率分析 我们发现，多线程的测试反而效率更慢了！ 主要原因是rand为了保证全局的随机性和并发安全，持有了一把全局锁。 这里贴了字节实现的较为快速的随机数实现库：fastrand 安装这个库也很简单，下面一行命令即可： go get github.com/bytedance/gopkg/lang/fastrand 优化代码 通过把 rand 替换为 fastrand 后，重新测试结果如下： 我们发现多线程的效率与之前的效率相比，提升了百倍！ fastrand主要的实现思路是牺牲了一定的数列一致性，在大多数场景是适用的，同学在后面遇到随机的场景可以尝试用一下。 ","date":"2022-05-08","objectID":"/posts/golang-note2/:3:5","tags":["Go工程实践"],"title":"Go语言工程实践（二） | 青训营笔记","uri":"/posts/golang-note2/"},{"categories":["青训营笔记"],"content":"项目实战 ","date":"2022-05-08","objectID":"/posts/golang-note2/:4:0","tags":["Go工程实践"],"title":"Go语言工程实践（二） | 青训营笔记","uri":"/posts/golang-note2/"},{"categories":["青训营笔记"],"content":"需求描述 展示话题（标题，文字描述）和回帖列表 暂不考虑前端页面实现，仅实现一个本地的web服务 话题和回帖数据用文件存储 用户浏览 实例图 ","date":"2022-05-08","objectID":"/posts/golang-note2/:4:1","tags":["Go工程实践"],"title":"Go语言工程实践（二） | 青训营笔记","uri":"/posts/golang-note2/"},{"categories":["青训营笔记"],"content":"项目分层结构 数据层：Repository 数据Model，封装外部数据的增删改查，并将数据初步反序列化，且需要直接与底层的数据存储形式打交道，比如存储形式是文件，还是数据库，还是微服务等等。 逻辑层：Service 业务Entity，这里会利用数据层得到封装好的数据再次封装得到更贴近客户端请求的数据，同样也需要写好增删改查，但这里的增删改查并不会与真正的外部数据打交道，也就是说Service层不关心底层数据的存储形式，只关心核心业务输出。 视图层：Controller 视图View，处理和外部的交互逻辑，也就是说，这个层级也是依赖于上一个层级的数据，它负责真正和客户端交互的过程，只关心返回什么样的数据给客户端，而前面两个层级都是为这个层级做的铺垫。 ","date":"2022-05-08","objectID":"/posts/golang-note2/:4:2","tags":["Go工程实践"],"title":"Go语言工程实践（二） | 青训营笔记","uri":"/posts/golang-note2/"},{"categories":["青训营笔记"],"content":"代码实现 代码实现可以到TraningCamp查看lesson2源码（温馨提示github域名后加上1s可以有意想不到的源码阅读体验哦 Repository层实现 主要实现底层存储数据序列化到具体的结构体上，以及对应的增删改查。 一般经过以下过程： graph LR\ra(初始化)\rb(底层存储的交互)\ra--\u003eb\r 初始化：主要是对数据的准备，或者时数据库的连接的初始化。 底层存储的交互：如果数据库，那么就是对数据库发起请求得到对应的Model，如果是文件存储，那么数据应该已经初始化到内存，直接进行取值即可。 数据映射 由于本次的存储实现采取的是文件存储，故需要每次一次性把文件读取好并完成数据的反序列化。这里用到的map进行映射数据方便查询。 如果是数据库，这时应该通过一些orm框架直接进行数据的增删改查映射，但在此之前还是得连接数据库（初始化过程 具体源码实现（我多加了一个记录最后一个Id的，方便完成id的不重复生成 数据的增删改查 topic.go 实现对话题的增删改查，这里用到了一个结构体+方法的方式去实现，且用sync.Once实现单例，我觉得好处在于： 防止重名。 方便记忆，方便调用时进行对应的语法补全（比如想要对Topic进行操作，只需要想到TopicDao这个即可补全后续的操作 post.go 和前面的实现类似，这里我完成了homework，添加了AddPost方法以及对应的将数据插入到文件的方法，由于可能出现多个客户端同时发起post请求，这时我们需要对数据进行并发安全的保护，这里我使用的Mutex加锁的方式。 Service层实现 主要是对Repository层的Modle进行进一步的封装成更上层需要的Entity。 一般经过以下流程： graph LR\ra(参数校验)\rb(准备数据)\rc(组装实体)\ra--\u003eb--\u003ec\r 参数校验：由于是和上层通信的层，上层调用得到数据时，首先**需要传入对应的参数，那么我们需要对这个参数进行校验，**不同的方法需要的参数是不同的，需要进行的校验也是不同的，比如本项目查询的方法和插入的方法，需要的参数就不同，所以对应的也是走的这三个流程。 准备数据：在正式组装得到整个实体之前，我们应该先进行数据的准备，也就是需要把零件得到，当然，不一次性组装好的原因，我认为更重要的是这样可以减少代码的耦合，这样一来准备每个数据的过程可以独立开，且可以进行针对性的优化，或者进行局部的修改，也不会直接对组装代码造成影响。 组装实体：把准备好的数据返回即可。 为了实现上述过程，我们建立一个结构体，保存准备的数据，且把整个组装实体的过程流程化。 结构体如下： // PageInfo 一个页面的信息包括，topic和它上面的post言论 type PageInfo struct { Topic *repository.Topic PostList []*repository.Post } // QueryPageInfoFlow 为了防止高耦合度的构造PageInfo，可以构造如下结构体实现流式处理 type QueryPageInfoFlow struct { topicId int64 pageInfo *PageInfo topic *repository.Topic posts []*repository.Post } 整个组装过程： // Do 整个组装过程 func (q *QueryPageInfoFlow) Do() (*PageInfo, error) { //对id进行合法性验证 if err := q.checkNum(); err != nil { return nil, err } //准备好生成PageInfo的数据 if err := q.prepareInfo(); err != nil { return nil, err } //打包最终的PageInfo if err := q.packPageInfo(); err != nil { return nil, err } return q.pageInfo, nil } 参数校验 由于这个查询过程暂时只需要校验这一个参数 func (q *QueryPageInfoFlow) checkNum() error { if q.topicId \u003c= 0 { return errors.New(\"topic must larger than 0\") } return nil } 准备数据 由于两个数据的查询毫无关联，可以通过并行处理。 graph LR\ra[话题信息]\rb[回帖信息]\rc[查询]\rd[结束]\rc--\u003ea\rc--\u003eb\ra--\u003ed\rb--\u003ed\r//这两个过程，由于是毫无关联的，可以用go协程进行并发处理 func (q *QueryPageInfoFlow) prepareInfo() error { var wg sync.WaitGroup wg.Add(2) //获取Topic go func() { defer wg.Done() q.topic = repository.NewTopicDao().QueryTopicFromId(q.topicId) }() //获取Posts go func() { defer wg.Done() q.posts = repository.NewPostDao().QueryPostsFromParentId(q.topicId) }() wg.Wait() return nil } 组装实体 //更新最终的PageInfo func (q *QueryPageInfoFlow) packPageInfo() error { q.pageInfo = \u0026PageInfo{ Topic: q.topic, PostList: q.posts, } return nil } 这样的话实现整个QueryPageInfo函数就只需要调用这个结构体的方法即可。 如下： func QueryPageInfo(id int64) (*PageInfo, error) { return NewQueryPageInfoFlow(id).Do() } Controller层实现 这个层级是真正对客户端发来的请求进行直接响应的层级，直接与客户端交互。 一般经过以下过程： graph LR\ra[参数解析]\rb[构造数据]\rc[返回数据]\ra--\u003eb--\u003ec\r 参数解析：由于对接的数据直接是上层收到的信息，所以大概率是纯字符串，所以需要先对参数进行解析。 构造数据：也就是构造响应的数据，一般来说除了直接的数据外，还需要提供一个错误码和错误信息给前端。 返回数据：根据不同情况构造的不同数据直接返回即可。 具体代码 // PageData 最终发送给客户端的json数据对应的结构体，我们需要错误码，以及对应错误码对应的消息，最后再是数据(用空接口实现泛型 type PageData struct { Code int64 `json:\"code\"` Msg string `json:\"msg\"` Data interface{} `json:\"data\"` } // QueryPageINfo 真正和客户端进行交互的函数，需要注意客户端发来的流量都是字符串形式 func QueryPageINfo(topicIdStr string) *PageData { pageId, err := strconv.Atoi(topicIdStr) if err != nil { return \u0026PageData{Code: 1, Msg: err.Error(), Data: nil} } pageInfo, err := service.QueryPageInfo(int64(pageId)) if err != nil { return \u0026PageData{Code: 2, Msg: err.Error(), Data: nil} } return \u0026PageData{Code: 0, Msg: \"success\", Data: pageInfo} } homework部分 作业内容与思考 课后实战： 支持发布帖子。 本地Id生成保证不重复。 Append文件，更新索引，注意并发安全问题。 我发现一个特点，这种分Controller、Service、Repository层的情况， 当你上层调用查询接口的时候，数据是自下往上的，也就是数据是从下往上依次封装。 而如果是实现添加操作接口的时候，数据是自上往下的，则数据是从上往下依次封装。 具体实现 思路： Id生成唯一性，是用的一个lastIndexId保存整个post中最大的id，之后每次添加post都继续增加这个lastIndexId来得到新的id。 并发安全问题，用到Mutex加锁临界区即可。 Repository层 AddPost提供是提供给Service层的接口。 需要实现把数据添加到map里以及append到文件中（对应fileDataInsertPost函数） func (d *PostDao) AddPost(post *Post) error { //加锁保证同时请求的并发安全 lock := sync.Mutex{} lock.Lock() posts, ok := postIndexMap[post.ParentId] if !ok { return errors.New(\"post invalid,not exist parent id\") } /","date":"2022-05-08","objectID":"/posts/golang-note2/:4:3","tags":["Go工程实践"],"title":"Go语言工程实践（二） | 青训营笔记","uri":"/posts/golang-note2/"},{"categories":["青训营笔记"],"content":"实测结果 服务端代码 server.go package main import ( \"github.com/ACking-you/TraningCamp/lesson2/homework/controller\" \"github.com/ACking-you/TraningCamp/lesson2/homework/repository\" \"gopkg.in/gin-gonic/gin.v1\" \"os\" \"strings\" ) //最后再通过gin框架搭建服务器 func main() { //准备数据 if err := Init(\"./lesson2/homework/data/\"); err != nil { os.Exit(-1) } //注册路由 r := gin.Default() r.GET(\"me:id\", func(c *gin.Context) { topicId := c.Param(\"id\") topicId = strings.TrimLeft(topicId, \":,\") println(topicId) data := controller.QueryPageINfo(topicId) c.JSONP(200, data) }) r.POST(\"/post/do\", func(c *gin.Context) { uid, _ := c.GetPostForm(\"uid\") println(uid) topicId, _ := c.GetPostForm(\"topic_id\") println(topicId) content, _ := c.GetPostForm(\"content\") println(content) data := controller.PublishPost(uid, topicId, content) c.JSON(200, data) }) err := r.Run() if err != nil { return } } func Init(filepath string) error { err := repository.Init(filepath) if err != nil { return err } return nil } 请求结果 使用的是goland里面的http请求工具进行的。 GET请求测试（成功） 请求报文如下： GET http://localhost:8080/me:1 Accept: application/json 返回报文如下： HTTP/1.1 200 OK Content-Type: application/json; charset=utf-8 Date: Mon, 09 May 2022 05:17:28 GMT Content-Length: 426 { \"code\": 0, \"msg\": \"success\", \"data\": { \"Topic\": { \"id\": 1, \"title\": \"青训营来啦!\", \"content\": \"小姐姐，快到碗里来~\", \"create_time\": 1650437625 }, \"PostList\": [ { \"id\": 1, \"parent_id\": 1, \"content\": \"小姐姐快来1\", \"create_time\": 1650437616, \"user_id\": 1 }, { \"id\": 2, \"parent_id\": 1, \"content\": \"小姐姐快来2\", \"create_time\": 1650437617, \"user_id\": 2 }, { \"id\": 3, \"parent_id\": 1, \"content\": \"小姐姐快来3\", \"create_time\": 1650437618, \"user_id\": 13 } ] } } Response code: 200 (OK); Time: 174ms; Content length: 368 bytes POST请求测试（成功） 请求报文： POST http://localhost:8080/post/do Content-Type: application/x-www-form-urlencoded uid=2\u0026topic_id=1\u0026content=测试内容嗨嗨嗨嗨 返回报文： HTTP/1.1 200 OK Content-Type: application/json; charset=utf-8 Date: Mon, 09 May 2022 05:22:38 GMT Content-Length: 47 { \"code\": 0, \"msg\": \"success\", \"data\": { \"post_id\": 5 } } Response code: 200 (OK); Time: 103ms; Content length: 47 bytes 再看看文件里面的内容是否添加： 成功！ ","date":"2022-05-08","objectID":"/posts/golang-note2/:4:4","tags":["Go工程实践"],"title":"Go语言工程实践（二） | 青训营笔记","uri":"/posts/golang-note2/"},{"categories":["青训营笔记"],"content":"这是我参与「第三届青训营 -后端场」笔记创作活动的的第一篇笔记。","date":"2022-05-07","objectID":"/posts/%E4%B8%80go%E8%AF%AD%E8%A8%80%E4%B8%8A%E6%89%8B-%E9%9D%92%E8%AE%AD%E8%90%A5%E7%AC%94%E8%AE%B0/","tags":["Go语言上手"],"title":"Go语言上手（一） | 青训营笔记","uri":"/posts/%E4%B8%80go%E8%AF%AD%E8%A8%80%E4%B8%8A%E6%89%8B-%E9%9D%92%E8%AE%AD%E8%90%A5%E7%AC%94%E8%AE%B0/"},{"categories":["青训营笔记"],"content":"这是我参与「第三届青训营 -后端场」笔记创作活动的的第一篇笔记。 ","date":"2022-05-07","objectID":"/posts/%E4%B8%80go%E8%AF%AD%E8%A8%80%E4%B8%8A%E6%89%8B-%E9%9D%92%E8%AE%AD%E8%90%A5%E7%AC%94%E8%AE%B0/:0:0","tags":["Go语言上手"],"title":"Go语言上手（一） | 青训营笔记","uri":"/posts/%E4%B8%80go%E8%AF%AD%E8%A8%80%E4%B8%8A%E6%89%8B-%E9%9D%92%E8%AE%AD%E8%90%A5%E7%AC%94%E8%AE%B0/"},{"categories":["青训营笔记"],"content":"语法速览 ","date":"2022-05-07","objectID":"/posts/%E4%B8%80go%E8%AF%AD%E8%A8%80%E4%B8%8A%E6%89%8B-%E9%9D%92%E8%AE%AD%E8%90%A5%E7%AC%94%E8%AE%B0/:1:0","tags":["Go语言上手"],"title":"Go语言上手（一） | 青训营笔记","uri":"/posts/%E4%B8%80go%E8%AF%AD%E8%A8%80%E4%B8%8A%E6%89%8B-%E9%9D%92%E8%AE%AD%E8%90%A5%E7%AC%94%E8%AE%B0/"},{"categories":["青训营笔记"],"content":"基础语法 基础语法有几点需要注意： 第一：类型 有值类型，有指针，指针只能作为引用的替代品，无法指针直接运算。 go语言有值类型，可以直接像下面这样定义变量： type Student struct { name string sid string } func main(){ var student = Student{name: \"John\", sid: \"1001\"} //student为值类型 var student = \u0026Student{name: \"John\", sid: \"1001\"} //student为指针类型（注意由于go有垃圾回收机制，所以这里会自动为我们开辟堆内存 student := new(Student) //也可通过内置的new()函数直接开辟堆内存，而不立马初始化，得到一个指针 } go语言的切片 同样切片类型也有上述两种获得内存的定义方式，也可通过内置的make函数对内部的cap和len进行初始的控制。 nums := make([]int,2,10)//得到一个底层数组长度为2，cap为10的初始切片 nums1 := nums2[0:3] //第二种切片方式 第二：内置库部分 json库的使用 通过在字段后面跟着的字符串进行序列化的定义，后面跟着的称为域标签。 package main import ( \"encoding/json\" \"fmt\" ) type Student struct { Name string `json:\"name\"` Sid string `json:\"sid\"` } func main() { s := Student{Name: \"jonh\" ,Sid: \"10323\"} //序列化 p ,err := json.Marshal(s) if err!=nil { panic(err) } fmt.Println(string(p)) //反序列化 err = json.Unmarshal(p,\u0026s) if err!=nil { panic(err) } fmt.Println(s) } 官方对域标签有以下说明： // Field appears in JSON as key \"myName\". Field int `json:\"myName\"` // Field appears in JSON as key \"myName\" and // the field is omitted from the object if its value is empty, // as defined above. Field int `json:\"myName,omitempty\"` // Field appears in JSON as key \"Field\" (the default), but // the field is skipped if empty. // Note the leading comma. Field int `json:\",omitempty\"` // Field is ignored by this package. Field int `json:\"-\"` // Field appears in JSON as key \"-\". Field int `json:\"-,\"` 时间库的使用 时间的获取 获取当前时间： package main import ( \"fmt\" \"time\" ) func main() { now := time.Now() //获取当前时间 fmt.Printf(\"current time:%v\\n\", now) year := now.Year() //年 month := now.Month() //月 day := now.Day() //日 hour := now.Hour() //小时 minute := now.Minute() //分钟 second := now.Second() //秒 fmt.Printf(\"%d-%02d-%02d %02d:%02d:%02d\\n\", year, month, day, hour, minute, second) } 获取时间戳 package main import ( \"fmt\" \"time\" ) func main() { now := time.Now() //获取当前时间 timestamp1 := now.Unix() //时间戳 timestamp2 := now.UnixNano() //纳秒时间戳 fmt.Printf(\"现在的时间戳：%v\\n\", timestamp1) fmt.Printf(\"现在的纳秒时间戳：%v\\n\", timestamp2) } 时间戳与时间的转换 package main import ( \"fmt\" \"time\" ) func main() { now := time.Now() //获取当前时间 timestamp := now.Unix() //时间戳 timeObj := time.Unix(timestamp, 0) //将时间戳转为时间格式 fmt.Println(timeObj) year := timeObj.Year() //年 month := timeObj.Month() //月 day := timeObj.Day() //日 hour := timeObj.Hour() //小时 minute := timeObj.Minute() //分钟 second := timeObj.Second() //秒 fmt.Printf(\"%d-%02d-%02d %02d:%02d:%02d\\n\", year, month, day, hour, minute, second) } 获取星期几 package main import ( \"fmt\" \"time\" ) func main() { t := time.Now() fmt.Println(t.Weekday().String()) } 时间的操作 （1）Add(during)函数实现某个时间 + 时间间隔 package main import ( \"fmt\" \"time\" ) func main() { now := time.Now() later := now.Add(time.Hour) // 当前时间加1小时后的时间 fmt.Println(later) } （2）Sub(Time)获取时间差值 返回一个时间段 t - u 的值。如果结果超出了 Duration 可以表示的最大值或最小值，将返回最大值或最小值，要获取时间点 t - d（d 为 Duration），可以使用 t.Add(-d)。 （3）Equal(Time)判断时间是否相同 （4）Before 和 After某个时间是否在他之前或之后 定时任务 使用 time.Tick(时间间隔) 可以设置定时器，定时器的本质上是一个通道（channel） package main import ( \"fmt\" \"time\" ) func main() { ticker := time.Tick(time.Second) //定义一个1秒间隔的定时器 for i := range ticker { fmt.Println(i) //每秒都会执行的任务 } } 解析字符串格式的时间 Parse 函数可以解析一个格式化的时间字符串并返回它代表的时间。 func Parse(layout, value string) (Time, error) 与 Parse 函数类似的还有 ParseInLocation 函数。 func ParseInLocation(layout, value string, loc *Location) (Time, error) ParseInLocation 与 Parse 函数类似，但有两个重要的不同之处： 第一，当缺少时区信息时，Parse 将时间解释为 UTC 时间，而 ParseInLocation 将返回值的 Location 设置为 loc； 第二，当时间字符串提供了时区偏移量信息时，Parse 会尝试去匹配本地时区，而 ParseInLocation 会去匹配 loc。 示例代码如下： package main import ( \"fmt\" \"time\" ) func main() { var layout string = \"2006-01-02 15:04:05\" var timeStr string = \"2019-12-12 15:22:12\" timeObj1, _ := time.Parse(layout, timeStr) fmt.Println(timeObj1) timeObj2, _ := time.ParseInLocation(layout, timeStr, time.Local) fmt.Println(timeObj2) } 字符串和数字互转 字符串与数字互转的想关库函数全在一个包内：strconv包 一图胜千言： os相关信息 os包里面封装了很多和操作系统相关的内容。 如下： package main import ( \"fmt\" \"os\" \"os/exec\" ) func main() { fmt.Println(os.Args) //打印命令行参数 fmt.Println(os.Getenv(\"PATH\")) //打印环","date":"2022-05-07","objectID":"/posts/%E4%B8%80go%E8%AF%AD%E8%A8%80%E4%B8%8A%E6%89%8B-%E9%9D%92%E8%AE%AD%E8%90%A5%E7%AC%94%E8%AE%B0/:1:1","tags":["Go语言上手"],"title":"Go语言上手（一） | 青训营笔记","uri":"/posts/%E4%B8%80go%E8%AF%AD%E8%A8%80%E4%B8%8A%E6%89%8B-%E9%9D%92%E8%AE%AD%E8%90%A5%E7%AC%94%E8%AE%B0/"},{"categories":["青训营笔记"],"content":"实战项目 ","date":"2022-05-07","objectID":"/posts/%E4%B8%80go%E8%AF%AD%E8%A8%80%E4%B8%8A%E6%89%8B-%E9%9D%92%E8%AE%AD%E8%90%A5%E7%AC%94%E8%AE%B0/:2:0","tags":["Go语言上手"],"title":"Go语言上手（一） | 青训营笔记","uri":"/posts/%E4%B8%80go%E8%AF%AD%E8%A8%80%E4%B8%8A%E6%89%8B-%E9%9D%92%E8%AE%AD%E8%90%A5%E7%AC%94%E8%AE%B0/"},{"categories":["青训营笔记"],"content":"猜谜游戏（pass，过于简单） ","date":"2022-05-07","objectID":"/posts/%E4%B8%80go%E8%AF%AD%E8%A8%80%E4%B8%8A%E6%89%8B-%E9%9D%92%E8%AE%AD%E8%90%A5%E7%AC%94%E8%AE%B0/:2:1","tags":["Go语言上手"],"title":"Go语言上手（一） | 青训营笔记","uri":"/posts/%E4%B8%80go%E8%AF%AD%E8%A8%80%E4%B8%8A%E6%89%8B-%E9%9D%92%E8%AE%AD%E8%90%A5%E7%AC%94%E8%AE%B0/"},{"categories":["青训营笔记"],"content":"在线词典 想要实现在线词典，首先就得用到别人的翻译引擎 第一步：抓包得得到数据进行分析 以彩云词典为例： 从网页调试工具里面查看随时收发的网络数据包，挨个查看它们的response，如果里面的json数据出现翻译结果，那么说明这个包就是返回的翻译结果！ 那么我们只需要让go语言来做同样的两件事： 发起请求。 解析返回的json内容。 只要做好了这两件事，那么就很快得到了一个单词的翻译了。 第二步：利用工具生成代码 在此之前我们需要清楚有两个神器般存在的网站： curlconverter 把curl请求直接转为go的请求代码。 oktools JSON转Golang Struct 那么我们先肯定是要得到请求的代码，然后稍作更改，解析body后得出想要的结果。 curl请求直接转为go的请求代码 如下图进到刚才我们捕捉到的目标包，然后复制cURL，到网站进行解析得到最终代码。 package main import ( \"fmt\" \"io/ioutil\" \"log\" \"net/http\" \"strings\" ) func main() { client := \u0026http.Client{} var data = strings.NewReader(`{\"trans_type\":\"en2zh\",\"source\":\"hello\"}`) req, err := http.NewRequest(\"POST\", \"https://api.interpreter.caiyunai.com/v1/dict\", data) if err != nil { log.Fatal(err) } req.Header.Set(\"Connection\", \"keep-alive\") req.Header.Set(\"sec-ch-ua\", `\" Not A;Brand\";v=\"99\", \"Chromium\";v=\"99\", \"Google Chrome\";v=\"99\"`) req.Header.Set(\"sec-ch-ua-mobile\", \"?0\") req.Header.Set(\"User-Agent\", \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/99.0.4844.51 Safari/537.36\") req.Header.Set(\"app-name\", \"xy\") req.Header.Set(\"Content-Type\", \"application/json;charset=UTF-8\") req.Header.Set(\"Accept\", \"application/json, text/plain, */*\") req.Header.Set(\"os-type\", \"web\") req.Header.Set(\"X-Authorization\", \"token:qgemv4jr1y38jyq6vhvi\") req.Header.Set(\"sec-ch-ua-platform\", `\"Windows\"`) req.Header.Set(\"Origin\", \"https://fanyi.caiyunapp.com\") req.Header.Set(\"Sec-Fetch-Site\", \"cross-site\") req.Header.Set(\"Sec-Fetch-Mode\", \"cors\") req.Header.Set(\"Sec-Fetch-Dest\", \"empty\") req.Header.Set(\"Referer\", \"https://fanyi.caiyunapp.com/\") req.Header.Set(\"Accept-Language\", \"zh-CN,zh;q=0.9\") resp, err := client.Do(req) if err != nil { log.Fatal(err) } defer resp.Body.Close() bodyText, err := ioutil.ReadAll(resp.Body) if err != nil { log.Fatal(err) } fmt.Printf(\"%s\\n\", bodyText) } 观察代码的改变我们只需对source部分的内容进行更改，即可得到对应的翻译结果。 JSON转Golang Struct 得到翻译结果，body内容后，我们需要把body内容解析为本地的sturct才能正常使用（当然你头铁的话可以直接找对应的字符串即可，也不需要反序列化。 type AutoGenerated struct { Rc int `json:\"rc\"` Wiki struct { KnownInLaguages int `json:\"known_in_laguages\"` Description struct { Source string `json:\"source\"` Target interface{} `json:\"target\"` } `json:\"description\"` ID string `json:\"id\"` Item struct { Source string `json:\"source\"` Target string `json:\"target\"` } `json:\"item\"` ImageURL string `json:\"image_url\"` IsSubject string `json:\"is_subject\"` Sitelink string `json:\"sitelink\"` } `json:\"wiki\"` Dictionary struct { Prons struct { EnUs string `json:\"en-us\"` En string `json:\"en\"` } `json:\"prons\"` Explanations []string `json:\"explanations\"` Synonym []string `json:\"synonym\"` Antonym []interface{} `json:\"antonym\"` WqxExample [][]string `json:\"wqx_example\"` Entry string `json:\"entry\"` Type string `json:\"type\"` Related []interface{} `json:\"related\"` Source string `json:\"source\"` } `json:\"dictionary\"` } 第三步：更改代码实现功能 通过前面生成的代码已经能够实现请求和接收响应，且可以直接把响应内容反序列化为结构体，那么接下来，只需要把想要的部分遍历打印即可。 最终代码如下： package src import ( \"bytes\" \"encoding/json\" \"fmt\" \"io/ioutil\" \"log\" \"net/http\" ) func QueryCaiyun(word string) { client := \u0026http.Client{} request := DictRequestCaiyun{TransType: \"en2zh\", Source: word} buf, err := json.Marshal(request) if err != nil { log.Fatal(err) } var data = bytes.NewReader(buf) req, err := http.NewRequest(\"POST\", \"https://api.interpreter.caiyunai.com/v1/dict\", data) if err != nil { log.Fatal(err) } req.Header.Set(\"Connection\", \"keep-alive\") req.Header.Set(\"sec-ch-ua\", `\" Not A;Brand\";v=\"99\", \"Chromium\";v=\"99\", \"Google Chrome\";v=\"99\"`) req.Header.Set(\"sec-ch-ua-mobile\", \"?0\") req.Header.Set(\"User-Agent\", \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/99.0.4844.51 Safari/537.36\") req.Header.Set(\"app-name\", \"xy\") req.Header.Set(\"Content-Type\", \"application/json;charset=UTF-8\") req.Header.Set(\"Accept\", \"application/json, text/plain, */*\") req.Header.Set(\"os-type\", \"web\") req.Header.Set(\"X-Authorization\", \"token:qgemv4jr1y38jyq6vhvi\") req.Header.Set(\"sec-ch-ua-platform\", `\"Windows\"`) req.Header.Set(\"Origin\", \"https://fanyi.caiy","date":"2022-05-07","objectID":"/posts/%E4%B8%80go%E8%AF%AD%E8%A8%80%E4%B8%8A%E6%89%8B-%E9%9D%92%E8%AE%AD%E8%90%A5%E7%AC%94%E8%AE%B0/:2:2","tags":["Go语言上手"],"title":"Go语言上手（一） | 青训营笔记","uri":"/posts/%E4%B8%80go%E8%AF%AD%E8%A8%80%E4%B8%8A%E6%89%8B-%E9%9D%92%E8%AE%AD%E8%90%A5%E7%AC%94%E8%AE%B0/"},{"categories":["青训营笔记"],"content":"SOCKS5代理服务器 SOCKS5简单介绍 SOCKS5是代理协议，在使用TCP/IP协议通信的前端机器和服务器之间发挥中介作用，使内部网络的前端机器能够访问互联网的服务器，使通信更加安全。SOCKS5服务器将前端发送的请求转发给真正的目标服务器，模拟前端行为。此处，前端与SOCKS5之间也是通过TCP/IP协议进行通信的，前端向SOCKS5服务器发送请求发送给SOCKS5服务器，然后SOCKS5服务器将请求发送给真正的服务器。SOCKS5服务器在将通讯请求发送给真正服务器的过程中，对于请求数据包本身不加任何改变（明文传输）。SOCKS5服务器在收到真实服务器响应后，也原样转发到前端。 它的用途是， 比如某些企业的内网为了确保安全性，有很严格的防火墙策略，但是带来的副作用就是访问某些资源会很麻烦。 socks5 相当于在防火墙开了个口子，让授权的用户可以通过单个端口去访问内部的所有资源。实际上很多翻墙软件，最终暴露的也是一个 socks5 协议的端口。 SOCKS5代理原理 正常浏览器访问一个网站，如果不经过代理服务器的话，就是先和对方的网站建立 TCP 连接，然后三次握手，握手完之后发起 HTTP 请求，然后服务返回 HTTP 响应。如果设置代理服务器之后，流程会变得复杂一些。 首先是浏览器和 socks5 代理建立 TCP 连接，代理再和真正的服务器建立 TCP 连接。这里可以分成四个阶段，握手阶段、认证阶段、请求阶段、 relay 阶段。 握手阶段：浏览器会向 socks5 代理发送请求，包的内容包括一个协议的版本号，还有支持的认证的种类，socks5 服务器会选中一个认证方式，返回给浏览器。如果返回的是 00 的话就代表不需要认证，返回其他类型的话会开始认证流程，这里我们就不对认证流程进行概述了。（本次课程跳过认证阶段） 请求阶段：认证通过之后浏览器会对 socks5 服务器发起请求。主要信息包括 版本号，请求的类型，一般主要是 connection 请求，就代表代理服务器要和某个域名或者某个 IP 地址某个端口建立 TCP 连接。代理服务器收到响应之后，会真正和后端服务器建立连接，然后返回一个响应。 relay 阶段：此时浏览器会发送 正常发送请求，然后代理服务器接收到请求之后，会直接把请求转换到真正的服务器上。然后如果真正的服务器以后返回响应的话，那么也会把请求转发到浏览器这边。然后实际上 代理服务器并不关心流量的细节，可以是 HTTP流量，也可以是其它 TCP 流量。 这个就是 socks5 协议的工作原理。 graph LR\ra[握手阶段]\rb[认证阶段]\rc[请求阶段]\rd[转发relay阶段]\ra--\u003eb--\u003ec--\u003ed\r具体实现 v1-简单echo服务器 package main import ( \"bufio\" \"fmt\" \"log\" \"net\" ) func main() { server, err := net.Listen(\"tcp\", \"0.0.0.0:1080\") if err != nil { panic(err) } for { client, err := server.Accept() if err != nil { log.Printf(\"Accept failed %v\", err) continue } fmt.Printf(\"连接成功! clent:%v \\n\", client.RemoteAddr()) go process(client) } } func process(conn net.Conn) { defer func() { conn.Close() fmt.Printf(\"连接断开! clent:%v \\n\", conn.RemoteAddr()) }() //用缓冲流进行一次包装，减少底层IO次数，让读取效率更高效 reader := bufio.NewReader(conn) for { b, err := reader.ReadByte() if err != nil { break } _, err = conn.Write([]byte{b}) if err != nil { break } } } 客户端验证： 没必要再写一个客户端，这时完全可以netcat工具进行tcp连接测试。 如下： v2-实现SOCKS5的握手阶段 实现SOCKS5之前我们需要清楚SOCKS5的握手阶段的请求和返回是怎么样的，如下面的图表所示： VER NMETHODS METHODS 1byte 1byte 1 to 255 byte 协议版本信息socks5为0x05 支持认证的方法数量值为0x00则表示无需认证 NMETHODS的值为多少METHODS就有多少个字节 package main //auth 阶段 import ( \"bufio\" \"fmt\" \"io\" \"log\" \"net\" ) const( socks5Ver = 0x05 cmdBind = 0x01 atypIPV4 = 0x01 atypeHOST = 0x03 atypeIPV6 = 0x04 ) func main() { server, err := net.Listen(\"tcp\", \"0.0.0.0:1080\") if err != nil { panic(err) } for { client, err := server.Accept() if err != nil { log.Printf(\"Accept failed %v\", err) continue } fmt.Printf(\"连接成功! clent:%v \\n\", client.RemoteAddr()) go process(client) } } func process(conn net.Conn) { defer func() { conn.Close() fmt.Printf(\"连接断开! clent:%v \\n\", conn.RemoteAddr()) }() reader := bufio.NewReader(conn) err := auth(reader,conn) if err!=nil{ log.Printf(\"client %v auth failed:%v\",conn.RemoteAddr(),err) } log.Println(\"auth success\") } func auth(reader *bufio.Reader, conn net.Conn) (err error) { //协议版本 ver,err := reader.ReadByte() if err != nil{ return fmt.Errorf(\"read ver failed:%w\",err) } if ver != socks5Ver{ return fmt.Errorf(\"not supported ver:%v\",ver) } //支持的方法数量 methodSize,err := reader.ReadByte() if err!=nil{ return fmt.Errorf(\"read methodSize failed:%w\",err) } //方法值 method := make([]byte,methodSize) _,err = io.ReadFull(reader,method) if err!=nil{ return fmt.Errorf(\"read method failed %w\",err) } log.Println(\"ver\",ver,\"method\",method) //返回的内容表示SOCKS5通信，且无需认证 _,err = conn.Write([]byte{socks5Ver,0x00}) if err !=nil{ return fmt.Errorf(\"write failed:%w\",err) } return nil } v3-实现SOCKS5的请求阶段 同样来看看此时的消息协议： 客户端请求： VER CMD RSV ATYP DST.ADDR DST.PORT 1byte 1byte 1byte 1byte Variable 2byte 协议版本0x05为SOCKS5 代表请求类型0x01表示CONNECT请求 保留字段（不理会） 目标地址类型（IPV4/IPV6/域名） 地址值，根据不同地址类型，长度不同 需要访问的服务器的端口号 服务端响应： VER REP RSV ATYP BIND.ADDR BIND.PORT 1byte 1byte 1byte 1byte Variable 2byte 协议版本0x05为SOCKS5 代表响应。成功就返回0 保留字段（不理会） 地址类型（IPV4/IPV6/域名） 地址值（这里暂时不需要 端口号（这里暂时不需要 这一过程的代码： 对当前的实现进行测试： 进行如下curl命令： curl --socks5 localhost:1080 -v http://www.qq.com 此时请求会失败，但我们已经能看到正常打印出来的ip和端口号 v4-实现SOCKS5的转发阶段（最终完全版本 最后的转发过程，由于不需要对流量进行任何的处理，所以没有上层协议，直接再Write操作完后把流量进行转发即可。 对于两个连接流量的转发，标准库里有有一些好用的函数库。 通过net.Dial建立tcp连接。 dest, err := net.Dial(\"tcp\", fmt","date":"2022-05-07","objectID":"/posts/%E4%B8%80go%E8%AF%AD%E8%A8%80%E4%B8%8A%E6%89%8B-%E9%9D%92%E8%AE%AD%E8%90%A5%E7%AC%94%E8%AE%B0/:2:3","tags":["Go语言上手"],"title":"Go语言上手（一） | 青训营笔记","uri":"/posts/%E4%B8%80go%E8%AF%AD%E8%A8%80%E4%B8%8A%E6%89%8B-%E9%9D%92%E8%AE%AD%E8%90%A5%E7%AC%94%E8%AE%B0/"},{"categories":["(bug日记)C++实现QQ——UI篇"],"content":"实现实时qq好友搜索框","date":"2022-04-24","objectID":"/posts/%E5%AE%9E%E7%8E%B0%E5%AE%9E%E6%97%B6qq%E5%A5%BD%E5%8F%8B%E6%90%9C%E7%B4%A2%E6%A1%86/","tags":["实现实时qq好友搜索框"],"title":"实现实时qq好友搜索框","uri":"/posts/%E5%AE%9E%E7%8E%B0%E5%AE%9E%E6%97%B6qq%E5%A5%BD%E5%8F%8B%E6%90%9C%E7%B4%A2%E6%A1%86/"},{"categories":["(bug日记)C++实现QQ——UI篇"],"content":"项目背景 想要用纯C++实现一个QQ，包括客户端的ui和通信，以及服务端的数据收发通信。 客户端：使用C++的Qt框架实现UI（正在进行），使用自己手写的网络框架进行通信（还未开始），以及手写的bencode编码进本地序列化（已经完成）。 服务端：使用自己造好的网络框架进行数据的收发和通信（还未开始）。 本篇进度：已经实现了登录界面和基本的主界面，本次是想拓展一个实时的搜索框，结果碰到了坑，然后在此写下记录。 目前UI实现情况如下图： 登录界面： 主界面： ","date":"2022-04-24","objectID":"/posts/%E5%AE%9E%E7%8E%B0%E5%AE%9E%E6%97%B6qq%E5%A5%BD%E5%8F%8B%E6%90%9C%E7%B4%A2%E6%A1%86/:1:0","tags":["实现实时qq好友搜索框"],"title":"实现实时qq好友搜索框","uri":"/posts/%E5%AE%9E%E7%8E%B0%E5%AE%9E%E6%97%B6qq%E5%A5%BD%E5%8F%8B%E6%90%9C%E7%B4%A2%E6%A1%86/"},{"categories":["(bug日记)C++实现QQ——UI篇"],"content":"实时QQ好友搜索框实现思路 实现目标：当用户在搜索框输入名字的时候，会实时将当前列表内的包含该名字的好友给列举出来。 实现方式：通过连接信号 QLineEdit::textChanged 来对应用户按钮的存储控件中的槽函数。 ","date":"2022-04-24","objectID":"/posts/%E5%AE%9E%E7%8E%B0%E5%AE%9E%E6%97%B6qq%E5%A5%BD%E5%8F%8B%E6%90%9C%E7%B4%A2%E6%A1%86/:2:0","tags":["实现实时qq好友搜索框"],"title":"实现实时qq好友搜索框","uri":"/posts/%E5%AE%9E%E7%8E%B0%E5%AE%9E%E6%97%B6qq%E5%A5%BD%E5%8F%8B%E6%90%9C%E7%B4%A2%E6%A1%86/"},{"categories":["(bug日记)C++实现QQ——UI篇"],"content":"具体思路 由于我是通过 QListWidget 存下多个自己重写的 QPushButton 来实现好友列表，故想要进行列表中的删除和增加就是对 QListWidget 增加或删除 QListWidgetItem 。由于 QListWidget 只提供了 QListWidget::addItem 方法进行添加，而这个方法并不能保证在具体哪一行插入，只会在列表的尾部进行添加，所以我通过这样一个方法实现实时的列表搜索项：清空再重新创建符合条件的 QPushButton。 ","date":"2022-04-24","objectID":"/posts/%E5%AE%9E%E7%8E%B0%E5%AE%9E%E6%97%B6qq%E5%A5%BD%E5%8F%8B%E6%90%9C%E7%B4%A2%E6%A1%86/:2:1","tags":["实现实时qq好友搜索框"],"title":"实现实时qq好友搜索框","uri":"/posts/%E5%AE%9E%E7%8E%B0%E5%AE%9E%E6%97%B6qq%E5%A5%BD%E5%8F%8B%E6%90%9C%E7%B4%A2%E6%A1%86/"},{"categories":["(bug日记)C++实现QQ——UI篇"],"content":"实践 ","date":"2022-04-24","objectID":"/posts/%E5%AE%9E%E7%8E%B0%E5%AE%9E%E6%97%B6qq%E5%A5%BD%E5%8F%8B%E6%90%9C%E7%B4%A2%E6%A1%86/:3:0","tags":["实现实时qq好友搜索框"],"title":"实现实时qq好友搜索框","uri":"/posts/%E5%AE%9E%E7%8E%B0%E5%AE%9E%E6%97%B6qq%E5%A5%BD%E5%8F%8B%E6%90%9C%E7%B4%A2%E6%A1%86/"},{"categories":["(bug日记)C++实现QQ——UI篇"],"content":"实践一：通过保存一份拷贝(扑街bug) 根据这个思路，我很快想到，需要保存好搜索前的所有列表项，然后再通过用户输入的文字筛选，将符合条件的列表项添加进去。 这样很快就出现了问题：由于清空列表会导致列表项里面的所有内存都被析构！所以如果你去按照这样一个思路去实现，我们需要在每次调用 addUserBtn 添加用户按钮的时候存下一份拷贝，然后你把列表清空后内存析构也一直能用这一份拷贝再生成新的拷贝按钮来添加到列表中去，这样问题应该就解决了。 然后我马不停蹄的马上写好了代码，跑起来准备测试，立马出现新的问题：每次输入时确实会显示对应的用户按钮是没错，但图片都没了，甚至很多按钮是空的？？？ 经过注意排查，发现是我写拷贝构造函数的时候把很多 QString 成员转了右值用了移动构造，所以每次发送拷贝时，实际上资源已经转移了。。。 改好这个bug，又继续测试，然后果不其然，又出现了新的问题：用户输入的时候会有符合条件的项被创建没错，且都有对应的数据，但是随着继续输入创建的对象是越来越多了？？？ 又经过仔细排查，发现是因为每次 addUserBtn 的时候都会把对应的数据添加一份拷贝到缓存，但是如果是用户在输入框立马输入信息进行查询时，调用了这个add函数，那么就会不断的添加重复的信息到缓存中去！！！ 此时很多人可能会想着用 set 替代 list 做缓存，但是我就此发现了我这个实现思路就很有问题： 一、每次重新添加控件需要把整个信息全拷贝一遍，如果数据多了会是一个很耗时的工作！ 二、我发现了罪恶之源：QListWidget 把控件的生命周期牢牢把握！！！要不是每次删除控件都得把立马的东西析构才能让这个控件不显示，才不会出现这等问题！也才不会需要重复不断的创建对象！ ","date":"2022-04-24","objectID":"/posts/%E5%AE%9E%E7%8E%B0%E5%AE%9E%E6%97%B6qq%E5%A5%BD%E5%8F%8B%E6%90%9C%E7%B4%A2%E6%A1%86/:3:1","tags":["实现实时qq好友搜索框"],"title":"实现实时qq好友搜索框","uri":"/posts/%E5%AE%9E%E7%8E%B0%E5%AE%9E%E6%97%B6qq%E5%A5%BD%E5%8F%8B%E6%90%9C%E7%B4%A2%E6%A1%86/"},{"categories":["(bug日记)C++实现QQ——UI篇"],"content":"实践二：通过前后端分离+智能指针完美解决 这次推倒重来，前面的试探也并非是在做无用功，至少通过前面的实践发现，既然我们没法把 Button 的生命周期拿在手里（每次还是需要重新new出新的Button），但我们至少把 Button 里数据的生命周期拿在手里啊，我们利用数据和界面分离的思想，将数据以一个智能指针的方式保存在 Button 内部，这样一来按钮被析构，数据也不一定就会被析构，只有当智能指针的引用计数为0的时候才被析构。 所以回到前面的实践一，这次我们还是以一个缓存存下原本的数据，但是这次我们存储的不是 Button 对象，而是 Button 对象中的智能指针数据，所以只要缓存还存在，那么 Button 里面的数据就还是可以复用的！所以每次 new 出新的 Button 去显示的代价是很小的 ，因为指针的copy几乎是没有代价的。。。 而且如果用set存储指针的话，直接通过判断地址就能清楚是否是相同的数据了！这样的存储性能会比直接存下数据要高很多。 像这样把数据和界面分离开的思路，我觉得就和web端的前后端分离的思路是一模一样，所以我愿意称之为桌面端的前后端分离。 ","date":"2022-04-24","objectID":"/posts/%E5%AE%9E%E7%8E%B0%E5%AE%9E%E6%97%B6qq%E5%A5%BD%E5%8F%8B%E6%90%9C%E7%B4%A2%E6%A1%86/:3:2","tags":["实现实时qq好友搜索框"],"title":"实现实时qq好友搜索框","uri":"/posts/%E5%AE%9E%E7%8E%B0%E5%AE%9E%E6%97%B6qq%E5%A5%BD%E5%8F%8B%E6%90%9C%E7%B4%A2%E6%A1%86/"},{"categories":["(bug日记)C++实现QQ——UI篇"],"content":"附录 最后我贴上我具体实现的代码： 能看懂的应该会有收获，看不懂以后总会看得懂😁 UserButton.h class UserButton :public QPushButton{ Q_OBJECT private: UserButton(QWidget*parent); public: //按钮的类型 enum class Type{ Meg_Btn, User_Btn }; //存储按钮数据的类型 struct ButtonInfo{ int _unread = 0; int _hide = 0; int _uid = 0; State _state = State::OffLine; Type _type = Type::Meg_Btn; QString _iconPath; QString _name; QString _text; static std::shared_ptr\u003cButtonInfo\u003e getDefaultButtonInfo(QString const\u0026name,QString const\u0026text,QString const\u0026iconPath); }; using shared_info = std::shared_ptr\u003cButtonInfo\u003e; //根据外界数据创建按钮 static UserButton* fromButtonInfo(shared_info const\u0026 info,QWidget* parent=nullptr); /** * 持久化成功返回存储的路径，否则返回空optional * @param imageSrc * @param name * @return */ static std::optional\u003cQString\u003e StorageIcon(QByteArray const\u0026imageSrc,QString const\u0026 name); ~UserButton() override; protected: void paintEvent(QPaintEvent *) override; public: //画出Message按钮 void PainMessageBtn(); //画出User按钮 void PainUserBtn(); QRect adjustSize(QString\u0026dest); //一大堆getter和setter QString getName(); void setName(QString name); int getNumUnread() const; void setNumUnread(int numUnread); State getMState() const; void setMState(State mState); const QString \u0026getMIconPath() const; void setMIconPath(const QString \u0026mIconPath); Type getMType() const; void setMType(Type mType); void setHideMsgStyle(bool isHide); int getMisHide(); int getUid() const; void setUid(int uid); void setContent(QString const\u0026 text); QString getContent(); shared_info getSharedInfo(); public slots: //用于外界实时更新消息框的显示内容的槽函数 void updateContent(QString const\u0026 text); private: //数据 shared_info m_info_; }; UserButton.cpp // // Created by Alone on 2022-4-18. // #include \"UserButton.h\"#include \u003cQFile\u003e#include \u003cQByteArray\u003e#include \u003cutility\u003e#include \u003cQDir\u003e#include \u003cconfig_path.h\u003e#include \u003ciostream\u003e#include \u003cQPainter\u003e //方便进行测试的信shared_info快速创建 UserButton::shared_info UserButton::ButtonInfo::getDefaultButtonInfo(const QString \u0026name, const QString \u0026text, const QString \u0026iconPath) { auto* src = new UserButton::ButtonInfo; src-\u003e_name = name; src-\u003e_text = text; src-\u003e_iconPath = iconPath; return std::shared_ptr\u003cUserButton::ButtonInfo\u003e(src); } //qss样式 inline QString My_StyleSheet(QString const\u0026 icon_path){ return QString(R\"( QPushButton{ border:none; image: url(%1); image-position:left; min-width:120px; padding-top:7px; padding-left:10px; padding-bottom:7px; background:rgb(248, 249, 249); } QPushButton:hover{ border:none; background:rgb(242, 242, 242); } QPushButton:checked{ border:none; background:rgb(235, 235, 235); } )\").arg(icon_path); } UserButton::UserButton(QWidget *parent): QPushButton(parent) { setCheckable(true); setAutoExclusive(true); } UserButton::~UserButton() { } UserButton* UserButton::fromButtonInfo(shared_info const\u0026 info,QWidget* parent){ auto* btn = new UserButton(parent); btn-\u003em_info_ = info; btn-\u003esetStyleSheet(My_StyleSheet(btn-\u003egetMIconPath())); return btn; } //调整内容显示 QRect UserButton::adjustSize(QString \u0026dest){ assert(m_info_!=nullptr); // 三档调节 int num_width = 0; int span = 13; if(m_info_-\u003e_unread\u003c10){ dest = QString::number(m_info_-\u003e_unread); num_width = span; }else if(m_info_-\u003e_unread\u003c99){ dest = QString::number(m_info_-\u003e_unread); num_width = span*2; }else{ dest.append(\"99+\"); num_width = span*3; } return {this-\u003ewidth()-10-num_width,this-\u003eheight()/2+5,num_width,13}; } //根据不同的按钮进行不同的绘制 void UserButton::paintEvent(QPaintEvent *e) { assert(m_info_!=nullptr); QPushButton::paintEvent(e); switch (m_info_-\u003e_type) { case Type::User_Btn: PainUserBtn(); break; case Type::Meg_Btn: PainMessageBtn(); break; } } //持久化二进制数据到本地(主要是图片) std::optional\u003cQString\u003e UserButton::StorageIcon(QByteArray const\u0026 imageSrc,QString const\u0026 name) { QString base_path = QDir::homePath()+DirName_Base; QString user_icon_path = base_path +DirName_Icon; //如果两级文件夹不存在，则先创建文件夹 QDir dir(base_path); if(!dir.exists()){ qDebug()\u003c\u003c\"base_dir not exists,being created\"; if(!dir.mkdir(base_path) ) return {}; } dir.setPath(user_icon_path); if(!dir.exists() ) { qDebug()\u003c\u003c\"icon_dir not exists","date":"2022-04-24","objectID":"/posts/%E5%AE%9E%E7%8E%B0%E5%AE%9E%E6%97%B6qq%E5%A5%BD%E5%8F%8B%E6%90%9C%E7%B4%A2%E6%A1%86/:4:0","tags":["实现实时qq好友搜索框"],"title":"实现实时qq好友搜索框","uri":"/posts/%E5%AE%9E%E7%8E%B0%E5%AE%9E%E6%97%B6qq%E5%A5%BD%E5%8F%8B%E6%90%9C%E7%B4%A2%E6%A1%86/"},{"categories":["C++多线程"],"content":"1.3-多线程控制的另一种姿势-条件变量(condition_variable), 信号量(semaphore)","date":"2022-03-27","objectID":"/posts/1.3-%E9%94%81%E9%87%8A%E6%94%BE%E7%9A%84%E5%8F%A6%E4%B8%80%E7%A7%8D%E5%A7%BF%E5%8A%BF-%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8Fcondition_variable-%E4%BF%A1%E5%8F%B7%E9%87%8Fsemaphore/","tags":["1.3-多线程控制的另一种姿势-条件变量(condition_variable), 信号量(semaphore)"],"title":"1.3-多线程控制的另一种姿势-条件变量(condition_variable), 信号量(semaphore)","uri":"/posts/1.3-%E9%94%81%E9%87%8A%E6%94%BE%E7%9A%84%E5%8F%A6%E4%B8%80%E7%A7%8D%E5%A7%BF%E5%8A%BF-%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8Fcondition_variable-%E4%BF%A1%E5%8F%B7%E9%87%8Fsemaphore/"},{"categories":["C++多线程"],"content":"条件变量(C++11) ","date":"2022-03-27","objectID":"/posts/1.3-%E9%94%81%E9%87%8A%E6%94%BE%E7%9A%84%E5%8F%A6%E4%B8%80%E7%A7%8D%E5%A7%BF%E5%8A%BF-%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8Fcondition_variable-%E4%BF%A1%E5%8F%B7%E9%87%8Fsemaphore/:1:0","tags":["1.3-多线程控制的另一种姿势-条件变量(condition_variable), 信号量(semaphore)"],"title":"1.3-多线程控制的另一种姿势-条件变量(condition_variable), 信号量(semaphore)","uri":"/posts/1.3-%E9%94%81%E9%87%8A%E6%94%BE%E7%9A%84%E5%8F%A6%E4%B8%80%E7%A7%8D%E5%A7%BF%E5%8A%BF-%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8Fcondition_variable-%E4%BF%A1%E5%8F%B7%E9%87%8Fsemaphore/"},{"categories":["C++多线程"],"content":"为什么要引入条件变量 我们先来看看一个由互斥量加锁构成的生产者消费者模型： // // Created by Alone on 2022-3-27. // #include \u003ciostream\u003e#include \u003cmutex\u003e#include \u003cdeque\u003e#include \u003cthread\u003estd::mutex mtx; std::deque\u003cint\u003e q; // producer void task1(){ int i = 0; while (1){ std::unique_lock\u003cstd::mutex\u003e lock(mtx); //std::this_thread::sleep_for(std::chrono::milliseconds(10)); q.push_back(i); if (i \u003c 9999999) { i++; }else { i = 0; } } } // consumer void task2(){ int data = 0; while (1) { std::unique_lock\u003cstd::mutex\u003e lock(mtx); if(!q.empty()){ data = q.front(); q.pop_front(); std::cout\u003c\u003c\"Get value from que task2:\"\u003c\u003cdata\u003c\u003cstd::endl; } } } void task3(){ int data = 0; while (1) { std::unique_lock\u003cstd::mutex\u003e lock(mtx); if (!q.empty()) { data = q.front(); q.pop_front(); std::cout\u003c\u003c\"Get value from que task3:\"\u003c\u003cdata\u003c\u003cstd::endl; } } } int main() { std::thread t1(task1); std::thread t2(task2); std::thread t3(task3); t1.join(); t2.join(); t3.join(); return 0; } 以上代码，由于直接的while(1)循环会导致cpu资源占用的非常厉害，我们可以通过延时sleep_for来进行优化，但这个延时的时间我们并不好控制！ 我们这个生产者、消费者线程，想要实现的愿景就是，当生成者生产出资源后，我们能够及时的唤醒消费者线程，让其获取资源。 但如果是简单的对生产者和消费者进行加锁来实现这一过程，可能中间会有很多过程是在消费者拿到锁后，发现生产者并没有生产出资源，而这个过程很明显就是一个无用功，那么有没有一种方式能够让生产者生产出资源后，立马通知消费者线程来读取，且在没有资源的时候，消费者线程能够阻塞让出cpu时间片呢？实现这个需求有很多种方法，而条件变量就是其中的一种！ ","date":"2022-03-27","objectID":"/posts/1.3-%E9%94%81%E9%87%8A%E6%94%BE%E7%9A%84%E5%8F%A6%E4%B8%80%E7%A7%8D%E5%A7%BF%E5%8A%BF-%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8Fcondition_variable-%E4%BF%A1%E5%8F%B7%E9%87%8Fsemaphore/:1:1","tags":["1.3-多线程控制的另一种姿势-条件变量(condition_variable), 信号量(semaphore)"],"title":"1.3-多线程控制的另一种姿势-条件变量(condition_variable), 信号量(semaphore)","uri":"/posts/1.3-%E9%94%81%E9%87%8A%E6%94%BE%E7%9A%84%E5%8F%A6%E4%B8%80%E7%A7%8D%E5%A7%BF%E5%8A%BF-%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8Fcondition_variable-%E4%BF%A1%E5%8F%B7%E9%87%8Fsemaphore/"},{"categories":["C++多线程"],"content":"条件变量的用法 从C++11起，标准库开始引入条件变量。 它的成员函数也不复杂，就下面这些： 更多详细描述 void wait (unique_lock\u003cmutex\u003e\u0026 lck); 这是非模板成员函数类型，接收一个unique_lock，调用后，会帮你unlock，并且线程陷入等待状态，直到被调用notify唤醒。 有关notify的成员函数也就这两个：notify_one和notify_all。 顾名思义，随机唤醒一个，和唤醒全部处于等待被唤醒的线程。 我们再利用新学的条件变量改造下前面的代码如下： #include \u003ciostream\u003e#include \u003cmutex\u003e#include \u003cdeque\u003e#include \u003cthread\u003e#include \u003ccondition_variable\u003estd::mutex mtx; std::deque\u003cint\u003e q; std::condition_variable cv; // producer void task1(){ int i = 0; while (1){ std::unique_lock\u003cstd::mutex\u003e lock(mtx); q.push_back(i); cv.notify_one(); if (i \u003c 9999999) { i++; }else { i = 0; } } } // consumer void task2(){ int data = 0; while (1) { std::unique_lock\u003cstd::mutex\u003e lock(mtx); if(q.empty()) { cv.wait(lock); } data = q.front(); q.pop_front(); std::cout\u003c\u003c\"Get value from que task2:\"\u003c\u003cdata\u003c\u003cstd::endl; } } void task3(){ int data = 0; while (1) { std::unique_lock\u003cstd::mutex\u003e lock(mtx); if(q.empty()){ cv.wait(lock); } data = q.front(); q.pop_front(); std::cout\u003c\u003c\"Get value from que task3:\"\u003c\u003cdata\u003c\u003cstd::endl; } } int main() { std::thread t1(task1); std::thread t2(task2); std::thread t3(task3); t1.join(); t2.join(); t3.join(); return 0; } ","date":"2022-03-27","objectID":"/posts/1.3-%E9%94%81%E9%87%8A%E6%94%BE%E7%9A%84%E5%8F%A6%E4%B8%80%E7%A7%8D%E5%A7%BF%E5%8A%BF-%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8Fcondition_variable-%E4%BF%A1%E5%8F%B7%E9%87%8Fsemaphore/:1:2","tags":["1.3-多线程控制的另一种姿势-条件变量(condition_variable), 信号量(semaphore)"],"title":"1.3-多线程控制的另一种姿势-条件变量(condition_variable), 信号量(semaphore)","uri":"/posts/1.3-%E9%94%81%E9%87%8A%E6%94%BE%E7%9A%84%E5%8F%A6%E4%B8%80%E7%A7%8D%E5%A7%BF%E5%8A%BF-%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8Fcondition_variable-%E4%BF%A1%E5%8F%B7%E9%87%8Fsemaphore/"},{"categories":["C++多线程"],"content":"条件变量引发的虚假唤醒 什么是虚假唤醒？ 前面我们写的利用条件变量写的生产者消费者线程，我可以肯定的告诉你，它是有问题的，运行起来肯定是会报错的！ 这是因为虚假唤醒的原因，那么什么是虚假唤醒呢？ 虚假唤醒的意思是，当一个正在等待条件变量的线程由于条件变量被触发而唤醒时，却发现它等待的条件（共享数据）没有满足(也就是没有共享数据)。 简而言之就是：明明当前线程已经被唤醒了，却得不到需要的数据。 虚假唤醒的产生分析： 那么我们来分析一下，上面的代码是如何发生的虚假唤醒，如果出现以下情形：task1刚好生成出一个数据到q中，而此时task2被唤醒，把数据读出后又pop掉，然后进入mutex争夺，进入阻塞或者是得到锁，按理来说，只要notify_one真的只会唤醒一个在等待的线程，那么一个生产者对应多个消费者的情况下，是不会产生虚假唤醒的。后面我多番查找资料，说是在多核处理器的环境下，notify_one可能会唤醒不止一个线程，所以会产生一个虚假唤醒，这就导致明明q是空的，却在被读取！ 如何避免虚假唤醒？ 一个简单粗暴的避免虚假唤醒的法子就是把if语句改为while语句就行，这个产生的直接作用就是，本来唤醒后会因为没有达到预期情况却还往下执行，而while的加入则确保被唤醒的线程一定要是满足预期情况！ 代码如下： #include \u003ciostream\u003e#include \u003cmutex\u003e#include \u003cdeque\u003e#include \u003cthread\u003e#include \u003ccondition_variable\u003estd::mutex mtx; std::deque\u003cint\u003e q; std::condition_variable cv; // producer void task1(){ int i = 0; while (1){ std::unique_lock\u003cstd::mutex\u003e lock(mtx); q.push_back(i); cv.notify_one(); if (i \u003c 9999999) { i++; }else { i = 0; } } } // consumer void task2(){ int data = 0; while (1) { std::unique_lock\u003cstd::mutex\u003e lock(mtx); while (q.empty()) { cv.wait(lock); } data = q.front(); q.pop_front(); std::cout\u003c\u003c\"Get value from que task2:\"\u003c\u003cdata\u003c\u003cstd::endl; } } void task3(){ int data = 0; while (1) { std::unique_lock\u003cstd::mutex\u003e lock(mtx); while (q.empty()){ cv.wait(lock); } data = q.front(); q.pop_front(); std::cout\u003c\u003c\"Get value from que task3:\"\u003c\u003cdata\u003c\u003cstd::endl; } } int main() { std::thread t1(task1); std::thread t2(task2); std::thread t3(task3); t1.join(); t2.join(); t3.join(); return 0; } ","date":"2022-03-27","objectID":"/posts/1.3-%E9%94%81%E9%87%8A%E6%94%BE%E7%9A%84%E5%8F%A6%E4%B8%80%E7%A7%8D%E5%A7%BF%E5%8A%BF-%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8Fcondition_variable-%E4%BF%A1%E5%8F%B7%E9%87%8Fsemaphore/:1:3","tags":["1.3-多线程控制的另一种姿势-条件变量(condition_variable), 信号量(semaphore)"],"title":"1.3-多线程控制的另一种姿势-条件变量(condition_variable), 信号量(semaphore)","uri":"/posts/1.3-%E9%94%81%E9%87%8A%E6%94%BE%E7%9A%84%E5%8F%A6%E4%B8%80%E7%A7%8D%E5%A7%BF%E5%8A%BF-%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8Fcondition_variable-%E4%BF%A1%E5%8F%B7%E9%87%8Fsemaphore/"},{"categories":["C++多线程"],"content":"信号量(C++20) 定义于头文件 \u003csemaphore\u003e 信号量是C++20正式加入标准库的，之前使用信号量都是直接调用Linux或者window的底层API，没有统一的接口。 信号量应该算是操作系统里面的一个概念。 具体而言： 维基百科：信号量（英语：Semaphore）又称为信号量、旗语，是一个同步对象，用于保持在0至指定最大值之间的一个计数值。当线程完成一次对该semaphore对象的等待（wait）时，该计数值减一；当线程完成一次对semaphore对象的释放（release）时，计数值加一。当计数值为0，则线程等待该semaphore对象不能成功直至该semaphore对象变成signaled状态。semaphore对象的计数值大于0，为signaled状态；计数值等于0，为nonsignaled状态. 其中，信号量又分为两种：二进制信号量和计数信号量。 对应到C++20里面的semaphore就是： std::binary_semaphore 和 counting_semaphore ","date":"2022-03-27","objectID":"/posts/1.3-%E9%94%81%E9%87%8A%E6%94%BE%E7%9A%84%E5%8F%A6%E4%B8%80%E7%A7%8D%E5%A7%BF%E5%8A%BF-%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8Fcondition_variable-%E4%BF%A1%E5%8F%B7%E9%87%8Fsemaphore/:2:0","tags":["1.3-多线程控制的另一种姿势-条件变量(condition_variable), 信号量(semaphore)"],"title":"1.3-多线程控制的另一种姿势-条件变量(condition_variable), 信号量(semaphore)","uri":"/posts/1.3-%E9%94%81%E9%87%8A%E6%94%BE%E7%9A%84%E5%8F%A6%E4%B8%80%E7%A7%8D%E5%A7%BF%E5%8A%BF-%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8Fcondition_variable-%E4%BF%A1%E5%8F%B7%E9%87%8Fsemaphore/"},{"categories":["C++多线程"],"content":"std::binary_semaphore使用 其实binary_semaphore就是counting_sesmaphore的一个特化而已。 定义如下： using binary_semaphore = std::counting_semaphore\u003c1\u003e; 讲信号量使用前，我们需要讲讲它的基本运用场景，它一般不使用在存在资源竞争的多线程情况下，比如之前的生产者消费者线程，用信号量是非常不适合的。 比较适合的情况是：某些线程需要在满足某个情况后被通知执行，有点类似于Qt的信号槽机制。 以下有个使用示例： 以下代码已经还有充分的注释了，具体而言就是可以通过release方法让计数器+1，从而使得信号量状态发生改变，由于binary_semaphore只有0和1两个状态，当状态为1的时候，会使得被阻塞的线程激活，而被激活后会立马把状态-1为0，使得其他线程还是被阻塞状态，所以binary的信号量只能通知一个线程执行任务。 以下代码定义了两个信号量，一个是从main线程传递到子线程的信号量，一个是从子线程传递到main线程的信号量。 #include \u003ciostream\u003e#include \u003cthread\u003e#include \u003cchrono\u003e#include \u003csemaphore\u003e // global binary semaphore instances // object counts are set to zero // objects are in non-signaled state std::binary_semaphore smphSignalMainToThread{0}, smphSignalThreadToMain{0}; void ThreadProc() { // wait for a signal from the main proc // by attempting to decrement the semaphore smphSignalMainToThread.acquire(); // this call blocks until the semaphore's count // is increased from the main proc std::cout \u003c\u003c \"[thread] Got the signal\\n\"; // response message // wait for 3 seconds to imitate some work // being done by the thread using namespace std::literals; std::this_thread::sleep_for(3s); std::cout \u003c\u003c \"[thread] Send the signal\\n\"; // message // signal the main proc back smphSignalThreadToMain.release(); } int main() { // create some worker thread std::thread thrWorker(ThreadProc); std::cout \u003c\u003c \"[main] Send the signal\\n\"; // message // signal the worker thread to start working // by increasing the semaphore's count smphSignalMainToThread.release(); // wait until the worker thread is done doing the work // by attempting to decrement the semaphore's count smphSignalThreadToMain.acquire(); std::cout \u003c\u003c \"[main] Got the signal\\n\"; // response message thrWorker.join(); } ","date":"2022-03-27","objectID":"/posts/1.3-%E9%94%81%E9%87%8A%E6%94%BE%E7%9A%84%E5%8F%A6%E4%B8%80%E7%A7%8D%E5%A7%BF%E5%8A%BF-%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8Fcondition_variable-%E4%BF%A1%E5%8F%B7%E9%87%8Fsemaphore/:2:1","tags":["1.3-多线程控制的另一种姿势-条件变量(condition_variable), 信号量(semaphore)"],"title":"1.3-多线程控制的另一种姿势-条件变量(condition_variable), 信号量(semaphore)","uri":"/posts/1.3-%E9%94%81%E9%87%8A%E6%94%BE%E7%9A%84%E5%8F%A6%E4%B8%80%E7%A7%8D%E5%A7%BF%E5%8A%BF-%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8Fcondition_variable-%E4%BF%A1%E5%8F%B7%E9%87%8Fsemaphore/"},{"categories":["C++多线程"],"content":"counting_semaphore使用 原理与binary版本完全一致只是状态不只是0和1，它能够自定义上限的状态，如下代码，我将上限定为了3，那么release调用的时候可以设置最多+3，那么它就能成功唤醒三个线程. #include \u003ciostream\u003e#include \u003cthread\u003e#include \u003cchrono\u003e#include \u003csemaphore\u003e // global binary semaphore instances // object counts are set to zero // objects are in non-signaled state std::counting_semaphore\u003c3\u003e smphSignalMainToThread{0}, smphSignalThreadToMain{0}; void ThreadProc2() { // wait for a signal from the main proc // by attempting to decrement the semaphore smphSignalMainToThread.acquire(); // this call blocks until the semaphore's count // is increased from the main proc std::cout \u003c\u003c \"[thread] Got the signal2\\n\"; // response message // wait for 3 seconds to imitate some work // being done by the thread using namespace std::literals; std::this_thread::sleep_for(3s); std::cout \u003c\u003c \"[thread] Send the signal2\\n\"; // message // signal the main proc back smphSignalThreadToMain.release(); } void ThreadProc1() { // wait for a signal from the main proc // by attempting to decrement the semaphore smphSignalMainToThread.acquire(); // this call blocks until the semaphore's count // is increased from the main proc std::cout \u003c\u003c \"[thread] Got the signal1\\n\"; // response message // wait for 3 seconds to imitate some work // being done by the thread using namespace std::literals; std::this_thread::sleep_for(3s); std::cout \u003c\u003c \"[thread] Send the signal1\\n\"; // message // signal the main proc back smphSignalThreadToMain.release(); } void ThreadProc3() { // wait for a signal from the main proc // by attempting to decrement the semaphore smphSignalMainToThread.acquire(); // this call blocks until the semaphore's count // is increased from the main proc std::cout \u003c\u003c \"[thread] Got the signal3\\n\"; // response message // wait for 3 seconds to imitate some work // being done by the thread using namespace std::literals; std::this_thread::sleep_for(3s); std::cout \u003c\u003c \"[thread] Send the signal3\\n\"; // message // signal the main proc back smphSignalThreadToMain.release(); } int main() { // create some worker thread std::thread thrWorker1(ThreadProc1); std::thread thrWorker2(ThreadProc2); std::cout \u003c\u003c \"[main] Send the signal\\n\"; // message // signal the worker thread to start working // by increasing the semaphore's count smphSignalMainToThread.release(3); // wait until the worker thread is done doing the work // by attempting to decrement the semaphore's count smphSignalThreadToMain.acquire(); std::cout \u003c\u003c \"[main] Got the signal\\n\"; // response message thrWorker1.join(); thrWorker2.join(); } ","date":"2022-03-27","objectID":"/posts/1.3-%E9%94%81%E9%87%8A%E6%94%BE%E7%9A%84%E5%8F%A6%E4%B8%80%E7%A7%8D%E5%A7%BF%E5%8A%BF-%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8Fcondition_variable-%E4%BF%A1%E5%8F%B7%E9%87%8Fsemaphore/:2:2","tags":["1.3-多线程控制的另一种姿势-条件变量(condition_variable), 信号量(semaphore)"],"title":"1.3-多线程控制的另一种姿势-条件变量(condition_variable), 信号量(semaphore)","uri":"/posts/1.3-%E9%94%81%E9%87%8A%E6%94%BE%E7%9A%84%E5%8F%A6%E4%B8%80%E7%A7%8D%E5%A7%BF%E5%8A%BF-%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8Fcondition_variable-%E4%BF%A1%E5%8F%B7%E9%87%8Fsemaphore/"},{"categories":["现代C++语法"],"content":"利用string_view优化C++的string","date":"2022-03-24","objectID":"/posts/%E5%88%A9%E7%94%A8string_view%E4%BC%98%E5%8C%96%E7%8E%B0%E4%BB%A3c++%E8%AF%AD%E6%B3%95/","tags":["利用string_view优化string"],"title":"利用string_view优化string","uri":"/posts/%E5%88%A9%E7%94%A8string_view%E4%BC%98%E5%8C%96%E7%8E%B0%E4%BB%A3c++%E8%AF%AD%E6%B3%95/"},{"categories":["现代C++语法"],"content":"一、背景 在日常C/C++编程中，我们常进行数据的传递操作，比如，将数据传给函数。当数据占用的内存较大时，减少数据的拷贝可以有效提高程序的性能。在C中指针是完成这一目的的标准数据结构，而**C++引入了安全性更高的引用类型。所以在C++中若传递的数据仅仅只读，const string\u0026成了C++**的天然的方式。但这并非完美，从实践来看，它至少有以下几方面问题： 字符串字面值、字符数组、字符串指针的传递仍要数据拷贝 这三类低级数据类型与string类型不同，传入时，编译器需要做隐式转换，即需要拷贝这些数据生成string临时对象。const string\u0026指向的实际上是这个临时对象。通常字符串字面值较小，性能损耗可以忽略不计；但字符串指针和字符数组某些情况下可能会比较大（比如读取文件的内容），此时会引起频繁的内存分配和数据拷贝，会严重影响程序的性能。 substr **O(n)**复杂度 这是一个特别常用的函数，好在std::string提供了这个函数，美中不足的是其每次都返回一个新生成的子串，很容易引起性能热点。实际上我们本意并不是要改变原字符串，为什么不在原字符串基础上返回呢？ 在C++17中引入了string_view，能很好的解决以上两个问题。 ","date":"2022-03-24","objectID":"/posts/%E5%88%A9%E7%94%A8string_view%E4%BC%98%E5%8C%96%E7%8E%B0%E4%BB%A3c++%E8%AF%AD%E6%B3%95/:1:0","tags":["利用string_view优化string"],"title":"利用string_view优化string","uri":"/posts/%E5%88%A9%E7%94%A8string_view%E4%BC%98%E5%8C%96%E7%8E%B0%E4%BB%A3c++%E8%AF%AD%E6%B3%95/"},{"categories":["现代C++语法"],"content":"二、std::string_view 从名字出发，我们可以类比数据库视图，view表示该类型不会为数据分配存储空间，而且该数据类型只能用来读。该数据类型可通过{数据的起始指针，数据的长度}两个元素表示，实际上该数据类型的实例不会具体存储原数据，仅仅存储指向的数据的起始指针和长度，所以这个开销是非常小的。 要使用字符串视图，需要引入\u003cstring_view\u003e，下面介绍该数据类型主要的API。这些API基本上都有constexpr修饰，所以能在编译时很好地处理字符串字面值，从而提高程序效率。 ","date":"2022-03-24","objectID":"/posts/%E5%88%A9%E7%94%A8string_view%E4%BC%98%E5%8C%96%E7%8E%B0%E4%BB%A3c++%E8%AF%AD%E6%B3%95/:2:0","tags":["利用string_view优化string"],"title":"利用string_view优化string","uri":"/posts/%E5%88%A9%E7%94%A8string_view%E4%BC%98%E5%8C%96%E7%8E%B0%E4%BB%A3c++%E8%AF%AD%E6%B3%95/"},{"categories":["现代C++语法"],"content":"2.1 构造函数 constexpr string_view() noexcept; constexpr string_view(const string_view\u0026 other) noexcept = default; constexpr string_view(const CharT* s, size_type count); constexpr string_view(const CharT* s); 唯一需要说明的是：为什么我们代码string_view foo(string(\"abc\"))可以编译通过，但为什么没有对应的构造函数？ 实际上这是因为string类重载了string到string_view的转换操作符： operator std::basic_string_view\u003cCharT, Traits\u003e() const noexcept; ","date":"2022-03-24","objectID":"/posts/%E5%88%A9%E7%94%A8string_view%E4%BC%98%E5%8C%96%E7%8E%B0%E4%BB%A3c++%E8%AF%AD%E6%B3%95/:2:1","tags":["利用string_view优化string"],"title":"利用string_view优化string","uri":"/posts/%E5%88%A9%E7%94%A8string_view%E4%BC%98%E5%8C%96%E7%8E%B0%E4%BB%A3c++%E8%AF%AD%E6%B3%95/"},{"categories":["现代C++语法"],"content":"2.2 自定义字面量 自定义字面量也是C++17新增的特性，提高了常量的易读。 下面的代码取值cppreference，能很好地说明自定义字面值和字符串语义的差异。 #include \u003cstring_view\u003e#include \u003ciostream\u003e int main() { using namespace std::literals; std::string_view s1 = \"abc\\0\\0def\"; std::string_view s2 = \"abc\\0\\0def\"sv; std::cout \u003c\u003c \"s1: \" \u003c\u003c s1.size() \u003c\u003c \" \\\"\" \u003c\u003c s1 \u003c\u003c \"\\\"\\n\"; std::cout \u003c\u003c \"s2: \" \u003c\u003c s2.size() \u003c\u003c \" \\\"\" \u003c\u003c s2 \u003c\u003c \"\\\"\\n\"; } 输出： s1: 3 \"abc\" s2: 8 \"abc^@^@def\" 以上例子能很好看清二者的语义区别，\\0对于字符串而言，有其特殊的意义，即表示字符串的结束，字符串视图根本不care，它关心实际的字符个数。 ","date":"2022-03-24","objectID":"/posts/%E5%88%A9%E7%94%A8string_view%E4%BC%98%E5%8C%96%E7%8E%B0%E4%BB%A3c++%E8%AF%AD%E6%B3%95/:2:2","tags":["利用string_view优化string"],"title":"利用string_view优化string","uri":"/posts/%E5%88%A9%E7%94%A8string_view%E4%BC%98%E5%8C%96%E7%8E%B0%E4%BB%A3c++%E8%AF%AD%E6%B3%95/"},{"categories":["现代C++语法"],"content":"2.3 成员函数 下面列举其成员函数：忽略了函数的返回值，若函数有重载，括号内用...填充。这样可以对其有个整体轮廓。 // 迭代器 begin() end() cbegin() cend() rbegin() rend() crbegin() crend() // 容量 size() length() max_size() empty() // 元素访问 operator[](size_type pos) at(size_type pos) front() back() data() // 修改器 remove_prefix(size_type n) remove_suffix(size_type n) swap(basic_string_view\u0026 s) copy(charT* s, size_type n, size_type pos = 0) string_view substr(size_type pos = 0, size_type n = npos) compare(...) starts_with(...) ends_with(...) find(...) rfind(...) find_first_of(...) find_last_of(...) find_first_not_of(...) find_last_not_of(...) 从函数列表来看，几乎跟string的只读函数一致，使用string_view的方式跟string基本一致。有几个地方需要特别说明： string_view的substr函数的时间复杂度是O(1)，解决了背景部分的第二个问题。 修改器中的三个函数仅会修改string_view的数据指向，不会修改指向的数据。 除此之外，函数名基本是自解释的。 ","date":"2022-03-24","objectID":"/posts/%E5%88%A9%E7%94%A8string_view%E4%BC%98%E5%8C%96%E7%8E%B0%E4%BB%A3c++%E8%AF%AD%E6%B3%95/:2:3","tags":["利用string_view优化string"],"title":"利用string_view优化string","uri":"/posts/%E5%88%A9%E7%94%A8string_view%E4%BC%98%E5%8C%96%E7%8E%B0%E4%BB%A3c++%E8%AF%AD%E6%B3%95/"},{"categories":["现代C++语法"],"content":"2.4 示例 Haskell中有一个常用函数lines，会将字符串切割成行存储在容器里。下面我们用**C++**来实现 string-版本 #include \u003cstring\u003e#include \u003ciostream\u003e#include \u003cvector\u003e#include \u003calgorithm\u003e#include \u003csstream\u003e void lines(std::vector\u003cstd::string\u003e \u0026lines, const std::string \u0026str) { auto sep{\"\\n\"}; size_t start{str.find_first_not_of(sep)}; size_t end{}; while (start != std::string::npos) { end = str.find_first_of(sep, start + 1); if (end == std::string::npos) end = str.length(); lines.push_back(str.substr(start, end - start)); start = str.find_first_not_of(sep, end + 1); } } 上面我们用const std::string \u0026类型接收待分割的字符串，若我们传入指向较大内存的字符指针时，会影响程序效率。 使用std::string_view可以避免这种情况： string_view-版本 #include \u003cstring\u003e#include \u003ciostream\u003e#include \u003cvector\u003e#include \u003calgorithm\u003e#include \u003csstream\u003e#include \u003cstring_view\u003e void lines(std::vector\u003cstd::string\u003e \u0026lines, std::string_view str) { auto sep{\"\\n\"}; size_t start{str.find_first_not_of(sep)}; size_t end{}; while (start != std::string_view::npos) { end = str.find_first_of(sep, start + 1); if (end == std::string_view::npos) end = str.length(); lines.push_back(std::string{str.substr(start, end - start)}); start = str.find_first_not_of(sep, end + 1); } } 上面的例子仅仅是把string类型修改成了string_view就获得了性能上的提升。一般情况下，将程序中的string换成string_view的过程是比较直观的，这得益于两者的成员函数的相似性。但并不是所有的“翻译”过程都是这样的，比如： void lines(std::vector\u003cstd::string\u003e \u0026lines, const std::string\u0026 str) { std::stringstream ss(str); std::string line; while (std::getline(ss, line, '\\n')) { lines.push_back(line); } } 这个版本使用stringstream实现lines函数。由于stringstream没有相应的构造函数接收string_view类型参数，所以没法采用直接替换的方式，所以翻译过程要复杂点。 ","date":"2022-03-24","objectID":"/posts/%E5%88%A9%E7%94%A8string_view%E4%BC%98%E5%8C%96%E7%8E%B0%E4%BB%A3c++%E8%AF%AD%E6%B3%95/:2:4","tags":["利用string_view优化string"],"title":"利用string_view优化string","uri":"/posts/%E5%88%A9%E7%94%A8string_view%E4%BC%98%E5%8C%96%E7%8E%B0%E4%BB%A3c++%E8%AF%AD%E6%B3%95/"},{"categories":["现代C++语法"],"content":"三、使用陷阱 世上没有免费的午餐。不恰当的使用string_view也会带来一系列的问题。 string_view范围内的字符可能不包含\\0 如： #include \u003ciostream\u003e#include \u003cstring_view\u003e int main() { std::string_view str{\"abc\", 1}; std::cout \u003c\u003c str.data() \u003c\u003c std::endl; return 0; } 本来是要打印a，但输出了abc。这是因为字符串相关的函数都有一条兼容C的约定：\\0代表字符串的结尾。上面的程序打印从开始到字符串结束的所有字符，虽然str包含的有效字符是a，但cout认\\0。好在这块内存空间有合法的字符串结尾符，如果str指向的是一个没有\\0的字符数组，程序很有可能会出现内存问题，所以我们在将string_view类型的数据传入接收字符串的函数时要非常小心。 从[const] char*构造string_view对象时间复杂度O(n) 这是因为获取字符串的长度需要从头开始遍历。如果对[const] char*类型仅仅是一些O(1)的操作，相比直接使用[const] char*，转为string_view是没有性能优势的。只不过是相比const string\u0026，string_view少了拷贝的损耗。实际上我们完全可以用[const] char*接收所有的字符串，但这个类型太底层了，不便使用。在某些情况下，我们转为string_view可能仅仅是想用其中的一些函数，比如substr。 string_view指向的内容的生命周期可能比其本身短 string_view并不拥有其指向内容的所有权，用Rust的术语来说，它仅仅是暂时borrow（借用）了它。如果拥有者提前释放了，你还在使用这些内容，那会出现内存问题，这跟悬挂指针(dangling pointer)或悬挂引用（dangling references）很像。Rust专门有套机制在编译时分析变量的生命期，保证borrow的资源在使用期间不会被释放，但C++没有这样的检查，需要人工保证。下面列出一些典型的问题情况： std::string_view sv = std::string{\"hello world\"}; string_view foo() { std::string s{\"hello world\"}; return string_view{s}; } auto id(std::string_view sv) { return sv; } int main() { std::string s = \"hello\"; auto sv = id(s + \" world\"); } ","date":"2022-03-24","objectID":"/posts/%E5%88%A9%E7%94%A8string_view%E4%BC%98%E5%8C%96%E7%8E%B0%E4%BB%A3c++%E8%AF%AD%E6%B3%95/:3:0","tags":["利用string_view优化string"],"title":"利用string_view优化string","uri":"/posts/%E5%88%A9%E7%94%A8string_view%E4%BC%98%E5%8C%96%E7%8E%B0%E4%BB%A3c++%E8%AF%AD%E6%B3%95/"},{"categories":["现代C++语法"],"content":"四、测试具体性能 光说不用假把式，直接就地写个测试： #include \u003cstring\u003e#include \u003cstring_view\u003e#include \"../BenchMark/Timer.h\"#include \u003cvector\u003eusing std::vector; using std::string; using std::string_view; //TODO string_view 和 string const\u0026对比。 // 发现string_view在substr()方法和vector的push_back过程中有巨大优势！ std::vector\u003cstring\u003e testStringView(string_view s){ s.substr(0); vector\u003cstring \u003eret; ret.emplace_back(s); return ret; } std::vector\u003cstring\u003e testString(string const\u0026s){ s.substr(0); vector\u003cstring \u003eret; ret.emplace_back(s); return ret; } int main() { //TEST string const\u0026 { Timer t; for (int i = 0; i \u003c 1000000; ++i) { testString(string (100,'0')); } } //TEST string_view { Timer t; for (int i = 0; i \u003c 1000000; ++i) { testStringView(string(100,'0')); } } return 0; } 性能差距： 除了以上代码，我还经过多次测试，发现在用到substr成员函数以及进行各种拷贝的时候，string_view会比string const\u0026快很多。其余情况差不太多。 ","date":"2022-03-24","objectID":"/posts/%E5%88%A9%E7%94%A8string_view%E4%BC%98%E5%8C%96%E7%8E%B0%E4%BB%A3c++%E8%AF%AD%E6%B3%95/:4:0","tags":["利用string_view优化string"],"title":"利用string_view优化string","uri":"/posts/%E5%88%A9%E7%94%A8string_view%E4%BC%98%E5%8C%96%E7%8E%B0%E4%BB%A3c++%E8%AF%AD%E6%B3%95/"},{"categories":["现代C++语法"],"content":"五、总结 string_view解决了一些痛点，但同时也引入了指针和引用的一些老问题。C++标准并没有对这个类型做太多的约束，这引来的问题是我们可以像平常的变量一样以多种方式使用它，如，可以传参，可以作为函数返回值，可以做普通变量，甚至我们可以放到容器里。随着使用场景的复杂，人工是很难保证指向的内容的生命周期足够长。所以，推荐的使用方式：仅仅作为函数参数，因为如果该参数仅仅在函数体内使用而不传递出去，这样使用是安全的。 ","date":"2022-03-24","objectID":"/posts/%E5%88%A9%E7%94%A8string_view%E4%BC%98%E5%8C%96%E7%8E%B0%E4%BB%A3c++%E8%AF%AD%E6%B3%95/:5:0","tags":["利用string_view优化string"],"title":"利用string_view优化string","uri":"/posts/%E5%88%A9%E7%94%A8string_view%E4%BC%98%E5%8C%96%E7%8E%B0%E4%BB%A3c++%E8%AF%AD%E6%B3%95/"},{"categories":["手写数据结构"],"content":"通过阅读Redis源码简单实现跳表","date":"2022-03-19","objectID":"/posts/%E9%98%85%E8%AF%BBredis%E6%BA%90%E7%A0%81%E5%AE%9E%E7%8E%B0%E8%B7%B3%E8%A1%A8/","tags":["通过阅读Redis源码简单实现跳表"],"title":"通过阅读Redis源码简单实现跳表","uri":"/posts/%E9%98%85%E8%AF%BBredis%E6%BA%90%E7%A0%81%E5%AE%9E%E7%8E%B0%E8%B7%B3%E8%A1%A8/"},{"categories":["手写数据结构"],"content":"什么是跳表？ 想要弄清这个，可以查看一篇大佬的文章，把跳表分析的非常透彻，并且剖析了Redis源码，我这里只讲解不带span的Redis源码C++复现。（后续会有带span的完美Redis源码C++复刻） 大佬的讲解 如果想查看Redis源码的各位，可以点进这个链接https://github1s.com/redis/redis/blob/unstable/src/t_zset.c ","date":"2022-03-19","objectID":"/posts/%E9%98%85%E8%AF%BBredis%E6%BA%90%E7%A0%81%E5%AE%9E%E7%8E%B0%E8%B7%B3%E8%A1%A8/:1:0","tags":["通过阅读Redis源码简单实现跳表"],"title":"通过阅读Redis源码简单实现跳表","uri":"/posts/%E9%98%85%E8%AF%BBredis%E6%BA%90%E7%A0%81%E5%AE%9E%E7%8E%B0%E8%B7%B3%E8%A1%A8/"},{"categories":["手写数据结构"],"content":"正式实现 ","date":"2022-03-19","objectID":"/posts/%E9%98%85%E8%AF%BBredis%E6%BA%90%E7%A0%81%E5%AE%9E%E7%8E%B0%E8%B7%B3%E8%A1%A8/:2:0","tags":["通过阅读Redis源码简单实现跳表"],"title":"通过阅读Redis源码简单实现跳表","uri":"/posts/%E9%98%85%E8%AF%BBredis%E6%BA%90%E7%A0%81%E5%AE%9E%E7%8E%B0%E8%B7%B3%E8%A1%A8/"},{"categories":["手写数据结构"],"content":"跳表的创建 Redis实现 跳表结构：sds类型是Redis内部实现的字符串 创建函数，这时前面定义的level[]类型的优势就体现出来了，在C中这个类型算是未完成的类型，所以需要根据你给它分配的内存来进行具体的使用，没有分配内存前，你可以sizeof(zskiplistNode);试一试，你会发现level不计内存！ 销毁函数 cpp实现 struct SkiplistNode { // string ele; 此题不需要维护元素字段，所以舍去 double score; SkiplistNode *backward; struct SkiplistLevel { struct SkiplistNode *forward; // unsigned long span;此题不需要维护跨度，所以省去 }* level; //TODO 构造和析构 SkiplistNode(int level,double score):level(new SkiplistLevel[level]) ,score(score),backward(nullptr){} ~SkiplistNode(){ delete[] level; } }; class Skiplist { struct SkiplistNode *header, *tail; unsigned long length; //当前跳表中的元素个数 int level; //当前跳表中最大表的高度 public: /** * 构造函数和析构函数 */ Skiplist():level(1),length(0),tail(nullptr){ header = new SkiplistNode(Skiplist_MAXLEVEL,0); for (int j = 0; j \u003c Skiplist_MAXLEVEL; j++) { header-\u003elevel[j].forward = nullptr; } header-\u003ebackward = nullptr; } ~Skiplist(){ SkiplistNode* node = header, *next; while(node) { next = node-\u003elevel[0].forward; delete node; node = next; } } }; ","date":"2022-03-19","objectID":"/posts/%E9%98%85%E8%AF%BBredis%E6%BA%90%E7%A0%81%E5%AE%9E%E7%8E%B0%E8%B7%B3%E8%A1%A8/:2:1","tags":["通过阅读Redis源码简单实现跳表"],"title":"通过阅读Redis源码简单实现跳表","uri":"/posts/%E9%98%85%E8%AF%BBredis%E6%BA%90%E7%A0%81%E5%AE%9E%E7%8E%B0%E8%B7%B3%E8%A1%A8/"},{"categories":["手写数据结构"],"content":"Insert插入元素 Redis实现 cpp实现 带span和ele的1:1还原 SkiplistNode* Skiplist::Insert(double score,const string\u0026 ele){ SkiplistNode *update[Skiplist_MAXLEVEL], *x; unsigned int rank[Skiplist_MAXLEVEL]; int i,level; //TODO part1：找到需要插入位置的前一个跳表节点，顺便更新update数组（存储着经过路径中的每个层级最多走到了哪个节点(用于连接新节点的每个层级的forward和更新span)）和rank数组（存储着路径中经过的层级节点到header的长度） x = header; for (i = this-\u003elevel-1; i \u003e= 0; i--) { rank[i] = i == (this-\u003elevel-1) ? 0 : rank[i+1]; cout\u003c\u003crank[i]\u003c\u003cendl; while (x-\u003elevel[i].forward \u0026\u0026 (x-\u003elevel[i].forward-\u003escore \u003c score || (x-\u003elevel[i].forward-\u003escore == score \u0026\u0026 x-\u003elevel[i].forward-\u003eele\u003cele))) { rank[i] += x-\u003elevel[i].span; x = x-\u003elevel[i].forward; } update[i] = x; } //TODO 生成节点内存，如果随机生成的节点拥有的层级比当前最高的节点还高，则需要把update数组和rank数组中高于当前level的部分看作是前一个节点是header来更新 level = RandomLevel(); if (level \u003e this-\u003elevel) { for (i = this-\u003elevel; i \u003c level; i++) { rank[i] = 0; update[i] = this-\u003eheader; update[i]-\u003elevel[i].span = this-\u003elength; } this-\u003elevel = level; } x = new SkiplistNode(level,score,ele); //TODO 连接操作，连接的同时把上一个节点的span给转移给我，如果该层级的上一个节点就紧挨着那么可直接转移，否则根据update[i]-\u003elevel[i].span - (rank[0] - rank[i]);来更新，实际上也包含了前一种情况 for (i = 0; i \u003c level; i++) { x-\u003elevel[i].forward = update[i]-\u003elevel[i].forward; update[i]-\u003elevel[i].forward = x; /* update span covered by update[i] as x is inserted here */ x-\u003elevel[i].span = update[i]-\u003elevel[i].span - (rank[0] - rank[i]); update[i]-\u003elevel[i].span = (rank[0] - rank[i]) + 1; } //TODO 最后的善后操作，1.前面高于它的节点，会因为它的产生而使得它们的span+1. 2.更新backward指针，如果不是队尾则需要更新后面的backward，如果插入的是队尾，则更新tail指针 3.更新length /** * 更新插入的节点未能到达的元素的span+1 */ for (i = level; i \u003c this-\u003elevel; i++) { update[i]-\u003elevel[i].span++; } /** * 更新backward，以及判断插入元素是否是队尾，如果是，则更新tail指针 */ x-\u003ebackward = (update[0] == this-\u003eheader) ? nullptr : update[0]; if (x-\u003elevel[0].forward) x-\u003elevel[0].forward-\u003ebackward = x; else this-\u003etail = x; this-\u003elength++; return x; } 不带span和ele SkiplistNode* Skiplist::Insert(double score){ SkiplistNode *update[Skiplist_MAXLEVEL], *x; int i,level; //TODO part1：找到需要插入位置的前一个跳表节点，顺便更新update数组(存储着经过路径中的每个层级最多走到了哪个节点(用于连接新节点的每个层级的forward)) x = this-\u003eheader; for (i = this-\u003elevel-1; i \u003e= 0; i--) { while (x-\u003elevel[i].forward\u0026\u0026 x-\u003elevel[i].forward-\u003escore \u003c score) { x = x-\u003elevel[i].forward; } update[i] = x; } //TODO 生成节点内存，如果随机生成的节点拥有的层级比当前最高的节点还高，则需要把update数组中高于当前level的部分看作是前一个节点是header来更新 level = RandomLevel(); if (level \u003e this-\u003elevel) { for (i = this-\u003elevel; i \u003c level; i++) { update[i] = this-\u003eheader; } this-\u003elevel = level; } x = new SkiplistNode(level,score); //TODO 连接操作 for (i = 0; i \u003c level; i++) { x-\u003elevel[i].forward = update[i]-\u003elevel[i].forward; update[i]-\u003elevel[i].forward = x; } /** * 更新backward，以及判断插入元素是否是队尾，如果是，则更新tail指针 */ x-\u003ebackward = (update[0] == this-\u003eheader) ? nullptr : update[0]; if (x-\u003elevel[0].forward) x-\u003elevel[0].forward-\u003ebackward = x; else this-\u003etail = x; this-\u003elength++; return x; } ","date":"2022-03-19","objectID":"/posts/%E9%98%85%E8%AF%BBredis%E6%BA%90%E7%A0%81%E5%AE%9E%E7%8E%B0%E8%B7%B3%E8%A1%A8/:2:2","tags":["通过阅读Redis源码简单实现跳表"],"title":"通过阅读Redis源码简单实现跳表","uri":"/posts/%E9%98%85%E8%AF%BBredis%E6%BA%90%E7%A0%81%E5%AE%9E%E7%8E%B0%E8%B7%B3%E8%A1%A8/"},{"categories":["手写数据结构"],"content":"Delete删除元素 Redis实现 delete的helper函数 正式delete cpp实现 1:1还原实现 /** * 该函数处理传入的update数组，并更新删除x节点后的指针连接和span值 * @param zsl 需要处理的跳表 * @param x 需要删除的节点 * @param update 需要处理的的update数组 */ static void Skiplist::DeleteNode(Skiplist *zsl, SkiplistNode *x, SkiplistNode **update) { int i; for (i = 0; i \u003c zsl-\u003elevel; i++) { if (update[i]-\u003elevel[i].forward == x) {//TODO 如果该层级的节点的后一个节点就是x节点，那么删除x节点后span会增加，forward要更新 update[i]-\u003elevel[i].span += x-\u003elevel[i].span - 1; update[i]-\u003elevel[i].forward = x-\u003elevel[i].forward; } else {//TODO 如果后一个节点不是x节点，那么就仅仅只是跨度上减少1而已 update[i]-\u003elevel[i].span -= 1; } } //TODO 和之前的插入处理相同，如果删除的节点是末尾节点，则需要更新tail指针，如果不是，则需要更新backward指针 if (x-\u003elevel[0].forward) { x-\u003elevel[0].forward-\u003ebackward = x-\u003ebackward; } else { zsl-\u003etail = x-\u003ebackward; } while(zsl-\u003elevel \u003e 1 \u0026\u0026 zsl-\u003eheader-\u003elevel[zsl-\u003elevel-1].forward == NULL) zsl-\u003elevel--; zsl-\u003elength--; } /** * 根据score和ele删除节点 * @param score 传入的分值标识 * @param ele 传入的元素字符串标识 * @param node 用于选择是否要传出node，而不是就地删除 * @return 0表示节点未找到，1表示删除处理成功 */ int Skiplist::Delete( double score, string ele, SkiplistNode **node = nullptr) { SkiplistNode *update[Skiplist_MAXLEVEL], *x; int i; x = this-\u003eheader; for (i = this-\u003elevel-1; i \u003e= 0; i--) { while (x-\u003elevel[i].forward \u0026\u0026 (x-\u003elevel[i].forward-\u003escore \u003c score || (x-\u003elevel[i].forward-\u003escore == score \u0026\u0026 x-\u003elevel[i].forward-\u003eele\u003cele))) { x = x-\u003elevel[i].forward; } update[i] = x; } /** * 我们可能有多个相同分数的元素，我们需要找到同时具有正确分数和对象的元素。 */ x = x-\u003elevel[0].forward; if (x \u0026\u0026 score == x-\u003escore \u0026\u0026 x-\u003eele==ele) { DeleteNode(this, x, update);//TODO 处理update数组上的指针连接 if (!node)//TODO 如果外界不需要接住node来进行处理，则该node就地销毁，否则资源传出到外界 delete x; else *node = x; return 1; } return 0; /* not found */ } 仅包含score的还原 /** * 删除节点后的处理过程 * @param zsl 需要处理的跳表 * @param x 需要删除的节点 * @param update 需要处理的update数组 */ static void Skiplist::DeleteHelper(Skiplist *zsl, SkiplistNode *x, SkiplistNode **update) { assert(zsl!= nullptr\u0026\u0026x!= nullptr\u0026\u0026update!= nullptr); int i; for (i = 0; i \u003c zsl-\u003elevel; i++) { if (update[i]-\u003elevel[i].forward == x) { update[i]-\u003elevel[i].forward = x-\u003elevel[i].forward; } } //TODO 和之前的插入处理相同，如果删除的节点是末尾节点，则需要更新tail指针，如果不是，则更新backward指针 if (x-\u003elevel[0].forward) { x-\u003elevel[0].forward-\u003ebackward = x-\u003ebackward; } else { zsl-\u003etail = x-\u003ebackward; } //TODO 删除的节点可能是最高的高度，由于可能存在多个相同的高度，所以我们不能直接判断 // 可从头节点的forward指针是否为空来确认高度是否需要下降 while(zsl-\u003elevel \u003e 1 \u0026\u0026 zsl-\u003eheader-\u003elevel[zsl-\u003elevel-1].forward == nullptr) zsl-\u003elevel--; zsl-\u003elength--; } /** * 根据score和ele删除节点 * @param score 传入的分值标识 * @param node 用于选择是否要传出node，而不是就地删除 * @return 0表示节点未找到，1表示删除处理成功 */ int Skiplist::Delete( double score,SkiplistNode **node = nullptr) { SkiplistNode *update[Skiplist_MAXLEVEL], *x; int i; /** * 查找并更新update数组 */ x = this-\u003eheader; for (i = this-\u003elevel-1; i \u003e= 0; i--) { while (x-\u003elevel[i].forward \u0026\u0026 (x-\u003elevel[i].forward-\u003escore \u003c score)) { x = x-\u003elevel[i].forward; } update[i] = x; } x = x-\u003elevel[0].forward; if (x \u0026\u0026 score == x-\u003escore) { DeleteHelper(this, x, update);//TODO 处理update数组上的指针连接 if (!node)//TODO 如果外界不需要接住node来进行处理，则该node就地销毁，否则资源传出到外界 delete x; else *node = x; return 1; } return 0; /* not found */ } ","date":"2022-03-19","objectID":"/posts/%E9%98%85%E8%AF%BBredis%E6%BA%90%E7%A0%81%E5%AE%9E%E7%8E%B0%E8%B7%B3%E8%A1%A8/:2:3","tags":["通过阅读Redis源码简单实现跳表"],"title":"通过阅读Redis源码简单实现跳表","uri":"/posts/%E9%98%85%E8%AF%BBredis%E6%BA%90%E7%A0%81%E5%AE%9E%E7%8E%B0%E8%B7%B3%E8%A1%A8/"},{"categories":["手写数据结构"],"content":"正式解题 题目链接 前面的增删弄懂了，这个跳表的各种查找也就不在话下了，现在可以正式解题了。 效率还是比较nice的！ 解题源码： #define Skiplist_MAXLEVEL 32 /* Should be enough for 2^64 elements */#define Skiplist_P 0.25 /* Skiplist P = 1/4 */ struct SkiplistNode { // string ele; 此题不需要维护元素字段，所以舍去 double score; SkiplistNode *backward; struct SkiplistLevel { struct SkiplistNode *forward; // unsigned long span;此题不需要维护跨度，所以省去 }* level; SkiplistNode(int level,double score):level(new SkiplistLevel[level]) ,score(score),backward(nullptr){} ~SkiplistNode(){ delete[] level; } }; class Skiplist { public: struct SkiplistNode *header, *tail; unsigned long length; //当前跳表中的元素个数 int level; //当前跳表中最大表的高度 private: /** * * @return 返回随机产生的level高度 */ static int RandomLevel() {//TODO 根据rand()和掩码相与得到对应的随机值(0,0xffff)来产生level int level = 1; while ((rand()\u00260xFFFF) \u003c (Skiplist_P * 0xFFFF)) level += 1; return (level\u003cSkiplist_MAXLEVEL) ? level : Skiplist_MAXLEVEL; } /** * 删除节点后的处理过程 * @param zsl 需要处理的跳表 * @param x 需要删除的节点 * @param update 需要处理的update数组 */ static void DeleteHelper(Skiplist *zsl, SkiplistNode *x, SkiplistNode **update) { assert(zsl!= nullptr\u0026\u0026x!= nullptr\u0026\u0026update!= nullptr); int i; for (i = 0; i \u003c zsl-\u003elevel; i++) { if (update[i]-\u003elevel[i].forward == x) { update[i]-\u003elevel[i].forward = x-\u003elevel[i].forward; } } //TODO 和之前的插入处理相同，如果删除的节点是末尾节点，则需要更新tail指针，如果不是，则更新backward指针 if (x-\u003elevel[0].forward) { x-\u003elevel[0].forward-\u003ebackward = x-\u003ebackward; } else { zsl-\u003etail = x-\u003ebackward; } //TODO 删除的节点可能是最高的高度，由于可能存在多个相同的高度，所以我们不能直接判断 // 可从头节点的forward指针是否为空来确认高度是否需要下降 while(zsl-\u003elevel \u003e 1 \u0026\u0026 zsl-\u003eheader-\u003elevel[zsl-\u003elevel-1].forward == nullptr) zsl-\u003elevel--; zsl-\u003elength--; } public: /** * 构造函数和析构函数 */ Skiplist():level(1),length(0),tail(nullptr){ header = new SkiplistNode(Skiplist_MAXLEVEL,0); for (int j = 0; j \u003c Skiplist_MAXLEVEL; j++) { header-\u003elevel[j].forward = nullptr; } header-\u003ebackward = nullptr; } ~Skiplist(){ SkiplistNode* node = header, *next; while(node) { next = node-\u003elevel[0].forward; delete node; node = next; } } /** * 插入元素 * @param score 用于定位的score * @param ele 存储的元素 * @return 被插入元素的指针 */ SkiplistNode* Insert(double score){ SkiplistNode *update[Skiplist_MAXLEVEL], *x; int i,level; //TODO part1：找到需要插入位置的前一个跳表节点，顺便更新update数组(存储着经过路径中的每个层级最多走到了哪个节点(用于连接新节点的每个层级的forward)) x = header; for (i = this-\u003elevel-1; i \u003e= 0; i--) { while (x-\u003elevel[i].forward\u0026\u0026 x-\u003elevel[i].forward-\u003escore \u003c score) { x = x-\u003elevel[i].forward; } update[i] = x; } //TODO 生成节点内存，如果随机生成的节点拥有的层级比当前最高的节点还高，则需要把update数组中高于当前level的部分看作是前一个节点是header来更新 level = RandomLevel(); if (level \u003e this-\u003elevel) { for (i = this-\u003elevel; i \u003c level; i++) { update[i] = this-\u003eheader; } this-\u003elevel = level; } x = new SkiplistNode(level,score); //TODO 连接操作 for (i = 0; i \u003c level; i++) { x-\u003elevel[i].forward = update[i]-\u003elevel[i].forward; update[i]-\u003elevel[i].forward = x; } /** * 更新backward，以及判断插入元素是否是队尾，如果是，则更新tail指针 */ x-\u003ebackward = (update[0] == this-\u003eheader) ? nullptr : update[0]; if (x-\u003elevel[0].forward) x-\u003elevel[0].forward-\u003ebackward = x; else this-\u003etail = x; this-\u003elength++; return x; } /** * 根据score和ele删除节点 * @param score 传入的分值标识 * @param node 用于选择是否要传出node，而不是就地删除 * @return 0表示节点未找到，1表示删除处理成功 */ int Delete( double score,SkiplistNode **node = nullptr) { SkiplistNode *update[Skiplist_MAXLEVEL], *x; int i; /** * 查找并更新update数组 */ x = this-\u003eheader; for (i = this-\u003elevel-1; i \u003e= 0; i--) { while (x-\u003elevel[i].forward \u0026\u0026 (x-\u003elevel[i].forward-\u003escore \u003c score)) { x = x-\u003elevel[i].forward; } update[i] = x; } x = x-\u003elevel[0].forward; if (x \u0026\u0026 score == x-\u003escore) { DeleteHelper(this, x, update);//TODO 处理update数组上的指针连接 if (!node)//TODO 如果外界不需要接住node来进行处理，则该node就地销毁，否则资源传出到外界 delete x; else *node = x; return 1; } return 0; /* not found */ } //本题的函数接口 bool search(int target) const { double score = target; SkiplistNode* x; int i; x = this-\u003eheader; for (i = this-\u003elevel-1; i \u003e= 0; i--) { while (x-\u003elevel[i].forward \u0026\u0026 (x-\u003elevel[i].forward-\u003escore \u003c score)) { x = x-\u003elevel[i].forward; } } auto val = x-\u003elevel[0].forward; if(val) return val-\u003escore==score; return false; } void add(int num) { In","date":"2022-03-19","objectID":"/posts/%E9%98%85%E8%AF%BBredis%E6%BA%90%E7%A0%81%E5%AE%9E%E7%8E%B0%E8%B7%B3%E8%A1%A8/:3:0","tags":["通过阅读Redis源码简单实现跳表"],"title":"通过阅读Redis源码简单实现跳表","uri":"/posts/%E9%98%85%E8%AF%BBredis%E6%BA%90%E7%A0%81%E5%AE%9E%E7%8E%B0%E8%B7%B3%E8%A1%A8/"},{"categories":["C++底层原理"],"content":"宏和模板的对比——预编译和编译的较量","date":"2022-03-05","objectID":"/posts/%E5%AE%8F%E5%92%8C%E6%A8%A1%E6%9D%BF%E7%9A%84%E5%AF%B9%E6%AF%94%E9%A2%84%E7%BC%96%E8%AF%91%E5%92%8C%E7%BC%96%E8%AF%91%E7%9A%84%E8%BE%83%E9%87%8F/","tags":["宏和模板的对比——预编译和编译的较量"],"title":"宏和模板的对比——预编译和编译的较量","uri":"/posts/%E5%AE%8F%E5%92%8C%E6%A8%A1%E6%9D%BF%E7%9A%84%E5%AF%B9%E6%AF%94%E9%A2%84%E7%BC%96%E8%AF%91%E5%92%8C%E7%BC%96%E8%AF%91%E7%9A%84%E8%BE%83%E9%87%8F/"},{"categories":["C++底层原理"],"content":" 本文默认你已经拥有基本的gcc编译选项知识，如果没有，可以看看这篇文章 程序的编译过程gcc版。 ","date":"2022-03-05","objectID":"/posts/%E5%AE%8F%E5%92%8C%E6%A8%A1%E6%9D%BF%E7%9A%84%E5%AF%B9%E6%AF%94%E9%A2%84%E7%BC%96%E8%AF%91%E5%92%8C%E7%BC%96%E8%AF%91%E7%9A%84%E8%BE%83%E9%87%8F/:0:0","tags":["宏和模板的对比——预编译和编译的较量"],"title":"宏和模板的对比——预编译和编译的较量","uri":"/posts/%E5%AE%8F%E5%92%8C%E6%A8%A1%E6%9D%BF%E7%9A%84%E5%AF%B9%E6%AF%94%E9%A2%84%E7%BC%96%E8%AF%91%E5%92%8C%E7%BC%96%E8%AF%91%E7%9A%84%E8%BE%83%E9%87%8F/"},{"categories":["C++底层原理"],"content":"从预编译的角度对比宏定义和模板 ","date":"2022-03-05","objectID":"/posts/%E5%AE%8F%E5%92%8C%E6%A8%A1%E6%9D%BF%E7%9A%84%E5%AF%B9%E6%AF%94%E9%A2%84%E7%BC%96%E8%AF%91%E5%92%8C%E7%BC%96%E8%AF%91%E7%9A%84%E8%BE%83%E9%87%8F/:1:0","tags":["宏和模板的对比——预编译和编译的较量"],"title":"宏和模板的对比——预编译和编译的较量","uri":"/posts/%E5%AE%8F%E5%92%8C%E6%A8%A1%E6%9D%BF%E7%9A%84%E5%AF%B9%E6%AF%94%E9%A2%84%E7%BC%96%E8%AF%91%E5%92%8C%E7%BC%96%E8%AF%91%E7%9A%84%E8%BE%83%E9%87%8F/"},{"categories":["C++底层原理"],"content":"来测测宏定义 大家都知道，宏定义仅仅只作用于文本的替换，在预编译的时候，把用到宏定义的部分替换为真正的文本而已，缺点就是不会做类型检查，只要语法能过编译就行。 我们定义一个宏来求两者之间的最大值，为了防止预编译的代码太过冗长不易看懂，没有用 include 去包含其他函数库的声明。 代码如下： #define MAX_VALUE(_1,_2) ((_1\u003e_2)?_1:_2) int main(){ MAX_VALUE(1,2); } 经过 gcc -E 命令后得到预处理后的代码如下： # 0 \".\\\\test_template.cpp\" # 0 \"\u003cbuilt-in\u003e\" # 0 \"\u003ccommand-line\u003e\" # 1 \".\\\\test_template.cpp\" # 10 \".\\\\test_template.cpp\" int main(){ ((1\u003e2)?1:2); } 观察以上代码，我们发现，确实是直接的文本替换，前面的宏定义代码都不见了，只有，传入的替换文本了。 ","date":"2022-03-05","objectID":"/posts/%E5%AE%8F%E5%92%8C%E6%A8%A1%E6%9D%BF%E7%9A%84%E5%AF%B9%E6%AF%94%E9%A2%84%E7%BC%96%E8%AF%91%E5%92%8C%E7%BC%96%E8%AF%91%E7%9A%84%E8%BE%83%E9%87%8F/:1:1","tags":["宏和模板的对比——预编译和编译的较量"],"title":"宏和模板的对比——预编译和编译的较量","uri":"/posts/%E5%AE%8F%E5%92%8C%E6%A8%A1%E6%9D%BF%E7%9A%84%E5%AF%B9%E6%AF%94%E9%A2%84%E7%BC%96%E8%AF%91%E5%92%8C%E7%BC%96%E8%AF%91%E7%9A%84%E8%BE%83%E9%87%8F/"},{"categories":["C++底层原理"],"content":"宏定义的害处 如果我们把下面这段代码传入到宏定义中： #define MAX_VALUE(_1,_2) ((_1\u003e_2)?_1:_2) int main(){ MAX_VALUE(\"abdcdf\",\"fdf\"); } 很明显，这个代码是可以过编译的，但我们肯定不想直接的如下的方式进行字符串的比较，这样的比较毫无意义，只不过是比较的地址而已。 # 0 \".\\\\test_template.cpp\" # 0 \"\u003cbuilt-in\u003e\" # 0 \"\u003ccommand-line\u003e\" # 1 \".\\\\test_template.cpp\" # 10 \".\\\\test_template.cpp\" int main(){ ((\"abdcdf\"\u003e\"fdf\")?\"abdcdf\":\"fdf\"); } 故宏定义的最大危害，就是没法对类型进行检查！这就导致无法灵活的进行优化和调整一些直接文本替换带来的副作用。 ","date":"2022-03-05","objectID":"/posts/%E5%AE%8F%E5%92%8C%E6%A8%A1%E6%9D%BF%E7%9A%84%E5%AF%B9%E6%AF%94%E9%A2%84%E7%BC%96%E8%AF%91%E5%92%8C%E7%BC%96%E8%AF%91%E7%9A%84%E8%BE%83%E9%87%8F/:1:2","tags":["宏和模板的对比——预编译和编译的较量"],"title":"宏和模板的对比——预编译和编译的较量","uri":"/posts/%E5%AE%8F%E5%92%8C%E6%A8%A1%E6%9D%BF%E7%9A%84%E5%AF%B9%E6%AF%94%E9%A2%84%E7%BC%96%E8%AF%91%E5%92%8C%E7%BC%96%E8%AF%91%E7%9A%84%E8%BE%83%E9%87%8F/"},{"categories":["C++底层原理"],"content":"模板是否会进行预处理操作？ 源代码： template\u003ctypename T\u003e T MAX_VALUE(T _1, T _2){ if(_1\u003c_2) return _2; return _1; } int main(){ MAX_VALUE(\"abdcdf\",\"fdf\"); } 预处理后： # 0 \".\\\\test_template.cpp\" # 0 \"\u003cbuilt-in\u003e\" # 0 \"\u003ccommand-line\u003e\" # 1 \".\\\\test_template.cpp\" template\u003ctypename T\u003e T MAX_VALUE(T _1, T _2){ if(_1\u003c_2) return _2; return _1; } int main(){ MAX_VALUE(\"abdcdf\",\"fdf\"); } 我们发现模板并不会在预处理时被展开，它甚至不会和预处理的调用部分形成任何联系！ 看来模板的展开处理过程是发生在后续的编译过程中，由于本人不清楚如何反汇编和反编译过程，故没有亲身实践。 但从我的日常使用体验和大佬们总结的经验看来，模板也和宏定义的展开类似，就是简单的文本替换，但可以利用编译时期的语法检查和类型判断（type_traits技术），所以能够对不同情况的展开进行不同的处理。 比如上面的代码利用偏特化进行优化： #include \u003ciostream\u003e#include \u003ccstring\u003etemplate\u003ctypename T\u003e int MAX_VALUE(T _1, T _2){ if(_1\u003c_2) return _2; return _1; } using type = const char *; template\u003c\u003e int MAX_VALUE\u003ctype\u003e(type _1, type _2){ std::cout \u003c\u003c \"调用偏特化\"; return strcmp(_1, _2); } int main(){ MAX_VALUE(\"abdcdf\",\"fdf\"); } ","date":"2022-03-05","objectID":"/posts/%E5%AE%8F%E5%92%8C%E6%A8%A1%E6%9D%BF%E7%9A%84%E5%AF%B9%E6%AF%94%E9%A2%84%E7%BC%96%E8%AF%91%E5%92%8C%E7%BC%96%E8%AF%91%E7%9A%84%E8%BE%83%E9%87%8F/:1:3","tags":["宏和模板的对比——预编译和编译的较量"],"title":"宏和模板的对比——预编译和编译的较量","uri":"/posts/%E5%AE%8F%E5%92%8C%E6%A8%A1%E6%9D%BF%E7%9A%84%E5%AF%B9%E6%AF%94%E9%A2%84%E7%BC%96%E8%AF%91%E5%92%8C%E7%BC%96%E8%AF%91%E7%9A%84%E8%BE%83%E9%87%8F/"},{"categories":["C++底层原理"],"content":"善用编译期的模板 ","date":"2022-03-05","objectID":"/posts/%E5%AE%8F%E5%92%8C%E6%A8%A1%E6%9D%BF%E7%9A%84%E5%AF%B9%E6%AF%94%E9%A2%84%E7%BC%96%E8%AF%91%E5%92%8C%E7%BC%96%E8%AF%91%E7%9A%84%E8%BE%83%E9%87%8F/:2:0","tags":["宏和模板的对比——预编译和编译的较量"],"title":"宏和模板的对比——预编译和编译的较量","uri":"/posts/%E5%AE%8F%E5%92%8C%E6%A8%A1%E6%9D%BF%E7%9A%84%E5%AF%B9%E6%AF%94%E9%A2%84%E7%BC%96%E8%AF%91%E5%92%8C%E7%BC%96%E8%AF%91%E7%9A%84%E8%BE%83%E9%87%8F/"},{"categories":["C++底层原理"],"content":"为什么大多数模板库声明和定义都放在一起？ 声明和定义分开处理的原因 我们清楚，声明和定义中，声明可以有无数份，但定义在一个项目里只能存在一份！所以我们在多文件项目的过程中，需要 include\u003cxxx.h\u003e 得到对应的声明，最后再把对应的实现 xxx.c 编译完后，再通过链接过程让声明能够连接到对应的定义来进行使用。所以在通常情况下我们都是在 .h 文件里面进行声明，再写一个 .c 文件实现定义，把声明和定义进行分开，这样无论你在其他的 .c 文件里使用多少个 include 操作，整个项目都只存在一份定义而已。故这种情况下，用 include 把多份相同的声明放在一个main函数里运行也是没问题的。 话说回来，那为什么一般不会去直接把定义和声明写在一起呢？ 很明显，定义和声明分开，无论我们怎么 include 都不会因为重复定义而产生错误，而如果我们写在一个被 include 的文件里面，则整个项目中，每次 include 都会多产生一次定义！ 为什么模板要把声明和定义写在一起？ 那既然如此，为什么写模板的时候声明和定义写在一个文件里面呢？？？ 我们前面已经清楚了，预编译命令 include 就仅仅把里面的代码拷贝到使用它的文件里去，如果我们把模板的定义和声明分开，画风大概会像下面这样： //test.h #ifndef TEST_TEMPLATE_TEST_H #define TEST_TEMPLATE_TEST_H template\u003ctypename T\u003e void print(T val); #endif //TEST_TEMPLATE_TEST_H //test.cpp #include \"test.h\"#include \u003ciostream\u003etemplate\u003ctypename T\u003e void print(T val) { std::cout\u003c\u003cval; } 不出我所料，很快就报错，内容如下： undefined reference to `void print\u003cint\u003e(int)'\r就是链接时找不到对应的函数定义，原因是模板只会在调用的时候实例化展开代码，如果 .h 只存在模板的声明，那么被include后调用，只会被实例化为以下内容： void print([实例化的类型名] val); 因为对应的.cpp文件里面，不会有任何的变更，也就是不会有对应的定义产生。 所以想要把声明和定义分文件且实现模板的实例化展开，几乎是不可能的（我目前不清楚有哪种方式可以（似乎在末尾再include定义的文件就可以但。。和直接include没区别）） 所以在写模板的时候，我们需要让使用到它的人（include调用者）把声明和定义一块给它，而防止找不到实例化展开的定义。 如何防止模板类的重复定义？ 以上描述了，为什么模板声明和定义需要写在同一个文件里，但问题又出现了，如何预防一个项目中产生多个定义呢？ 简单预防： 通过预处理的宏定义控制导入导出的代码，但这样只能够保证一个 .c文件 中不会出现两次 include 相同代码段。而无法保证其他 .c文件 include 后再次产生定义！ 如下代码，我写了一个ttt.h文件，导出一个 print 函数的声明和定义（直接定义就包含声明）。 //ttt.h #ifndef TEST_TEMPLATE_TTT_H #define TEST_TEMPLATE_TTT_H #include \u003ciostream\u003e void print(){ std::cout\u003c\u003c\"hhhh\"; } #endif //TEST_TEMPLATE_TTT_H //test.cpp #include \"ttt.h\"#include \u003ciostream\u003e//main.cpp #include \"ttt.h\"#include \u003ciostream\u003e int main() { print(); return 0; } 运行main函数时，很快就发生了重复定义的报错！ 因为我们在test.cpp文件里面也 include“ttt.h\" 这将导致重复定义跨文件的重复定义是简单的宏定义没法避免的！ 但我们又发现我们导入多次 \u003ciostream\u003e 标准库却不会出现这个问题，这是为什么呢？ 我试着点进 iostream 里面观察观察，发现写的全是声明。 再进入到更深层的include瞧一瞧看看： 好家伙，\u003cbits/c++config.h\u003e 是两千多行的宏定义！ \u003costream\u003e 和 \u003cistream\u003e 也都只是大量的类型定义和各种类的声明而已，还有我看不懂的各种模板语法的运用，追溯到 \u003cios_base.h\u003e 才终于发现各种类和方法的实现，但看起来都很短，还有各种模板技术的运用，感觉还有很多实现没有放在这个库里面。最后总之就是虽然标准库用的模板，但它用各种技术避免了声明和定义放在一个文件里面。。。或者说让文件导入的时候不会重复的去导入了。 以我目前的水平，看标准库就等于是看天书。。。 大概这就是C++劝退的原因之一吧，模板库为了防止重复定义，使得可读性变得极差，反正我是完全看不懂。。。 相对而言，Java的源代码直接就能简单上手看懂，而且比读文档还清晰，只能说C++的痛。。。 ","date":"2022-03-05","objectID":"/posts/%E5%AE%8F%E5%92%8C%E6%A8%A1%E6%9D%BF%E7%9A%84%E5%AF%B9%E6%AF%94%E9%A2%84%E7%BC%96%E8%AF%91%E5%92%8C%E7%BC%96%E8%AF%91%E7%9A%84%E8%BE%83%E9%87%8F/:2:1","tags":["宏和模板的对比——预编译和编译的较量"],"title":"宏和模板的对比——预编译和编译的较量","uri":"/posts/%E5%AE%8F%E5%92%8C%E6%A8%A1%E6%9D%BF%E7%9A%84%E5%AF%B9%E6%AF%94%E9%A2%84%E7%BC%96%E8%AF%91%E5%92%8C%E7%BC%96%E8%AF%91%E7%9A%84%E8%BE%83%E9%87%8F/"},{"categories":["C++底层原理"],"content":"一些简单且常用的模板技术 template + 函数声明将模板提前实例化一份 由于我们template定义后，只有调用它的时候，才会实例化展开一份代码，但我们也能让编译器先为我们实例化一份代码，这个我也是最近才清楚有这个用法，以前从碰到过。 template\u003ctypename T\u003e int MAX_VALUE(T _1, T _2){ if(_1\u003c_2) return _2; return _1; } using type = const char *; template int MAX_VALUE(type _1, type _2); type_traits（类型萃取技术） type_traits是编译期就去确定具体的类型，而如何确定的呢，这个只需要用到模板的特化展开进行特定的标记即可。 比如写一个无符号整型的编译期类型判断工具可以像下面这样写： 原理就是利用的模板的实例化展开，再加上特定的偏特化，来对类内变量的值进行一个区分，便可实现类型的判断了。 type_traits + static_assert()的运用 我们都知道C语言有个assert()宏，用于DEBUG模式下的断言（不清楚的可以看看我的 assert源码解析），而C++也有static_assert()进行断言，这个断言比assert宏要强大很多。 assert和static_assert的对比 共同点： 都是用于断言，满足条件则正常运行，否则抛出错误信息。 不同点： assert是在运行时且为DEBUG模式，出错后调用函数来进行报错退出处理。 static_assert()则是在程序编译时，在编译时进行判断，再抛出相应信息。 type_tarits的运用 如下图： 通过type_trait可以实现只接受float类型和int类型。 ","date":"2022-03-05","objectID":"/posts/%E5%AE%8F%E5%92%8C%E6%A8%A1%E6%9D%BF%E7%9A%84%E5%AF%B9%E6%AF%94%E9%A2%84%E7%BC%96%E8%AF%91%E5%92%8C%E7%BC%96%E8%AF%91%E7%9A%84%E8%BE%83%E9%87%8F/:2:2","tags":["宏和模板的对比——预编译和编译的较量"],"title":"宏和模板的对比——预编译和编译的较量","uri":"/posts/%E5%AE%8F%E5%92%8C%E6%A8%A1%E6%9D%BF%E7%9A%84%E5%AF%B9%E6%AF%94%E9%A2%84%E7%BC%96%E8%AF%91%E5%92%8C%E7%BC%96%E8%AF%91%E7%9A%84%E8%BE%83%E9%87%8F/"},{"categories":["C++多线程"],"content":"1.1-创建线程(thread)、线程的汇聚(join)、线程的分离(detach)","date":"2022-03-02","objectID":"/posts/1.1-%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8Bthread%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%B1%87%E8%81%9Ajoin%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%88%86%E7%A6%BBdetach/","tags":["1.1-创建线程(thread)、线程的汇聚(join)、线程的分离(detach)"],"title":"1.1-创建线程(thread)、线程的汇聚(join)、线程的分离(detach)","uri":"/posts/1.1-%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8Bthread%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%B1%87%E8%81%9Ajoin%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%88%86%E7%A6%BBdetach/"},{"categories":["C++多线程"],"content":"创建线程(thread)分析程序报错原因 头文件：include\u003cthread\u003e ","date":"2022-03-02","objectID":"/posts/1.1-%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8Bthread%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%B1%87%E8%81%9Ajoin%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%88%86%E7%A6%BBdetach/:1:0","tags":["1.1-创建线程(thread)、线程的汇聚(join)、线程的分离(detach)"],"title":"1.1-创建线程(thread)、线程的汇聚(join)、线程的分离(detach)","uri":"/posts/1.1-%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8Bthread%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%B1%87%E8%81%9Ajoin%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%88%86%E7%A6%BBdetach/"},{"categories":["C++多线程"],"content":"理解线程的创建运行过程 你可以试着运行下面这段代码，你会发现，他肯定会报错！ #include\u003cthread\u003e#include\u003ciostream\u003e void task(){ std::cout\u003c\u003c\"线程运行开始\" } int main(){ std::thread th1(task); } 为什么会报错？ Java里的多线程，创建好线程后，需要调用 run 或者 start 方法来启动这个线程。而 C++ 里的 thread 不需要这个过程，直接传值创建这个线程的内存后，会自动的开始运行这个线程（应该是利用的RAII特性在构造函数里面运行了这个线程的代码）。 但上面并不是报错的理由，在Java里面，线程创建之后会自动和主线程形成联系，start方法开始运行后，这个子线程会和主线程的生命周期一致，如果子线程后于主线程结束，那么就会阻塞主线程直到子线程结束才终止整个程序。当然也可以把子线程通过 setDaemon(true) 设置后，使得主线程和子线程直接的关系切断，这样主线程就不会再等待子线程了，这样就形成了守护线程。 好了，现在回归到上面的C++代码，说说为什么会发生错误。 同样，在C++里创建线程后，也会和主线程产生联系，但它并不会像Java一样主线程自动的等待子线程结束，这个等待结束的过程需要你自己去调用这个线程对应的方法。如果不去调用方法等待子线程结束，或者切断他们之间的联系，那程序就会Crash。这就是报错的原因了！ ","date":"2022-03-02","objectID":"/posts/1.1-%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8Bthread%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%B1%87%E8%81%9Ajoin%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%88%86%E7%A6%BBdetach/:1:1","tags":["1.1-创建线程(thread)、线程的汇聚(join)、线程的分离(detach)"],"title":"1.1-创建线程(thread)、线程的汇聚(join)、线程的分离(detach)","uri":"/posts/1.1-%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8Bthread%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%B1%87%E8%81%9Ajoin%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%88%86%E7%A6%BBdetach/"},{"categories":["C++多线程"],"content":"解决报错的方式：join()和detach 为了解决上面的报错问题有两种方式解决。 ","date":"2022-03-02","objectID":"/posts/1.1-%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8Bthread%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%B1%87%E8%81%9Ajoin%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%88%86%E7%A6%BBdetach/:2:0","tags":["1.1-创建线程(thread)、线程的汇聚(join)、线程的分离(detach)"],"title":"1.1-创建线程(thread)、线程的汇聚(join)、线程的分离(detach)","uri":"/posts/1.1-%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8Bthread%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%B1%87%E8%81%9Ajoin%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%88%86%E7%A6%BBdetach/"},{"categories":["C++多线程"],"content":"方法一：调用join()方法进行合并 由于主线程和子线程之间有联系，我们如果需要正常执行完这个程序，则需要保证整个线程一并结束或者是切断联系。 join() 方法的调用就是等待子线程和主线程汇聚，产生的效果就是主线程被阻塞，直到子线程结束运行，阻塞停止。 join在这里是汇聚汇集之意，你可以想象有多根线，最终结束的时候这几根线需要汇聚到一起，然后全部的线程就结束了，整个程序正常退出！ 代码如下：就仅仅在最后加入了一行join代码，程序bug被解决！ #include\u003cthread\u003e#include\u003ciostream\u003e void task(){ std::cout\u003c\u003c\"线程运行开始\"; } int main(){ std::thread th1(task); th1.join(); } ","date":"2022-03-02","objectID":"/posts/1.1-%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8Bthread%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%B1%87%E8%81%9Ajoin%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%88%86%E7%A6%BBdetach/:2:1","tags":["1.1-创建线程(thread)、线程的汇聚(join)、线程的分离(detach)"],"title":"1.1-创建线程(thread)、线程的汇聚(join)、线程的分离(detach)","uri":"/posts/1.1-%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8Bthread%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%B1%87%E8%81%9Ajoin%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%88%86%E7%A6%BBdetach/"},{"categories":["C++多线程"],"content":"方法二：调用detach()方法分离线程联系 前面也讲到，由于主线程和子线程之间的联系，导致主线程需要照顾子线程。那么detach方法的调用就是切断这个联系。调用了这个方法后，主线程不会再等待子线程执行结束，而是直接正常结束，而子线程是否执行完成和我主线程没有任何关系了。 调用这个方法后的线程，可以理解为守护线程了。这种情况下内存安全要引起重视，如果子线程用到了主线程的资源，这个情况下将会导致 指针悬空 这是一个非常严重的内存安全问题！ 代码如下： #include\u003cthread\u003e#include\u003ciostream\u003e void task(){ std::cout\u003c\u003c\"线程运行开始\"; } int main(){ std::thread th1(task); th1.detach(); } ","date":"2022-03-02","objectID":"/posts/1.1-%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8Bthread%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%B1%87%E8%81%9Ajoin%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%88%86%E7%A6%BBdetach/:2:2","tags":["1.1-创建线程(thread)、线程的汇聚(join)、线程的分离(detach)"],"title":"1.1-创建线程(thread)、线程的汇聚(join)、线程的分离(detach)","uri":"/posts/1.1-%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8Bthread%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%B1%87%E8%81%9Ajoin%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%88%86%E7%A6%BBdetach/"},{"categories":["C++多线程"],"content":"1.2-线程安全的保证——互斥量(锁)和原子变量","date":"2022-03-02","objectID":"/posts/1.2-%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E4%BF%9D%E8%AF%81%E4%BA%92%E6%96%A5%E9%87%8F%E9%94%81%E5%92%8C%E5%8E%9F%E5%AD%90%E5%8F%98%E9%87%8F/","tags":["1.2-线程安全的保证——互斥量(锁)和原子变量"],"title":"1.2-线程安全的保证——互斥量mutex(锁)和原子变量atomic","uri":"/posts/1.2-%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E4%BF%9D%E8%AF%81%E4%BA%92%E6%96%A5%E9%87%8F%E9%94%81%E5%92%8C%E5%8E%9F%E5%AD%90%E5%8F%98%E9%87%8F/"},{"categories":["C++多线程"],"content":"资源竞争引发的线程安全问题 有如下的代码： #include\u003cthread\u003e#include\u003ciostream\u003eint globalVariable = 0; void task(){ for (int i = 0; i \u003c 1000000; ++i) { ++globalVariable; } } int main(){ std::thread th1(task); std::thread th2(task); th1.join(); th2.join(); std::cout\u003c\u003cglobalVariable; } 我们开了两个线程，一共执行了两次 task ，按理来讲 globalVariable 变量应该被加到 2000000 。事实上，你可跑以上代码进行验证，肯定是达不到 2000000 的！ 这又是怎么一回事呢？ 资源竞争的产生： 在多线程中，由于类似于并行的逻辑存在，我们可以想象一下，到 th1 调用 task 函数，且正在为 globalVariable 变量做加法操作的时候，可能此时 th2 也正在为它做加法操作，线程中也是存在对应的工作内存，不是直接更改原内存的值，而是经过 读取-\u003e执行-\u003e写入 的过程。故此时如果两个线程同时进行读取并写入，那么实际上 globalVariable 只加了1，而不是2。 故由于资源竞争的存在，导致结果小于正确的结果！ ","date":"2022-03-02","objectID":"/posts/1.2-%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E4%BF%9D%E8%AF%81%E4%BA%92%E6%96%A5%E9%87%8F%E9%94%81%E5%92%8C%E5%8E%9F%E5%AD%90%E5%8F%98%E9%87%8F/:1:0","tags":["1.2-线程安全的保证——互斥量(锁)和原子变量"],"title":"1.2-线程安全的保证——互斥量mutex(锁)和原子变量atomic","uri":"/posts/1.2-%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E4%BF%9D%E8%AF%81%E4%BA%92%E6%96%A5%E9%87%8F%E9%94%81%E5%92%8C%E5%8E%9F%E5%AD%90%E5%8F%98%E9%87%8F/"},{"categories":["C++多线程"],"content":"如何解决资源竞争问题？ 正如标题所示，如何解决资源竞争问题呢？ 我们经过前面的分析，可知，资源竞争问题是因为并行逻辑的存在，扰乱了原本需要的有序逻辑。怎么理解呢，当多个线程同时处理同一个变量时是不安全的，我们只要让同时只有一个线程去处理这个变量即可。 上面所说的正是多线程的 原子性，执行一个操作的时候不会被其他的线程打断，或者说只能有一个线程在执行这个操作。而之前的代码中 ++globalVarible 这句正需要这样的原子性操作！ 而C++里面也有两类方法去实现这样的效果。 ","date":"2022-03-02","objectID":"/posts/1.2-%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E4%BF%9D%E8%AF%81%E4%BA%92%E6%96%A5%E9%87%8F%E9%94%81%E5%92%8C%E5%8E%9F%E5%AD%90%E5%8F%98%E9%87%8F/:2:0","tags":["1.2-线程安全的保证——互斥量(锁)和原子变量"],"title":"1.2-线程安全的保证——互斥量mutex(锁)和原子变量atomic","uri":"/posts/1.2-%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E4%BF%9D%E8%AF%81%E4%BA%92%E6%96%A5%E9%87%8F%E9%94%81%E5%92%8C%E5%8E%9F%E5%AD%90%E5%8F%98%E9%87%8F/"},{"categories":["C++多线程"],"content":"法一：加互斥锁mutex（性能较低） 代码如下： #include\u003cthread\u003e#include\u003ciostream\u003e int globalVariable = 0; std::mutex mtx; void task(){ for (int i = 0; i \u003c 1000000; ++i) { mtx.lock(); //上锁 ++globalVariable; mtx.unlock();//解锁 } } int main(){ std::thread th1(task); std::thread th2(task); th1.join(); th2.join(); std::cout\u003c\u003cglobalVariable; } 这下终于可以正确的得到 2000000 这个结果了。 我们来讲讲互斥量解锁和上锁的原理： lock()：形象的描述就是，当调用这个方法的时候，会去互斥量里面拿取这把锁，如果这个锁已经被其他线程持有，则阻塞，直到其他线程把这把锁释放，每个互斥量都是一把相同的锁。 unlock()：字面意思，把我现在持有的锁给释放掉，这样就可以让其他因为没有拿到锁的线程停止阻塞，开始争抢这把锁，谁抢到了谁就能得到下一个CPU的时间片。 最终的结果就是哪个线程先拿下这把锁，那么其他线程再运行到这块代码的位置就会被阻塞，这就使得被上锁的区域是具有原子性的！这样就保证了线程的安全。 ","date":"2022-03-02","objectID":"/posts/1.2-%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E4%BF%9D%E8%AF%81%E4%BA%92%E6%96%A5%E9%87%8F%E9%94%81%E5%92%8C%E5%8E%9F%E5%AD%90%E5%8F%98%E9%87%8F/:2:1","tags":["1.2-线程安全的保证——互斥量(锁)和原子变量"],"title":"1.2-线程安全的保证——互斥量mutex(锁)和原子变量atomic","uri":"/posts/1.2-%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E4%BF%9D%E8%AF%81%E4%BA%92%E6%96%A5%E9%87%8F%E9%94%81%E5%92%8C%E5%8E%9F%E5%AD%90%E5%8F%98%E9%87%8F/"},{"categories":["C++多线程"],"content":"法二：转用原子变量（效率更高） C++中可用模板类，把类型转为原子类型，原子变量的实现方式实际上和上锁的过程是类似，但可能由于不同编译器的实现方式，可能会调用计算机的硬件去优化这个加锁解锁的过程，所以效率会更高。 如下代码：(这时就不需要加解锁了，变量本身就是线程安全的) #include\u003cthread\u003e#include\u003ciostream\u003e std::atomic\u003cint\u003e globalVariable = 0; void task(){ for (int i = 0; i \u003c 1000000; ++i) { ++globalVariable; } } int main(){ std::thread th1(task); std::thread th2(task); th1.join(); th2.join(); std::cout\u003c\u003cglobalVariable; } ","date":"2022-03-02","objectID":"/posts/1.2-%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E4%BF%9D%E8%AF%81%E4%BA%92%E6%96%A5%E9%87%8F%E9%94%81%E5%92%8C%E5%8E%9F%E5%AD%90%E5%8F%98%E9%87%8F/:2:2","tags":["1.2-线程安全的保证——互斥量(锁)和原子变量"],"title":"1.2-线程安全的保证——互斥量mutex(锁)和原子变量atomic","uri":"/posts/1.2-%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E4%BF%9D%E8%AF%81%E4%BA%92%E6%96%A5%E9%87%8F%E9%94%81%E5%92%8C%E5%8E%9F%E5%AD%90%E5%8F%98%E9%87%8F/"},{"categories":["C++多线程"],"content":"三个常用的互斥量装饰器 ","date":"2022-03-02","objectID":"/posts/1.2-%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E4%BF%9D%E8%AF%81%E4%BA%92%E6%96%A5%E9%87%8F%E9%94%81%E5%92%8C%E5%8E%9F%E5%AD%90%E5%8F%98%E9%87%8F/:3:0","tags":["1.2-线程安全的保证——互斥量(锁)和原子变量"],"title":"1.2-线程安全的保证——互斥量mutex(锁)和原子变量atomic","uri":"/posts/1.2-%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E4%BF%9D%E8%AF%81%E4%BA%92%E6%96%A5%E9%87%8F%E9%94%81%E5%92%8C%E5%8E%9F%E5%AD%90%E5%8F%98%E9%87%8F/"},{"categories":["C++多线程"],"content":"std::lock_guard (C++11) 这是一个最简单的互斥量装饰器，就是简单的利用C++构造函数和析构函数的RAII特性，在构造的时候上锁和析构的时候解锁，并不会维持传入的互斥器状态。 故前面的代码我们可以改作： #include\u003cthread\u003e#include\u003ciostream\u003e int globalVariable = 0; std::mutex mtx; void task(){ for (int i = 0; i \u003c 1000000; ++i) { std::lock_guard\u003cstd::mutex\u003e lock(mtx); ++globalVariable; } } int main(){ std::thread th1(task); std::thread th2(task); th1.join(); th2.join(); std::cout\u003c\u003cglobalVariable; } std::lock_guard 还有第二个可选参数用于告知它此传入的互斥器已经被锁上，你无需再次上锁，这种主要用在上锁过程自己完成的情况下。例如很多情况我们为了防止产生死锁，需要调用 std::lock() 函数进行统一的上锁。 死锁的产生 如下代码： #include\u003cthread\u003e#include\u003ciostream\u003e#include \u003cmutex\u003e int globalVariable = 0; std::mutex mtx1; std::mutex mtx2; void task1(){ mtx1.lock(); for (int i = 0; i \u003c 10; ++i) { std::cout\u003c\u003c\"test2\"\u003c\u003c'\\n'; } mtx2.lock(); mtx1.unlock(); mtx2.unlock(); } void task2(){ mtx2.lock(); mtx1.lock(); mtx2.unlock(); mtx1.unlock(); } int main(){ std::thread th1(task1); std::thread th2(task2); th1.join(); th2.join(); std::cout\u003c\u003cglobalVariable; } 以上代码的运行结果大概率是由于死锁产生的程序阻塞。 你想想一个过程：如果 mtx1 在 th1 线程先被上锁，而与此同时 mtx2 在 th2 线程被上锁，在 th1 线程运行完 for 循环代码后，遇到将 mtx2 上锁的代码后，由于此时 th2 线程正持有此锁，而 th1 也正持有 mtx1 这样的互相持有对方所需的锁的时候，将会发生死锁现象，即两个线程都被永远的阻塞了！ 利用std::lock批量上锁防止死锁发生 以上的死锁发生的原因就是因为上锁的顺序所导致的，我们可以采取多个线程上多个锁时采用相同的顺序，便可防止死锁的发生，当然也可以直接调用标准库提供的 std::lock 函数批量上锁，来防止上锁顺序导致的死锁！ 如下代码：（lock函数批量上锁是具有原子性的，不会被其他线程打断） #include\u003cthread\u003e#include\u003ciostream\u003e#include \u003cmutex\u003e std::mutex mtx1; std::mutex mtx2; void task1(){ std::lock(mtx1,mtx2); std::lock_guard\u003cstd::mutex\u003e _1(mtx1,std::adopt_lock); //adopt_lock代表一个标志，表示已经被上锁了，别再调用lock方法了 std::lock_guard\u003cstd::mutex\u003e _2(mtx2,std::adopt_lock); for (int i = 0; i \u003c 5; ++i) { std::cout\u003c\u003c\"test1\\n\"; } } void task2(){ std::lock(mtx1,mtx2); std::lock_guard\u003cstd::mutex\u003e _1(mtx1,std::adopt_lock); //adopt_lock代表一个标志，表示已经被上锁了，别再调用lock方法了 std::lock_guard\u003cstd::mutex\u003e _2(mtx2,std::adopt_lock); for (int i = 0; i \u003c 5; ++i) { std::cout\u003c\u003c\"test2\\n\"; } } int main(){ std::thread th1(task1); std::thread th2(task2); th1.join(); th2.join(); } 代码执行结果： ","date":"2022-03-02","objectID":"/posts/1.2-%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E4%BF%9D%E8%AF%81%E4%BA%92%E6%96%A5%E9%87%8F%E9%94%81%E5%92%8C%E5%8E%9F%E5%AD%90%E5%8F%98%E9%87%8F/:3:1","tags":["1.2-线程安全的保证——互斥量(锁)和原子变量"],"title":"1.2-线程安全的保证——互斥量mutex(锁)和原子变量atomic","uri":"/posts/1.2-%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E4%BF%9D%E8%AF%81%E4%BA%92%E6%96%A5%E9%87%8F%E9%94%81%E5%92%8C%E5%8E%9F%E5%AD%90%E5%8F%98%E9%87%8F/"},{"categories":["C++多线程"],"content":"std::unique_lock (C++11) 和 lock_guard 类似，也是用的 RAII 手法进行上锁和解锁。但它还会维持互斥量的状态，你可以通过传入第二个参数告诉它状态。且它是支持无参构造的。 注意：这三个装饰器只有 unique_lock 含有移动构造函数，所以你可以写一个函数简化初始化过程。他们都没有复制构造器！ 如： std::unique_lock\u003cstd::mutex\u003e lock(mtx2,std::defer_lock); 传入的 defer_lock 表示上锁过程暂时不调用，将在后面由我自己上锁。统样也支持 adopt_lock 选项表示已经上了锁。 ","date":"2022-03-02","objectID":"/posts/1.2-%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E4%BF%9D%E8%AF%81%E4%BA%92%E6%96%A5%E9%87%8F%E9%94%81%E5%92%8C%E5%8E%9F%E5%AD%90%E5%8F%98%E9%87%8F/:3:2","tags":["1.2-线程安全的保证——互斥量(锁)和原子变量"],"title":"1.2-线程安全的保证——互斥量mutex(锁)和原子变量atomic","uri":"/posts/1.2-%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E4%BF%9D%E8%AF%81%E4%BA%92%E6%96%A5%E9%87%8F%E9%94%81%E5%92%8C%E5%8E%9F%E5%AD%90%E5%8F%98%E9%87%8F/"},{"categories":["C++多线程"],"content":"std::scoped_lock（C++17） 这个装饰器，支持同时装饰多个互斥量，且也是通过 RAII 手法进行解锁和上锁过程。 创建 scoped_lock 对象时，它试图取得给定互斥的所有权。控制离开创建 scoped_lock 对象的作用域时，析构 scoped_lock 并以逆序释放互斥。若给出数个互斥，则使用免死锁算法，如同以 std::lock 。 scoped_lock 类不可复制。 如下代码： std::scoped_lock lock(e1.m, e2.m); // 等价代码 1 （用 std::lock 和 std::lock_guard ） // std::lock(e1.m, e2.m); // std::lock_guard\u003cstd::mutex\u003e lk1(e1.m, std::adopt_lock); // std::lock_guard\u003cstd::mutex\u003e lk2(e2.m, std::adopt_lock); // 等价代码 2 （若需要 unique_lock ，例如对于条件变量） // std::unique_lock\u003cstd::mutex\u003e lk1(e1.m, std::defer_lock); // std::unique_lock\u003cstd::mutex\u003e lk2(e2.m, std::defer_lock); // std::lock(lk1, lk2); ","date":"2022-03-02","objectID":"/posts/1.2-%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E4%BF%9D%E8%AF%81%E4%BA%92%E6%96%A5%E9%87%8F%E9%94%81%E5%92%8C%E5%8E%9F%E5%AD%90%E5%8F%98%E9%87%8F/:3:3","tags":["1.2-线程安全的保证——互斥量(锁)和原子变量"],"title":"1.2-线程安全的保证——互斥量mutex(锁)和原子变量atomic","uri":"/posts/1.2-%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E4%BF%9D%E8%AF%81%E4%BA%92%E6%96%A5%E9%87%8F%E9%94%81%E5%92%8C%E5%8E%9F%E5%AD%90%E5%8F%98%E9%87%8F/"},{"categories":["算法——动态规划"],"content":"增量元素之间的最大差值——前缀dp","date":"2022-02-26","objectID":"/posts/%E5%A2%9E%E9%87%8F%E5%85%83%E7%B4%A0%E4%B9%8B%E9%97%B4%E7%9A%84%E6%9C%80%E5%A4%A7%E5%B7%AE%E5%80%BC%E5%89%8D%E7%BC%80dp/","tags":["增量元素之间的最大差值——前缀dp"],"title":"增量元素之间的最大差值——前缀dp","uri":"/posts/%E5%A2%9E%E9%87%8F%E5%85%83%E7%B4%A0%E4%B9%8B%E9%97%B4%E7%9A%84%E6%9C%80%E5%A4%A7%E5%B7%AE%E5%80%BC%E5%89%8D%E7%BC%80dp/"},{"categories":["算法——动态规划"],"content":"题目 题目链接 ","date":"2022-02-26","objectID":"/posts/%E5%A2%9E%E9%87%8F%E5%85%83%E7%B4%A0%E4%B9%8B%E9%97%B4%E7%9A%84%E6%9C%80%E5%A4%A7%E5%B7%AE%E5%80%BC%E5%89%8D%E7%BC%80dp/:1:0","tags":["增量元素之间的最大差值——前缀dp"],"title":"增量元素之间的最大差值——前缀dp","uri":"/posts/%E5%A2%9E%E9%87%8F%E5%85%83%E7%B4%A0%E4%B9%8B%E9%97%B4%E7%9A%84%E6%9C%80%E5%A4%A7%E5%B7%AE%E5%80%BC%E5%89%8D%E7%BC%80dp/"},{"categories":["算法——动态规划"],"content":"题目解析 ","date":"2022-02-26","objectID":"/posts/%E5%A2%9E%E9%87%8F%E5%85%83%E7%B4%A0%E4%B9%8B%E9%97%B4%E7%9A%84%E6%9C%80%E5%A4%A7%E5%B7%AE%E5%80%BC%E5%89%8D%E7%BC%80dp/:2:0","tags":["增量元素之间的最大差值——前缀dp"],"title":"增量元素之间的最大差值——前缀dp","uri":"/posts/%E5%A2%9E%E9%87%8F%E5%85%83%E7%B4%A0%E4%B9%8B%E9%97%B4%E7%9A%84%E6%9C%80%E5%A4%A7%E5%B7%AE%E5%80%BC%E5%89%8D%E7%BC%80dp/"},{"categories":["算法——动态规划"],"content":"法一：暴力枚举 此题由于是简单题，所以直接可以暴力枚举。暴力枚举的时候我们也可以考虑优化一下，比如外层枚举 $nums[i]$ 的时候，内层直接找右边的最大值。 代码如下： class Solution { public: int maximumDifference(vector\u003cint\u003e\u0026 nums) { int n = nums.size(); int ret = INT_MIN,mx; for(int i=0;i\u003cn;i++){ mx = *max_element(nums.begin()+i,nums.begin()+n); if(mx\u003enums[i]) ret = max(ret,mx-nums[i]); } if(ret==INT_MIN)return -1; return ret; } }; ","date":"2022-02-26","objectID":"/posts/%E5%A2%9E%E9%87%8F%E5%85%83%E7%B4%A0%E4%B9%8B%E9%97%B4%E7%9A%84%E6%9C%80%E5%A4%A7%E5%B7%AE%E5%80%BC%E5%89%8D%E7%BC%80dp/:2:1","tags":["增量元素之间的最大差值——前缀dp"],"title":"增量元素之间的最大差值——前缀dp","uri":"/posts/%E5%A2%9E%E9%87%8F%E5%85%83%E7%B4%A0%E4%B9%8B%E9%97%B4%E7%9A%84%E6%9C%80%E5%A4%A7%E5%B7%AE%E5%80%BC%E5%89%8D%E7%BC%80dp/"},{"categories":["算法——动态规划"],"content":"法二：dp优化 很明显，时间复杂度实际上还是 $O(n^2)$ ，我们可以通过动态规划，提前求出 $nums[i]$ 之前的最小值，然后我们就可以直接通过 $nums[i]-dp_{min}[i-1]$ 求得，此时时间复杂度被优化为了 $O(n)$ ，但空间复杂度也上升到了 $O(n)$ 。 代码如下： class Solution { public: const int maxn = 0x3f3f3f3f; int maximumDifference(vector\u003cint\u003e\u0026 nums) { //计算dp值 int n = nums.size(); int dp_min[n]; memset(dp_min,0x3f,sizeof(dp_min)); dp_min[0] = nums[0]; int ret = INT_MIN; for(int i=1;i\u003cn;i++) dp_min[i] = min(dp_min[i-1],nums[i]); //得出答案 for(int i=0;i\u003cn;i++){ if(i\u003e0\u0026\u0026nums[i]\u003edp_min[i-1]){ ret = max(ret,nums[i]-dp_min[i-1]); } } if(ret==INT_MIN)return -1; return ret; } }; ","date":"2022-02-26","objectID":"/posts/%E5%A2%9E%E9%87%8F%E5%85%83%E7%B4%A0%E4%B9%8B%E9%97%B4%E7%9A%84%E6%9C%80%E5%A4%A7%E5%B7%AE%E5%80%BC%E5%89%8D%E7%BC%80dp/:2:2","tags":["增量元素之间的最大差值——前缀dp"],"title":"增量元素之间的最大差值——前缀dp","uri":"/posts/%E5%A2%9E%E9%87%8F%E5%85%83%E7%B4%A0%E4%B9%8B%E9%97%B4%E7%9A%84%E6%9C%80%E5%A4%A7%E5%B7%AE%E5%80%BC%E5%89%8D%E7%BC%80dp/"},{"categories":["算法——动态规划"],"content":"法三：进一步优化空间复杂度 我们在 $dp$ 求解的时候发现，我们转移的状态依赖并未跨维度，而仅仅只和上一个状态 $dp[i-1]$ 相关，所以我们实际上只需要一个变量来记录 $nums[i]$ 前的最小值，故把所有的处理放到一个循环中实现即可。 代码如下： class Solution { public: int maximumDifference(vector\u003cint\u003e\u0026 nums) { int n = nums.size(); int ret = -1, premin = nums[0]; for (int i = 1; i \u003c n; ++i) { if (nums[i] \u003e premin) { ret = max(ret, nums[i] - premin); } else { premin = nums[i]; } } return ret; } }; ","date":"2022-02-26","objectID":"/posts/%E5%A2%9E%E9%87%8F%E5%85%83%E7%B4%A0%E4%B9%8B%E9%97%B4%E7%9A%84%E6%9C%80%E5%A4%A7%E5%B7%AE%E5%80%BC%E5%89%8D%E7%BC%80dp/:2:3","tags":["增量元素之间的最大差值——前缀dp"],"title":"增量元素之间的最大差值——前缀dp","uri":"/posts/%E5%A2%9E%E9%87%8F%E5%85%83%E7%B4%A0%E4%B9%8B%E9%97%B4%E7%9A%84%E6%9C%80%E5%A4%A7%E5%B7%AE%E5%80%BC%E5%89%8D%E7%BC%80dp/"},{"categories":["C++实战"],"content":"bitset与埃氏筛","date":"2022-02-22","objectID":"/posts/bitset%E4%B8%8E%E5%9F%83%E6%B0%8F%E7%AD%9B/","tags":["bitset与埃氏筛"],"title":"bitset与埃氏筛","uri":"/posts/bitset%E4%B8%8E%E5%9F%83%E6%B0%8F%E7%AD%9B/"},{"categories":["C++实战"],"content":"bitset ","date":"2022-02-22","objectID":"/posts/bitset%E4%B8%8E%E5%9F%83%E6%B0%8F%E7%AD%9B/:0:0","tags":["bitset与埃氏筛"],"title":"bitset与埃氏筛","uri":"/posts/bitset%E4%B8%8E%E5%9F%83%E6%B0%8F%E7%AD%9B/"},{"categories":["C++实战"],"content":"介绍 std::bitset 是标准库中的一个存储 0/1 的大小不可变容器。严格来讲，它并不属于 STL。 bitset 并不属于 STL，而是一种标准库中的 “Special Container”。事实上，它作为一种容器，也并不满足 STL 容器的要求。说它是适配器，它也并不依赖于其它 STL 容器作为底层实现。——摘自《The C++ Standard Library 2nd Edition》 由于内存地址是按字节即 byte 寻址，而非比特 bit，一个 bool 类型的变量，虽然只能表示 0/1, 但是也占了 1 byte 的内存。 bitset 就是通过固定的优化，使得一个字节的八个比特能分别储存 8 位的 0/1。 对于一个 4 字节的 int 变量，在只存 0/1 的意义下，bitset 占用空间只是其 ，计算一些信息时，所需时间也是其 。 在某些情况下通过 bitset 可以优化程序的运行效率。至于其优化的是复杂度还是常数，要看计算复杂度的角度。一般 bitset 的复杂度有以下几种记法：（设原复杂度为 ） $O(n)$，这种记法认为 bitset 完全没有优化复杂度。 $O(n/32)$，这种记法不太严谨（复杂度中不应出现常数），但体现了 bitset 能将所需时间优化至 $1/32$。 $O(n/w)$，其中 $w=32$（计算机的位数），这种记法较为普遍接受。 $O(n/logw)$，其中 $w$ 为计算机一个整型变量的大小。 当然，vector 的一个特化 vector\u003cbool\u003e 的储存方式同 bitset 一样，区别在于其支持动态开空间，bitset 则和我们一般的静态数组一样，是在编译时就开好了的。 然而，bitset 有一些好用的库函数，不仅方便，而且有时可以避免使用 for 循环而没有实质的速度优化。因此，一般不使用 vector\u003cbool\u003e。 ","date":"2022-02-22","objectID":"/posts/bitset%E4%B8%8E%E5%9F%83%E6%B0%8F%E7%AD%9B/:1:0","tags":["bitset与埃氏筛"],"title":"bitset与埃氏筛","uri":"/posts/bitset%E4%B8%8E%E5%9F%83%E6%B0%8F%E7%AD%9B/"},{"categories":["C++实战"],"content":"使用¶ ","date":"2022-02-22","objectID":"/posts/bitset%E4%B8%8E%E5%9F%83%E6%B0%8F%E7%AD%9B/:2:0","tags":["bitset与埃氏筛"],"title":"bitset与埃氏筛","uri":"/posts/bitset%E4%B8%8E%E5%9F%83%E6%B0%8F%E7%AD%9B/"},{"categories":["C++实战"],"content":"头文件¶ #include \u003cbitset\u003e ","date":"2022-02-22","objectID":"/posts/bitset%E4%B8%8E%E5%9F%83%E6%B0%8F%E7%AD%9B/:2:1","tags":["bitset与埃氏筛"],"title":"bitset与埃氏筛","uri":"/posts/bitset%E4%B8%8E%E5%9F%83%E6%B0%8F%E7%AD%9B/"},{"categories":["C++实战"],"content":"指定大小¶ bitset\u003c1000\u003e bs; // a bitset with 1000 bits ","date":"2022-02-22","objectID":"/posts/bitset%E4%B8%8E%E5%9F%83%E6%B0%8F%E7%AD%9B/:2:2","tags":["bitset与埃氏筛"],"title":"bitset与埃氏筛","uri":"/posts/bitset%E4%B8%8E%E5%9F%83%E6%B0%8F%E7%AD%9B/"},{"categories":["C++实战"],"content":"构造函数¶ bitset(): 每一位都是 false。 bitset(unsigned long val): 设为 val 的二进制形式。 bitset(const string\u0026 str): 设为 串 str。 ","date":"2022-02-22","objectID":"/posts/bitset%E4%B8%8E%E5%9F%83%E6%B0%8F%E7%AD%9B/:2:3","tags":["bitset与埃氏筛"],"title":"bitset与埃氏筛","uri":"/posts/bitset%E4%B8%8E%E5%9F%83%E6%B0%8F%E7%AD%9B/"},{"categories":["C++实战"],"content":"运算符¶ operator []: 访问其特定的一位。 operator ==/!=: 比较两个 bitset 内容是否完全一样。 operator \u0026/\u0026=/|/| =/^/^=/~: 进行按位与/或/异或/取反操作。bitset 只能与 bitset 进行位运算，若要和整型进行位运算，要先将整型转换为 bitset。 operator \u003c\u003e/\u003c\u003c=/\u003e\u003e=: 进行二进制左移/右移。 operator \u003c\u003e: 流运算符，这意味着你可以通过 cin/cout 进行输入输出。 ","date":"2022-02-22","objectID":"/posts/bitset%E4%B8%8E%E5%9F%83%E6%B0%8F%E7%AD%9B/:2:4","tags":["bitset与埃氏筛"],"title":"bitset与埃氏筛","uri":"/posts/bitset%E4%B8%8E%E5%9F%83%E6%B0%8F%E7%AD%9B/"},{"categories":["C++实战"],"content":"成员函数¶ count(): 返回 true 的数量。 size(): 返回 bitset 的大小。 test(pos): 它和 vector 中的 at() 的作用是一样的，和 [] 运算符的区别就是越界检查。 any(): 若存在某一位是 true 则返回 true，否则返回 false。 none(): 若所有位都是 false 则返回 true，否则返回 false。 all():C++11，若所有位都是 true 则返回 true，否则返回 false。 set(): 将整个 bitset 设置成 true。 set(pos, val = true): 将某一位设置成 true/false。 reset(): 将整个 bitset 设置成 false。 reset(pos): 将某一位设置成 false。相当于 set(pos, false)。 flip(): 翻转每一位。（相当于异或一个全是 1 的 bitset） flip(pos): 翻转某一位。 to_string(): 返回转换成的字符串表达。 to_ulong(): 返回转换成的 unsigned long 表达 (long 在 NT 及 32 位 POSIX 系统下与 int 一样，在 64 位 POSIX 下与 long long 一样）。 to_ullong():C++11，返回转换成的 unsigned long long 表达。 一些文档中没有的成员函数： _Find_first(): 返回 bitset 第一个 true 的下标，若没有 true 则返回 bitset 的大小。 _Find_next(pos): 返回 pos 后面（下标严格大于 pos 的位置）第一个 true 的下标，若 pos 后面没有 true 则返回 bitset 的大小。 ","date":"2022-02-22","objectID":"/posts/bitset%E4%B8%8E%E5%9F%83%E6%B0%8F%E7%AD%9B/:2:5","tags":["bitset与埃氏筛"],"title":"bitset与埃氏筛","uri":"/posts/bitset%E4%B8%8E%E5%9F%83%E6%B0%8F%E7%AD%9B/"},{"categories":["C++实战"],"content":"应用¶ ","date":"2022-02-22","objectID":"/posts/bitset%E4%B8%8E%E5%9F%83%E6%B0%8F%E7%AD%9B/:3:0","tags":["bitset与埃氏筛"],"title":"bitset与埃氏筛","uri":"/posts/bitset%E4%B8%8E%E5%9F%83%E6%B0%8F%E7%AD%9B/"},{"categories":["C++实战"],"content":"「LibreOJ β Round #2」贪心只能过样例¶ 这题可以用 dp 做，转移方程很简单： 表示前 个数的平方和能否为 ，那么 （或起来）。 但如果直接做的话是 的，（看起来）过不了。 发现可以用 bitset 优化，左移再或起来就好了：std::bitset 然后发现……被加了几个剪枝的暴力艹了：加了几个剪枝的暴力 然而，可以手写 bitset（只需要支持左移后或起来这一种操作）压 位（unsigned long long）来艹掉暴力：手写 bitset ","date":"2022-02-22","objectID":"/posts/bitset%E4%B8%8E%E5%9F%83%E6%B0%8F%E7%AD%9B/:3:1","tags":["bitset与埃氏筛"],"title":"bitset与埃氏筛","uri":"/posts/bitset%E4%B8%8E%E5%9F%83%E6%B0%8F%E7%AD%9B/"},{"categories":["C++实战"],"content":"与埃氏筛结合 由于 bitset 快速的连续读写效率（前提是开O2优化），使得它非常适合用于与埃氏筛结合打质数表。 使用的方式也很简单，只需要将埃氏筛中的布尔数组替换成 bitset 即可。 参考代码 bitset\u003cN\u003e vis; void Prime(int n) { vis.set(); vis[0] = vis[1] = 0; for (int i = 2; i * i \u003c= n; i++) { if (vis[i]) { for (int j = i \u003c\u003c 1; j \u003c= n; j += i) vis[j] = 0; } } } ","date":"2022-02-22","objectID":"/posts/bitset%E4%B8%8E%E5%9F%83%E6%B0%8F%E7%AD%9B/:3:2","tags":["bitset与埃氏筛"],"title":"bitset与埃氏筛","uri":"/posts/bitset%E4%B8%8E%E5%9F%83%E6%B0%8F%E7%AD%9B/"},{"categories":["C++实战"],"content":"埃氏筛速度测试 测试代码如下： #include\u003ccstdio\u003e#include \"../BenchMark/Timer.h\"using namespace std; #define BIT_SET //通过是否定义BIT_SET宏来控制测试对象 #ifdef BIT_SET #include\u003cbitset\u003e bitset\u003c100001000\u003e vis; #else bool vis[100001000]; #endif int n, ans; #ifdef BIT_SET void Prime() { vis.set(); vis[0] = vis[1] = 0; for (int i = 2; i * i \u003c= n; i++) { if (vis[i]) { for (int j = i \u003c\u003c 1; j \u003c= n; j += i) vis[j] = 0; } } } #else void GetPrimes() { fill(vis,vis+100001000, true); vis[0] = vis[1] = 0; for (int i = 2; i * i \u003c= n; i++) { if (vis[i]) { for (int j = i \u003c\u003c 1; j \u003c= n; j += i) vis[j] = 0; } } } #endif int main() { scanf(\"%d\", \u0026n); { ans = 0; Timer c; #ifdef BIT_SET Prime(); #else GetPrimes(); #endif for (int i = 2; i \u003c= n; i++) if (vis[i]) ans++; printf(\"%d \", ans); } return 0; } 其中的计时器Timer是我封装的一个用于测试速度的类，利用的C++ RAII特性写的。 代码如下： // // Created by Alone on 2022-1-31. // #ifndef BENCHMARK_TIMER_H #define BENCHMARK_TIMER_H #include \u003cchrono\u003e#include \u003ciostream\u003eclass Timer { public: Timer(){ m_StartTimepoint = std::chrono::high_resolution_clock::now(); } ~Timer(){ Stop(); } void Stop(){ auto endTimepoint = std::chrono::high_resolution_clock::now(); auto start = std::chrono::time_point_cast\u003cstd::chrono::microseconds\u003e(m_StartTimepoint).time_since_epoch().count(); auto end = std::chrono::time_point_cast\u003cstd::chrono::microseconds\u003e(endTimepoint).time_since_epoch().count(); auto duration = end-start; //以微秒为单位 double ms = duration * 0.001;//得到毫秒 printf(\"%lld us (%lf ms)\\n\",duration,ms); } private: std::chrono::time_point\u003cstd::chrono::high_resolution_clock\u003em_StartTimepoint; }; #endif //BENCHMARK_TIMER_H 测试结果： 测试中使用的环境为mingw，使用了 $o2$ 级别的优化，所以 bitset 明显会快很多！ 在 n==1e8 的情况下，轮番三次 bool vs bitset 结果如下： 第一次：1351532 us (1351.532000 ms) vs 1171797 us (1171.797000 ms) 第二次：1814639 us (1814.639000 ms) vs 1236894 us (1236.894000 ms) 第三次：1812811 us (1812.811000 ms) vs 5761455 1188555 us (1188.555000 ms) 难道以后都优先使用bitset？别高兴的太早！在我们默认的debug模式下bitset根本就完全不是bool数组的对手，随手一测，直接就是 2397002 us (2397.002000 ms) vs 8512716 us (8512.716000 ms) bitset大败！！！ 所以，在一般的算法题情况下，写质数筛还是用bool数组吧！因为算法题的oj不会给你开优化的！故原始bool数组是最好的选择！ ","date":"2022-02-22","objectID":"/posts/bitset%E4%B8%8E%E5%9F%83%E6%B0%8F%E7%AD%9B/:3:3","tags":["bitset与埃氏筛"],"title":"bitset与埃氏筛","uri":"/posts/bitset%E4%B8%8E%E5%9F%83%E6%B0%8F%E7%AD%9B/"},{"categories":["算法——最短路问题"],"content":"k站中转内最便宜的航班--BellmanFord算法和SPFA算法的改造","date":"2022-02-22","objectID":"/posts/k%E7%AB%99%E4%B8%AD%E8%BD%AC%E5%86%85%E6%9C%80%E4%BE%BF%E5%AE%9C%E7%9A%84%E8%88%AA%E7%8F%AD-bellmanford%E7%AE%97%E6%B3%95%E5%92%8Cspfa%E7%AE%97%E6%B3%95%E7%9A%84%E6%94%B9%E9%80%A0/","tags":["k站中转内最便宜的航班--BellmanFord算法和SPFA算法的改造"],"title":"k站中转内最便宜的航班--BellmanFord算法和SPFA算法的改造","uri":"/posts/k%E7%AB%99%E4%B8%AD%E8%BD%AC%E5%86%85%E6%9C%80%E4%BE%BF%E5%AE%9C%E7%9A%84%E8%88%AA%E7%8F%AD-bellmanford%E7%AE%97%E6%B3%95%E5%92%8Cspfa%E7%AE%97%E6%B3%95%E7%9A%84%E6%94%B9%E9%80%A0/"},{"categories":["算法——最短路问题"],"content":"题目 oj平台 ","date":"2022-02-22","objectID":"/posts/k%E7%AB%99%E4%B8%AD%E8%BD%AC%E5%86%85%E6%9C%80%E4%BE%BF%E5%AE%9C%E7%9A%84%E8%88%AA%E7%8F%AD-bellmanford%E7%AE%97%E6%B3%95%E5%92%8Cspfa%E7%AE%97%E6%B3%95%E7%9A%84%E6%94%B9%E9%80%A0/:1:0","tags":["k站中转内最便宜的航班--BellmanFord算法和SPFA算法的改造"],"title":"k站中转内最便宜的航班--BellmanFord算法和SPFA算法的改造","uri":"/posts/k%E7%AB%99%E4%B8%AD%E8%BD%AC%E5%86%85%E6%9C%80%E4%BE%BF%E5%AE%9C%E7%9A%84%E8%88%AA%E7%8F%AD-bellmanford%E7%AE%97%E6%B3%95%E5%92%8Cspfa%E7%AE%97%E6%B3%95%E7%9A%84%E6%94%B9%E9%80%A0/"},{"categories":["算法——最短路问题"],"content":"BellmanFord算法的动态规划解决(效率一般) 看到k站内，肯定会想到 BellmanFord 算法的动态规划解法，本来优化成按边遍历的动态规划可以不用计较多少次，但这里必须要计较用了多少次，所以我们要在同一次边的选择中，保证另一个边用的是上一次的结果，故通过二维数组进行dp即可写出，要压缩成一维数组也不难，毕竟用的仅仅只是上一行的结果，所以动态规划解决是非常简单的。 class Solution { public: int findCheapestPrice(int n, vector\u003cvector\u003cint\u003e\u003e\u0026 flights, int src, int dst, int k) { const int INF = 0x3f3f3f3f; //用临时数组存储，这样改变了dist也不会改变temp,这样便达到了控制遍历次数的目的 int* dist = new int[n]; memset(dist,0x3f,sizeof(int)*n); dist[src] = 0; int sz = flights.size(); for(int i=0;i\u003c=k;i++){ int* temp = new int[n]; memcpy(temp,dist,n*sizeof(int)); for(int j=0;j\u003csz;j++){ if(temp[flights[j][0]]!=INF){ dist[flights[j][1]] = min(dist[flights[j][1]],temp[flights[j][0]] + flights[j][2]); } } delete[] temp; } return dist[dst]==INF?-1:dist[dst]; } }; ","date":"2022-02-22","objectID":"/posts/k%E7%AB%99%E4%B8%AD%E8%BD%AC%E5%86%85%E6%9C%80%E4%BE%BF%E5%AE%9C%E7%9A%84%E8%88%AA%E7%8F%AD-bellmanford%E7%AE%97%E6%B3%95%E5%92%8Cspfa%E7%AE%97%E6%B3%95%E7%9A%84%E6%94%B9%E9%80%A0/:2:0","tags":["k站中转内最便宜的航班--BellmanFord算法和SPFA算法的改造"],"title":"k站中转内最便宜的航班--BellmanFord算法和SPFA算法的改造","uri":"/posts/k%E7%AB%99%E4%B8%AD%E8%BD%AC%E5%86%85%E6%9C%80%E4%BE%BF%E5%AE%9C%E7%9A%84%E8%88%AA%E7%8F%AD-bellmanford%E7%AE%97%E6%B3%95%E5%92%8Cspfa%E7%AE%97%E6%B3%95%E7%9A%84%E6%94%B9%E9%80%A0/"},{"categories":["算法——最短路问题"],"content":"SPFA算法改造成为经典BFS解决(效率高) 为了效率，我建图时候用了链式前向星。 这道题开始拿到的时候，我就再想这个SPFA类似于BFS，那肯定是可以控制次数的，然后就开始行动了，SPFA队列遍历的时候需要判断该结点是否存在于队列中，如果存在，则不能入队，使用的数据都是通过 dist 数组来更新，这样导致完全丧失了BFS的遍历次数信息，使得答案更新的很快是没错，但无法控制在一定的遍历次数范围内(因为可能你本次所用到的 dist 可能不是上一次的)。 那么如何解决这个 BFS 遍历次数的限制问题呢？ 为了解决 SPFA 算法的这个问题我试了两种方式，只有最后有一种是可行的： (错误)利用同等长度的临时数组记录此次遍历后dist数组更新的结果，然后在遍历完的尾部利用该数组对 dist 数组进行更新。 就像这样： 但很快会发现出现一个问题：一次遍历途中可能一个结点更新多次，那么这样就无法保证把所有k次中转内的情况都列举出来。 (正确)利用队列的参数对dist进行更新，如何更新呢？队列中记录每个结点的编号和到src的距离,每次更新新的 dist 的时候直接用正在遍历的编号到src的距离替代直接使用dist数组(这样便防止了更新dist数组后影响后续更新)。 如图： 解题代码： class Solution { public: //用于建图的结构体 struct { int to; int len; int next; }edge[5000]; int findCheapestPrice(int n, vector\u003cvector\u003cint\u003e\u003e\u0026 flights, int src, int dst, int k) { const int INF = 0x3f3f3f3f; memset(head, 0xff, sizeof head); int dist[n];memset(dist,0x3f,sizeof dist); dist[src] = 0; queue\u003cpair\u003cint,int\u003e\u003eQ; int sz = flights.size(); for(int i=0;i\u003csz;i++){ add(flights[i][0],flights[i][1],flights[i][2]); } Q.push({src,dist[src]}); int step = 0; while(!Q.empty()){ if(step\u003ek) break; for(int i=Q.size();i\u003e0;i--){ auto idx = move(Q.front());Q.pop(); for(int j=head[idx.first];j!=-1;j=edge[j].next){ if(idx.second+edge[j].len\u003cdist[edge[j].to]){ dist[edge[j].to] = idx.second+edge[j].len; Q.push({edge[j].to,dist[edge[j].to]}); } } } step++; } if(dist[dst]!=INF)return dist[dst]; return -1; } private: //用于链式前向星建图的函数和数据 int tot = 0; int head[100]; void add(int node,int to,int len){ edge[tot].to = to; edge[tot].len = len; edge[tot].next = head[node]; head[node] = tot; tot++; } }; ","date":"2022-02-22","objectID":"/posts/k%E7%AB%99%E4%B8%AD%E8%BD%AC%E5%86%85%E6%9C%80%E4%BE%BF%E5%AE%9C%E7%9A%84%E8%88%AA%E7%8F%AD-bellmanford%E7%AE%97%E6%B3%95%E5%92%8Cspfa%E7%AE%97%E6%B3%95%E7%9A%84%E6%94%B9%E9%80%A0/:3:0","tags":["k站中转内最便宜的航班--BellmanFord算法和SPFA算法的改造"],"title":"k站中转内最便宜的航班--BellmanFord算法和SPFA算法的改造","uri":"/posts/k%E7%AB%99%E4%B8%AD%E8%BD%AC%E5%86%85%E6%9C%80%E4%BE%BF%E5%AE%9C%E7%9A%84%E8%88%AA%E7%8F%AD-bellmanford%E7%AE%97%E6%B3%95%E5%92%8Cspfa%E7%AE%97%E6%B3%95%E7%9A%84%E6%94%B9%E9%80%A0/"},{"categories":["Linux网络编程"],"content":"TCP协议详解","date":"2022-02-21","objectID":"/posts/tcp%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/","tags":["TCP协议详解"],"title":"TCP协议详解","uri":"/posts/tcp%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/"},{"categories":["Linux网络编程"],"content":" 本文章为《Linux高性能服务器编程》第四章的笔记，该书描述该章的各种内容的时候，几乎都使用了实践的工具来抓包验证并解释的方式来铺开知识点。我这里几乎是照搬了书本的知识点，但做了个分类处理。 TCP协议 在详细讨论TCP协议之前，我们先简单介绍一下TCP服务的特点，以及它和UDP服务的区别。 传输层协议主要有两个：TCP协议和UDP协议。TCP协议相对于UDP协议的特点是：面向连接、字节流和可靠传输。 面向连接： 使用TCP协议通信的双方必须先建立连接，然后才能开始数据的读写。双方都必须为该连接分配必要的内核资源，以管理连接的状态和连接上数据的传输。TCP连接是全双工的，即双方的数据读写可以通过一个连接进行。完成数据交换之后，通信双方都必须断开连接以释放系统资源。 字节流： 字节流服务和数据报服务的接收双方的最终表现出来的区别是，通信双方是否必须执行相同次数的读、写操作。具体原因在于，TCP通信是有接收和发送缓冲区的，应用程序可以一次性将TCP接收缓冲区中的数据全部读出，也可以分多次读取，这取决于用户指定的应用程序读缓冲区的大小。因此，应用程序执行的读操作次数和TCP模块接收到的TCP报文段个数之间也没有固定的数量关系。 综上所述，发送端执行的写操作次数和接收端执行的读操作次数之间没有任何数量关系，这就是字节流的概念：应用程序对数据的发送和接收是没有边界限制的。UDP则不然。发送端应用程序每执行一次写操作，UDP模块就将其封装成一个UDP数据报并发送之。接收端必须及时针对每一个UDP数据报执行读操作（通过recvfrom系统调用），否则就会丢包（这经常发生在较慢的服务器上）。并且，如果用户没有指定足够的应用程序缓冲区（程序开发者自建的）来读取UDP数据，则UDP数据将被截断。 图3-1和图3-2显示了TCP字节流服务和UDP数据报服务的上述区别。两图中省略了传输层以下的通信细节。 可靠传输： TCP协议采用发送应答机制，即发送端发送的每个TCP报文段都必须得到接收方的应答，才认为这个TCP报文段传输成功。 TCP协议采用超时重传机制，发送端在发送出一个TCP报文段之后启动定时器，如果在定时时间内未收到应答，它将重发该报文段。 因为TCP报文段最终是以IP数据报发送的，而IP数据报到达接收端可能乱序、重复，所以TCP协议还会对接收到的TCP报文段重排、整理，再交付给应用层。 UDP协议则和IP协议一样，提供不可靠服务。它们都需要上层协议来处理数据确认和超时重传。 ","date":"2022-02-21","objectID":"/posts/tcp%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/:0:0","tags":["TCP协议详解"],"title":"TCP协议详解","uri":"/posts/tcp%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/"},{"categories":["Linux网络编程"],"content":"TCP头部信息 ","date":"2022-02-21","objectID":"/posts/tcp%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/:1:0","tags":["TCP协议详解"],"title":"TCP协议详解","uri":"/posts/tcp%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/"},{"categories":["Linux网络编程"],"content":"TCP头部信息清单 TCP头部结构如图3-3所示，其中的诸多字段为管理TCP连接和控制数据流提供了足够的信息。 16位端口号（port number） 告知主机该报文段是来自哪里（源端口）以及传给哪个上层协议或应用程序（目的端口）的。 进行TCP通信时，客户端通常使用系统自动选择的临时端口号，而服务器则使用知名服务端口号。 32位序号（sequence number） 一次TCP通信（从TCP连接建立到断开）过程中某一个传输方向上的字节流的每个字节的编号。 假设主机A和主机B进行TCP通信，A发送给B的第一个TCP报文段中，序号值被系统初始化为某个随机值ISN（InitialSequence Number，初始序号值）。那么在该传输方向上（从A到B），后续的TCP报文段中序号值将被系统设置成ISN加上该报文段所携带数据的第一个字节在整个字节流中的偏移。例如，某个TCP报文段传送的数据是字节流中的第1025～2048字节，那么该报文段的序号值就是ISN+1025。另外一个传输方向（从B到A）的TCP报文段的序号值也具有相同的含义。 32位确认号（acknowledgement number） 用作对另一方发送来的TCP报文段的响应。其值是收到的TCP报文段的序号值加1。 假设主机A和主机B进行TCP通信，那么A发送出的TCP报文段不仅携带自己的序号，而且包含对B发送来的TCP报文段的确认号。反之，B发送出的TCP报文段也同时携带自己的序号和对A发送来的报文段的确认号。 4位头部长度（header length） 标识该TCP头部有多少个32bit字（4字节）。因为4位最大能表示15，所以TCP头部最长是60字节。 6位标志位 ❑URG标志，表示紧急指针（urgent pointer）是否有效。 ❑ACK标志，表示确认号是否有效。我们称携带ACK标志的TCP报文段为确认报文段。 ❑PSH标志，提示接收端应用程序应该立即从TCP接收缓冲区中读走数据，为接收后续数据腾出空间（如果应用程序不将接收到的数据读走，它们就会一直停留在TCP接收缓冲区中）。 ❑RST标志，表示要求对方重新建立连接。我们称携带RST标志的TCP报文段为复位报文段。 ❑SYN标志，表示请求建立一个连接。我们称携带SYN标志的TCP报文段为同步报文段。 ❑FIN标志，表示通知对方本端要关闭连接了。我们称携带FIN标志的TCP报文段为结束报文段。 16位窗口大小（window size） 是TCP流量控制的一个手段。这里说的窗口，指的是接收通告窗口（Receiver Window，RWND）注意这个名词，后面TCP数据流的控制会再碰到。它告诉对方本端的TCP接收缓冲区还能容纳多少字节的数据，这样对方就可以控制发送数据的速度。 16位校验和（TCP checksum） 由发送端填充，接收端对TCP报文段执行CRC算法以检验TCP报文段在传输过程中是否损坏。注意，这个校验不仅包括TCP头部，也包括数据部分。这也是TCP可靠传输的一个重要保障。 16位紧急指针（urgent pointer） 是一个正的偏移量。它和序号字段的值相加表示最后一个紧急数据的下一字节的序号。因此，确切地说，这个字段是紧急指针相对当前序号的偏移，不妨称之为紧急偏移。TCP的紧急指针是发送端向接收端发送紧急数据的方法。我们将在后面讨论TCP紧急数据。 ","date":"2022-02-21","objectID":"/posts/tcp%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/:1:1","tags":["TCP协议详解"],"title":"TCP协议详解","uri":"/posts/tcp%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/"},{"categories":["Linux网络编程"],"content":"TCP头部选项 TCP头部的最后一个选项字段（options）是可变长的可选信息。这部分最多包含40字节，因为TCP头部最长是60字节（其中还包含前面讨论的20字节的固定部分）。典型的TCP头部选项结构如图3-4所示。 选项的第一个字段kind说明选项的类型。有的TCP选项没有后面两个字段，仅包含1字节的kind字段。第二个字段length（如果有的话）指定该选项的总长度，该长度包括kind字段和length字段占据的2字节。第三个字段info（如果有的话）是选项的具体信息。 常见的TCP选项有7种，如图3-5所示。 kind=0是选项表结束选项。 kind=1是空操作（nop）选项，没有特殊含义，一般用于将TCP选项的总长度填充为4字节的整数倍。 kind=2是最大报文段长度选项。重要 TCP连接初始化时，通信双方使用该选项来协商最大报文段长度（Max Segment Size，MSS）。TCP模块通常将MSS设置为（MTU-40）字节（减掉的这40字节包括20字节的TCP头部和20字节的IP头部）。这样携带TCP报文段的IP数据报的长度就不会超过MTU（假设TCP头部和IP头部都不包含选项字段，并且这也是一般情况），从而避免本机发生IP分片。对以太网而言，MSS值是1460（1500-40）字节。 kind=3是窗口扩大因子选项。重要 TCP连接初始化时，通信双方使用该选项来协商接收通告窗口的扩大因子。在TCP的头部中，接收通告窗口大小是用16位表示的，故最大为65 535字节，但实际上TCP模块允许的接收通告窗口大小远不止这个数（为了提高TCP通信的吞吐量）。窗口扩大因子解决了这个问题。假设TCP头部中的接收通告窗口大小是N，窗口扩大因子（移位数）是M，那么TCP报文段的实际接收通告窗口大小是N乘2M ，或者说N左移M位。注意，M的取值范围是0～14。我们可以通过修改/proc/sys/net/ipv4/tcp_window_scaling内核变量来启用或关闭窗口扩大因子选项。 和MSS选项一样，窗口扩大因子选项只能出现在同步报文段中，否则将被忽略。但同步报文段本身不执行窗口扩大操作，即同步报文段头部的接收通告窗口大小就是该TCP报文段的实际接收通告窗口大小。当连接建立好之后，每个数据传输方向的窗口扩大因子就固定不变了。 kind=4是选择性确认（Selective Acknowledgment，SACK）选项。 TCP通信时，如果某个TCP报文段丢失，则TCP模块会重传最后被确认的TCP报文段后续的所有报文段，这样原先已经正确传输的TCP报文段也可能重复发送，从而降低了TCP性能。SACK技术正是为改善这种情况而产生的，它使TCP模块只重新发送丢失的TCP报文段，不用发送所有未被确认的TCP报文段。选择性确认选项用在连接初始化时，表示是否支持SACK技术。我们可以通过修改/proc/sys/net/ipv4/tcp_sack内核变量来启用或关闭选择性确认选项。 kind=5是SACK实际工作的选项。 该选项的参数告诉发送方本端已经收到并缓存的不连续的数据块，从而让发送端可以据此检查并重发丢失的数据块。每个块边沿（edge of block）参数包含一个4字节的序号。其中块左边沿表示不连续块的第一个数据的序号，而块右边沿则表示不连续块的最后一个数据的序号的下一个序号。这样一对参数（块左边沿和块右边沿）之间的数据是没有收到的。因为一个块信息占用8字节，所以TCP头部选项中实际上最多可以包含4个这样的不连续数据块（考虑选项类型和长度占用的2字节）。 kind=8是时间戳选项。 该选项提供了较为准确的计算通信双方之间的回路时间（Round Trip Time，RTT）的方法，从而为TCP流量控制提供重要信息。我们可以通过修改/proc/sys/net/ipv4/tcp_timestamps内核变量来启用或关闭时间戳选项。 ","date":"2022-02-21","objectID":"/posts/tcp%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/:1:2","tags":["TCP协议详解"],"title":"TCP协议详解","uri":"/posts/tcp%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/"},{"categories":["Linux网络编程"],"content":"一个真实的抓包验证过程 tcpdump抓取数据包 tcpdump输出Flags[S]，表示该TCP报文段包含SYN标志，因此它是一个同步报文段。如果TCP报文段包含其他标志，则tcpdump也会将该标志的首字母显示在“Flags”后的方括号中。 seq是序号值。因为该同步报文段是从127.0.0.1.41621（客户端IP地址和端口号）到127.0.0.1.23（服务器IP地址和端口号）这个传输方向上的第一个TCP报文段，所以这个序号值也就是此次通信过程中该传输方向的ISN值。并且，因为这是整个通信过程中的第一个TCP报文段，所以它没有针对对方发送来的TCP报文段的确认值（尚未收到任何对方发送来的TCP报文段）。 win是接收通告窗口的大小。因为这是一个同步报文段，所以win值反映的是实际的接收通告窗口大小。 options是TCP选项，其具体内容列在方括号中。mss是发送端（客户端）通告的最大报文段长度。通过ifconfig命令查看回路接口的MTU为16436字节，因此可以预想到TCP报文段的MSS为16396（16436-40）字节。sackOK表示发送端支持并同意使用SACK选项。TS val是发送端的时间戳。ecr是时间戳回显应答。因为这是一次TCP通信的第一个TCP报文段，所以它针对对方的时间戳的应答为0（尚未收到对方的时间戳）。紧接着的nop是一个空操作选项。wscale指出发送端使用的窗口扩大因子为6。 ","date":"2022-02-21","objectID":"/posts/tcp%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/:1:3","tags":["TCP协议详解"],"title":"TCP协议详解","uri":"/posts/tcp%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/"},{"categories":["Linux网络编程"],"content":"TCP的建立和关闭 ","date":"2022-02-21","objectID":"/posts/tcp%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/:2:0","tags":["TCP协议详解"],"title":"TCP协议详解","uri":"/posts/tcp%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/"},{"categories":["Linux网络编程"],"content":"三次握手和四次挥手 三次握手 第1个TCP报文段包含SYN标志，因此它是一个同步报文段，即ernest-laptop（客户端）向Kongming20（服务器）发起连接请求。同时，该同步报文段包含一个ISN值为535734930的序号。 第2个TCP报文段也是同步报文段，表示Kongming20同意与ernest-laptop建立连接。同时它发送自己的ISN值为2159701207的序号，并对第1个同步报文段进行确认。确认值是535734931，即第1个同步报文段的序号值加1。序号值是用来标识TCP数据流中的数据部分的起始字节在整个传输过程中的序号。但同步报文段比较特殊，即使它并没有携带任何应用程序数据，它也要占用一个序号值。 第3个TCP报文段是ernest-laptop对第2个同步报文段的确认。至此，TCP连接就建立起来了。建立TCP连接的这3个步骤被称为TCP三次握手。 四次挥手 后面4个TCP报文段是关闭连接的过程。第4个TCP报文段包含FIN标志，因此它是一个结束报文段，即ernest-laptop要求关闭连接。结束报文段和同步报文段一样，也要占用一个序号值。 Kongming20用TCP报文段5来确认该结束报文段。紧接着Kongming20发送自己的结束报文段6，ernest-laptop则用TCP报文段7给予确认。实际上，仅用于确认目的的确认报文段5是可以省略的，因为结束报文段6也携带了该确认信息。确认报文段5是否出现在连接断开的过程中，取决于TCP的延迟确认特性（除了延迟确认特性外我觉得还能用来实现半关闭状态）。 在连接的关闭过程中，因为ernest-laptop先发送结束报文段（telnet客户端程序主动退出），故称ernest-laptop执行主动关闭，而称Kongming20执行被动关闭。 ","date":"2022-02-21","objectID":"/posts/tcp%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/:2:1","tags":["TCP协议详解"],"title":"TCP协议详解","uri":"/posts/tcp%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/"},{"categories":["Linux网络编程"],"content":"半关闭状态 TCP通信的一端可以发送结束报文段给对方，告诉它本端已经完成了数据的发送，但允许继续接收来自对方的数据，直到对方也发送结束报文段以关闭连接。TCP连接的这种状态称为半关闭（half close）状态，如图3-7所示。 socket网络编程接口通过shutdown函数提供了对半关闭的支持，我们将在后续章节讨论它。这里强调一下，虽然我们介绍了半关闭状态，但是使用半关闭的应用程序很少见。 ","date":"2022-02-21","objectID":"/posts/tcp%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/:2:2","tags":["TCP协议详解"],"title":"TCP协议详解","uri":"/posts/tcp%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/"},{"categories":["Linux网络编程"],"content":"超时重连的抓包探索 前面我们讨论的是很快建立连接的情况。如果客户端访问一个距离它很远的服务器，或者由于网络繁忙，导致服务器对于客户端发送出的同步报文段没有应答，此时客户端程序将产生什么样的行为呢？显然，对于提供可靠服务的TCP来说，它必然是先进行重连（可能执行多次），如果重连仍然无效，则通知应用程序连接超时。 作者抓包Linux系统后输出包的时间戳，得到以下结果： 我们一共抓取到6个TCP报文段，它们都是同步报文段，并且具有相同的序号值，这说明后面5个同步报文段都是超时重连报文段。观察这些TCP报文段被发送的时间间隔，它们分别为1s、2s、4s、8s和16s（由于定时器精度的问题，这些时间间隔都有一定偏差），可以推断最后一个TCP报文段的超时时间是32s（63s-16s-8s-4s-2s-1s）。因此，TCP模块一共执行了5次重连操作，这是由/proc/sys/net/ipv4/tcp_syn_retries内核变量所定义的。每次重连的超时时间都增加一倍。在5次重连均失败的情况下，TCP模块放弃连接并通知应用程序。 ","date":"2022-02-21","objectID":"/posts/tcp%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/:2:3","tags":["TCP协议详解"],"title":"TCP协议详解","uri":"/posts/tcp%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/"},{"categories":["Linux网络编程"],"content":"TCP状态转移过程 TCP连接的任意一端在任一时刻都处于某种状态，当前状态可以通过netstat命令查看。本节我们要讨论的是TCP连接从建立到关闭的整个过程中通信两端状态的变化。图3-8是完整的状态转移图，它描绘了所有的TCP状态以及可能的状态转换。 图3-8中的粗虚线表示典型的服务器端连接的状态转移；粗实线表示典型的客户端连接的状态转移。CLOSED是一个假想的起始点，并不是一个实际的状态。 ","date":"2022-02-21","objectID":"/posts/tcp%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/:3:0","tags":["TCP协议详解"],"title":"TCP协议详解","uri":"/posts/tcp%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/"},{"categories":["Linux网络编程"],"content":"TCP状态转移总图文字详解 服务器状态转移过程 服务器通过listen系统调用进入 LISTEN 状态，被动等待客户端连接，因此执行的是所谓的被动打开。服务器一旦监听到某个连接请求（收到同步报文段），就将该连接放入内核等待队列中，并向客户端发送带SYN标志的确认报文段。此时该连接处于 SYN_RCVD 状态。如果服务器成功地接收到客户端发送回的确认报文段，则该连接转移到 ESTABLISHED 状态。ESTABLISHED状态是连接双方能够进行双向数据传输的状态。 当客户端主动关闭连接时（通过close或shutdown系统调用向服务器发送结束报文段），服务器通过返回确认报文段使连接进入 CLOSE_WAIT 状态。这个状态的含义很明确：等待服务器应用程序关闭连接。通常，服务器检测到客户端关闭连接后，也会立即给客户端发送一个结束报文段来关闭连接。这将使连接转移到 LAST_ACK 状态，以等待客户端对结束报文段的最后一次确认。一旦确认完成，连接就彻底关闭了。 客户端状态转移过程 客户端通过connect系统调用主动与服务器建立连接。connect系统调用首先给服务器发送一个同步报文段，使连接转移到 SYN_SENT 状态。此后，connect系统调用可能因为如下两个原因失败返回： ❑如果connect连接的目标端口不存在（未被任何进程监听），或者该端口仍被处于TIME_WAIT状态的连接所占用（见后文），则服务器将给客户端发送一个复位报文段，connect调用失败。 ❑如果目标端口存在，但connect在超时时间内未收到服务器的确认报文段，则connect调用失败。 connect调用失败将使连接立即返回到初始的CLOSED状态。如果客户端成功收到服务器的同步报文段和确认，则connect调用成功返回，连接转移至 ESTABLISHED 状态。 当客户端执行主动关闭时，它将向服务器发送一个结束报文段，同时连接进入 FIN_WAIT_1 状态。若此时客户端收到服务器专门用于确认目的的确认报文段（比如图3-6中的TCP报文段5），则连接转移至 FIN_WAIT_2 状态。当客户端处于 FIN_WAIT_2 状态时，服务器处于 CLOSE_WAIT 状态，这一对状态是可能发生半关闭的状态。此时如果服务器也关闭连接（发送结束报文段），则客户端将给予确认并进入TIME_WAIT状态。 图3-8还给出了客户端从 FIN_WAIT_1 状态直接进入 TIME_WAIT 状态的一条线路（不经过 FIN_WAIT_2 状态），前提是处于FIN_WAIT_1 状态的服务器直接收到带确认信息的结束报文段（而不是先收到确认报文段，再收到结束报文段）。这种情况对应于图3-6中的服务器不发送TCP报文段5。 前面说过，处于 FIN_WAIT_2 状态的客户端需要等待服务器发送结束报文段，才能转移至 TIME_WAIT 状态，否则它将一直停留在这个状态。如果不是为了在半关闭状态下继续接收数据，连接长时间地停留在 FIN_WAIT_2 状态并无益处（所以客户端处于 FIN_WAIT_2 服务端处于 CLOSE_WAIT 状态时一般是为了保持半关闭状态）。 那么问题来了：客户端执行半关闭后，未等服务器关闭连接就强行退出了。此时客户端连接由内核来接管，可称之为孤儿连接（和孤儿进程类似）。Linux为了防止孤儿连接长时间存留在内核中，定义了两个内核变量：/proc/sys/net/ipv4/tcp_max_orphans和/proc/sys/net/ipv4/tcp_fin_timeout。前者指定内核能接管的孤儿连接数目，后者指定孤儿连接在内核中生存的时间。 至此，我们简单地讨论了服务器和客户端程序的典型TCP状态转移路线。对应于图3-6所示的TCP连接的建立与断开过程，客户端和服务器的状态转移如图3-9所示。 ","date":"2022-02-21","objectID":"/posts/tcp%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/:3:1","tags":["TCP协议详解"],"title":"TCP协议详解","uri":"/posts/tcp%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/"},{"categories":["Linux网络编程"],"content":"TIME_WAIT状态 客户端处于 TIME_WAIT 状态。在这个状态，客户端连接要等待一段长为2MSL（Maximum Segment Life，报文段最大生存时间）的时间，才能完全关闭。MSL是TCP报文段在网络中的最大生存时间，标准文档RFC 1122的建议值是2 min。 TIME_WAIT 状态存在的原因有两点： ❑可靠地终止TCP连接。 ❑保证让迟来的TCP报文段有足够的时间被识别并丢弃。 第一个原因很好理解。假设图3-9中用于确认服务器结束报文段6的TCP报文段7丢失，那么服务器将重发结束报文段。因此客户端需要停留在某个状态以处理重复收到的结束报文段（即向服务器发送确认报文段）。否则，客户端将以复位报文段来回应服务器，服务器则认为这是一个错误，因为它期望的是一个像TCP报文段7那样的确认报文段。 TIME_WAIT状态持续2MSL的原因 在Linux系统上，一个TCP端口不能被同时打开多次（两次及以上）。当一个TCP连接处于 TIME_WAIT 状态时，我们将无法立即使用该连接占用着的端口来建立一个新连接。反过来思考，如果不存在 TIME_WAIT 状态，则应用程序能够立即建立一个和刚关闭的连接相似的连接（这里说的相似，是指它们具有相同的IP地址和端口号）。这个新的、和原来相似的连接被称为原来的连接的化身（incarnation）。新的化身可能接收到属于原来的连接的、携带应用程序数据的TCP报文段（迟到的报文段），这显然是不应该发生的。这就是TIME_WAIT状态存在的第二个原因。 另外，因为TCP报文段的最大生存时间是MSL，所以坚持2MSL时间的TIME_WAIT状态能够确保网络上两个传输方向上尚未被接收到的、迟到的TCP报文段都已经消失（被中转路由器丢弃）。 因此，一个连接的新的化身可以在2MSL时间之后安全地建立，而绝对不会接收到属于原来连接的应用程序数据，这就是 TIME_WAIT 状态要持续2MSL时间的原因。 TIME_WAIT引发的端口占用问题 关于客户端 既然一个客户端处于 TIME_WAIT 状态时会占用端口号，那我们下次重启程序不久没法再和服务端进行通信了？ 实际上客户端并不用担心这个问题，因为客户端一般使用系统自动分配的临时端口号来建立连接，而由于随机性，临时端口号一般和程序上一次使用的端口号（还处于TIME_WAIT状态的那个连接使用的端口号）不同，所以客户端程序一般可以立即重启。 关于服务端 但如果是服务器主动关闭连接后异常终止，则因为它总是使用同一个知名服务端口号，所以连接的 TIME_WAIT 状态将导致它不能立即重启。不过，我们可以通过socket选项SO_REUSEADDR来强制进程立即使用处于TIME_WAIT状态的连接占用的端口。（当然你也可以把这个端口号对应的进程杀死） ","date":"2022-02-21","objectID":"/posts/tcp%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/:3:2","tags":["TCP协议详解"],"title":"TCP协议详解","uri":"/posts/tcp%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/"},{"categories":["Linux网络编程"],"content":"复位报文段 在某些特殊条件下，TCP连接的一端会向另一端发送携带RST标志的报文段，即复位报文段，以通知对方关闭连接或重新建立连接。 我们讨论产生复位报文段的3种情况。 情况一：访问不存在的端口 抓包测试如下： 由此可见，ernest-laptop针对Kongming20的连接请求（同步报文段）回应了一个复位报文段（tcpdump输出R标志）。因为复位报文段的接收通告窗口大小为0，所以可以预见：收到复位报文段的一端应该关闭连接或者重新连接，而不能回应这个复位报文段。 实际上，当客户端程序向服务器的某个端口发起连接，而该端口仍被处于TIME_WAIT状态的连接所占用时，客户端程序也将收到复位报文段。 情况二：异常终止连接 前面讨论的连接终止方式都是正常的终止方式：数据交换完成之后，一方给另一方发送结束报文段。TCP提供了异常终止一个连接的方法，即给对方发送一个复位报文段。一旦发送了复位报文段，发送端所有排队等待发送的数据都将被丢弃。 应用程序可以使用socket选项SO_LINGER来发送复位报文段，以异常终止一个连接。 情况三：处理半打开连接 考虑下面的情况：服务器（或客户端）关闭或者异常终止了连接，而对方没有接收到结束报文段（比如发生了网络故障），此时，客户端（或服务器）还维持着原来的连接，而服务器（或客户端）即使重启，也已经没有该连接的任何信息了。我们将这种状态称为半打开状态，处于这种状态的连接称为半打开连接。如果客户端（或服务器）往处于半打开状态的连接写入数据，则对方将回应一个复位报文段。 举例来说，我们在Kongming20上使用nc命令模拟一个服务器程序，使之监听12345端口，然后从ernest-laptop运行telnet命令登录到该端口上，接着拔掉ernest-laptop的网线，并在Kongming20上请求连接中断。显然，此时ernest-laptop上运行的telnet客户端程序维持着一个半打开连接。然后接上ernest-laptop的网线，并从客户端程序往半打开连接写入1字节的数据“a”。 具体的实践抓包： 该输出内容中，前3个TCP报文段是正常建立TCP连接的3次握手的过程。第4个TCP报文段由客户端发送给服务器，它携带了3字节的应用程序数据，这3字节依次是：字母“a”、回车符“\\r”和换行符“\\n”。不过因为服务器程序已经被中断，所以Kongming20对客户端发送的数据回应了一个复位报文段5。 ","date":"2022-02-21","objectID":"/posts/tcp%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/:3:3","tags":["TCP协议详解"],"title":"TCP协议详解","uri":"/posts/tcp%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/"},{"categories":["Linux网络编程"],"content":"TCP数据流 TCP报文段所携带的应用程序数据按照长度分为两种：交互数据和成块数据。交互数据仅包含很少的字节。使用交互数据的应用程序（或协议）对实时性要求高，比如telnet、ssh等。成块数据的长度则通常为TCP报文段允许的最大数据长度。使用成块数据的应用程序（或协议）对传输效率要求高，比如ftp。 ","date":"2022-02-21","objectID":"/posts/tcp%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/:4:0","tags":["TCP协议详解"],"title":"TCP协议详解","uri":"/posts/tcp%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/"},{"categories":["Linux网络编程"],"content":"交互数据流抓包讲解 考虑如下情况：在ernest-laptop上执行telnet命令登录到本机，然后在shell命令提示符后执行ls命令，同时用tcpdump抓取这一过程中telnet客户端和telnet服务器交换的TCP报文段。 TCP报文段1由客户端发送给服务器，它携带1个字节的应用程序数据，即字母“l”。 TCP报文段2是服务器对TCP报文段1的确认，同时回显字母“l”。 TCP报文段3是客户端对TCP报文段2的确认。 第4～6个TCP报文段是针对字母“s”的上述过程。 TCP报文段7传送的2字节数据分别是：客户端键入的回车符和流结束符（EOF，本例中是0x00）。 TCP报文段8携带服务器返回的客户查询的目录的内容（ls命令的输出），包括该目录下文件的文件名及其显示控制参数。 TCP报文段9是客户端对TCP报文段8的确认。 TCP报文段10携带的也是服务器返回给客户端的数据，包括一个回车符、一个换行符、客户端登录用户的PS1环境变量（第一级命令提示符）。 TCP报文段11是客户端对TCP报文段10的确认。 延迟确认 在上述过程中，客户端针对服务器返回的数据所发送的确认报文段（TCP报文段6、9和11）都不携带任何应用程序数据（长度为0），而服务器每次发送的确认报文段（TCP报文段2、5、8和10）都包含它需要发送的应用程序数据。 服务器的这种处理方式称为延迟确认，即它不马上确认上次收到的数据，而是在一段延迟时间后查看本端是否有数据需要发送，如果有，则和确认信息一起发出。因为服务器对客户请求处理得很快，所以它发送确认报文段的时候总是有数据一起发送。延迟确认可以减少发送TCP报文段的数量。而由于用户的输入速度明显慢于客户端程序的处理速度，所以客户端的确认报文段总是不携带任何应用程序数据。 Nagle算法 上例是在本地回路运行的结果，在局域网中也能得到基本相同的结果，但在广域网就未必如此了。广域网上的交互数据流可能经受很大的延迟，并且，携带交互数据的微小TCP报文段数量一般很多（一个按键输入就导致一个TCP报文段），这些因素都可能导致拥塞发生。解决该问题的一个简单有效的方法是使用Nagle算法。 Nagle算法要求一个TCP连接的通信双方在任意时刻都最多只能发送一个未被确认的TCP报文段，在该TCP报文段的确认到达之前不能发送其他TCP报文段。另一方面，发送方在等待确认的同时收集本端需要发送的微量数据，并在确认到来时以一个TCP报文段将它们全部发出。这样就极大地减少了网络上的微小TCP报文段的数量。该算法的另一个优点在于其自适应性：确认到达得越快，数据也就发送得越快。 ","date":"2022-02-21","objectID":"/posts/tcp%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/:4:1","tags":["TCP协议详解"],"title":"TCP协议详解","uri":"/posts/tcp%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/"},{"categories":["Linux网络编程"],"content":"TCP成块数据流抓包讲解 下面考虑用FTP协议传输一个大文件。在ernest-laptop上启动一个vsftpd服务器程序（升级的、安全版的ftp服务器程序），并执行ftp命令登录该服务器上，然后在ftp命令提示符后输入get命令，从服务器下载一个几百兆的大文件。 注意，客户端发送的最后两个TCP报文段17和18，它们分别是对TCP报文段2和16的确认（从序号值和确认值来判断）。由此可见，当传输大量大块数据的时候，发送方会连续发送多个TCP报文段，接收方可以一次确认所有这些报文段。那么发送方在收到上一次确认后，能连续发送多少个TCP报文段呢？这是由接收通告窗口（还需要考虑拥塞窗口，见后文）的大小决定的。TCP报文段17说明客户端还能接收30 084×64字节（本例中窗口扩大因子为6），即1 925 376字节的数据。而在TCP报文段18中，接收通告窗口大小为1 748 288字节，即客户端能接收的数据量变小了。这表明客户端的TCP接收缓冲区有更多的数据未被应用程序读取而停留在其中，这些数据都来自TCP报文段3～16中的一部分。服务器收到TCP报文段18后，它至少（因为接收通告窗口可能扩大）还能连续发送的未被确认的报文段数量是1 748 288/16 384个，即106个（但一般不会连续发送这么多）。其中，16 384是成块数据的长度（见TCP报文段1～16的length值），很显然它小于但接近MSS规定的16 396字节。 另外一个值得注意的地方是，服务器每发送4个TCP报文段就传送一个PSH标志（tcpdump输出标志P）给客户端，以通知客户端的应用程序尽快读取数据。不过这对服务器来说显然不是必需的，因为它知道客户端的TCP接收缓冲区中还有空闲空间（接收通告窗口大小不为0）。 ","date":"2022-02-21","objectID":"/posts/tcp%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/:4:2","tags":["TCP协议详解"],"title":"TCP协议详解","uri":"/posts/tcp%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/"},{"categories":["Linux网络编程"],"content":"带外数据 有些传输层协议具有带外（Out Of Band，OOB）数据的概念，用于迅速通告对方本端发生的重要事件。因此，带外数据比普通数据（也称为带内数据）有更高的优先级，它应该总是立即被发送，而不论发送缓冲区中是否有排队等待发送的普通数据。 带外数据的传输可以使用一条独立的传输层连接，也可以映射到传输普通数据的连接中。 UDP没有实现带外数据传输，TCP也没有真正的带外数据。不过TCP利用其头部中的紧急指针标志和紧急指针两个字段，给应用程序提供了一种紧急方式。 TCP发送带外数据的过程 假设一个进程已经往某个TCP连接的发送缓冲区中写入了N字节的普通数据，并等待其发送。在数据被发送前，该进程又向这个连接写入了3字节的带外数据“abc”。 此时，待发送的TCP报文段的头部将被设置URG标志，并且紧急指针被设置为指向最后一个带外数据的下一字节（进一步减去当前TCP报文段的序号值得到其头部中的紧急偏移值），如图3-10所示。 由图3-10可见，发送端一次发送的多字节的带外数据中只有最后一字节被当作带外数据（字母c），而其他数据（字母a和b）被当成了普通数据。 如果TCP模块以多个TCP报文段来发送图3-10所示TCP发送缓冲区中的内容，则每个TCP报文段都将设置URG标志，并且它们的紧急指针指向同一个位置（数据流中带外数据的下一个位置），但只有一个TCP报文段真正携带带外数据。 TCP接收带外数据的过程 TCP接收端只有在接收到紧急指针标志时才检查紧急指针，然后根据紧急指针所指的位置确定带外数据的位置，并将它读入一个特殊的缓存中。这个缓存只有1字节，称为带外缓存。如果上层应用程序没有及时将带外数据从带外缓存中读出，则后续的带外数据（如果有的话）将覆盖它。 前面讨论的带外数据的接收过程是TCP模块接收带外数据的默认方式。如果我们给TCP连接设置了 SO_OOBINLINE 选项，则带外数据将和普通数据一样被TCP模块存放在TCP接收缓冲区中。此时应用程序需要像读取普通数据一样来读取带外数据。那么这种情况下如何区分带外数据和普通数据呢？显然，紧急指针可以用来指出带外数据的位置，socket编程接口也提供了系统调用来识别带外数据。 ","date":"2022-02-21","objectID":"/posts/tcp%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/:4:3","tags":["TCP协议详解"],"title":"TCP协议详解","uri":"/posts/tcp%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/"},{"categories":["Linux网络编程"],"content":"TCP数据流的控制（拥塞控制） ","date":"2022-02-21","objectID":"/posts/tcp%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/:5:0","tags":["TCP协议详解"],"title":"TCP协议详解","uri":"/posts/tcp%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/"},{"categories":["Linux网络编程"],"content":"超时重传机制 在正式进入拥塞控制之前，先聊聊超时重传机制。 抓包截图就省略了，直接开始分析： 观察TCP报文段6～11被发送的时间间隔，它们分别为0.2 s、0.4 s、0.8 s、1.6 s和3.2 s。由此可见，TCP一共执行5次重传，每次重传超时时间都增加一倍（因此，和TCP超时重连的策略相似）。在5次重传均失败的情况下，底层的IP和ARP开始接管，直到telnet客户端放弃连接为止。 Linux有两个重要的内核参数与TCP超时重传相关：/proc/sys/net/ipv4/tcp_retries1和/proc/sys/net/ipv4/tcp_retries2。前者指定在底层IP接管之前TCP最少执行的重传次数，默认值是3。后者指定连接放弃前TCP最多可以执行的重传次数，默认值是15（一般对应13～30 min）。在我们的实例中，TCP超时重传发生了5次，连接坚持的时间是15 min（可以用date命令来测量）。 虽然超时会导致TCP报文段重传，但TCP报文段的重传可以发生在超时之前，即快速重传（接收到重复的确认报文段）。 ","date":"2022-02-21","objectID":"/posts/tcp%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/:5:1","tags":["TCP协议详解"],"title":"TCP协议详解","uri":"/posts/tcp%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/"},{"categories":["Linux网络编程"],"content":"拥塞控制 拥塞控制算法在Linux下有多种实现，比如reno算法、vegas算法和cubic算法等。它们或者部分或者全部实现了上述四个部分。/proc/sys/net/ipv4/tcp_congestion_control文件指示机器当前所使用的拥塞控制算法。 拥塞控制的最终受控变量是发送端向网络一次连续写入（收到其中第一个数据的确认之前）的数据量，我们称为SWND（Send Window，发送窗口[1]）。不过，发送端最终以TCP报文段来发送数据，所以SWND限定了发送端能连续发送的TCP报文段数量。这些TCP报文段的最大长度（仅指数据部分）称为SMSS（SenderMaximum Segment Size，发送者最大段大小），其值一般等于MSS。 发送端需要合理地选择SWND的大小。如果SWND太小，会引起明显的网络延迟；反之，如果SWND太大，则容易导致网络拥塞。前文提到，接收方可通过其接收通告窗口（RWND）来控制发送端的SWND。但这显然不够，所以发送端引入了一个称为拥塞窗口（Congestion Window，CWND）的状态变量。实际的SWND值是RWND和CWND中的较小者。图3-11显示了拥塞控制的输入和输出（可见，它是一个闭环反馈控制）。 慢启动和拥塞避免 TCP连接建立好之后，CWND将被设置成初始值IW（Initial Window），其大小为2～4个SMSS。但新的Linux内核提高了该初始值，以减小传输滞后。此时发送端最多能发送IW字节的数据。此后发送端每收到接收端的一个确认，其CWND就按照式（3-1）增加： 其中N是此次确认中包含的之前未被确认的字节数。这样一来，CWND将按照指数形式扩大，这就是所谓的慢启动。慢启动算法的理由是，TCP模块刚开始发送数据时并不知道网络的实际情况，需要用一种试探的方式平滑地增加CWND的大小。 但是如果不施加其他手段，慢启动必然使得CWND很快膨胀（可见慢启动其实不慢）并最终导致网络拥塞。因此TCP拥塞控制中定义了另一个重要的状态变量：慢启动门限（slow start threshold size，ssthresh）。当CWND的大小超过该值时，TCP拥塞控制将进入拥塞避免阶段。 拥塞避免算法使得CWND按照线性方式增加，从而减缓其扩大。RFC 5681中提到了如下两种实现方式： ❑每个RTT时间内按照式（3-1）计算新的CWND，而不论该RTT时间内发送端收到多少个确认。 ❑每收到一个对新数据的确认报文段，就按照式（3-2）来更新CWND。 图3-12粗略地描述了慢启动和拥塞避免发生的时机和区别。该图中，我们以SMSS为单位来显示CWND（实际上它是以字节为单位的），以次数为单位来显示RTT，这只是为了方便讨论问题。此外，我们假设当前的ssthresh是16SMSS大小（当然，实际的ssthresh显然远不止这么大）。 判断拥塞是否发生 以上我们讨论了发送端在未检测到拥塞时所采用的积极避免拥塞的方法。接下来介绍拥塞发生时（可能发生在慢启动阶段或者拥塞避免阶段）拥塞控制的行为。不过我们先要搞清楚发送端是如何判断拥塞已经发生的。发送端判断拥塞发生的依据有如下两个： ❑传输超时，或者说TCP重传定时器溢出。 ❑接收到重复的确认报文段。 拥塞控制对这两种情况有不同的处理方式。对第一种情况仍然使用慢启动和拥塞避免。对第二种情况则使用快速重传和快速恢复（如果是真的发生拥塞的话），这种情况将在后面讨论。注意，第二种情况如果发生在重传定时器溢出之后，则也被拥塞控制当成第一种情况来对待。 如果发送端检测到拥塞发生是由于传输超时，即上述第一种情况，那么它将执行重传并做如下调整： 快速重传和快速恢复 在很多情况下，发送端都可能接收到重复的确认报文段，比如TCP报文段丢失，或者接收端收到乱序TCP报文段并重排之等。拥塞控制算法需要判断当收到重复的确认报文段时，网络是否真的发生了拥塞，或者说TCP报文段是否真的丢失了。具体做法是：发送端如果连续收到3个重复的确认报文段，就认为是拥塞发生了。然后它启用快速重传和快速恢复算法来处理拥塞，过程如下： 1）当收到第3个重复的确认报文段时，按照式（3-3）计算ssthresh，然后立即重传丢失的报文段，并按照以下式子设置CWND。 $$CWND=ssthresh+3*SMSS$$ 2）每次收到1个重复的确认时，设置CWND=CWND+SMSS。此时发送端可以发送新的TCP报文段（如果新的CWND允许的话）。 3）当收到新数据的确认时，设置CWND=ssthresh（ssthresh是新的慢启动门限值，由第一步计算得到）。 快速重传和快速恢复完成之后，拥塞控制将恢复到拥塞避免阶段，这一点由第3步操作可得知。 ","date":"2022-02-21","objectID":"/posts/tcp%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/:5:2","tags":["TCP协议详解"],"title":"TCP协议详解","uri":"/posts/tcp%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/"},{"categories":["算法——模拟题"],"content":"1bit与2bit字符——简单模拟题","date":"2022-02-20","objectID":"/posts/1bit%E4%B8%8E2bit%E5%AD%97%E7%AC%A6%E7%AE%80%E5%8D%95%E6%A8%A1%E6%8B%9F%E9%A2%98/","tags":["1bit与2bit字符——简单模拟题"],"title":"1bit与2bit字符——简单模拟题","uri":"/posts/1bit%E4%B8%8E2bit%E5%AD%97%E7%AC%A6%E7%AE%80%E5%8D%95%E6%A8%A1%E6%8B%9F%E9%A2%98/"},{"categories":["算法——模拟题"],"content":"题目 题目链接 ","date":"2022-02-20","objectID":"/posts/1bit%E4%B8%8E2bit%E5%AD%97%E7%AC%A6%E7%AE%80%E5%8D%95%E6%A8%A1%E6%8B%9F%E9%A2%98/:1:0","tags":["1bit与2bit字符——简单模拟题"],"title":"1bit与2bit字符——简单模拟题","uri":"/posts/1bit%E4%B8%8E2bit%E5%AD%97%E7%AC%A6%E7%AE%80%E5%8D%95%E6%A8%A1%E6%8B%9F%E9%A2%98/"},{"categories":["算法——模拟题"],"content":"题目详解 读懂题： 此题是为了让最后以一个字符解码，也就是 $0$ ，而含 $1$ 的只能是两个字符进行解码，所以遇到 $1$ 就必须确保后面有 $0$ 或 $1$ 来用于抵消。 解题法： 法一：正向遍历法 直接通过遇到 $0$ 走一步，遇到 $1$ 走两步，再看最后是否能恰好走到最后一个 $0$ 的位置，如果能则 $true$ 否则 $false$ 。 法二：反向遍历法 由于遇到 $0$ 能直接跳过，而遇到 $1$ 则后面必须含有一个字符被抵消，所以为了让最后一个 $0$ 不被抵消，它前面的连续 $1$ 应该要为偶数个，否则 $0$ 将会被抵消。故具体做法直接记录最后一个 $0$ 前面的 $1$ 的个数即可得出答案。 ","date":"2022-02-20","objectID":"/posts/1bit%E4%B8%8E2bit%E5%AD%97%E7%AC%A6%E7%AE%80%E5%8D%95%E6%A8%A1%E6%8B%9F%E9%A2%98/:2:0","tags":["1bit与2bit字符——简单模拟题"],"title":"1bit与2bit字符——简单模拟题","uri":"/posts/1bit%E4%B8%8E2bit%E5%AD%97%E7%AC%A6%E7%AE%80%E5%8D%95%E6%A8%A1%E6%8B%9F%E9%A2%98/"},{"categories":["算法——模拟题"],"content":"解题代码 法一： class Solution { public: bool isOneBitCharacter(vector\u003cint\u003e\u0026 bits) { int sz = bits.size(); if(sz\u003c2) return true; int start = 0; while(start\u003csz-1){ if(bits[start]==0) start++; else{ start += 2; } } return start==sz-1; } }; 法二： class Solution { public: bool isOneBitCharacter(vector\u003cint\u003e\u0026 bits) { return find(rbegin(bits)+1, rend(bits), 0) - rbegin(bits) \u0026 1; } }; ","date":"2022-02-20","objectID":"/posts/1bit%E4%B8%8E2bit%E5%AD%97%E7%AC%A6%E7%AE%80%E5%8D%95%E6%A8%A1%E6%8B%9F%E9%A2%98/:3:0","tags":["1bit与2bit字符——简单模拟题"],"title":"1bit与2bit字符——简单模拟题","uri":"/posts/1bit%E4%B8%8E2bit%E5%AD%97%E7%AC%A6%E7%AE%80%E5%8D%95%E6%A8%A1%E6%8B%9F%E9%A2%98/"},{"categories":["Java底层原理"],"content":"Java动态代理详解","date":"2022-02-20","objectID":"/posts/java%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E8%AF%A6%E8%A7%A3/","tags":["Java动态代理详解"],"title":"Java动态代理详解","uri":"/posts/java%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E8%AF%A6%E8%A7%A3/"},{"categories":["Java底层原理"],"content":" 在介绍动态代理之前，必须先来聊聊静态代理。 ","date":"2022-02-20","objectID":"/posts/java%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E8%AF%A6%E8%A7%A3/:0:0","tags":["Java动态代理详解"],"title":"Java动态代理详解","uri":"/posts/java%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E8%AF%A6%E8%A7%A3/"},{"categories":["Java底层原理"],"content":"静态代理介绍 假设现在项目经理有一个需求：在项目现有所有类的方法前后打印日志。 你如何在不修改已有代码的前提下，完成这个需求？ 我首先想到的是静态代理。具体做法是： 一、为现有的每一个类都编写一个对应的代理类，并且让它实现和目标类相同的接口（假设都有） 二、在创建代理对象时，通过构造器塞入一个目标对象，然后在代理对象的方法内部调用目标对象同名方法，并在调用前后打印日志。也就是说，代理对象 = 增强代码 + 目标对象（原对象）。有了代理对象后，就不用原对象了 静态代理的缺陷 程序员要手动为每一个目标类编写对应的代理类。如果当前系统已经有成百上千个类，工作量太大了。所以，现在我们的努力方向是：如何少写或者不写代理类，却能完成代理功能？ 复习对象的创建 很多初学Java的朋友眼中创建对象的过程 实际上可以换个角度，也说得通 所谓的Class对象，是Class类的实例，而Class类是描述所有类的，比如Person类，Student类 可以看出，要创建一个实例，最关键的就是得到对应的Class对象。只不过对于初学者来说，new这个关键字配合构造方法，实在太好用了，底层隐藏了太多细节，一句 Person p = new Person();直接把对象返回给你了。我自己刚开始学Java时，也没意识到Class对象的存在。 分析到这里，貌似有了思路： 能否不写代理类，而直接得到代理Class对象，然后根据它创建代理实例（反射）。 Class对象包含了一个类的所有信息，比如构造器、方法、字段等。如果我们不写代理类，这些信息从哪获取呢？苦思冥想，突然灵光一现：代理类和目标类理应实现同一组接口。之所以实现相同接口，是为了尽可能保证代理对象的内部结构和目标对象一致，这样我们对代理对象的操作最终都可以转移到目标对象身上，代理对象只需专注于增强代码的编写。还是上面这幅图： 所以，可以这样说：接口拥有代理对象和目标对象共同的类信息。所以，我们可以从接口那得到理应由代理类提供的信息。但是别忘了，接口是无法创建对象的，怎么办？ ","date":"2022-02-20","objectID":"/posts/java%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E8%AF%A6%E8%A7%A3/:1:0","tags":["Java动态代理详解"],"title":"Java动态代理详解","uri":"/posts/java%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E8%AF%A6%E8%A7%A3/"},{"categories":["Java底层原理"],"content":"走进动态代理 JDK提供了java.lang.reflect.InvocationHandler接口和 java.lang.reflect.Proxy类，这两个类相互配合，入口是Proxy，所以我们先聊它。 Proxy有个静态方法：getProxyClass(ClassLoader, interfaces)，只要你给它传入类加载器和一组接口，它就给你返回代理Class对象。 用通俗的话说，getProxyClass() 这个方法，会从你传入的接口Class中，“拷贝”类结构信息到一个新的Class对象中，但新的Class对象带有构造器，是可以创建对象的。打个比方，一个大内太监（接口Class），空有一身武艺（类信息），但是无法传给后人。现在江湖上有个妙手神医（Proxy类），发明了克隆大法（getProxyClass），不仅能克隆太监的一身武艺，还保留了小DD（构造器）…（这到底是道德の沦丧，还是人性的扭曲，欢迎走进动态代理） 所以，一旦我们明确接口，完全可以通过接口的Class对象，创建一个代理Class，通过代理Class即可创建代理对象。 所以，按我理解，Proxy.getProxyClass()这个方法的本质就是：以Class造Class。 有了Class对象，就很好办了，具体看代码： 根据代理Class的构造器创建对象时，需要传入InvocationHandler。每次调用代理对象的方法，最终都会调用InvocationHandler的invoke()方法： 怎么做到的呢？ 上面不是说了吗，根据代理Class的构造器创建对象时，需要传入InvocationHandler。通过构造器传入一个引用，那么必然有个成员变量去接收。没错，代理对象的内部确实有个成员变量invocationHandler，而且代理对象的每个方法内部都会调用handler.invoke()！ InvocationHandler对象成了代理对象和目标对象的桥梁，不像静态代理这么直接。 大家仔细看上图右侧的动态代理，我在invocationHandler的invoke()方法中并没有写目标对象。因为一开始invocationHandler的invoke()里确实没有目标对象，需要我们手动new。 但这种写法不够优雅，属于硬编码。我这次代理A对象，下次想代理B对象还要进来改invoke()方法，太差劲了。改进一下，让调用者把目标对象作为参数传进来： public class ProxyTest { public static void main(String[] args) throws Throwable { CalculatorImpl target = new CalculatorImpl(); //传入目标对象 //目的：1.根据它实现的接口生成代理对象 2.代理对象调用目标对象方法 Calculator calculatorProxy = (Calculator) getProxy(target); calculatorProxy.add(1, 2); calculatorProxy.subtract(2, 1); } private static Object getProxy(final Object target) throws Exception { //参数1：随便找个类加载器给它， 参数2：目标对象实现的接口，让代理对象实现相同接口 Class proxyClazz = Proxy.getProxyClass(target.getClass().getClassLoader(), target.getClass().getInterfaces()); Constructor constructor = proxyClazz.getConstructor(InvocationHandler.class); Object proxy = constructor.newInstance(new InvocationHandler() { @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { System.out.println(method.getName() + \"方法开始执行...\"); Object result = method.invoke(target, args); System.out.println(result); System.out.println(method.getName() + \"方法执行结束...\"); return result; } }); return proxy; } } 这样就非常灵活，非常优雅了。无论现在系统有多少类，只要你把实例传进来，getProxy()都能给你返回对应的代理对象。就这样，我们完美地跳过了代理类，直接创建了代理对象！ 不过实际编程中，一般不用getProxyClass()，而是使用Proxy类的另一个静态方法：Proxy.newProxyInstance()，直接返回代理实例，连中间得到代理Class对象的过程都帮你隐藏： public class ProxyTest { public static void main(String[] args) throws Throwable { CalculatorImpl target = new CalculatorImpl(); Calculator calculatorProxy = (Calculator) getProxy(target); calculatorProxy.add(1, 2); calculatorProxy.subtract(2, 1); } private static Object getProxy(final Object target) throws Exception { Object proxy = Proxy.newProxyInstance( target.getClass().getClassLoader(),/*类加载器*/ target.getClass().getInterfaces(),/*让代理对象和目标对象实现相同接口*/ new InvocationHandler(){/*代理对象的方法最终都会被JVM导向它的invoke方法*/ public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { System.out.println(method.getName() + \"方法开始执行...\"); Object result = method.invoke(target, args); System.out.println(result); System.out.println(method.getName() + \"方法执行结束...\"); return result; } } ); return proxy; } } 现在，我想大家应该能看懂动态代理了。 那么来张小图做总结： ","date":"2022-02-20","objectID":"/posts/java%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E8%AF%A6%E8%A7%A3/:2:0","tags":["Java动态代理详解"],"title":"Java动态代理详解","uri":"/posts/java%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E8%AF%A6%E8%A7%A3/"},{"categories":["Java底层原理"],"content":"代理的真正作用（实践） ","date":"2022-02-20","objectID":"/posts/java%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E8%AF%A6%E8%A7%A3/:3:0","tags":["Java动态代理详解"],"title":"Java动态代理详解","uri":"/posts/java%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E8%AF%A6%E8%A7%A3/"},{"categories":["Java底层原理"],"content":"静态代理的作用 假如我们有一个字体提供类，有多种实现（从磁盘，从网络，从系统） public interface FontProvider { Font getFont(String name); } public abstract class ProviderFactory { public static FontProvider getFontProvider() { return new FontProviderFromDisk(); } } public class Main() { public static void main(String[] args) { FontProvider fontProvider = ProviderFactory.getFontProvider(); Font font = fontProvider.getFont(\"微软雅黑\"); ...... } } 现在我们希望给他加上一个缓存功能，我们可以用静态代理来完成。 public class CachedFontProvider implements FontProvider { private FontProvider fontProvider; private Map\u003cString, Font\u003e cached; public CachedFontProvider(FontProvider fontProvider) { this.fontProvider = fontProvider; } public Font getFont(String name) { Font font = cached.get(name); if (font == null) { font = fontProvider.getFont(name); cached.put(name, font); } return font; } } /* 对工厂类进行相应修改，代码使用处不必进行任何修改。 这也是面向接口编程以及工厂模式的一个好处 */ public abstract class ProviderFactory { public static FontProvider getFontProvider() { return new CachedFontProvider(new FontProviderFromDisk()); } } 当然，我们直接修改FontProviderFromDisk类也可以实现目的，但是我们还有FontProviderFromNet, FontProviderFromSystem等多种实现类，一一修改太过繁琐且易出错。 况且将来还可能添加日志，权限检查，异常处理等功能显然用代理类更好一点。 ","date":"2022-02-20","objectID":"/posts/java%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E8%AF%A6%E8%A7%A3/:3:1","tags":["Java动态代理详解"],"title":"Java动态代理详解","uri":"/posts/java%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E8%AF%A6%E8%A7%A3/"},{"categories":["Java底层原理"],"content":"动态代理的运用场景（减少重复劳作） 比如：考虑以下各种情况，有多个提供类，每个类都有getXxx(String name)方法，每个类都要加入缓存功能，使用静态代理虽然也能实现，但是也是略显繁琐，需要手动一一创建代理类。 public abstract class ProviderFactory { public static FontProvider getFontProvider() {...} public static ImageProvider getImageProvider() {...} public static MusicProvider getMusicProvider() {...} ...... } 使用动态代理怎么完成呢？(只需一份缓存版本实现即可) public class CachedProviderHandler implements InvocationHandler { private Map\u003cString, Object\u003e cached = new HashMap\u003c\u003e(); private Object target; public CachedProviderHandler(Object target) { this.target = target; } public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { Type[] types = method.getParameterTypes(); //关键逻辑：当调用的是get方法时，我们就来发挥缓冲区的作用 if (method.getName().matches(\"get.+\") \u0026\u0026 (types.length == 1) \u0026\u0026 (types[0] == String.class)) { String key = (String) args[0]; Object value = cached.get(key); if (value == null) { value = method.invoke(target, args); cached.put(key, value); } return value; } return method.invoke(target, args); } } public abstract class ProviderFactory { public static FontProvider getFontProvider() { Class\u003cFontProvider\u003e targetClass = FontProvider.class; return (FontProvider) Proxy.newProxyInstance(targetClass.getClassLoader(), new Class[] { targetClass }, new CachedProviderHandler(new FontProviderFromDisk())); } } ","date":"2022-02-20","objectID":"/posts/java%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E8%AF%A6%E8%A7%A3/:3:2","tags":["Java动态代理详解"],"title":"Java动态代理详解","uri":"/posts/java%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E8%AF%A6%E8%A7%A3/"},{"categories":["Java底层原理"],"content":"总结 很明显，动态代理在需要大量静态代理的情况下，大大减少了重复劳作，动态代理yyds！(不知道C++如何去实现动态代理。。) ","date":"2022-02-20","objectID":"/posts/java%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E8%AF%A6%E8%A7%A3/:3:3","tags":["Java动态代理详解"],"title":"Java动态代理详解","uri":"/posts/java%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E8%AF%A6%E8%A7%A3/"},{"categories":["算法——排序原理运用"],"content":"PAT甲级--Insertion-or-Heap-Sort","date":"2022-02-19","objectID":"/posts/pat%E7%94%B2%E7%BA%A7-insertion-or-heap-sort/","tags":["PAT甲级--Insertion-or-Heap-Sort"],"title":"PAT甲级--Insertion-or-Heap-Sort","uri":"/posts/pat%E7%94%B2%E7%BA%A7-insertion-or-heap-sort/"},{"categories":["算法——排序原理运用"],"content":"题目 OJ平台 ","date":"2022-02-19","objectID":"/posts/pat%E7%94%B2%E7%BA%A7-insertion-or-heap-sort/:1:0","tags":["PAT甲级--Insertion-or-Heap-Sort"],"title":"PAT甲级--Insertion-or-Heap-Sort","uri":"/posts/pat%E7%94%B2%E7%BA%A7-insertion-or-heap-sort/"},{"categories":["算法——排序原理运用"],"content":"题目大意 有很多题目实际不需要看懂题目，只需要看懂输入和输出，比如这题。 此题虽然题目较为学术，且比较长，实际总结下来就是，通过给你一个原数组序列，还有一个用插入排序或者是堆排序排了几轮的数组序列，你要根据这个序列判断所使用的排序方式，并且再以该排序方式往下排一轮。 ","date":"2022-02-19","objectID":"/posts/pat%E7%94%B2%E7%BA%A7-insertion-or-heap-sort/:2:0","tags":["PAT甲级--Insertion-or-Heap-Sort"],"title":"PAT甲级--Insertion-or-Heap-Sort","uri":"/posts/pat%E7%94%B2%E7%BA%A7-insertion-or-heap-sort/"},{"categories":["算法——排序原理运用"],"content":"解题代码拆解 这次由于我使用的接口化函数设计，也就是传入指针进行操作，没有采用全局变量，所以直接input操作写在main函数里面，省空间。 ","date":"2022-02-19","objectID":"/posts/pat%E7%94%B2%E7%BA%A7-insertion-or-heap-sort/:3:0","tags":["PAT甲级--Insertion-or-Heap-Sort"],"title":"PAT甲级--Insertion-or-Heap-Sort","uri":"/posts/pat%E7%94%B2%E7%BA%A7-insertion-or-heap-sort/"},{"categories":["算法——排序原理运用"],"content":"关键的判断函数 isInsert() 设计思路：假设为插入排序后的序列，通过一次循环，找到下一个要被排序的元素位置，按理来说，没有被排序的位置应该和原数组的序列情况一致，如果不一致，则不是插入排序。 //用于确定是否为插入排序，顺便返回此时待插入处理的位置 int isInsert(int* nums, int len) { int i = 1; for (; i \u003c len; i++) { if (nums[i - 1] \u003e nums[i]) break; } for (int j = i; j \u003c len; j++) { if (original[j] != nums[j]) return -1; } return i; } ","date":"2022-02-19","objectID":"/posts/pat%E7%94%B2%E7%BA%A7-insertion-or-heap-sort/:3:1","tags":["PAT甲级--Insertion-or-Heap-Sort"],"title":"PAT甲级--Insertion-or-Heap-Sort","uri":"/posts/pat%E7%94%B2%E7%BA%A7-insertion-or-heap-sort/"},{"categories":["算法——排序原理运用"],"content":"堆排序和插入排序 插入排序 插入排序很简单，我这里直接写插入排序的每一轮处理函数来代替。 //插入排序的单步处理 void InsertSort(int* nums, int numSize, int i) { int j = i; int temp = nums[i]; for (; j \u003e 0 \u0026\u0026 nums[j - 1] \u003e temp; j--) { nums[j] = nums[j - 1]; } nums[j] = temp; } 堆排序 堆排序的原理： 对于一个完整的堆排序，分为两个过程：堆化+维持堆化。 建立大根堆，每次堆化找到最大值，为了维持堆的结构和排序，将堆顶与最后一个元素交换，然后更新堆的范围到 0~i-1 再次堆化，又能找到这个堆中的最大值，长此以往，便完成了排序。 对于堆排序中的每一轮：堆排中的每一轮都是缩小堆的范围，并继续维持大根堆，在堆范围以外的元素就是被排好的元素。所以重点在于从后往前找到已经排到了哪个位置，再进行一次交换和堆化便可完成一轮排序。 堆排的过程： 向下堆化的函数：sift_down() //堆化，得到大根堆 //对于从0开始编号的二叉堆: /* iparent = (i-1)/2, ilchild = i*2+1, irchild = i*2+2 */ void sift_down(int arr[], int start, int end) { // 计算父结点和子结点的下标 int parent = start; int child = parent * 2 + 1; while (child \u003c= end) { // 子结点下标在范围内才做比较 // 先比较两个子结点大小，选择最大的 if (child + 1 \u003c= end \u0026\u0026 arr[child] \u003c arr[child + 1]) child++; // 如果父结点比子结点大，代表调整完毕，直接跳出函数 if (arr[parent] \u003e= arr[child]) return; else { // 否则交换父子内容，子结点再和孙结点比较 swap(arr[parent], arr[child]); parent = child; child = parent * 2 + 1; } } } 先完全堆化，再利用它挑选最大值维持堆化的过程：heap_sort() void heap_sort(int arr[], int len) { // 从最后一个节点的父节点开始 sift down 以完成堆化 (heapify) for (int i = (len - 1 - 1) / 2; i \u003e= 0; i--) sift_down(arr, i, len - 1); // 先将第一个元素和已经排好的元素前一位做交换，再重新调整（刚调整的元素之前的元素），直到排序完毕 for (int i = len - 1; i \u003e 0; i--) { swap(arr[0], arr[i]); sift_down(arr, 0, i - 1); } } 方便更新下一轮堆排的工具： 确定堆排序到哪个位置的函数：findP //由于堆排是从后往前先得出最大值，所以直接从后往前判断最大值位置即可得出堆排排到了哪一轮 int findP(int* nums, int len) { int i = 0; for (; i \u003c len; i++) { int val = *max_element(nums, nums + len - i); if (nums[len - 1 - i] != val) break; } return len - 1 - i; } ","date":"2022-02-19","objectID":"/posts/pat%E7%94%B2%E7%BA%A7-insertion-or-heap-sort/:3:2","tags":["PAT甲级--Insertion-or-Heap-Sort"],"title":"PAT甲级--Insertion-or-Heap-Sort","uri":"/posts/pat%E7%94%B2%E7%BA%A7-insertion-or-heap-sort/"},{"categories":["算法——排序原理运用"],"content":"整合代码进行提交 效率还行！ #include \u003cbits/stdc++.h\u003eusing namespace std; int* original = nullptr; //插入排序的单步处理 void InsertSort(int* nums, int numSize, int i) { int j = i; int temp = nums[i]; for (; j \u003e 0 \u0026\u0026 nums[j - 1] \u003e temp; j--) { nums[j] = nums[j - 1]; } nums[j] = temp; } //堆排序 void sift_down(int arr[], int start, int end) { // 计算父结点和子结点的下标 int parent = start; int child = parent * 2 + 1; while (child \u003c= end) { // 子结点下标在范围内才做比较 // 先比较两个子结点大小，选择最大的 if (child + 1 \u003c= end \u0026\u0026 arr[child] \u003c arr[child + 1]) child++; // 如果父结点比子结点大，代表调整完毕，直接跳出函数 if (arr[parent] \u003e= arr[child]) return; else { // 否则交换父子内容，子结点再和孙结点比较 swap(arr[parent], arr[child]); parent = child; child = parent * 2 + 1; } } } //用于找出堆排已经拍到了哪个位置的最大值。 int findP(int* nums, int len) { int i = 0; for (; i \u003c len; i++) { int val = *max_element(nums, nums + len - i); if (nums[len - 1 - i] != val) break; } return len - 1 - i; } //用于确定是否为插入排序，顺便返回此时待插入处理的位置 int isInsert(int* nums, int len) { int i = 1; for (; i \u003c len; i++) { if (nums[i - 1] \u003e nums[i]) break; } for (int j = i; j \u003c len; j++) { if (original[j] != nums[j]) return -1; } return i; } //统一打印结果函数 void print(int* nums, int len) { cout \u003c\u003c nums[0]; for (int i = 1; i \u003c len; i++) { cout \u003c\u003c ' ' \u003c\u003c nums[i]; } } int main() { //@输入处理 ios::sync_with_stdio(false); int N; cin \u003e\u003e N; int org[N], nums[N]; for (int i = 0; i \u003c N; ++i) { cin \u003e\u003e org[i]; } for (int i = 0; i \u003c N; ++i) { cin \u003e\u003e nums[i]; } //@根据不同的排序方式进行答案的打印 original = org; int flag = isInsert(nums, N); if (flag != -1) { cout \u003c\u003c \"Insertion Sort\" \u003c\u003c endl; InsertSort(nums, N, flag); print(nums, N); } else { cout \u003c\u003c \"Heap Sort\" \u003c\u003c endl; int pos = findP(nums, N); swap(nums[0], nums[pos]); sift_down(nums, 0, pos - 1); print(nums, N); } return 0; } ","date":"2022-02-19","objectID":"/posts/pat%E7%94%B2%E7%BA%A7-insertion-or-heap-sort/:3:3","tags":["PAT甲级--Insertion-or-Heap-Sort"],"title":"PAT甲级--Insertion-or-Heap-Sort","uri":"/posts/pat%E7%94%B2%E7%BA%A7-insertion-or-heap-sort/"},{"categories":["算法——贪心"],"content":"堆的运用——有序元素的多路归并topk问题","date":"2022-02-19","objectID":"/posts/%E5%A0%86%E7%9A%84%E8%BF%90%E7%94%A8%E6%9C%89%E5%BA%8F%E5%85%83%E7%B4%A0%E7%9A%84%E5%A4%9A%E8%B7%AF%E5%BD%92%E5%B9%B6topk%E9%97%AE%E9%A2%98/","tags":["堆的运用——有序元素的多路归并topk问题"],"title":"堆的运用——有序元素的多路归并topk问题","uri":"/posts/%E5%A0%86%E7%9A%84%E8%BF%90%E7%94%A8%E6%9C%89%E5%BA%8F%E5%85%83%E7%B4%A0%E7%9A%84%E5%A4%9A%E8%B7%AF%E5%BD%92%E5%B9%B6topk%E9%97%AE%E9%A2%98/"},{"categories":["算法——贪心"],"content":"题目一：有序矩阵第k小的元素(提炼出做题方法) 题目链接 ","date":"2022-02-19","objectID":"/posts/%E5%A0%86%E7%9A%84%E8%BF%90%E7%94%A8%E6%9C%89%E5%BA%8F%E5%85%83%E7%B4%A0%E7%9A%84%E5%A4%9A%E8%B7%AF%E5%BD%92%E5%B9%B6topk%E9%97%AE%E9%A2%98/:1:0","tags":["堆的运用——有序元素的多路归并topk问题"],"title":"堆的运用——有序元素的多路归并topk问题","uri":"/posts/%E5%A0%86%E7%9A%84%E8%BF%90%E7%94%A8%E6%9C%89%E5%BA%8F%E5%85%83%E7%B4%A0%E7%9A%84%E5%A4%9A%E8%B7%AF%E5%BD%92%E5%B9%B6topk%E9%97%AE%E9%A2%98/"},{"categories":["算法——贪心"],"content":"解题技法 感觉这张图基本就清楚了这题目如何解。 具体详解过程请看lc大神：题目详解 ","date":"2022-02-19","objectID":"/posts/%E5%A0%86%E7%9A%84%E8%BF%90%E7%94%A8%E6%9C%89%E5%BA%8F%E5%85%83%E7%B4%A0%E7%9A%84%E5%A4%9A%E8%B7%AF%E5%BD%92%E5%B9%B6topk%E9%97%AE%E9%A2%98/:2:0","tags":["堆的运用——有序元素的多路归并topk问题"],"title":"堆的运用——有序元素的多路归并topk问题","uri":"/posts/%E5%A0%86%E7%9A%84%E8%BF%90%E7%94%A8%E6%9C%89%E5%BA%8F%E5%85%83%E7%B4%A0%E7%9A%84%E5%A4%9A%E8%B7%AF%E5%BD%92%E5%B9%B6topk%E9%97%AE%E9%A2%98/"},{"categories":["算法——贪心"],"content":"解题代码 class Solution { public: //TODO 多路归并 int kthSmallest(vector\u003cvector\u003cint\u003e\u003e\u0026 matrix, int k) { auto cmp = [\u0026](pair\u003cint,int\u003e\u0026a,pair\u003cint,int\u003e\u0026b){ return matrix[a.first][a.second]\u003ematrix[b.first][b.second]; }; priority_queue\u003cpair\u003cint,int\u003e,vector\u003cpair\u003cint,int\u003e\u003e,decltype(cmp)\u003epq(cmp); int n = matrix.size(); for(int i=0;i\u003cmin(k,n);i++){ pq.push({i,0});//TODO 得到第一次的行首元素 } int ret = INT_MAX; while(k--\u0026\u0026!pq.empty()){ auto [x,y] = pq.top();pq.pop(); if(y+1\u003cn)//TODO 更新这一行的下一个元素到堆中 pq.push({x,y+1}); ret = matrix[x][y]; } return ret; } }; ","date":"2022-02-19","objectID":"/posts/%E5%A0%86%E7%9A%84%E8%BF%90%E7%94%A8%E6%9C%89%E5%BA%8F%E5%85%83%E7%B4%A0%E7%9A%84%E5%A4%9A%E8%B7%AF%E5%BD%92%E5%B9%B6topk%E9%97%AE%E9%A2%98/:3:0","tags":["堆的运用——有序元素的多路归并topk问题"],"title":"堆的运用——有序元素的多路归并topk问题","uri":"/posts/%E5%A0%86%E7%9A%84%E8%BF%90%E7%94%A8%E6%9C%89%E5%BA%8F%E5%85%83%E7%B4%A0%E7%9A%84%E5%A4%9A%E8%B7%AF%E5%BD%92%E5%B9%B6topk%E9%97%AE%E9%A2%98/"},{"categories":["算法——贪心"],"content":"(进阶运用)题目二：查找和最小的K对数字 题目链接 ","date":"2022-02-19","objectID":"/posts/%E5%A0%86%E7%9A%84%E8%BF%90%E7%94%A8%E6%9C%89%E5%BA%8F%E5%85%83%E7%B4%A0%E7%9A%84%E5%A4%9A%E8%B7%AF%E5%BD%92%E5%B9%B6topk%E9%97%AE%E9%A2%98/:4:0","tags":["堆的运用——有序元素的多路归并topk问题"],"title":"堆的运用——有序元素的多路归并topk问题","uri":"/posts/%E5%A0%86%E7%9A%84%E8%BF%90%E7%94%A8%E6%9C%89%E5%BA%8F%E5%85%83%E7%B4%A0%E7%9A%84%E5%A4%9A%E8%B7%AF%E5%BD%92%E5%B9%B6topk%E9%97%AE%E9%A2%98/"},{"categories":["算法——贪心"],"content":"题目解析 和前面那道题的做法一样，这道题是由于者均有序，所以如果是直接进行两层循环的枚举的话，得到的数字可以看作是一个和上题一模一样的矩阵，也就是把 nums1[0...]+nums2[0] 看作是一行的首元素即可，然后处理过程就和前面的处理过程是完全一致。和前面一题的区别仅仅在于未有确定矩阵的内容而已，而我们需要做的就是确定这个矩阵的内容！ 细节优化：由于矩阵的内容由我们来确定，为了防止初始化矩阵首行元素过多，我们可以采取把长度小的 nums 作为行的标准，那么为了让每次的答案顺序不变，所以需要一个标记。 ","date":"2022-02-19","objectID":"/posts/%E5%A0%86%E7%9A%84%E8%BF%90%E7%94%A8%E6%9C%89%E5%BA%8F%E5%85%83%E7%B4%A0%E7%9A%84%E5%A4%9A%E8%B7%AF%E5%BD%92%E5%B9%B6topk%E9%97%AE%E9%A2%98/:5:0","tags":["堆的运用——有序元素的多路归并topk问题"],"title":"堆的运用——有序元素的多路归并topk问题","uri":"/posts/%E5%A0%86%E7%9A%84%E8%BF%90%E7%94%A8%E6%9C%89%E5%BA%8F%E5%85%83%E7%B4%A0%E7%9A%84%E5%A4%9A%E8%B7%AF%E5%BD%92%E5%B9%B6topk%E9%97%AE%E9%A2%98/"},{"categories":["算法——贪心"],"content":"解题代码 class Solution { public: bool flag = true; vector\u003cvector\u003cint\u003e\u003e kSmallestPairs(vector\u003cint\u003e\u0026 nums1, vector\u003cint\u003e\u0026 nums2, int k) { vector\u003cvector\u003cint\u003e\u003e ans; int n = nums1.size(), m = nums2.size(); if(n \u003e m) { //始终确保nums1为两数组中长度较少的那个(这样做可以适当的减少堆的初始大小)，这个不处理也可以，只是简单的优化 swap(nums1, nums2); swap(m,n); flag = false;//确保原本的第一个取数的数字时nums1原本的数字 } //定义比较规则 auto cmp = [\u0026](const auto\u0026 a, const auto\u0026 b){ return nums1[a.first] + nums2[a.second] \u003e nums1[b.first] + nums2[b.second]; }; priority_queue\u003c pair\u003cint,int\u003e, vector\u003cpair\u003cint,int\u003e\u003e, decltype(cmp) \u003e q(cmp); for(int i = 0; i \u003c min(n,k); i++){ q.push( {i, 0} ); } while(k-- and !q.empty()){ auto [a,b] = q.top(); q.pop(); flag ? ans.push_back( {nums1[a], nums2[b]}) : ans.push_back( {nums2[b], nums1[a]}); //TODO 得到这一行的下一个元素，如果超过则不入 if(b + 1 \u003c m) q.push( {a, b + 1} ); } return ans; } }; ","date":"2022-02-19","objectID":"/posts/%E5%A0%86%E7%9A%84%E8%BF%90%E7%94%A8%E6%9C%89%E5%BA%8F%E5%85%83%E7%B4%A0%E7%9A%84%E5%A4%9A%E8%B7%AF%E5%BD%92%E5%B9%B6topk%E9%97%AE%E9%A2%98/:6:0","tags":["堆的运用——有序元素的多路归并topk问题"],"title":"堆的运用——有序元素的多路归并topk问题","uri":"/posts/%E5%A0%86%E7%9A%84%E8%BF%90%E7%94%A8%E6%9C%89%E5%BA%8F%E5%85%83%E7%B4%A0%E7%9A%84%E5%A4%9A%E8%B7%AF%E5%BD%92%E5%B9%B6topk%E9%97%AE%E9%A2%98/"},{"categories":["算法——排序原理运用"],"content":"归并的运用——计算逆序对","date":"2022-02-19","objectID":"/posts/%E5%BD%92%E5%B9%B6%E7%9A%84%E8%BF%90%E7%94%A8%E8%AE%A1%E7%AE%97%E9%80%86%E5%BA%8F%E5%AF%B9/","tags":["归并的运用——计算逆序数"],"title":"归并的运用——计算逆序数","uri":"/posts/%E5%BD%92%E5%B9%B6%E7%9A%84%E8%BF%90%E7%94%A8%E8%AE%A1%E7%AE%97%E9%80%86%E5%BA%8F%E5%AF%B9/"},{"categories":["算法——排序原理运用"],"content":"题目 题目链接 ","date":"2022-02-19","objectID":"/posts/%E5%BD%92%E5%B9%B6%E7%9A%84%E8%BF%90%E7%94%A8%E8%AE%A1%E7%AE%97%E9%80%86%E5%BA%8F%E5%AF%B9/:1:0","tags":["归并的运用——计算逆序数"],"title":"归并的运用——计算逆序数","uri":"/posts/%E5%BD%92%E5%B9%B6%E7%9A%84%E8%BF%90%E7%94%A8%E8%AE%A1%E7%AE%97%E9%80%86%E5%BA%8F%E5%AF%B9/"},{"categories":["算法——排序原理运用"],"content":"题目解析 很明显此题的问题规模来到了 1e5 的级别，显然不是 O(n^2) 的暴力方式能够解决的。 具体的详细解析，这里有力扣大神在：题目解析 我这里把最关键的图解过程扣了下来： ","date":"2022-02-19","objectID":"/posts/%E5%BD%92%E5%B9%B6%E7%9A%84%E8%BF%90%E7%94%A8%E8%AE%A1%E7%AE%97%E9%80%86%E5%BA%8F%E5%AF%B9/:2:0","tags":["归并的运用——计算逆序数"],"title":"归并的运用——计算逆序数","uri":"/posts/%E5%BD%92%E5%B9%B6%E7%9A%84%E8%BF%90%E7%94%A8%E8%AE%A1%E7%AE%97%E9%80%86%E5%BA%8F%E5%AF%B9/"},{"categories":["算法——排序原理运用"],"content":"解题代码 配上这简洁清晰的解题代码： class Solution { public: int reversePairs(vector\u003cint\u003e\u0026 nums) { vector\u003cint\u003e tmp(nums.size()); return mergeSort(0, nums.size() - 1, nums, tmp); } private: int mergeSort(int l, int r, vector\u003cint\u003e\u0026 nums, vector\u003cint\u003e\u0026 tmp) { // 终止条件 if (l \u003e= r) return 0; // 递归划分 int m = (l + r) / 2; int res = mergeSort(l, m, nums, tmp) + mergeSort(m + 1, r, nums, tmp); // 合并阶段 int i = l, j = m + 1; for (int k = l; k \u003c= r; k++) tmp[k] = nums[k]; for (int k = l; k \u003c= r; k++) { if (i == m + 1) nums[k] = tmp[j++]; else if (j == r + 1 || tmp[i] \u003c= tmp[j]) nums[k] = tmp[i++]; else { nums[k] = tmp[j++]; res += m - i + 1; // 统计逆序对 } } return res; } }; ","date":"2022-02-19","objectID":"/posts/%E5%BD%92%E5%B9%B6%E7%9A%84%E8%BF%90%E7%94%A8%E8%AE%A1%E7%AE%97%E9%80%86%E5%BA%8F%E5%AF%B9/:3:0","tags":["归并的运用——计算逆序数"],"title":"归并的运用——计算逆序数","uri":"/posts/%E5%BD%92%E5%B9%B6%E7%9A%84%E8%BF%90%E7%94%A8%E8%AE%A1%E7%AE%97%E9%80%86%E5%BA%8F%E5%AF%B9/"},{"categories":["算法——排序原理运用"],"content":"煎饼排序——选择排序的运用","date":"2022-02-19","objectID":"/posts/%E7%85%8E%E9%A5%BC%E6%8E%92%E5%BA%8F%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%E7%9A%84%E8%BF%90%E7%94%A8/","tags":["煎饼排序——选择排序的运用"],"title":"煎饼排序——选择排序的运用","uri":"/posts/%E7%85%8E%E9%A5%BC%E6%8E%92%E5%BA%8F%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%E7%9A%84%E8%BF%90%E7%94%A8/"},{"categories":["算法——排序原理运用"],"content":"题目 题目链接 ","date":"2022-02-19","objectID":"/posts/%E7%85%8E%E9%A5%BC%E6%8E%92%E5%BA%8F%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%E7%9A%84%E8%BF%90%E7%94%A8/:1:0","tags":["煎饼排序——选择排序的运用"],"title":"煎饼排序——选择排序的运用","uri":"/posts/%E7%85%8E%E9%A5%BC%E6%8E%92%E5%BA%8F%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%E7%9A%84%E8%BF%90%E7%94%A8/"},{"categories":["算法——排序原理运用"],"content":"解题思路 读懂题目： 此题并不是要我们求出类似于示例所给的最优情况的方式得出答案。 他只要能够翻转成有序的操作序列即可。 故我们可以按照选择排序的思路，利用翻转能够将首尾交换，来进行两次翻转把最大值移动到最后的位置，第一次翻转到首位，第二次翻转到后面的位置即可。 具体例子： 例如:[3,2,4,1]—-\u003e[?,?,?,4] 我们可以先找到数字4的位置,将数字4前进行翻转变成[4,2,3,1],接下来我们在整体翻转[1,3,2,4],这样我们把数字4移动列表底. 然后,我们[1,3,2,4]—\u003e[?,?,3,4],还是用刚才方法,首先找到数字3,翻转数字3前面的,再翻转已经排好数字(这里指数字4)前就可以了. ","date":"2022-02-19","objectID":"/posts/%E7%85%8E%E9%A5%BC%E6%8E%92%E5%BA%8F%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%E7%9A%84%E8%BF%90%E7%94%A8/:2:0","tags":["煎饼排序——选择排序的运用"],"title":"煎饼排序——选择排序的运用","uri":"/posts/%E7%85%8E%E9%A5%BC%E6%8E%92%E5%BA%8F%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%E7%9A%84%E8%BF%90%E7%94%A8/"},{"categories":["算法——排序原理运用"],"content":"解题代码 class Solution { public: vector\u003cint\u003e pancakeSort(vector\u003cint\u003e \u0026arr) { int n = arr.size(); vector\u003cint\u003e ret; while (n \u003e 1) { if (arr[n - 1] != n) { int index = find_if(arr.begin(), arr.end(), [n](auto \u0026num) { if (num == n) return true; return false; }) - arr.begin(); ret.push_back(index + 1); ret.push_back(n); reverse(arr.begin(), arr.begin() + index + 1); reverse(arr.begin(), arr.begin() + n); } --n; } return ret; } }; ","date":"2022-02-19","objectID":"/posts/%E7%85%8E%E9%A5%BC%E6%8E%92%E5%BA%8F%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%E7%9A%84%E8%BF%90%E7%94%A8/:3:0","tags":["煎饼排序——选择排序的运用"],"title":"煎饼排序——选择排序的运用","uri":"/posts/%E7%85%8E%E9%A5%BC%E6%8E%92%E5%BA%8F%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%E7%9A%84%E8%BF%90%E7%94%A8/"},{"categories":["算法——排序原理运用"],"content":"高频面试考点(考察分治思想)：合并k个排序链表","date":"2022-02-19","objectID":"/posts/%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E8%80%83%E7%82%B9%E8%80%83%E5%AF%9F%E5%88%86%E6%B2%BB%E6%80%9D%E6%83%B3%E5%90%88%E5%B9%B6k%E4%B8%AA%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8/","tags":["高频面试考点(考察分治思想)：合并k个排序链表"],"title":"高频面试考点(考察分治思想)：合并k个排序链表","uri":"/posts/%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E8%80%83%E7%82%B9%E8%80%83%E5%AF%9F%E5%88%86%E6%B2%BB%E6%80%9D%E6%83%B3%E5%90%88%E5%B9%B6k%E4%B8%AA%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8/"},{"categories":["算法——排序原理运用"],"content":"题目 题目解析 很明显，这种多个有序链表的排序可以分解为，两个过程： 合并两个有序链表的函数。 实现多次调用合并两个有序链表。 关于分治法如何优化该过程的？很明显如果直接从左往右调用多次合并两个有序链表来实现需要调用n-1次，而分治法通过先把数组分割成两个数组元素为一个基本的操作对象，那么很明显可以优化为调用logn次。 以下是两种方式的时间差距： 解题代码 朴素解法 class Solution { public: ListNode* mergeKLists(vector\u003cListNode*\u003e\u0026 lists) { int size = lists.size(); if(size==0) return nullptr; ListNode* res = lists[0]; for(int i=1;i\u003csize;i++){ res = mergeTwo(res,lists[i]); } return res; } private: ListNode* mergeTwo(ListNode* a,ListNode* b){ ListNode h; ListNode * head = \u0026h; ListNode* res = head; while(a\u0026\u0026b){ if(a-\u003eval\u003eb-\u003eval){ head-\u003enext = b; b = b-\u003enext; head = head-\u003enext; }else{ head-\u003enext = a; a = a-\u003enext; head = head-\u003enext; } } if(b){ head-\u003enext = b; }else{ head-\u003enext = a; } return res-\u003enext; } }; 分治法 class Solution { public: ListNode* mergeKLists(vector\u003cListNode*\u003e\u0026 lists) { return merge(lists,0,lists.size()-1); } private: ListNode* merge(vector \u003cListNode*\u003e \u0026lists, int l, int r) { if (l == r) return lists[l]; if (l \u003e r) return nullptr; int mid = (l + r) \u003e\u003e 1; //开始分治 return mergeTwo(merge(lists, l, mid), merge(lists, mid + 1, r)); } ListNode* mergeTwo(ListNode* a,ListNode* b){ ListNode h; ListNode * head = \u0026h; ListNode* res = head; while(a\u0026\u0026b){ if(a-\u003eval\u003eb-\u003eval){ head-\u003enext = b; b = b-\u003enext; head = head-\u003enext; }else{ head-\u003enext = a; a = a-\u003enext; head = head-\u003enext; } } if(b){ head-\u003enext = b; }else{ head-\u003enext = a; } return res-\u003enext; } }; ","date":"2022-02-19","objectID":"/posts/%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E8%80%83%E7%82%B9%E8%80%83%E5%AF%9F%E5%88%86%E6%B2%BB%E6%80%9D%E6%83%B3%E5%90%88%E5%B9%B6k%E4%B8%AA%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8/:0:0","tags":["高频面试考点(考察分治思想)：合并k个排序链表"],"title":"高频面试考点(考察分治思想)：合并k个排序链表","uri":"/posts/%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E8%80%83%E7%82%B9%E8%80%83%E5%AF%9F%E5%88%86%E6%B2%BB%E6%80%9D%E6%83%B3%E5%90%88%E5%B9%B6k%E4%B8%AA%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8/"},{"categories":["算法——动态规划"],"content":"骑士在棋盘上的概率——dp棋盘概率题","date":"2022-02-18","objectID":"/posts/%E9%AA%91%E5%A3%AB%E5%9C%A8%E6%A3%8B%E7%9B%98%E4%B8%8A%E7%9A%84%E6%A6%82%E7%8E%87dp%E6%A3%8B%E7%9B%98%E6%A6%82%E7%8E%87%E9%A2%98/","tags":["骑士在棋盘上的概率——dp棋盘概率题"],"title":"骑士在棋盘上的概率——dp棋盘概率题","uri":"/posts/%E9%AA%91%E5%A3%AB%E5%9C%A8%E6%A3%8B%E7%9B%98%E4%B8%8A%E7%9A%84%E6%A6%82%E7%8E%87dp%E6%A3%8B%E7%9B%98%E6%A6%82%E7%8E%87%E9%A2%98/"},{"categories":["算法——动态规划"],"content":"题目 题目链接 ","date":"2022-02-18","objectID":"/posts/%E9%AA%91%E5%A3%AB%E5%9C%A8%E6%A3%8B%E7%9B%98%E4%B8%8A%E7%9A%84%E6%A6%82%E7%8E%87dp%E6%A3%8B%E7%9B%98%E6%A6%82%E7%8E%87%E9%A2%98/:1:0","tags":["骑士在棋盘上的概率——dp棋盘概率题"],"title":"骑士在棋盘上的概率——dp棋盘概率题","uri":"/posts/%E9%AA%91%E5%A3%AB%E5%9C%A8%E6%A3%8B%E7%9B%98%E4%B8%8A%E7%9A%84%E6%A6%82%E7%8E%87dp%E6%A3%8B%E7%9B%98%E6%A6%82%E7%8E%87%E9%A2%98/"},{"categories":["算法——动态规划"],"content":"题目详解 一个骑士有 $8$ 种可能的走法，骑士会从中以等概率随机选择一种。部分走法可能会让骑士离开棋盘，另外的走法则会让骑士移动到棋盘的其他位置，并且剩余的移动次数会减少 1。 定义 $dp[step][i][j]$ 表示其实从棋盘商店的点 $(i,j)$ 出发，走了 $step$ 步时仍然留在棋盘上的概率。 当点 $(i,j)$ 不在棋盘上的时候，$dp[step][i][j] = 0;$ 当点 $(i,j)$ 在棋盘上且 $step = 0$ 时，$dp[step][i][j]=1$ 。 对于其他情况，$dp[step][i][j]=1/8×∑dp[step-1][i+di][j+dj]$。 其中$(di,dj)$ 表示走法对坐标的偏移量，具体为 $(−2,−1),(−2,1),(2,−1),(2,1),(−1,−2),(−1,2),(1,−2),(1,2)$ 共 $8$ 种。 ","date":"2022-02-18","objectID":"/posts/%E9%AA%91%E5%A3%AB%E5%9C%A8%E6%A3%8B%E7%9B%98%E4%B8%8A%E7%9A%84%E6%A6%82%E7%8E%87dp%E6%A3%8B%E7%9B%98%E6%A6%82%E7%8E%87%E9%A2%98/:2:0","tags":["骑士在棋盘上的概率——dp棋盘概率题"],"title":"骑士在棋盘上的概率——dp棋盘概率题","uri":"/posts/%E9%AA%91%E5%A3%AB%E5%9C%A8%E6%A3%8B%E7%9B%98%E4%B8%8A%E7%9A%84%E6%A6%82%E7%8E%87dp%E6%A3%8B%E7%9B%98%E6%A6%82%E7%8E%87%E9%A2%98/"},{"categories":["算法——动态规划"],"content":"解题代码 class Solution { public: vector\u003cvector\u003cint\u003e\u003e dirs = {{-2, -1}, {-2, 1}, {2, -1}, {2, 1}, {-1, -2}, {-1, 2}, {1, -2}, {1, 2}}; double knightProbability(int n, int k, int row, int column) { vector\u003cvector\u003cvector\u003cdouble\u003e\u003e\u003e dp(k + 1, vector\u003cvector\u003cdouble\u003e\u003e(n, vector\u003cdouble\u003e(n))); for (int step = 0; step \u003c= k; step++) { for (int i = 0; i \u003c n; i++) { for (int j = 0; j \u003c n; j++) { if (step == 0) { dp[step][i][j] = 1; } else { for (auto \u0026 dir : dirs) { int ni = i + dir[0], nj = j + dir[1]; if (ni \u003e= 0 \u0026\u0026 ni \u003c n \u0026\u0026 nj \u003e= 0 \u0026\u0026 nj \u003c n) { dp[step][i][j] += dp[step - 1][ni][nj] / 8; } } } } } } return dp[k][row][column]; } }; ","date":"2022-02-18","objectID":"/posts/%E9%AA%91%E5%A3%AB%E5%9C%A8%E6%A3%8B%E7%9B%98%E4%B8%8A%E7%9A%84%E6%A6%82%E7%8E%87dp%E6%A3%8B%E7%9B%98%E6%A6%82%E7%8E%87%E9%A2%98/:3:0","tags":["骑士在棋盘上的概率——dp棋盘概率题"],"title":"骑士在棋盘上的概率——dp棋盘概率题","uri":"/posts/%E9%AA%91%E5%A3%AB%E5%9C%A8%E6%A3%8B%E7%9B%98%E4%B8%8A%E7%9A%84%E6%A6%82%E7%8E%87dp%E6%A3%8B%E7%9B%98%E6%A6%82%E7%8E%87%E9%A2%98/"},{"categories":["手写数据结构"],"content":"C++手撕哈希表详解","date":"2022-02-16","objectID":"/posts/c++%E6%89%8B%E6%92%95%E5%93%88%E5%B8%8C%E8%A1%A8%E8%AF%A6%E8%A7%A3/","tags":["C/C++手撕哈希表详解"],"title":"C/C++手撕哈希表详解","uri":"/posts/c++%E6%89%8B%E6%92%95%E5%93%88%E5%B8%8C%E8%A1%A8%E8%AF%A6%E8%A7%A3/"},{"categories":["手写数据结构"],"content":"关于实现源码 实现源码仓库在线查看链接： C语言实现 C++实现 ","date":"2022-02-16","objectID":"/posts/c++%E6%89%8B%E6%92%95%E5%93%88%E5%B8%8C%E8%A1%A8%E8%AF%A6%E8%A7%A3/:0:0","tags":["C/C++手撕哈希表详解"],"title":"C/C++手撕哈希表详解","uri":"/posts/c++%E6%89%8B%E6%92%95%E5%93%88%E5%B8%8C%E8%A1%A8%E8%AF%A6%E8%A7%A3/"},{"categories":["手写数据结构"],"content":"哈希表的理论知识 ","date":"2022-02-16","objectID":"/posts/c++%E6%89%8B%E6%92%95%E5%93%88%E5%B8%8C%E8%A1%A8%E8%AF%A6%E8%A7%A3/:1:0","tags":["C/C++手撕哈希表详解"],"title":"C/C++手撕哈希表详解","uri":"/posts/c++%E6%89%8B%E6%92%95%E5%93%88%E5%B8%8C%E8%A1%A8%E8%AF%A6%E8%A7%A3/"},{"categories":["手写数据结构"],"content":"哈希表的定义 哈希表也叫散列表，我们先来看看哈希表的定义： 哈希表是保存键值映射关系的查找表，通过关键字可以很快找到对应的值。 简单说来说，哈希表由两个要素构成：桶数组 和 散列函数（哈希函数）。 桶数组：用于存储键值对的空间。 散列函数：用于给键值对在桶数组中的位置指路。 ","date":"2022-02-16","objectID":"/posts/c++%E6%89%8B%E6%92%95%E5%93%88%E5%B8%8C%E8%A1%A8%E8%AF%A6%E8%A7%A3/:1:1","tags":["C/C++手撕哈希表详解"],"title":"C/C++手撕哈希表详解","uri":"/posts/c++%E6%89%8B%E6%92%95%E5%93%88%E5%B8%8C%E8%A1%A8%E8%AF%A6%E8%A7%A3/"},{"categories":["手写数据结构"],"content":"桶数组 我们可能知道，有一类基础的数据结构 线性表，而线性表又分两种，数组 和 链表。 哈希表数据结构里，存储元素的数据结构就是数组，数组里的每个单元都可以想象成一个 桶（Bucket）。 而我们每次都是把我们需要存入的键值对加入到这样的桶子中。 ","date":"2022-02-16","objectID":"/posts/c++%E6%89%8B%E6%92%95%E5%93%88%E5%B8%8C%E8%A1%A8%E8%AF%A6%E8%A7%A3/:1:2","tags":["C/C++手撕哈希表详解"],"title":"C/C++手撕哈希表详解","uri":"/posts/c++%E6%89%8B%E6%92%95%E5%93%88%E5%B8%8C%E8%A1%A8%E8%AF%A6%E8%A7%A3/"},{"categories":["手写数据结构"],"content":"散列函数 我们需要在元素和 桶数组 对应位置建立一种映射映射关系，这种映射关系就是 散列函数 ，也可以叫哈希函数。 比如我们平时生活中，碰到排队型的时候，都需要根据高矮来进行一定的队形调整，这个调整过程也可以看做是散列函数的一种体现。 散列函数的构造 散列函数有很多类，这其中的奥妙来自于数学，而不是我们程序员需要过于操心的事情。 在Java语言中只要是继承自Object类的所有类都有默认的一个 hashcode() 方法，而对于具体过程我们不需要多想，我们来看看最常用的字符串的哈希过程： static inline size_t strHashcode(char *key) { size_t hash = 0; size_t index = 0; while (key[index] != '\\0') { hash = hash * 31 + key[index++]; } return hash; } 很明显得出的 hashcode 是一个以31为底的次方数，关于为什么以31为底，我这里简单的描述一下： 以31为底能很快得出比较散且比较大的二进制码（底层的01串），这样结合子掩码的与运算有利于减少哈希冲突的产生。 31 * i == (i \u003c\u003c 5) - i 因为这个等式的成立使得运算性能也有很大的提升。（编译器一般会对 31*i 进行优化的） 更多细节看看这篇文章：关于为什么选31 扰动函数 和 按位与 我们通过散列函数得到一堆 01 串后，我们该怎么做？ 接下来一般就是通过和桶数组的长度取余然后得到对应的位置进行插入。这样虽然也可以，但我们有更好的方式进行替代，那就是位运算。 既然要讲位运算，那么我先讲讲一个二进制串。 在只有一个 1 的二进制串里面，我们对它再减去 1 的时候，我们很快得到它的低位掩码。 比如： 0001000 - 1 = 0000111，得到的 0000111 有什么用处呢？ 如果我们把一个 hashcode 和这个数进行按位与，则得到的结果肯定是介于 000~111 之间，也就是 0~7 之间，这个时候我们思考一下，如果把这个 0001000 看做是桶数组的长度，那么这个按位与的结果就可以当做需要存入的桶的具体位置了。 基于这个理论，我们只要桶数组长度是 2的倍数 则 hashcode%size 可用 hashcode\u0026(size-1) 来替代。 这样做有以下好处： 位运算的性能更好。 便于控制 hashcode 最终得出的结果，有些时候我们得到的 hashcode不够均匀 高位的1比较多，而低位的1比较少，这个时候可以利用 hashcode^(hashcode\u003e\u003e16) 进行一定程度的打散，而这个打散的过程我们一般把它叫做 扰动函数 。 哈希冲突 当出现键值运算结果得到的桶子位置是同一个的时候便产生了哈希冲突。 而解决哈希冲突的方案一般有以下三种： 链地址法 一旦发生哈希冲突，直接生成链表往后继续延伸。 开放地址法 简单来说就是给冲突的元素再在桶数组里找到一个空闲的位置。 而常用采用的方法有： 线性探查法: 从冲突的位置开始，依次判断下一个位置是否空闲，直至找到空闲位置。 平方探查法: 从冲突的位置x开始，第一次增加 1^2 个位置，第二次增加 2^2…，直至找到空闲的位置。 双散列函数探查法 …… 再哈希法 再哈希法完全可以配备以上两类方法进行使用。 当然也可单独使用，单独使用的话就行配备多个哈希函数，一个不行的话换另一个哈希函数，直到不产生哈希冲突为止。 最终的选择： 而我们常用的是 链地址法 + 再哈希 ，为了能够尽量减少内存空间的使用，我们默认从容量为 16 的桶数组开始，一旦装入的键值对超过 capacity * factor 个时，我们进行一次两倍的（左移1位）扩容，而由于扩容会导致 capacity 改变，所以通过 哈希函数 + 与运算 得出的位置也会出错，故需要经过 再哈希 。 我们其实可以继续细想，我们左移一位后，得出的结果再减一，它也仅仅多出一位掩码，而我们的 hashcode 只要在这一位上为 0 则最后得到的桶位置不会有任何改变，只有在这一位上为 1 的才会发生改变，所以根据这个特点，Java 8 进行了一些优化，更厉害的优化方式在于，只要链比较长，它还会转红黑树（这就在我的能力范围之外了）。 以上内容参考的文章为：一个HashMap和面试官扯了半小时 ","date":"2022-02-16","objectID":"/posts/c++%E6%89%8B%E6%92%95%E5%93%88%E5%B8%8C%E8%A1%A8%E8%AF%A6%E8%A7%A3/:1:3","tags":["C/C++手撕哈希表详解"],"title":"C/C++手撕哈希表详解","uri":"/posts/c++%E6%89%8B%E6%92%95%E5%93%88%E5%B8%8C%E8%A1%A8%E8%AF%A6%E8%A7%A3/"},{"categories":["手写数据结构"],"content":"HashMap实现 ","date":"2022-02-16","objectID":"/posts/c++%E6%89%8B%E6%92%95%E5%93%88%E5%B8%8C%E8%A1%A8%E8%AF%A6%E8%A7%A3/:2:0","tags":["C/C++手撕哈希表详解"],"title":"C/C++手撕哈希表详解","uri":"/posts/c++%E6%89%8B%E6%92%95%E5%93%88%E5%B8%8C%E8%A1%A8%E8%AF%A6%E8%A7%A3/"},{"categories":["手写数据结构"],"content":"类型定义（键值对以及对应节点） C #define DEFAULT_CAPACITY 16 //初始的表长 #define DEFAULT_FACTOR 0.75f //初始的装载因子 /*类型定义 和 装载因子初始化*/ typedef int key_t; typedef int val_t; static const float factor = DEFAULT_FACTOR; //装载因子 typedef struct node {//每个哈希表的键值对 key_t key; val_t val; struct node *next; } Node; C++ 全程用的泛型模板 ","date":"2022-02-16","objectID":"/posts/c++%E6%89%8B%E6%92%95%E5%93%88%E5%B8%8C%E8%A1%A8%E8%AF%A6%E8%A7%A3/:2:1","tags":["C/C++手撕哈希表详解"],"title":"C/C++手撕哈希表详解","uri":"/posts/c++%E6%89%8B%E6%92%95%E5%93%88%E5%B8%8C%E8%A1%A8%E8%AF%A6%E8%A7%A3/"},{"categories":["手写数据结构"],"content":"哈希表的数据 C typedef struct { size_t size; //记录已经存下的键值对数目 size_t capacity; //记录表长 Node **buckets; //桶子：用于记录的哈希桶，桶子中每个元素是Node* } HashMap; C++ ","date":"2022-02-16","objectID":"/posts/c++%E6%89%8B%E6%92%95%E5%93%88%E5%B8%8C%E8%A1%A8%E8%AF%A6%E8%A7%A3/:2:2","tags":["C/C++手撕哈希表详解"],"title":"C/C++手撕哈希表详解","uri":"/posts/c++%E6%89%8B%E6%92%95%E5%93%88%E5%B8%8C%E8%A1%A8%E8%AF%A6%E8%A7%A3/"},{"categories":["手写数据结构"],"content":"初始化方法（构造方法） C HashMap *init() { //初始化得到一个哈希表 HashMap *ret = (HashMap *) malloc(sizeof(HashMap)); assert(ret != NULL); ret-\u003esize = 0; ret-\u003ecapacity = DEFAULT_CAPACITY; ret-\u003ebuckets = (Node **) calloc(DEFAULT_CAPACITY, sizeof(Node *)); assert(ret-\u003ebuckets != NULL); return ret; } C++ ","date":"2022-02-16","objectID":"/posts/c++%E6%89%8B%E6%92%95%E5%93%88%E5%B8%8C%E8%A1%A8%E8%AF%A6%E8%A7%A3/:2:3","tags":["C/C++手撕哈希表详解"],"title":"C/C++手撕哈希表详解","uri":"/posts/c++%E6%89%8B%E6%92%95%E5%93%88%E5%B8%8C%E8%A1%A8%E8%AF%A6%E8%A7%A3/"},{"categories":["手写数据结构"],"content":"根据散列函数得到位置 C static inline size_t getHashcode(key_t key) { return key ^ (key \u003e\u003e 16);//这是32位数的扰动函数 } static inline size_t getIndex(key_t key, size_t bucket_size) {//由于bucketsize一定是2的次方，所以size-1和key相与得到的就是下标 return getHashcode(key) \u0026 (bucket_size - 1); } C++ ","date":"2022-02-16","objectID":"/posts/c++%E6%89%8B%E6%92%95%E5%93%88%E5%B8%8C%E8%A1%A8%E8%AF%A6%E8%A7%A3/:2:4","tags":["C/C++手撕哈希表详解"],"title":"C/C++手撕哈希表详解","uri":"/posts/c++%E6%89%8B%E6%92%95%E5%93%88%E5%B8%8C%E8%A1%A8%E8%AF%A6%E8%A7%A3/"},{"categories":["手写数据结构"],"content":"put方法 C void put(HashMap *map, key_t key, val_t val) { assert(map != NULL); //判断是否需要扩容 if (map-\u003esize \u003e= map-\u003ecapacity * factor) resize(map); putVal(key, val, map-\u003ebuckets, \u0026map-\u003esize, map-\u003ecapacity); } static void putVal(key_t key, val_t val, Node **buckets, size_t *returnSize, size_t bucketSize) { //获取位置 size_t index = getIndex(key, bucketSize); Node *node = buckets[index]; if (node == NULL) {//插入位置为空 node = (Node *) malloc(sizeof(Node)); assert(node != NULL); node-\u003eval = val; node-\u003ekey = key; node-\u003enext = NULL; buckets[index] = node; (*returnSize)++; //哈希表内的元素增加 return; } //插入位置不为空，说明发生冲突，使用链地址法，遍历链表 while (node != NULL) { //如果key相同就覆盖 if (node-\u003ekey == key) { node-\u003eval = val; return; } node = node-\u003enext; } //当前的key不在链表中，则插入链表头部 Node *newNode = (Node *) malloc(sizeof(Node)); assert(newNode != NULL); newNode-\u003enext = buckets[index]; buckets[index] = newNode; (*returnSize)++; //哈希表内元素增加 } C++ ","date":"2022-02-16","objectID":"/posts/c++%E6%89%8B%E6%92%95%E5%93%88%E5%B8%8C%E8%A1%A8%E8%AF%A6%E8%A7%A3/:2:5","tags":["C/C++手撕哈希表详解"],"title":"C/C++手撕哈希表详解","uri":"/posts/c++%E6%89%8B%E6%92%95%E5%93%88%E5%B8%8C%E8%A1%A8%E8%AF%A6%E8%A7%A3/"},{"categories":["手写数据结构"],"content":"扩容方法 C static void resize(HashMap *map) { map-\u003ecapacity \u003c\u003c= 1; //扩大两倍容量，相当于左移一位 Node **tmp = map-\u003ebuckets; //存下之前的内存地址 map-\u003ebuckets = (Node **) calloc(map-\u003ecapacity, sizeof(Node *)); //重新分配 assert(map-\u003ebuckets != NULL); rehash(map, tmp);//重新哈希处理 free(tmp); //释放之前的内存 } static void rehash(HashMap *map, Node **preTable) {//采取java1.7的方式进行rehash也就是最简单直接的直接重新哈希插入 size_t preCap = map-\u003ecapacity / 2; //改变前的有效区域 for (size_t i = 0; i \u003c preCap; i++) { if (preTable[i] != NULL) {//判断对应的key是否需要重新换位置,如果对最新掩码多出来的1敏感则需要rehash Node *preNode; Node *curNode = preTable[i]; while (curNode != NULL) { preNode = curNode; curNode = curNode-\u003enext; insert(map, preNode); } } } } C++ ","date":"2022-02-16","objectID":"/posts/c++%E6%89%8B%E6%92%95%E5%93%88%E5%B8%8C%E8%A1%A8%E8%AF%A6%E8%A7%A3/:2:6","tags":["C/C++手撕哈希表详解"],"title":"C/C++手撕哈希表详解","uri":"/posts/c++%E6%89%8B%E6%92%95%E5%93%88%E5%B8%8C%E8%A1%A8%E8%AF%A6%E8%A7%A3/"},{"categories":["手写数据结构"],"content":"get方法 C val_t *get(HashMap *map, key_t key) {//前面的写好后，那么get就很好写了 int index = getIndex(key, map-\u003ecapacity); Node *node = map-\u003ebuckets[index]; while (node != NULL) { if (node-\u003ekey == key) { return \u0026(node-\u003eval); } node = node-\u003enext; } return NULL;//没找到返回NULL指针 } C++ C++标准中主要采用重载下标运算符的方式进行get。 ","date":"2022-02-16","objectID":"/posts/c++%E6%89%8B%E6%92%95%E5%93%88%E5%B8%8C%E8%A1%A8%E8%AF%A6%E8%A7%A3/:2:7","tags":["C/C++手撕哈希表详解"],"title":"C/C++手撕哈希表详解","uri":"/posts/c++%E6%89%8B%E6%92%95%E5%93%88%E5%B8%8C%E8%A1%A8%E8%AF%A6%E8%A7%A3/"},{"categories":["手写数据结构"],"content":"完整代码 C完整代码 C++完整代码 ","date":"2022-02-16","objectID":"/posts/c++%E6%89%8B%E6%92%95%E5%93%88%E5%B8%8C%E8%A1%A8%E8%AF%A6%E8%A7%A3/:2:8","tags":["C/C++手撕哈希表详解"],"title":"C/C++手撕哈希表详解","uri":"/posts/c++%E6%89%8B%E6%92%95%E5%93%88%E5%B8%8C%E8%A1%A8%E8%AF%A6%E8%A7%A3/"},{"categories":["手写数据结构"],"content":"测试：LeetCode 1.两数之和 这效率在用C语言哈希表的方法里面应该是无敌的存在了。。。试了下比UT_HASH还要快一些☺ 再看看之前写的比较烂的哈希表的效率😂 测试源码： // // Created by L_B__ on 2021/11/24. // //底层的表长都用2的次方，然后-1后可以得到低位掩码 //该设计理念急于java1.7的源代码，本来是想基于1.8的实现， // 因为1.8巧妙太多，比如对rehash尽量能不动的就不动，再比如对于链比较长的结构直接转红黑树。可惜能力不能及 /** * 简单说明：static修饰的函数为单文件的中间委托功能函数，不对外公开 * 简单的功能函数介绍： * init()得到一个默认表长的哈希表 * put()插入键值，内部自动进行内存的申请 * get()得到key对应的val的地址，若不存在该键值对返回NULL * insert()外界已经分配好node的内存和key\u0026val对，进行哈希运算后直接插入即可 * destroy()把整个哈希表牵扯的所有内存释放 * **/ #include \u003cassert.h\u003e#include \u003cstdlib.h\u003e#ifndef MY_TINY_STL_HASHMAP_C_H #define MY_TINY_STL_HASHMAP_C_H #define DEFAULT_CAPACITY 128 //初始的表长 #define DEFAULT_FACTOR 0.75f //初始的装载因子 /*类型定义 和 装载因子初始化*/ typedef int key_t; typedef int val_t ; static const float factor = DEFAULT_FACTOR; //装载因子 typedef struct node{//每个哈希表的键值对 key_t key; val_t val; struct node* next; }Node; typedef struct { size_t size; //记录已经存下的键值对数目 size_t capacity; //记录表长 Node** buckets; //桶子：用于记录的哈希桶，桶子中每个元素是Node* }HashMap; /*函数的声明*/ HashMap* init(); void put(HashMap*,key_t,val_t); void insert(HashMap*,Node*); //直接把已经分配好的内存插入哈希表 static void putVal(key_t,val_t,Node**,size_t*,size_t); //这个是put的委托函数,用于直接更新桶子，并更新HashMap的size static inline size_t getHashcode(key_t ); //得到key对应的hashcode static inline size_t getIndex(key_t,size_t); //通过桶的大小和key映射位置，算是包含了关键的哈希函数：由于C不支持泛型也就无法针对不同类型作出不同的哈希了，我这里默认key为int static void resize(HashMap*); //如果插入的元素过多，*2进行重新哈希分配 static void rehash(HashMap*,Node**); //重新设置长度则需要重新哈希一些key的位置 val_t* get(HashMap*,key_t); //得到key对应的val static void del_nodes(Node*); //把单个链表销毁 void destroy(HashMap*); //把哈希表的内存销毁 /*函数实现*/ HashMap* init(){ //初始化得到一个哈希表 HashMap * ret = (HashMap*)malloc(sizeof(HashMap)); assert(ret!=NULL); ret-\u003esize = 0; ret-\u003ecapacity = DEFAULT_CAPACITY; ret-\u003ebuckets = (Node**)calloc(DEFAULT_CAPACITY,sizeof(Node*)); assert(ret-\u003ebuckets!=NULL); return ret; } void insert(HashMap* map,Node* node){ assert(map!=NULL\u0026\u0026node!=NULL); size_t index = getIndex(node-\u003ekey,map-\u003ecapacity); if(map-\u003ebuckets[index]==NULL){ node-\u003enext = NULL; map-\u003ebuckets[index] = node; }else{ node-\u003enext = map-\u003ebuckets[index]; map-\u003ebuckets[index] = node; } } void put(HashMap* map,key_t key,val_t val){ assert(map != NULL); //判断是否需要扩容 if(map-\u003esize \u003e= map-\u003ecapacity*factor) resize(map); putVal(key,val,map-\u003ebuckets,\u0026map-\u003esize,map-\u003ecapacity); } static inline size_t getHashcode(key_t key){ return key ^ (key\u003e\u003e16);//这是32位数的扰动函数 } static inline size_t getIndex(key_t key,size_t bucket_size){//由于bucketsize一定是2的次方，所以size-1和key相与得到的就是下标 return getHashcode(key)\u0026(bucket_size-1); } static void putVal(key_t key,val_t val,Node** buckets,size_t* returnSize,size_t bucketSize){ //获取位置 size_t index = getIndex(key,bucketSize); Node * node = buckets[index]; if(node==NULL){//插入位置为空 node = (Node*)malloc(sizeof(Node)); assert(node!=NULL); node-\u003eval = val; node-\u003ekey = key; node-\u003enext = NULL; buckets[index] = node; (*returnSize)++; //哈希表内的元素增加 return; } //插入位置不为空，说明发生冲突，使用链地址法，遍历链表 while (node!=NULL){ //如果key相同就覆盖 if(node-\u003ekey==key){ node-\u003eval = val; return; } node = node-\u003enext; } //当前的key不在链表中，则插入链表头部 Node* newNode = (Node*)malloc(sizeof(Node)); assert(newNode != NULL); newNode-\u003enext = buckets[index]; buckets[index] = newNode; (*returnSize)++; //哈希表内元素增加 } static void resize(HashMap* map){ map-\u003ecapacity \u003c\u003c= 1; //扩大两倍容量，相当于左移一位 Node ** tmp = map-\u003ebuckets; //存下之前的内存地址 map-\u003ebuckets = (Node**)calloc(map-\u003ecapacity,sizeof(Node*)); //重新分配 assert(map-\u003ebuckets!=NULL); rehash(map,tmp);//重新哈希处理 free(tmp); //释放之前的内存 } static void rehash(HashMap* map,Node** preTable){//采取java1.7的方式进行rehash也就是最简单直接的直接重新哈希插入 size_t preCap = map-\u003ecapacity / 2; //改变前的有效区域 for(size_t i=0;i\u003cpreCap;i++){ if(preTable[i] != NULL){//判断对应的key是否需要重新换位置,如果对最新掩码多出来的1敏感则需要rehash Node *preNode; Node *curNode = preTable[i]; while (curNode!=NULL){ preNode = curNode; curNode = curNode-\u003enext; insert(map,preNode); } } } } val_t* get(HashMap* map,key_t key){//前面的写好后，那么get就很好写了 int index = getIndex(key,map-\u003ecapacity); Node * node = map-\u003ebuckets[index]; while (node != NULL){ if(node-\u003ekey==key){ retur","date":"2022-02-16","objectID":"/posts/c++%E6%89%8B%E6%92%95%E5%93%88%E5%B8%8C%E8%A1%A8%E8%AF%A6%E8%A7%A3/:2:9","tags":["C/C++手撕哈希表详解"],"title":"C/C++手撕哈希表详解","uri":"/posts/c++%E6%89%8B%E6%92%95%E5%93%88%E5%B8%8C%E8%A1%A8%E8%AF%A6%E8%A7%A3/"},{"categories":["手写数据结构"],"content":"总结 通过这次手撕比较规范的哈希表的收获： 更加深入的理解了哈希表的基本实现思想。 从LeetCode刷题无用的感觉到有用，比如时刻需要的链表增删操作。 有点遗憾，没能按照java1.8的思路再进一步优化哈希表。 看了很多大厂的面试题，现在对哈希表这块数据结构的考量是越来越严苛了，比如你如果走的 java 后端岗位，面试可能需要你回答 java HashMap 源码的相关实现部分，深挖原理，而不是死记硬背了，所以最好的学习方式就是学习源码，然后根据学到的思想自己实现一些功能。 参考： [1]. 《数据结构与算法》 [2]. HashMap跟面试官扯了半个小时 [3]. hashCode 为什么乘以 31？ ","date":"2022-02-16","objectID":"/posts/c++%E6%89%8B%E6%92%95%E5%93%88%E5%B8%8C%E8%A1%A8%E8%AF%A6%E8%A7%A3/:3:0","tags":["C/C++手撕哈希表详解"],"title":"C/C++手撕哈希表详解","uri":"/posts/c++%E6%89%8B%E6%92%95%E5%93%88%E5%B8%8C%E8%A1%A8%E8%AF%A6%E8%A7%A3/"},{"categories":["JavaWeb笔记"],"content":"Java连接数据库","date":"2022-02-16","objectID":"/posts/java%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93/","tags":["Java连接数据库"],"title":"Java连接数据库","uri":"/posts/java%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"categories":["JavaWeb笔记"],"content":"Java与数据库 通过Java如何去使用数据库来帮助我们存储数据呢，这将是本章节讨论的重点。 ","date":"2022-02-16","objectID":"/posts/java%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93/:0:0","tags":["Java连接数据库"],"title":"Java连接数据库","uri":"/posts/java%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"categories":["JavaWeb笔记"],"content":"初识JDBC JDBC是什么？JDBC英文名为：Java Data Base Connectivity(Java数据库连接)，官方解释它是Java编程语言和广泛的数据库之间独立于数据库的连接标准的Java API，根本上说JDBC是一种规范，它提供的接口，一套完整的，允许便捷式访问底层数据库。可以用JAVA来写不同类型的可执行文件：JAVA应用程序、JAVA Applets、Java Servlet、JSP等，不同的可执行文件都能通过JDBC访问数据库，又兼备存储的优势。简单说它就是Java与数据库的连接的桥梁或者插件，用Java代码就能操作数据库的增删改查、存储过程、事务等。 我们可以发现，JDK自带了一个java.sql包，而这里面就定义了大量的接口，不同类型的数据库，都可以通过实现此接口，编写适用于自己数据库的实现类。而不同的数据库厂商实现的这套标准，我们称为数据库驱动。 ","date":"2022-02-16","objectID":"/posts/java%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93/:1:0","tags":["Java连接数据库"],"title":"Java连接数据库","uri":"/posts/java%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"categories":["JavaWeb笔记"],"content":"准备工作 那么我们首先来进行一些准备工作，以便开始JDBC的学习： 将idea连接到我们的数据库，以便以后调试。 将mysql驱动jar依赖导入到项目中（推荐6.0版本以上，这里用到是8.0） 向Jetbrians申请一个学生/教师授权，用于激活idea终极版（进行JavaWeb开发需要用到，一般申请需要3-7天时间审核）不是大学生的话…emmm…懂的都懂。 教育授权申请地址：https://www.jetbrains.com/shop/eform/students 一个Java程序并不是一个人的战斗，我们可以在别人开发的基础上继续向上开发，其他的开发者可以将自己编写的Java代码打包为jar，我们只需要导入这个jar作为依赖，即可直接使用别人的代码，就像我们直接去使用JDK提供的类一样。 ","date":"2022-02-16","objectID":"/posts/java%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93/:1:1","tags":["Java连接数据库"],"title":"Java连接数据库","uri":"/posts/java%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"categories":["JavaWeb笔记"],"content":"使用JDBC连接数据库 **注意：**6.0版本以上，不用手动加载驱动，我们直接使用即可！ //1. 通过DriverManager来获得数据库连接 try (Connection connection = DriverManager.getConnection(\"连接URL\",\"用户名\",\"密码\"); //2. 创建一个用于执行SQL的Statement对象 Statement statement = connection.createStatement()){ //注意前两步都放在try()中，因为在最后需要释放资源！ //3. 执行SQL语句，并得到结果集 ResultSet set = statement.executeQuery(\"select * from 表名\"); //4. 查看结果 while (set.next()){ ... } }catch (SQLException e){ e.printStackTrace(); } //5. 释放资源，try-with-resource语法会自动帮助我们close 其中，连接的URL如果记不住格式，我们可以打开idea的数据库连接配置，复制一份即可。（其实idea本质也是使用的JDBC，整个idea程序都是由Java编写的，实际上idea就是一个Java程序） ","date":"2022-02-16","objectID":"/posts/java%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93/:1:2","tags":["Java连接数据库"],"title":"Java连接数据库","uri":"/posts/java%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"categories":["JavaWeb笔记"],"content":"了解DriverManager 我们首先来了解一下DriverManager是什么东西，它其实就是管理我们的数据库驱动的： public static synchronized void registerDriver(java.sql.Driver driver, DriverAction da) throws SQLException { /* Register the driver if it has not already been added to our list */ if(driver != null) { registeredDrivers.addIfAbsent(new DriverInfo(driver, da)); //在刚启动时，mysql实现的驱动会被加载，我们可以断点调试一下。 } else { // This is for compatibility with the original DriverManager throw new NullPointerException(); } println(\"registerDriver: \" + driver); } 我们可以通过调用getConnection()来进行数据库的链接： @CallerSensitive public static Connection getConnection(String url, String user, String password) throws SQLException { java.util.Properties info = new java.util.Properties(); if (user != null) { info.put(\"user\", user); } if (password != null) { info.put(\"password\", password); } return (getConnection(url, info, Reflection.getCallerClass())); //内部有实现 } 我们可以手动为驱动管理器添加一个日志打印： static { DriverManager.setLogWriter(new PrintWriter(System.out)); //这里直接设定为控制台输出 } 现在我们执行的数据库操作日志会在控制台实时打印。 ","date":"2022-02-16","objectID":"/posts/java%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93/:1:3","tags":["Java连接数据库"],"title":"Java连接数据库","uri":"/posts/java%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"categories":["JavaWeb笔记"],"content":"了解Connection Connection是数据库的连接对象，可以通过连接对象来创建一个Statement用于执行SQL语句： Statement createStatement() throws SQLException; 我们发现除了普通的Statement，还存在PreparedStatement： PreparedStatement prepareStatement(String sql) throws SQLException; 在后面我们会详细介绍PreparedStatement的使用，它能够有效地预防SQL注入式攻击。 它还支持事务的处理，也放到后面来详细进行讲解。 ","date":"2022-02-16","objectID":"/posts/java%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93/:1:4","tags":["Java连接数据库"],"title":"Java连接数据库","uri":"/posts/java%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"categories":["JavaWeb笔记"],"content":"了解Statement 我们发现，我们之前使用了executeQuery()方法来执行select语句，此方法返回给我们一个ResultSet对象，查询得到的数据，就存放在ResultSet中！ Statement除了执行这样的DQL语句外，我们还可以使用executeUpdate()方法来执行一个DML或是DDL语句，它会返回一个int类型，表示执行后受影响的行数，可以通过它来判断DML语句是否执行成功。 也可以通过excute()来执行任意的SQL语句，它会返回一个boolean来表示执行结果是一个ResultSet还是一个int，我们可以通过使用getResultSet()或是getUpdateCount()来获取。 ","date":"2022-02-16","objectID":"/posts/java%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93/:1:5","tags":["Java连接数据库"],"title":"Java连接数据库","uri":"/posts/java%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"categories":["JavaWeb笔记"],"content":"执行DML操作 我们通过几个例子来向数据库中插入数据。 ","date":"2022-02-16","objectID":"/posts/java%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93/:1:6","tags":["Java连接数据库"],"title":"Java连接数据库","uri":"/posts/java%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"categories":["JavaWeb笔记"],"content":"执行DQL操作 执行DQL操作会返回一个ResultSet对象，我们来看看如何从ResultSet中去获取数据： //首先要明确，select返回的数据类似于一个excel表格 while (set.next()){ //每调用一次next()就会向下移动一行，首次调用会移动到第一行 } 我们在移动行数后，就可以通过set中提供的方法，来获取每一列的数据。 ","date":"2022-02-16","objectID":"/posts/java%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93/:1:7","tags":["Java连接数据库"],"title":"Java连接数据库","uri":"/posts/java%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"categories":["JavaWeb笔记"],"content":"执行批处理操作 当我们要执行很多条语句时，可以不用一次一次地提交，而是一口气全部交给数据库处理，这样会节省很多的时间。 public static void main(String[] args) throws ClassNotFoundException { try (Connection connection = DriverManager.getConnection(); Statement statement = connection.createStatement()){ statement.addBatch(\"insert into user values ('f', 1234)\"); statement.addBatch(\"insert into user values ('e', 1234)\"); //添加每一条批处理语句 statement.executeBatch(); //一起执行 }catch (SQLException e){ e.printStackTrace(); } } ","date":"2022-02-16","objectID":"/posts/java%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93/:1:8","tags":["Java连接数据库"],"title":"Java连接数据库","uri":"/posts/java%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"categories":["JavaWeb笔记"],"content":"将查询结果映射为对象 既然我们现在可以从数据库中获取数据了，那么现在就可以将这些数据转换为一个类来进行操作，首先定义我们的实体类： public class Student { Integer sid; String name; String sex; public Student(Integer sid, String name, String sex) { this.sid = sid; this.name = name; this.sex = sex; } public void say(){ System.out.println(\"我叫：\"+name+\"，学号为：\"+sid+\"，我的性别是：\"+sex); } } 现在我们来进行一个转换： while (set.next()){ Student student = new Student(set.getInt(1), set.getString(2), set.getString(3)); student.say(); } **注意：**列的下标是从1开始的。 我们也可以利用反射机制来将查询结果映射为对象，使用反射的好处是，无论什么类型都可以通过我们的方法来进行实体类型映射： private static \u003cT\u003e T convert(ResultSet set, Class\u003cT\u003e clazz){ try { Constructor\u003cT\u003e constructor = clazz.getConstructor(clazz.getConstructors()[0].getParameterTypes()); //默认获取第一个构造方法 Class\u003c?\u003e[] param = constructor.getParameterTypes(); //获取参数列表 Object[] object = new Object[param.length]; //存放参数 for (int i = 0; i \u003c param.length; i++) { //是从1开始的 object[i] = set.getObject(i+1); if(object[i].getClass() != param[i]) throw new SQLException(\"错误的类型转换：\"+object[i].getClass()+\" -\u003e \"+param[i]); } return constructor.newInstance(object); } catch (ReflectiveOperationException | SQLException e) { e.printStackTrace(); return null; } } 现在我们就可以通过我们的方法来将查询结果转换为一个对象了： while (set.next()){ Student student = convert(set, Student.class); if(student != null) student.say(); } 实际上，在后面我们会学习Mybatis框架，它对JDBC进行了深层次的封装，而它就进行类似上面反射的操作来便于我们对数据库数据与实体类的转换。 ","date":"2022-02-16","objectID":"/posts/java%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93/:1:9","tags":["Java连接数据库"],"title":"Java连接数据库","uri":"/posts/java%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"categories":["JavaWeb笔记"],"content":"实现登陆与SQL注入攻击 在使用之前，我们先来看看如果我们想模拟登陆一个用户，我们该怎么去写： try (Connection connection = DriverManager.getConnection(\"URL\",\"用户名\",\"密码\"); Statement statement = connection.createStatement(); Scanner scanner = new Scanner(System.in)){ ResultSet res = statement.executeQuery(\"select * from user where username='\"+scanner.nextLine()+\"'and pwd='\"+scanner.nextLine()+\"';\"); while (res.next()){ String username = res.getString(1); System.out.println(username+\" 登陆成功！\"); } }catch (SQLException e){ e.printStackTrace(); } 用户可以通过自己输入用户名和密码来登陆，乍一看好像没啥问题，那如果我输入的是以下内容呢： Test1111' or 1=1; -- # Test 登陆成功！ 1=1一定是true，那么我们原本的SQL语句会变为： select*fromuserwhereusername='Test'andpwd='1111'or1=1;-- ' 我们发现，如果允许这样的数据插入，那么我们原有的SQL语句结构就遭到了破坏，使得用户能够随意登陆别人的账号。因此我们可能需要限制用户的输入来防止用户输入一些SQL语句关键字，但是关键字非常多，这并不是解决问题的最好办法。 ","date":"2022-02-16","objectID":"/posts/java%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93/:1:10","tags":["Java连接数据库"],"title":"Java连接数据库","uri":"/posts/java%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"categories":["JavaWeb笔记"],"content":"使用PreparedStatement 我们发现，如果单纯地使用Statement来执行SQL命令，会存在严重的SQL注入攻击漏洞！而这种问题，我们可以使用PreparedStatement来解决： public static void main(String[] args) throws ClassNotFoundException { try (Connection connection = DriverManager.getConnection(\"URL\",\"用户名\",\"密码\"); PreparedStatement statement = connection.prepareStatement(\"select * from user where username= ? and pwd=?;\"); Scanner scanner = new Scanner(System.in)){ statement.setString(1, scanner.nextLine()); statement.setString(2, scanner.nextLine()); System.out.println(statement); //打印查看一下最终执行的 ResultSet res = statement.executeQuery(); while (res.next()){ String username = res.getString(1); System.out.println(username+\" 登陆成功！\"); } }catch (SQLException e){ e.printStackTrace(); } } 我们发现，我们需要提前给到PreparedStatement一个SQL语句，并且使用?作为占位符，它会预编译一个SQL语句，通过直接将我们的内容进行替换的方式来填写数据。使用这种方式，我们之前的例子就失效了！我们来看看实际执行的SQL语句是什么： com.mysql.cj.jdbc.ClientPreparedStatement: select * from user where username= 'Test' and pwd='123456'' or 1=1; -- ';\r我们发现，我们输入的参数一旦出现'时，会被变为转义形式\\'，而最外层有一个真正的'来将我们输入的内容进行包裹，因此它能够有效地防止SQL注入攻击！ ","date":"2022-02-16","objectID":"/posts/java%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93/:1:11","tags":["Java连接数据库"],"title":"Java连接数据库","uri":"/posts/java%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"categories":["JavaWeb笔记"],"content":"管理事务 JDBC默认的事务处理行为是自动提交，所以前面我们执行一个SQL语句就会被直接提交（相当于没有启动事务），所以JDBC需要进行事务管理时，首先要通过Connection对象调用setAutoCommit(false) 方法, 将SQL语句的提交（commit）由驱动程序转交给应用程序负责。 con.setAutoCommit(); //关闭自动提交后相当于开启事务。 // SQL语句 // SQL语句 // SQL语句 con.commit();或 con.rollback(); 一旦关闭自动提交，那么现在执行所有的操作如果在最后不进行commit()来提交事务的话，那么所有的操作都会丢失，只有提交之后，所有的操作才会被保存！也可以使用rollback()来手动回滚之前的全部操作！ public static void main(String[] args) throws ClassNotFoundException { try (Connection connection = DriverManager.getConnection(\"URL\",\"用户名\",\"密码\"); Statement statement = connection.createStatement()){ connection.setAutoCommit(false); //关闭自动提交，现在将变为我们手动提交 statement.executeUpdate(\"insert into user values ('a', 1234)\"); statement.executeUpdate(\"insert into user values ('b', 1234)\"); statement.executeUpdate(\"insert into user values ('c', 1234)\"); connection.commit(); //如果前面任何操作出现异常，将不会执行commit()，之前的操作也就不会生效 }catch (SQLException e){ e.printStackTrace(); } } 我们来接着尝试一下使用回滚操作： public static void main(String[] args) throws ClassNotFoundException { try (Connection connection = DriverManager.getConnection(\"URL\",\"用户名\",\"密码\"); Statement statement = connection.createStatement()){ connection.setAutoCommit(false); //关闭自动提交，现在将变为我们手动提交 statement.executeUpdate(\"insert into user values ('a', 1234)\"); statement.executeUpdate(\"insert into user values ('b', 1234)\"); connection.rollback(); //回滚，撤销前面全部操作 statement.executeUpdate(\"insert into user values ('c', 1234)\"); connection.commit(); //提交事务（注意，回滚之前的内容都没了） }catch (SQLException e){ e.printStackTrace(); } } 同样的，我们也可以去创建一个回滚点来实现定点回滚： public static void main(String[] args) throws ClassNotFoundException { try (Connection connection = DriverManager.getConnection(\"URL\",\"用户名\",\"密码\"); Statement statement = connection.createStatement()){ connection.setAutoCommit(false); //关闭自动提交，现在将变为我们手动提交 statement.executeUpdate(\"insert into user values ('a', 1234)\"); Savepoint savepoint = connection.setSavepoint(); //创建回滚点 statement.executeUpdate(\"insert into user values ('b', 1234)\"); connection.rollback(savepoint); //回滚到回滚点，撤销前面全部操作 statement.executeUpdate(\"insert into user values ('c', 1234)\"); connection.commit(); //提交事务（注意，回滚之前的内容都没了） }catch (SQLException e){ e.printStackTrace(); } } 通过开启事务，我们就可以更加谨慎地进行一些操作了，如果我们想从事务模式切换为原有的自动提交模式，我们可以直接将其设置回去： public static void main(String[] args) throws ClassNotFoundException { try (Connection connection = DriverManager.getConnection(\"URL\",\"用户名\",\"密码\"); Statement statement = connection.createStatement()){ connection.setAutoCommit(false); //关闭自动提交，现在将变为我们手动提交 statement.executeUpdate(\"insert into user values ('a', 1234)\"); connection.setAutoCommit(true); //重新开启自动提交，开启时把之前的事务模式下的内容给提交了 statement.executeUpdate(\"insert into user values ('d', 1234)\"); //没有commit也成功了！ }catch (SQLException e){ e.printStackTrace(); } 通过学习JDBC，我们现在就可以通过Java来访问和操作我们的数据库了！为了更好地衔接，我们还会接着讲解主流持久层框架——Mybatis，加深JDBC的记忆。 ","date":"2022-02-16","objectID":"/posts/java%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93/:1:12","tags":["Java连接数据库"],"title":"Java连接数据库","uri":"/posts/java%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"categories":["JavaWeb笔记"],"content":"使用Lombok 我们发现，在以往编写项目时，尤其是在类进行类内部成员字段封装时，需要编写大量的get/set方法，这不仅使得我们类定义中充满了get和set方法，同时如果字段名称发生改变，又要挨个进行修改，甚至当字段变得很多时，构造方法的编写会非常麻烦！ 通过使用Lombok（小辣椒）就可以解决这样的问题！ 我们来看看，使用原生方式和小辣椒方式编写类的区别，首先是传统方式： public class Student { private Integer sid; private String name; private String sex; public Student(Integer sid, String name, String sex) { this.sid = sid; this.name = name; this.sex = sex; } public Integer getSid() { //长！ return sid; } public void setSid(Integer sid) { //到！ this.sid = sid; } public String getName() { //爆！ return name; } public void setName(String name) { //炸！ this.name = name; } public String getSex() { return sex; } public void setSex(String sex) { this.sex = sex; } } 而使用Lombok之后： @Getter @Setter @AllArgsConstructor public class Student { private Integer sid; private String name; private String sex; } 我们发现，使用Lombok之后，只需要添加几个注解，就能够解决掉我们之前长长的一串代码！ ","date":"2022-02-16","objectID":"/posts/java%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93/:2:0","tags":["Java连接数据库"],"title":"Java连接数据库","uri":"/posts/java%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"categories":["JavaWeb笔记"],"content":"配置Lombok 首先我们需要导入Lombok的jar依赖，和jdbc依赖是一样的，放在项目目录下直接导入就行了。可以在这里进行下载：https://projectlombok.org/download 然后我们要安装一下Lombok插件，由于IDEA默认都安装了Lombok的插件，因此直接导入依赖后就可以使用了。 重启IDEA Lombok是一种插件化注解API，是通过添加注解来实现的，然后在javac进行编译的时候，进行处理。 Java的编译过程可以分成三个阶段： 所有源文件会被解析成语法树。 调用注解处理器。如果注解处理器产生了新的源文件，新文件也要进行编译。 最后，语法树会被分析并转化成类文件。 实际上在上述的第二阶段，会执行*lombok.core.AnnotationProcessor*，它所做的工作就是我们上面所说的，修改语法树。 ","date":"2022-02-16","objectID":"/posts/java%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93/:2:1","tags":["Java连接数据库"],"title":"Java连接数据库","uri":"/posts/java%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"categories":["JavaWeb笔记"],"content":"使用Lombok 我们通过实战来演示一下Lombok的实用注解： 我们通过添加@Getter和@Setter来为当前类的所有字段生成get/set方法，他们可以添加到类或是字段上，注意静态字段不会生成，final字段无法生成set方法。 我们还可以使用@Accessors来控制生成Getter和Setter的样式。 我们通过添加@ToString来为当前类生成预设的toString方法。 我们可以通过添加@EqualsAndHashCode来快速生成比较和哈希值方法。 我们可以通过添加@AllArgsConstructor和@NoArgsConstructor来快速生成全参构造和无参构造。 我们可以添加@RequiredArgsConstructor来快速生成参数只包含final或被标记为@NonNull的成员字段。 使用@Data能代表@Setter、@Getter、@RequiredArgsConstructor、@ToString、@EqualsAndHashCode全部注解。 一旦使用@Data就不建议此类有继承关系，因为equal方法可能不符合预期结果（尤其是仅比较子类属性）。 使用@Value与@Data类似，但是并不会生成setter并且成员属性都是final的。 使用@SneakyThrows来自动生成try-catch代码块。 使用@Cleanup作用与局部变量，在最后自动调用其close()方法（可以自由更换） 使用@Builder来快速生成建造者模式。 通过使用@Builder.Default来指定默认值。 通过使用@Builder.ObtainVia来指定默认值的获取方式。 ","date":"2022-02-16","objectID":"/posts/java%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93/:2:2","tags":["Java连接数据库"],"title":"Java连接数据库","uri":"/posts/java%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"categories":["JavaWeb笔记"],"content":"认识Mybatis 在前面JDBC的学习中，虽然我们能够通过JDBC来连接和操作数据库，但是哪怕只是完成一个SQL语句的执行，都需要编写大量的代码，更不用说如果我还需要进行实体类映射，将数据转换为我们可以直接操作的实体类型，JDBC很方便，但是还不够方便，我们需要一种更加简洁高效的方式来和数据库进行交互。 **再次强调：**学习厉害的框架或是厉害的技术，并不是为了一定要去使用它，而是它们能够使得我们在不同的开发场景下，合理地使用这些技术，以灵活地应对需要解决的问题。 MyBatis 是一款优秀的持久层框架，它支持定制化 SQL、存储过程以及高级映射。MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。MyBatis 可以使用简单的 XML 或注解来配置和映射原生信息，将接口和 Java 的 POJOs(Plain Ordinary Java Object,普通的 Java对象)映射成数据库中的记录。 我们依然使用传统的jar依赖方式，从最原始开始讲起，不使用Maven，有关Maven内容我们会在后面统一讲解！全程围绕官方文档讲解！ 这一块内容很多很杂，再次强调要多实践！ ","date":"2022-02-16","objectID":"/posts/java%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93/:3:0","tags":["Java连接数据库"],"title":"Java连接数据库","uri":"/posts/java%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"categories":["JavaWeb笔记"],"content":"XML语言概述 在开始介绍Mybatis之前，XML语言发明最初是用于数据的存储和传输，它可以长这样： \u003c?xml version=\"1.0\" encoding=\"UTF-8\" ?\u003e \u003couter\u003e \u003cname\u003e阿伟\u003c/name\u003e \u003cdesc\u003e怎么又在玩电动啊\u003c/desc\u003e \u003cinner type=\"1\"\u003e \u003cage\u003e10\u003c/age\u003e \u003csex\u003e男\u003c/sex\u003e \u003c/inner\u003e \u003c/outer\u003e 如果你学习过前端知识，你会发现它和HTML几乎长得一模一样！但是请注意，虽然它们长得差不多，但是他们的意义却不同，HTML主要用于通过编排来展示数据，而XML主要是存放数据，它更像是一个配置文件！当然，浏览器也是可以直接打开XML文件的。 一个XML文件存在以下的格式规范： 必须存在一个根节点，将所有的子标签全部包含。 可以但不必须包含一个头部声明（主要是可以设定编码格式） 所有的标签必须成对出现，可以嵌套但不能交叉嵌套 区分大小写。 标签中可以存在属性，比如上面的type=\"1\"就是inner标签的一个属性，属性的值由单引号或双引号包括。 XML文件也可以使用注释： \u003c?xml version=\"1.0\" encoding=\"UTF-8\" ?\u003e \u003c!-- 注释内容 --\u003e 通过IDEA我们可以使用Ctrl+/来快速添加注释文本（不仅仅适用于XML，还支持很多种类型的文件） 那如果我们的内容中出现了\u003c或是\u003e字符，那该怎么办呢？我们就可以使用XML的转义字符来代替： 如果嫌一个一个改太麻烦，也可以使用CD来快速创建不解析区域： \u003ctest\u003e \u003cname\u003e\u003c![CDATA[我看你\u003c\u003e\u003c\u003e\u003c\u003e是一点都不懂哦\u003e\u003e\u003e]]\u003e\u003c/name\u003e \u003c/test\u003e 那么，我们现在了解了XML文件的定义，现在该如何去解析一个XML文件呢？比如我们希望将定义好的XML文件读取到Java程序中，这时该怎么做呢？ JDK为我们内置了一个叫做org.w3c的XML解析库，我们来看看如何使用它来进行XML文件内容解析： // 创建DocumentBuilderFactory对象 DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance(); // 创建DocumentBuilder对象 try { DocumentBuilder builder = factory.newDocumentBuilder(); Document d = builder.parse(\"file:mappers/test.xml\"); // 每一个标签都作为一个节点 NodeList nodeList = d.getElementsByTagName(\"test\"); // 可能有很多个名字为test的标签 Node rootNode = nodeList.item(0); // 获取首个 NodeList childNodes = rootNode.getChildNodes(); // 一个节点下可能会有很多个节点，比如根节点下就囊括了所有的节点 //节点可以是一个带有内容的标签（它内部就还有子节点），也可以是一段文本内容 for (int i = 0; i \u003c childNodes.getLength(); i++) { Node child = childNodes.item(i); if(child.getNodeType() == Node.ELEMENT_NODE) //过滤换行符之类的内容，因为它们都被认为是一个文本节点 System.out.println(child.getNodeName() + \"：\" +child.getFirstChild().getNodeValue()); // 输出节点名称，也就是标签名称，以及标签内部的文本（内部的内容都是子节点，所以要获取内部的节点） } } catch (Exception e) { e.printStackTrace(); } 当然，学习和使用XML只是为了更好地去认识Mybatis的工作原理，以及如何使用XML来作为Mybatis的配置文件，这是在开始之前必须要掌握的内容（使用Java读取XML内容不要求掌握，但是需要知道Mybatis就是通过这种方式来读取配置文件的） 不仅仅是Mybatis，包括后面的Spring等众多框架都会用到XML来作为框架的配置文件！ ","date":"2022-02-16","objectID":"/posts/java%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93/:3:1","tags":["Java连接数据库"],"title":"Java连接数据库","uri":"/posts/java%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"categories":["JavaWeb笔记"],"content":"初次使用Mybatis 那么我们首先来感受一下Mybatis给我们带来的便捷，就从搭建环境开始，中文文档网站：https://mybatis.org/mybatis-3/zh/configuration.html 我们需要导入Mybatis的依赖，Jar包需要在github上下载，如果卡得一匹，连不上可以在视频简介处从分享的文件中获取。同样地放入到项目的根目录下，右键作为依赖即可！（依赖变多之后，我们可以将其放到一个单独的文件夹，不然会很繁杂） 依赖导入完成后，我们就可以编写Mybatis的配置文件了（现在不是在Java代码中配置了，而是通过一个XML文件去配置，这样就使得硬编码的部分大大减少，项目后期打包成Jar运行不方便修复，但是通过配置文件，我们随时都可以去修改，就变得很方便了，同时代码量也大幅度减少，配置文件填写完成后，我们只需要关心项目的业务逻辑而不是如何去读取配置文件）我们按照官方文档给定的提示，在项目根目录下新建名为mybatis-config.xml的文件，并填写以下内容： \u003c?xml version=\"1.0\" encoding=\"UTF-8\" ?\u003e \u003c!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\"\u003e \u003cconfiguration\u003e \u003cenvironments default=\"development\"\u003e \u003cenvironment id=\"development\"\u003e \u003ctransactionManager type=\"JDBC\"/\u003e \u003cdataSource type=\"POOLED\"\u003e \u003cproperty name=\"driver\" value=\"${驱动类（含包名）}\"/\u003e \u003cproperty name=\"url\" value=\"${数据库连接URL}\"/\u003e \u003cproperty name=\"username\" value=\"${用户名}\"/\u003e \u003cproperty name=\"password\" value=\"${密码}\"/\u003e \u003c/dataSource\u003e \u003c/environment\u003e \u003c/environments\u003e \u003c/configuration\u003e 我们发现，在最上方还引入了一个叫做DTD（文档类型定义）的东西，它提前帮助我们规定了一些标签，我们就需要使用Mybatis提前帮助我们规定好的标签来进行配置（因为只有这样Mybatis才能正确识别我们配置的内容） 通过进行配置，我们就告诉了Mybatis我们链接数据库的一些信息，包括URL、用户名、密码等，这样Mybatis就知道该链接哪个数据库、使用哪个账号进行登陆了（也可以不使用配置文件，这里不做讲解，还请各位小伙伴自行阅读官方文档） 配置文件完成后，我们需要在Java程序启动时，让Mybatis对配置文件进行读取并得到一个SqlSessionFactory对象： public static void main(String[] args) throws FileNotFoundException { SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(new FileInputStream(\"mybatis-config.xml\")); try (SqlSession sqlSession = sqlSessionFactory.openSession(true)){ //暂时还没有业务 } } 直接运行即可，虽然没有干什么事情，但是不会出现错误，如果之前的配置文件编写错误，直接运行会产生报错！那么现在我们来看看，SqlSessionFactory对象是什么东西： 每个基于 MyBatis 的应用都是以一个 SqlSessionFactory 的实例为核心的，我们可以通过SqlSessionFactory来创建多个新的会话，SqlSession对象，每个会话就相当于我不同的地方登陆一个账号去访问数据库，你也可以认为这就是之前JDBC中的Statement对象，会话之间相互隔离，没有任何关联。 而通过SqlSession就可以完成几乎所有的数据库操作，我们发现这个接口中定义了大量数据库操作的方法，因此，现在我们只需要通过一个对象就能完成数据库交互了，极大简化了之前的流程。 我们来尝试一下直接读取实体类，读取实体类肯定需要一个映射规则，比如类中的哪个字段对应数据库中的哪个字段，在查询语句返回结果后，Mybatis就会自动将对应的结果填入到对象的对应字段上。首先编写实体类，，直接使用Lombok是不是就很方便了： import lombok.Data; @Data public class Student { int sid; //名称最好和数据库字段名称保持一致，不然可能会映射失败导致查询结果丢失 String name; String sex; } 在根目录下重新创建一个mapper文件夹，新建名为TestMapper.xml的文件作为我们的映射器，并填写以下内容： \u003c?xml version=\"1.0\" encoding=\"UTF-8\" ?\u003e \u003c!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"\u003e \u003cmapper namespace=\"TestMapper\"\u003e \u003cselect id=\"selectStudent\" resultType=\"com.test.entity.Student\"\u003e select * from student \u003c/select\u003e \u003c/mapper\u003e 其中namespace就是命名空间，每个Mapper都是唯一的，因此需要用一个命名空间来区分，它还可以用来绑定一个接口。我们在里面写入了一个select标签，表示添加一个select操作，同时id作为操作的名称，resultType指定为我们刚刚定义的实体类，表示将数据库结果映射为Student类，然后就在标签中写入我们的查询语句即可。 编写好后，我们在配置文件中添加这个Mapper映射器： \u003cmappers\u003e \u003cmapper url=\"file:mappers/TestMapper.xml\"/\u003e \u003c!-- 这里用的是url，也可以使用其他类型，我们会在后面讲解 --\u003e \u003c/mappers\u003e 最后在程序中使用我们定义好的Mapper即可： public static void main(String[] args) throws FileNotFoundException { SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(new FileInputStream(\"mybatis-config.xml\")); try (SqlSession sqlSession = sqlSessionFactory.openSession(true)){ List\u003cStudent\u003e student = sqlSession.selectList(\"selectStudent\"); student.forEach(System.out::println); } } 我们会发现，Mybatis非常智能，我们只需要告诉一个映射关系，就能够直接将查询结果转化为一个实体类！ ","date":"2022-02-16","objectID":"/posts/java%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93/:3:2","tags":["Java连接数据库"],"title":"Java连接数据库","uri":"/posts/java%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"categories":["JavaWeb笔记"],"content":"配置Mybatis 在了解了Mybatis为我们带来的便捷之后，现在我们就可以正式地去学习使用Mybatis了！ 由于SqlSessionFactory一般只需要创建一次，因此我们可以创建一个工具类来集中创建SqlSession，这样会更加方便一些： public class MybatisUtil { //在类加载时就进行创建 private static SqlSessionFactory sqlSessionFactory; static { try { sqlSessionFactory = new SqlSessionFactoryBuilder().build(new FileInputStream(\"mybatis-config.xml\")); } catch (FileNotFoundException e) { e.printStackTrace(); } } /** * 获取一个新的会话 * @param autoCommit 是否开启自动提交（跟JDBC是一样的，如果不自动提交，则会变成事务操作） * @return SqlSession对象 */ public static SqlSession getSession(boolean autoCommit){ return sqlSessionFactory.openSession(autoCommit); } } 现在我们只需要在main方法中这样写即可查询结果了： public static void main(String[] args) { try (SqlSession sqlSession = MybatisUtil.getSession(true)){ List\u003cStudent\u003e student = sqlSession.selectList(\"selectStudent\"); student.forEach(System.out::println); } } 之前我们演示了，如何创建一个映射器来将结果快速转换为实体类，但是这样可能还是不够方便，我们每次都需要去找映射器对应操作的名称，而且还要知道对应的返回类型，再通过SqlSession来执行对应的方法，能不能再方便一点呢？ 现在，我们可以通过namespace来绑定到一个接口上，利用接口的特性，我们可以直接指明方法的行为，而实际实现则是由Mybatis来完成。 public interface TestMapper { List\u003cStudent\u003e selectStudent(); } 将Mapper文件的命名空间修改为我们的接口，建议同时将其放到同名包中，作为内部资源： \u003cmapper namespace=\"com.test.mapper.TestMapper\"\u003e \u003cselect id=\"selectStudent\" resultType=\"com.test.entity.Student\"\u003e select * from student \u003c/select\u003e \u003c/mapper\u003e 作为内部资源后，我们需要修改一下配置文件中的mapper定义，不使用url而是resource表示是Jar内部的文件： \u003cmappers\u003e \u003cmapper resource=\"com/test/mapper/TestMapper.xml\"/\u003e \u003c/mappers\u003e 现在我们就可以直接通过SqlSession获取对应的实现类，通过接口中定义的行为来直接获取结果： public static void main(String[] args) { try (SqlSession sqlSession = MybatisUtil.getSession(true)){ TestMapper testMapper = sqlSession.getMapper(TestMapper.class); List\u003cStudent\u003e student = testMapper.selectStudent(); student.forEach(System.out::println); } } 那么肯定有人好奇，TestMapper明明是一个我们自己定义接口啊，Mybatis也不可能提前帮我们写了实现类啊，那这接口怎么就出现了一个实现类呢？我们可以通过调用getClass()方法来看看实现类是个什么： TestMapper testMapper = sqlSession.getMapper(TestMapper.class); System.out.println(testMapper.getClass()); 我们发现，实现类名称很奇怪，名称为com.sun.proxy.$Proxy4，它是通过动态代理生成的，相当于动态生成了一个实现类，而不是预先定义好的，有关Mybatis这一部分的原理，我们放在最后一节进行讲解。 接下来，我们再来看配置文件，之前我们并没有对配置文件进行一个详细的介绍： \u003cconfiguration\u003e \u003cenvironments default=\"development\"\u003e \u003cenvironment id=\"development\"\u003e \u003ctransactionManager type=\"JDBC\"/\u003e \u003cdataSource type=\"POOLED\"\u003e \u003cproperty name=\"driver\" value=\"com.mysql.cj.jdbc.Driver\"/\u003e \u003cproperty name=\"url\" value=\"jdbc:mysql://localhost:3306/study\"/\u003e \u003cproperty name=\"username\" value=\"test\"/\u003e \u003cproperty name=\"password\" value=\"123456\"/\u003e \u003c/dataSource\u003e \u003c/environment\u003e \u003c/environments\u003e \u003cmappers\u003e \u003cmapper resource=\"com/test/mapper/TestMapper.xml\"/\u003e \u003c/mappers\u003e \u003c/configuration\u003e 首先就从environments标签说起，一般情况下，我们在开发中，都需要指定一个数据库的配置信息，包含连接URL、用户、密码等信息，而environment就是用于进行这些配置的！实际情况下可能会不止有一个数据库连接信息，比如开发过程中我们一般会使用本地的数据库，而如果需要将项目上传到服务器或是防止其他人的电脑上运行时，我们可能就需要配置另一个数据库的信息，因此，我们可以提前定义好所有的数据库信息，该什么时候用什么即可！ 在environments标签上有一个default属性，来指定默认的环境，当然如果我们希望使用其他环境，可以修改这个默认环境，也可以在创建工厂时选择环境： sqlSessionFactory = new SqlSessionFactoryBuilder() .build(new FileInputStream(\"mybatis-config.xml\"), \"环境ID\"); 我们还可以给类型起一个别名，以简化Mapper的编写： \u003c!-- 需要在environments的上方 --\u003e \u003ctypeAliases\u003e \u003ctypeAlias type=\"com.test.entity.Student\" alias=\"Student\"/\u003e \u003c/typeAliases\u003e 现在Mapper就可以直接使用别名了： \u003cmapper namespace=\"com.test.mapper.TestMapper\"\u003e \u003cselect id=\"selectStudent\" resultType=\"Student\"\u003e select * from student \u003c/select\u003e \u003c/mapper\u003e 如果这样还是很麻烦，我们也可以直接让Mybatis去扫描一个包，并将包下的所有类自动起别名（别名为首字母小写的类名） \u003ctypeAliases\u003e \u003cpackage name=\"com.test.entity\"/\u003e \u003c/typeAliases\u003e 也可以为指定实体类添加一个注解，来指定别名： @Data @Alias(\"lbwnb\") public class Student { private int sid; private String name; private String sex; } 当然，Mybatis也包含许多的基础配置，通过使用： \u003csettings\u003e \u003csetting name=\"\" value=\"\"/\u003e \u003c/settings\u003e 所有的配置项可以在中文文档处查询，本文不会进行详细介绍，在后面我们会提出一些比较重要的配置项。 有关配置文件的介绍就暂时到这里为止，我们讨论的重心应该是Mybatis的应用，而不是配置文件，所以省略了一部分内容的讲解。 ","date":"2022-02-16","objectID":"/posts/java%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93/:3:3","tags":["Java连接数据库"],"title":"Java连接数据库","uri":"/posts/java%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"categories":["JavaWeb笔记"],"content":"增删改查 在了解了Mybatis的一些基本配置之后，我们就可以正式来使用Mybatis来进行数据库操作了！ 在前面我们演示了如何快速进行查询，我们只需要编写一个对应的映射器既可以了： \u003cmapper namespace=\"com.test.mapper.TestMapper\"\u003e \u003cselect id=\"studentList\" resultType=\"Student\"\u003e select * from student \u003c/select\u003e \u003c/mapper\u003e 当然，如果你不喜欢使用实体类，那么这些属性还可以被映射到一个Map上： \u003cselect id=\"selectStudent\" resultType=\"Map\"\u003e select * from student \u003c/select\u003e public interface TestMapper { List\u003cMap\u003e selectStudent(); } Map中就会以键值对的形式来存放这些结果了。 通过设定一个resultType属性，让Mybatis知道查询结果需要映射为哪个实体类，要求字段名称保持一致。那么如果我们不希望按照这样的规则来映射呢？我们可以自定义resultMap来设定映射规则： \u003cresultMap id=\"Test\" type=\"Student\"\u003e \u003cresult column=\"sid\" property=\"sid\"/\u003e \u003cresult column=\"sex\" property=\"name\"/\u003e \u003cresult column=\"name\" property=\"sex\"/\u003e \u003c/resultMap\u003e 通过指定映射规则，我们现在名称和性别一栏就发生了交换，因为我们将其映射字段进行了交换。 如果一个类中存在多个构造方法，那么很有可能会出现这样的错误： ### Exception in thread \"main\" org.apache.ibatis.exceptions.PersistenceException: ### Error querying database. Cause: org.apache.ibatis.executor.ExecutorException: No constructor found in com.test.entity.Student matching [java.lang.Integer, java.lang.String, java.lang.String] ### The error may exist in com/test/mapper/TestMapper.xml ### The error may involve com.test.mapper.TestMapper.getStudentBySid ### The error occurred while handling results ### SQL: select * from student where sid = ? ### Cause: org.apache.ibatis.executor.ExecutorException: No constructor found in com.test.entity.Student matching [java.lang.Integer, java.lang.String, java.lang.String] at org.apache.ibatis.exceptions.ExceptionFactory.wrapException(ExceptionFactory.java:30) ... 这时就需要使用constructor标签来指定构造方法： \u003cresultMap id=\"test\" type=\"Student\"\u003e \u003cconstructor\u003e \u003carg column=\"sid\" javaType=\"Integer\"/\u003e \u003carg column=\"name\" javaType=\"String\"/\u003e \u003c/constructor\u003e \u003c/resultMap\u003e 值得注意的是，指定构造方法后，若此字段被填入了构造方法作为参数，将不会通过反射给字段单独赋值，而构造方法中没有传入的字段，依然会被反射赋值，有关resultMap的内容，后面还会继续讲解。 如果数据库中存在一个带下划线的字段，我们可以通过设置让其映射为以驼峰命名的字段，比如my_test映射为myTest \u003csettings\u003e \u003csetting name=\"mapUnderscoreToCamelCase\" value=\"true\"/\u003e \u003c/settings\u003e 如果不设置，默认为不开启，也就是默认需要名称保持一致。 我们接着来看看条件查询，既然是条件查询，那么肯定需要我们传入查询条件，比如现在我们想通过sid字段来通过学号查找信息： Student getStudentBySid(int sid); \u003cselect id=\"getStudentBySid\" parameterType=\"int\" resultType=\"Student\"\u003e select * from student where sid = #{sid} \u003c/select\u003e 我们通过使用#{xxx}或是${xxx}来填入我们给定的属性，实际上Mybatis本质也是通过PreparedStatement首先进行一次预编译，有效地防止SQL注入问题，但是如果使用${xxx}就不再是通过预编译，而是直接传值，因此我们一般都使用#{xxx}来进行操作。 使用parameterType属性来指定参数类型（非必须，可以不用，推荐不用） 接着我们来看插入、更新和删除操作，其实与查询操作差不多，不过需要使用对应的标签，比如插入操作： \u003cinsert id=\"addStudent\" parameterType=\"Student\"\u003e insert into student(name, sex) values(#{name}, #{sex}) \u003c/insert\u003e int addStudent(Student student); 我们这里使用的是一个实体类，我们可以直接使用实体类里面对应属性替换到SQL语句中，只需要填写属性名称即可，和条件查询是一样的。 ","date":"2022-02-16","objectID":"/posts/java%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93/:3:4","tags":["Java连接数据库"],"title":"Java连接数据库","uri":"/posts/java%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"categories":["JavaWeb笔记"],"content":"复杂查询 一个老师可以教授多个学生，那么能否一次性将老师的学生全部映射给此老师的对象呢，比如： @Data public class Teacher { int tid; String name; List\u003cStudent\u003e studentList; } 映射为Teacher对象时，同时将其教授的所有学生一并映射为List列表，显然这是一种一对多的查询，那么这时就需要进行复杂查询了。而我们之前编写的都非常简单，直接就能完成映射，因此我们现在需要使用resultMap来自定义映射规则： \u003cselect id=\"getTeacherByTid\" resultMap=\"asTeacher\"\u003e select *, teacher.name as tname from student inner join teach on student.sid = teach.sid inner join teacher on teach.tid = teacher.tid where teach.tid = #{tid} \u003c/select\u003e \u003cresultMap id=\"asTeacher\" type=\"Teacher\"\u003e \u003cid column=\"tid\" property=\"tid\"/\u003e \u003cresult column=\"tname\" property=\"name\"/\u003e \u003ccollection property=\"studentList\" ofType=\"Student\"\u003e \u003cid property=\"sid\" column=\"sid\"/\u003e \u003cresult column=\"name\" property=\"name\"/\u003e \u003cresult column=\"sex\" property=\"sex\"/\u003e \u003c/collection\u003e \u003c/resultMap\u003e 可以看到，我们的查询结果是一个多表联查的结果，而联查的数据就是我们需要映射的数据（比如这里是一个老师有N个学生，联查的结果也是这一个老师对应N个学生的N条记录），其中id标签用于在多条记录中辨别是否为同一个对象的数据，比如上面的查询语句得到的结果中，tid这一行始终为1，因此所有的记录都应该是tid=1的教师的数据，而不应该变为多个教师的数据，如果不加id进行约束，那么会被识别成多个教师的数据！ 通过使用collection来表示将得到的所有结果合并为一个集合，比如上面的数据中每个学生都有单独的一条记录，因此tid相同的全部学生的记录就可以最后合并为一个List，得到最终的映射结果，当然，为了区分，最好也设置一个id，只不过这个例子中可以当做普通的result使用。 了解了一对多，那么多对一又该如何查询呢，比如每个学生都有一个对应的老师，现在Student新增了一个Teacher对象，那么现在又该如何去处理呢？ @Data @Accessors(chain = true) public class Student { private int sid; private String name; private String sex; private Teacher teacher; } @Data public class Teacher { int tid; String name; } 现在我们希望的是，每次查询到一个Student对象时都带上它的老师，同样的，我们也可以使用resultMap来实现（先修改一下老师的类定义，不然会很麻烦）： \u003cresultMap id=\"test2\" type=\"Student\"\u003e \u003cid column=\"sid\" property=\"sid\"/\u003e \u003cresult column=\"name\" property=\"name\"/\u003e \u003cresult column=\"sex\" property=\"sex\"/\u003e \u003cassociation property=\"teacher\" javaType=\"Teacher\"\u003e \u003cid column=\"tid\" property=\"tid\"/\u003e \u003cresult column=\"tname\" property=\"name\"/\u003e \u003c/association\u003e \u003c/resultMap\u003e \u003cselect id=\"selectStudent\" resultMap=\"test2\"\u003e select *, teacher.name as tname from student left join teach on student.sid = teach.sid left join teacher on teach.tid = teacher.tid \u003c/select\u003e 通过使用association进行关联，形成多对一的关系，实际上和一对多是同理的，都是对查询结果的一种处理方式罢了。 ","date":"2022-02-16","objectID":"/posts/java%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93/:3:5","tags":["Java连接数据库"],"title":"Java连接数据库","uri":"/posts/java%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"categories":["JavaWeb笔记"],"content":"事务操作 我们可以在获取SqlSession关闭自动提交来开启事务模式，和JDBC其实都差不多： public static void main(String[] args) { try (SqlSession sqlSession = MybatisUtil.getSession(false)){ TestMapper testMapper = sqlSession.getMapper(TestMapper.class); testMapper.addStudent(new Student().setSex(\"男\").setName(\"小王\")); testMapper.selectStudent().forEach(System.out::println); } } 我们发现，在关闭自动提交后，我们的内容是没有进入到数据库的，现在我们来试一下在最后提交事务： sqlSession.commit(); 在事务提交后，我们的内容才会被写入到数据库中。现在我们来试试看回滚操作： try (SqlSession sqlSession = MybatisUtil.getSession(false)){ TestMapper testMapper = sqlSession.getMapper(TestMapper.class); testMapper.addStudent(new Student().setSex(\"男\").setName(\"小王\")); testMapper.selectStudent().forEach(System.out::println); sqlSession.rollback(); sqlSession.commit(); } 回滚操作也印证成功。 ","date":"2022-02-16","objectID":"/posts/java%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93/:3:6","tags":["Java连接数据库"],"title":"Java连接数据库","uri":"/posts/java%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"categories":["JavaWeb笔记"],"content":"动态SQL 动态 SQL 是 MyBatis 的强大特性之一。如果你使用过 JDBC 或其它类似的框架，你应该能理解根据不同条件拼接 SQL 语句有多痛苦，例如拼接时要确保不能忘记添加必要的空格，还要注意去掉列表最后一个列名的逗号。利用动态 SQL，可以彻底摆脱这种痛苦。 我们直接使用官网的例子进行讲解。 ","date":"2022-02-16","objectID":"/posts/java%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93/:3:7","tags":["Java连接数据库"],"title":"Java连接数据库","uri":"/posts/java%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"categories":["JavaWeb笔记"],"content":"缓存机制 MyBatis 内置了一个强大的事务性查询缓存机制，它可以非常方便地配置和定制。 其实缓存机制我们在之前学习IO流的时候已经提及过了，我们可以提前将一部分内容放入缓存，下次需要获取数据时，我们就可以直接从缓存中读取，这样的话相当于直接从内存中获取而不是再去向数据库索要数据，效率会更高。 因此Mybatis内置了一个缓存机制，我们查询时，如果缓存中存在数据，那么我们就可以直接从缓存中获取，而不是再去向数据库进行请求。 Mybatis存在一级缓存和二级缓存，我们首先来看一下一级缓存，默认情况下，只启用了本地的会话缓存，它仅仅对一个会话中的数据进行缓存（一级缓存无法关闭，只能调整），我们来看看下面这段代码： public static void main(String[] args) throws InterruptedException { try (SqlSession sqlSession = MybatisUtil.getSession(true)){ TestMapper testMapper = sqlSession.getMapper(TestMapper.class); Student student1 = testMapper.getStudentBySid(1); Student student2 = testMapper.getStudentBySid(1); System.out.println(student1 == student2); } } 我们发现，两次得到的是同一个Student对象，也就是说我们第二次查询并没有重新去构造对象，而是直接得到之前创建好的对象。如果还不是很明显，我们可以修改一下实体类： @Data @Accessors(chain = true) public class Student { public Student(){ System.out.println(\"我被构造了\"); } private int sid; private String name; private String sex; } 我们通过前面的学习得知Mybatis在映射为对象时，在只有一个构造方法的情况下，无论你构造方法写成什么样子，都会去调用一次构造方法，如果存在多个构造方法，那么就会去找匹配的构造方法。我们可以通过查看构造方法来验证对象被创建了几次。 结果显而易见，只创建了一次，也就是说当第二次进行同样的查询时，会直接使用第一次的结果，因为第一次的结果已经被缓存了。 那么如果我修改了数据库中的内容，缓存还会生效吗： public static void main(String[] args) throws InterruptedException { try (SqlSession sqlSession = MybatisUtil.getSession(true)){ TestMapper testMapper = sqlSession.getMapper(TestMapper.class); Student student1 = testMapper.getStudentBySid(1); testMapper.addStudent(new Student().setName(\"小李\").setSex(\"男\")); Student student2 = testMapper.getStudentBySid(1); System.out.println(student1 == student2); } } 我们发现，当我们进行了插入操作后，缓存就没有生效了，我们再次进行查询得到的是一个新创建的对象。 也就是说，一级缓存，在进行DML操作后，会使得缓存失效，也就是说Mybatis知道我们对数据库里面的数据进行了修改，所以之前缓存的内容可能就不是当前数据库里面最新的内容了。还有一种情况就是，当前会话结束后，也会清理全部的缓存，因为已经不会再用到了。但是一定注意，一级缓存只针对于单个会话，多个会话之间不相通。 public static void main(String[] args) { try (SqlSession sqlSession = MybatisUtil.getSession(true)){ TestMapper testMapper = sqlSession.getMapper(TestMapper.class); Student student2; try(SqlSession sqlSession2 = MybatisUtil.getSession(true)){ TestMapper testMapper2 = sqlSession2.getMapper(TestMapper.class); student2 = testMapper2.getStudentBySid(1); } Student student1 = testMapper.getStudentBySid(1); System.out.println(student1 == student2); } } **注意：**一个会话DML操作只会重置当前会话的缓存，不会重置其他会话的缓存，也就是说，其他会话缓存是不会更新的！ 一级缓存给我们提供了很高速的访问效率，但是它的作用范围实在是有限，如果一个会话结束，那么之前的缓存就全部失效了，但是我们希望缓存能够扩展到所有会话都能使用，因此我们可以通过二级缓存来实现，二级缓存默认是关闭状态，要开启二级缓存，我们需要在映射器XML文件中添加： \u003ccache/\u003e 可见二级缓存是Mapper级别的，也就是说，当一个会话失效时，它的缓存依然会存在于二级缓存中，因此如果我们再次创建一个新的会话会直接使用之前的缓存，我们首先根据官方文档进行一些配置： \u003ccache eviction=\"FIFO\" flushInterval=\"60000\" size=\"512\" readOnly=\"true\"/\u003e 我们来编写一个代码： public static void main(String[] args) { Student student; try (SqlSession sqlSession = MybatisUtil.getSession(true)){ TestMapper testMapper = sqlSession.getMapper(TestMapper.class); student = testMapper.getStudentBySid(1); } try (SqlSession sqlSession2 = MybatisUtil.getSession(true)){ TestMapper testMapper2 = sqlSession2.getMapper(TestMapper.class); Student student2 = testMapper2.getStudentBySid(1); System.out.println(student2 == student); } } 我们可以看到，上面的代码中首先是第一个会话在进行读操作，完成后会结束会话，而第二个操作重新创建了一个新的会话，再次执行了同样的查询，我们发现得到的依然是缓存的结果。 那么如果我不希望某个方法开启缓存呢？我们可以添加useCache属性来关闭缓存： \u003cselect id=\"getStudentBySid\" resultType=\"Student\" useCache=\"false\"\u003e select * from student where sid = #{sid} \u003c/select\u003e 我们也可以使用flushCache=“false\"在每次执行后都清空缓存，通过这这个我们还可以控制DML操作完成之后不清空缓存。 \u003cselect id=\"getStudentBySid\" resultType=\"Student\" flushCache=\"true\"\u003e select * from student where sid = #{sid} \u003c/select\u003e 添加了二级缓存之后，会先从二级缓存中查找数据，当二级缓存中没有时，才会从一级缓存中获取，当一级缓存中都还没有数据时，才会请求数据库，因此我们再来执行上面的代码： public static void main(String[] args) { try (SqlSession sqlSession = MybatisUtil.getSession(true)){ TestMapper testMapper = sqlSession.getMapper(TestMapper.class); Student student2; try(SqlSession sqlSession2 = MybatisUtil.getSession(true)){ TestMapper testMapper2 = sqlSession2.getMapper(TestMapper.class); student2 = testMapper2.getStudentBySid(1); } Student student1 = testMapper.getStudentBySid(1); System.out.println(student1 == student2); } } 得到的结果就会是同一个对象了，因为现在是优先从二级缓存中获取。 读取顺序：二级缓存 =\u003e 一级缓存 =\u003e 数据库 虽然缓存机制给我","date":"2022-02-16","objectID":"/posts/java%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93/:3:8","tags":["Java连接数据库"],"title":"Java连接数据库","uri":"/posts/java%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"categories":["JavaWeb笔记"],"content":"使用注解开发 在之前的开发中，我们已经体验到Mybatis为我们带来的便捷了，我们只需要编写对应的映射器，并将其绑定到一个接口上，即可直接通过该接口执行我们的SQL语句，极大的简化了我们之前JDBC那样的代码编写模式。那么，能否实现无需xml映射器配置，而是直接使用注解在接口上进行配置呢？答案是可以的，也是现在推荐的一种方式（也不是说XML就不要去用了，由于Java 注解的表达能力和灵活性十分有限，可能相对于XML配置某些功能实现起来会不太好办，但是在大部分场景下，直接使用注解开发已经绰绰有余了） 首先我们来看一下，使用XML进行映射器编写时，我们需要现在XML中定义映射规则和SQL语句，然后再将其绑定到一个接口的方法定义上，然后再使用接口来执行： \u003cinsert id=\"addStudent\"\u003e insert into student(name, sex) values(#{name}, #{sex}) \u003c/insert\u003e int addStudent(Student student); 而现在，我们可以直接使用注解来实现，每个操作都有一个对应的注解： @Insert(\"insert into student(name, sex) values(#{name}, #{sex})\") int addStudent(Student student); 当然，我们还需要修改一下配置文件中的映射器注册： \u003cmappers\u003e \u003cmapper class=\"com.test.mapper.MyMapper\"/\u003e \u003c!-- 也可以直接注册整个包下的 \u003cpackage name=\"com.test.mapper\"/\u003e --\u003e \u003c/mappers\u003e 通过直接指定Class，来让Mybatis知道我们这里有一个通过注解实现的映射器。 我们接着来看一下，如何使用注解进行自定义映射规则： @Results({ @Result(id = true, column = \"sid\", property = \"sid\"), @Result(column = \"sex\", property = \"name\"), @Result(column = \"name\", property = \"sex\") }) @Select(\"select * from student\") List\u003cStudent\u003e getAllStudent(); 直接通过@Results注解，就可以直接进行配置了，此注解的value是一个@Result注解数组，每个@Result注解都都一个单独的字段配置，其实就是我们之前在XML映射器中写的： \u003cresultMap id=\"test\" type=\"Student\"\u003e \u003cid property=\"sid\" column=\"sid\"/\u003e \u003cresult column=\"name\" property=\"sex\"/\u003e \u003cresult column=\"sex\" property=\"name\"/\u003e \u003c/resultMap\u003e 现在我们就可以通过注解来自定义映射规则了。那么如何使用注解来完成复杂查询呢？我们还是使用一个老师多个学生的例子： @Results({ @Result(id = true, column = \"tid\", property = \"tid\"), @Result(column = \"name\", property = \"name\"), @Result(column = \"tid\", property = \"studentList\", many = @Many(select = \"getStudentByTid\") ) }) @Select(\"select * from teacher where tid = #{tid}\") Teacher getTeacherBySid(int tid); @Select(\"select * from student inner join teach on student.sid = teach.sid where tid = #{tid}\") List\u003cStudent\u003e getStudentByTid(int tid); 我们发现，多出了一个子查询，而这个子查询是单独查询该老师所属学生的信息，而子查询结果作为@Result注解的一个many结果，代表子查询的所有结果都归入此集合中（也就是之前的collection标签） \u003cresultMap id=\"asTeacher\" type=\"Teacher\"\u003e \u003cid column=\"tid\" property=\"tid\"/\u003e \u003cresult column=\"tname\" property=\"name\"/\u003e \u003ccollection property=\"studentList\" ofType=\"Student\"\u003e \u003cid property=\"sid\" column=\"sid\"/\u003e \u003cresult column=\"name\" property=\"name\"/\u003e \u003cresult column=\"sex\" property=\"sex\"/\u003e \u003c/collection\u003e \u003c/resultMap\u003e 同理，@Result也提供了@One子注解来实现一对一的关系表示，类似于之前的assocation标签： @Results({ @Result(id = true, column = \"sid\", property = \"sid\"), @Result(column = \"sex\", property = \"name\"), @Result(column = \"name\", property = \"sex\"), @Result(column = \"sid\", property = \"teacher\", one = @One(select = \"getTeacherBySid\") ) }) @Select(\"select * from student\") List\u003cStudent\u003e getAllStudent(); 如果现在我希望直接使用注解编写SQL语句但是我希望映射规则依然使用XML来实现，这时该怎么办呢？ @ResultMap(\"test\") @Select(\"select * from student\") List\u003cStudent\u003e getAllStudent(); 提供了@ResultMap注解，直接指定ID即可，这样我们就可以使用XML中编写的映射规则了，这里就不再演示了。 那么如果出现之前的两个构造方法的情况，且没有任何一个构造方法匹配的话，该怎么处理呢？ @Data @Accessors(chain = true) public class Student { public Student(int sid){ System.out.println(\"我是一号构造方法\"+sid); } public Student(int sid, String name){ System.out.println(\"我是二号构造方法\"+sid+name); } private int sid; private String name; private String sex; } 我们可以通过@ConstructorArgs注解来指定构造方法： @ConstructorArgs({ @Arg(column = \"sid\", javaType = int.class), @Arg(column = \"name\", javaType = String.class) }) @Select(\"select * from student where sid = #{sid} and sex = #{sex}\") Student getStudentBySidAndSex(@Param(\"sid\") int sid, @Param(\"sex\") String sex); 得到的结果和使用constructor标签效果一致，这里就不多做讲解了。 我们发现，当参数列表中出现两个以上的参数时，会出现错误： @Select(\"select * from student where sid = #{sid} and sex = #{sex}\") Student getStudentBySidAndSex(int sid, String sex); Exception in thread \"main\" org.apache.ibatis.exceptions.PersistenceException: ### Error querying database. Cause: org.apache.ibatis.binding.BindingException: Parameter 'sid' not found. Available parameters are [arg1, arg0, param1, param2] ### Cause: org.apache.ibatis.binding.BindingException: Parameter 'sid' not found. Available parameters are [arg1, arg0, param1, param2] at org.apache.ibatis.exceptions.ExceptionFactory.wrapException(ExceptionFactory.java:30) at org.apache.ibatis.session.defaults.","date":"2022-02-16","objectID":"/posts/java%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93/:3:9","tags":["Java连接数据库"],"title":"Java连接数据库","uri":"/posts/java%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"categories":["JavaWeb笔记"],"content":"探究Mybatis的动态代理机制 在探究动态代理机制之前，我们要先聊聊什么是代理：其实顾名思义，就好比我开了个大棚，里面栽种的西瓜，那么西瓜成熟了是不是得去卖掉赚钱，而我们的西瓜非常多，一个人肯定卖不过来，肯定就要去多找几个开水果摊的帮我们卖，这就是一种代理。实际上是由水果摊老板在帮我们卖瓜，我们只告诉老板卖多少钱，而至于怎么卖的是由水果摊老板决定的。 那么现在我们来尝试实现一下这样的类结构，首先定义一个接口用于规范行为： public interface Shopper { //卖瓜行为 void saleWatermelon(String customer); } 然后需要实现一下卖瓜行为，也就是我们要告诉老板卖多少钱，这里就直接写成成功出售： public class ShopperImpl implements Shopper{ //卖瓜行为的实现 @Override public void saleWatermelon(String customer) { System.out.println(\"成功出售西瓜给 ===\u003e \"+customer); } } 最后老板代理后肯定要用自己的方式去出售这些西瓜，成交之后再按照我们告诉老板的价格进行出售： public class ShopperProxy implements Shopper{ private final Shopper impl; public ShopperProxy(Shopper impl){ this.impl = impl; } //代理卖瓜行为 @Override public void saleWatermelon(String customer) { //首先进行 代理商讨价还价行为 System.out.println(customer + \"：哥们，这瓜多少钱一斤啊？\"); System.out.println(\"老板：两块钱一斤。\"); System.out.println(customer + \"：你这瓜皮子是金子做的，还是瓜粒子是金子做的？\"); System.out.println(\"老板：你瞅瞅现在哪有瓜啊，这都是大棚的瓜，你嫌贵我还嫌贵呢。\"); System.out.println(customer + \"：给我挑一个。\"); impl.saleWatermelon(customer); //讨价还价成功，进行我们告诉代理商的卖瓜行为 } } 现在我们来试试看： public class Main { public static void main(String[] args) { Shopper shopper = new ShopperProxy(new ShopperImpl()); shopper.saleWatermelon(\"小强\"); } } 这样的操作称为静态代理，也就是说我们需要提前知道接口的定义并进行实现才可以完成代理，而Mybatis这样的是无法预知代理接口的，我们就需要用到动态代理。 JDK提供的反射框架就为我们很好地解决了动态代理的问题，在这里相当于对JavaSE阶段反射的内容进行一个补充。 public class ShopperProxy implements InvocationHandler { Object target; public ShopperProxy(Object target){ this.target = target; } @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { String customer = (String) args[0]; System.out.println(customer + \"：哥们，这瓜多少钱一斤啊？\"); System.out.println(\"老板：两块钱一斤。\"); System.out.println(customer + \"：你这瓜皮子是金子做的，还是瓜粒子是金子做的？\"); System.out.println(\"老板：你瞅瞅现在哪有瓜啊，这都是大棚的瓜，你嫌贵我还嫌贵呢。\"); System.out.println(customer + \"：行，给我挑一个。\"); return method.invoke(target, args); } } 通过实现InvocationHandler来成为一个动态代理，我们发现它提供了一个invoke方法，用于调用被代理对象的方法并完成我们的代理工作。现在就可以通过 Proxy.newProxyInstance来生成一个动态代理类： public static void main(String[] args) { Shopper impl = new ShopperImpl(); Shopper shopper = (Shopper) Proxy.newProxyInstance(impl.getClass().getClassLoader(), impl.getClass().getInterfaces(), new ShopperProxy(impl)); shopper.saleWatermelon(\"小强\"); System.out.println(shopper.getClass()); } 通过打印类型我们发现，就是我们之前看到的那种奇怪的类：class com.sun.proxy.$Proxy0，因此Mybatis其实也是这样的来实现的（肯定有人问了：Mybatis是直接代理接口啊，你这个不还是要把接口实现了吗？）那我们来改改，现在我们不代理任何类了，直接做接口实现： public class ShopperProxy implements InvocationHandler { @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { String customer = (String) args[0]; System.out.println(customer + \"：哥们，这瓜多少钱一斤啊？\"); System.out.println(\"老板：两块钱一斤。\"); System.out.println(customer + \"：你这瓜皮子是金子做的，还是瓜粒子是金子做的？\"); System.out.println(\"老板：你瞅瞅现在哪有瓜啊，这都是大棚的瓜，你嫌贵我还嫌贵呢。\"); System.out.println(customer + \"：行，给我挑一个。\"); return null; } } public static void main(String[] args) { Shopper shopper = (Shopper) Proxy.newProxyInstance(Shopper.class.getClassLoader(), new Class[]{ Shopper.class }, //因为本身就是接口，所以直接用就行 new ShopperProxy()); shopper.saleWatermelon(\"小强\"); System.out.println(shopper.getClass()); } 我们可以去看看Mybatis的源码。 Mybatis的学习差不多就到这里为止了，不过，同样类型的框架还有很多，Mybatis属于半自动框架，SQL语句依然需要我们自己编写，虽然存在一定的麻烦，但是会更加灵活，而后面我们还会学习JPA，它是全自动的框架，你几乎见不到SQL的影子！ ","date":"2022-02-16","objectID":"/posts/java%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93/:3:10","tags":["Java连接数据库"],"title":"Java连接数据库","uri":"/posts/java%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"categories":["JavaWeb笔记"],"content":"使用JUnit进行单元测试 首先一问：我们为什么需要单元测试？ 随着我们的项目逐渐变大，比如我们之前编写的图书管理系统，我们都是边在写边在测试，而我们当时使用的测试方法，就是直接在主方法中运行测试，但是，在很多情况下，我们的项目可能会很庞大，不可能每次都去完整地启动一个项目来测试某一个功能，这样显然会降低我们的开发效率，因此，我们需要使用单元测试来帮助我们针对于某个功能或是某个模块单独运行代码进行测试，而不是启动整个项目。 同时，在我们项目的维护过程中，难免会涉及到一些原有代码的修改，很有可能出现改了代码导致之前的功能出现问题（牵一发而动全身），而我们又不一定能立即察觉到，因此，我们可以提前保存一些测试用例，每次完成代码后都可以跑一遍测试用例，来确保之前的功能没有因为后续的修改而出现问题。 我们还可以利用单元测试来评估某个模块或是功能的耗时和性能，快速排查导致程序运行缓慢的问题，这些都可以通过单元测试来完成，可见单元测试对于开发的重要性。 ","date":"2022-02-16","objectID":"/posts/java%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93/:4:0","tags":["Java连接数据库"],"title":"Java连接数据库","uri":"/posts/java%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"categories":["JavaWeb笔记"],"content":"尝试JUnit 首先需要导入JUnit依赖，我们在这里使用Junit4进行介绍，最新的Junit5放到Maven板块一起讲解，Jar包已经放在视频下方简介中，直接去下载即可。同时IDEA需要安装JUnit插件（默认是已经捆绑安装的，因此无需多余配置） 现在我们创建一个新的类，来编写我们的单元测试用例： public class TestMain { @Test public void method(){ System.out.println(\"我是测试用例1\"); } @Test public void method2(){ System.out.println(\"我是测试用例2\"); } } 我们可以点击类前面的测试按钮，或是单个方法前的测试按钮，如果点击类前面的测试按钮，会执行所有的测试用例。 运行测试后，我们发现控制台得到了一个测试结果，显示为绿色表示测试通过。 只需要通过打上@Test注解，即可将一个方法标记为测试案例，我们可以直接运行此测试案例，但是我们编写的测试方法有以下要求： 方法必须是public的 不能是静态方法 返回值必须是void 必须是没有任何参数的方法 对于一个测试案例来说，我们肯定希望测试的结果是我们所期望的一个值，因此，如果测试的结果并不是我们所期望的结果，那么这个测试就应该没有成功通过！ 我们可以通过断言工具类来进行判定： public class TestMain { @Test public void method(){ System.out.println(\"我是测试案例！\"); Assert.assertEquals(1, 2); //参数1是期盼值，参数2是实际测试结果值 } } 通过运行代码后，我们发现测试过程中抛出了一个错误，并且IDEA给我们显示了期盼结果和测试结果，那么现在我们来测试一个案例，比如我们想查看冒泡排序的编写是否正确： @Test public void method(){ int[] arr = {0, 4, 5, 2, 6, 9, 3, 1, 7, 8}; //错误的冒泡排序 for (int i = 0; i \u003c arr.length - 1; i++) { for (int j = 0; j \u003c arr.length - 1 - i; j++) { if(arr[j] \u003e arr[j + 1]){ int tmp = arr[j]; arr[j] = arr[j+1]; // arr[j+1] = tmp; } } } Assert.assertArrayEquals(new int[]{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}, arr); } 通过测试，我们发现得到的结果并不是我们想要的结果，因此现在我们需要去修改为正确的冒泡排序，修改后，测试就能正确通过了。我们还可以再通过一个案例来更加深入地了解测试，现在我们想测试从数据库中取数据是否为我们预期的数据： @Test public void method(){ try (SqlSession sqlSession = MybatisUtil.getSession(true)){ TestMapper mapper = sqlSession.getMapper(TestMapper.class); Student student = mapper.getStudentBySidAndSex(1, \"男\"); Assert.assertEquals(new Student().setName(\"小明\").setSex(\"男\").setSid(1), student); } } 那么如果我们在进行所有的测试之前需要做一些前置操作该怎么办呢，一种办法是在所有的测试用例前面都加上前置操作，但是这样显然是很冗余的，因为一旦发生修改就需要挨个进行修改，因此我们需要更加智能的方法，我们可以通过@Before注解来添加测试用例开始之前的前置操作： public class TestMain { private SqlSessionFactory sqlSessionFactory; @Before public void before(){ System.out.println(\"测试前置正在初始化...\"); try { sqlSessionFactory = new SqlSessionFactoryBuilder() .build(new FileInputStream(\"mybatis-config.xml\")); } catch (FileNotFoundException e) { e.printStackTrace(); } System.out.println(\"测试初始化完成，正在开始测试案例...\"); } @Test public void method1(){ try (SqlSession sqlSession = sqlSessionFactory.openSession(true)){ TestMapper mapper = sqlSession.getMapper(TestMapper.class); Student student = mapper.getStudentBySidAndSex(1, \"男\"); Assert.assertEquals(new Student().setName(\"小明\").setSex(\"男\").setSid(1), student); System.out.println(\"测试用例1通过！\"); } } @Test public void method2(){ try (SqlSession sqlSession = sqlSessionFactory.openSession(true)){ TestMapper mapper = sqlSession.getMapper(TestMapper.class); Student student = mapper.getStudentBySidAndSex(2, \"女\"); Assert.assertEquals(new Student().setName(\"小红\").setSex(\"女\").setSid(2), student); System.out.println(\"测试用例2通过！\"); } } } 同理，在所有的测试完成之后，我们还想添加一个收尾的动作，那么只需要使用@After注解即可添加结束动作： @After public void after(){ System.out.println(\"测试结束，收尾工作正在进行...\"); } 有关JUnit的使用我们就暂时只介绍这么多。 ","date":"2022-02-16","objectID":"/posts/java%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93/:4:1","tags":["Java连接数据库"],"title":"Java连接数据库","uri":"/posts/java%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"categories":["JavaWeb笔记"],"content":"JUL日志系统 首先一问：我们为什么需要日志系统？ 我们之前一直都在使用System.out.println来打印信息，但是，如果项目中存在大量的控制台输出语句，会显得很凌乱，而且日志的粒度是不够细的，假如我们现在希望，项目只在debug的情况下打印某些日志，而在实际运行时不打印日志，采用直接输出的方式就很难实现了，因此我们需要使用日志框架来规范化日志输出。 而JDK为我们提供了一个自带的日志框架，位于java.util.logging包下，我们可以使用此框架来实现日志的规范化打印，使用起来非常简单： public class Main { public static void main(String[] args) { // 首先获取日志打印器 Logger logger = Logger.getLogger(Main.class.getName()); // 调用info来输出一个普通的信息，直接填写字符串即可 logger.info(\"我是普通的日志\"); } } 我们可以在主类中使用日志打印，得到日志的打印结果： 十一月 15, 2021 12:55:37 下午 com.test.Main main 信息: 我是普通的日志 我们发现，通过日志输出的结果会更加规范。 ","date":"2022-02-16","objectID":"/posts/java%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93/:5:0","tags":["Java连接数据库"],"title":"Java连接数据库","uri":"/posts/java%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"categories":["JavaWeb笔记"],"content":"JUL日志讲解 日志分为7个级别，详细信息我们可以在Level类中查看： SEVERE（最高值）- 一般用于代表严重错误 WARNING - 一般用于表示某些警告，但是不足以判断为错误 INFO （默认级别） - 常规消息 CONFIG FINE FINER FINEST（最低值） 我们之前通过info方法直接输出的结果就是使用的默认级别的日志，我们可以通过log方法来设定该条日志的输出级别： public static void main(String[] args) { Logger logger = Logger.getLogger(Main.class.getName()); logger.log(Level.SEVERE, \"严重的错误\", new IOException(\"我就是错误\")); logger.log(Level.WARNING, \"警告的内容\"); logger.log(Level.INFO, \"普通的信息\"); logger.log(Level.CONFIG, \"级别低于普通信息\"); } 我们发现，级别低于默认级别的日志信息，无法输出到控制台，我们可以通过设置来修改日志的打印级别： public static void main(String[] args) { Logger logger = Logger.getLogger(Main.class.getName()); //修改日志级别 logger.setLevel(Level.CONFIG); //不使用父日志处理器 logger.setUseParentHandlers(false); //使用自定义日志处理器 ConsoleHandler handler = new ConsoleHandler(); handler.setLevel(Level.CONFIG); logger.addHandler(handler); logger.log(Level.SEVERE, \"严重的错误\", new IOException(\"我就是错误\")); logger.log(Level.WARNING, \"警告的内容\"); logger.log(Level.INFO, \"普通的信息\"); logger.log(Level.CONFIG, \"级别低于普通信息\"); } 每个Logger都有一个父日志打印器，我们可以通过getParent()来获取： public static void main(String[] args) throws IOException { Logger logger = Logger.getLogger(Main.class.getName()); System.out.println(logger.getParent().getClass()); } 我们发现，得到的是java.util.logging.LogManager$RootLogger这个类，它默认使用的是ConsoleHandler，且日志级别为INFO，由于每一个日志打印器都会直接使用父类的处理器，因此我们之前需要关闭父类然后使用我们自己的处理器。 我们通过使用自己日志处理器来自定义级别的信息打印到控制台，当然，日志处理器不仅仅只有控制台打印，我们也可以使用文件处理器来处理日志信息，我们继续添加一个处理器： //添加输出到本地文件 FileHandler fileHandler = new FileHandler(\"test.log\"); fileHandler.setLevel(Level.WARNING); logger.addHandler(fileHandler); 注意，这个时候就有两个日志处理器了，因此控制台和文件的都会生效。如果日志的打印格式我们不喜欢，我们还可以自定义打印格式，比如我们控制台处理器就默认使用的是SimpleFormatter，而文件处理器则是使用的XMLFormatter，我们可以自定义： //使用自定义日志处理器(控制台) ConsoleHandler handler = new ConsoleHandler(); handler.setLevel(Level.CONFIG); handler.setFormatter(new XMLFormatter()); logger.addHandler(handler); 我们可以直接配置为想要的打印格式，如果这些格式还不能满足你，那么我们也可以自行实现： public static void main(String[] args) throws IOException { Logger logger = Logger.getLogger(Main.class.getName()); logger.setUseParentHandlers(false); //为了让颜色变回普通的颜色，通过代码块在初始化时将输出流设定为System.out ConsoleHandler handler = new ConsoleHandler(){{ setOutputStream(System.out); }}; //创建匿名内部类实现自定义的格式 handler.setFormatter(new Formatter() { @Override public String format(LogRecord record) { SimpleDateFormat format = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss.SSS\"); String time = format.format(new Date(record.getMillis())); //格式化日志时间 String level = record.getLevel().getName(); // 获取日志级别名称 // String level = record.getLevel().getLocalizedName(); // 获取本地化名称（语言跟随系统） String thread = String.format(\"%10s\", Thread.currentThread().getName()); //线程名称（做了格式化处理，留出10格空间） long threadID = record.getThreadID(); //线程ID String className = String.format(\"%-20s\", record.getSourceClassName()); //发送日志的类名 String msg = record.getMessage(); //日志消息 //\\033[33m作为颜色代码，30~37都有对应的颜色，38是没有颜色，IDEA能显示，但是某些地方可能不支持 return \"\\033[38m\" + time + \" \\033[33m\" + level + \" \\033[35m\" + threadID + \"\\033[38m --- [\" + thread + \"] \\033[36m\" + className + \"\\033[38m : \" + msg + \"\\n\"; } }); logger.addHandler(handler); logger.info(\"我是测试消息1...\"); logger.log(Level.INFO, \"我是测试消息2...\"); logger.log(Level.WARNING, \"我是测试消息3...\"); } 日志可以设置过滤器，如果我们不希望某些日志信息被输出，我们可以配置过滤规则： public static void main(String[] args) throws IOException { Logger logger = Logger.getLogger(Main.class.getName()); //自定义过滤规则 logger.setFilter(record -\u003e !record.getMessage().contains(\"普通\")); logger.log(Level.SEVERE, \"严重的错误\", new IOException(\"我就是错误\")); logger.log(Level.WARNING, \"警告的内容\"); logger.log(Level.INFO, \"普通的信息\"); } 实际上，整个日志的输出流程如下： ","date":"2022-02-16","objectID":"/posts/java%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93/:5:1","tags":["Java连接数据库"],"title":"Java连接数据库","uri":"/posts/java%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"categories":["JavaWeb笔记"],"content":"Properties配置文件 Properties文件是Java的一种配置文件，我们之前学习了XML，但是我们发现XML配置文件读取实在是太麻烦，那么能否有一种简单一点的配置文件呢？我们可以使用Properties文件： name=Test\rdesc=Description\r该文件配置很简单，格式为配置项=配置值，我们可以直接通过Properties类来将其读取为一个类似于Map一样的对象： public static void main(String[] args) throws IOException { Properties properties = new Properties(); properties.load(new FileInputStream(\"test.properties\")); System.out.println(properties); } 我们发现，Properties类是继承自Hashtable，而Hashtable是实现的Map接口，也就是说，Properties本质上就是一个Map一样的结构，它会把所有的配置项映射为一个Map，这样我们就可以快速地读取对应配置的值了。 我们也可以将已经存在的Properties对象放入输出流进行保存，我们这里就不保存文件了，而是直接打印到控制台，我们只需要提供输出流即可： public static void main(String[] args) throws IOException { Properties properties = new Properties(); // properties.setProperty(\"test\", \"lbwnb\"); //和put效果一样 properties.put(\"test\", \"lbwnb\"); properties.store(System.out, \"????\"); //properties.storeToXML(System.out, \"????\"); 保存为XML格式 } 我们可以通过System.getProperties()获取系统的参数，我们来看看： public static void main(String[] args) throws IOException { System.getProperties().store(System.out, \"系统信息：\"); } ","date":"2022-02-16","objectID":"/posts/java%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93/:5:2","tags":["Java连接数据库"],"title":"Java连接数据库","uri":"/posts/java%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"categories":["JavaWeb笔记"],"content":"编写日志配置文件 我们可以通过进行配置文件来规定日志打印器的一些默认值： # RootLogger 的默认处理器为\rhandlers= java.util.logging.ConsoleHandler\r# RootLogger 的默认的日志级别\r.level= CONFIG\r我们来尝试使用配置文件来进行配置： public static void main(String[] args) throws IOException { //获取日志管理器 LogManager manager = LogManager.getLogManager(); //读取我们自己的配置文件 manager.readConfiguration(new FileInputStream(\"logging.properties\")); //再获取日志打印器 Logger logger = Logger.getLogger(Main.class.getName()); logger.log(Level.CONFIG, \"我是一条日志信息\"); //通过自定义配置文件，我们发现默认级别不再是INFO了 } 我们也可以去修改ConsoleHandler的默认配置： # 指定默认日志级别\rjava.util.logging.ConsoleHandler.level = ALL\r# 指定默认日志消息格式\rjava.util.logging.ConsoleHandler.formatter = java.util.logging.SimpleFormatter\r# 指定默认的字符集\rjava.util.logging.ConsoleHandler.encoding = UTF-8\r其实，我们阅读ConsoleHandler的源码就会发现，它就是通过读取配置文件来进行某些参数设置： // Private method to configure a ConsoleHandler from LogManager // properties and/or default values as specified in the class // javadoc. private void configure() { LogManager manager = LogManager.getLogManager(); String cname = getClass().getName(); setLevel(manager.getLevelProperty(cname +\".level\", Level.INFO)); setFilter(manager.getFilterProperty(cname +\".filter\", null)); setFormatter(manager.getFormatterProperty(cname +\".formatter\", new SimpleFormatter())); try { setEncoding(manager.getStringProperty(cname +\".encoding\", null)); } catch (Exception ex) { try { setEncoding(null); } catch (Exception ex2) { // doing a setEncoding with null should always work. // assert false; } } } ","date":"2022-02-16","objectID":"/posts/java%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93/:5:3","tags":["Java连接数据库"],"title":"Java连接数据库","uri":"/posts/java%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"categories":["JavaWeb笔记"],"content":"使用Lombok快速开启日志 我们发现，如果我们现在需要全面使用日志系统，而不是传统的直接打印，那么就需要在每个类都去编写获取Logger的代码，这样显然是很冗余的，能否简化一下这个流程呢？ 前面我们学习了Lombok，我们也体会到Lombok给我们带来的便捷，我们可以通过一个注解快速生成构造方法、Getter和Setter，同样的，Logger也是可以使用Lombok快速生成的。 @Log public class Main { public static void main(String[] args) { System.out.println(\"自动生成的Logger名称：\"+log.getName()); log.info(\"我是日志信息\"); } } 只需要添加一个@Log注解即可，添加后，我们可以直接使用一个静态变量log，而它就是自动生成的Logger。我们也可以手动指定名称： @Log(topic = \"打工是不可能打工的\") public class Main { public static void main(String[] args) { System.out.println(\"自动生成的Logger名称：\"+log.getName()); log.info(\"我是日志信息\"); } } ","date":"2022-02-16","objectID":"/posts/java%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93/:5:4","tags":["Java连接数据库"],"title":"Java连接数据库","uri":"/posts/java%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"categories":["JavaWeb笔记"],"content":"Mybatis日志系统 Mybatis也有日志系统，它详细记录了所有的数据库操作等，但是我们在前面的学习中没有开启它，现在我们学习了日志之后，我们就可以尝试开启Mybatis的日志系统，来监控所有的数据库操作，要开启日志系统，我们需要进行配置： \u003csetting name=\"logImpl\" value=\"STDOUT_LOGGING\" /\u003e logImpl包括很多种配置项，包括 SLF4J | LOG4J | LOG4J2 | JDK_LOGGING | COMMONS_LOGGING | STDOUT_LOGGING | NO_LOGGING，而默认情况下是未配置，也就是说不打印。我们这里将其设定为STDOUT_LOGGING表示直接使用标准输出将日志信息打印到控制台，我们编写一个测试案例来看看效果： public class TestMain { private SqlSessionFactory sqlSessionFactory; @Before public void before(){ try { sqlSessionFactory = new SqlSessionFactoryBuilder() .build(new FileInputStream(\"mybatis-config.xml\")); } catch (FileNotFoundException e) { e.printStackTrace(); } } @Test public void test(){ try(SqlSession sqlSession = sqlSessionFactory.openSession(true)){ TestMapper mapper = sqlSession.getMapper(TestMapper.class); System.out.println(mapper.getStudentBySidAndSex(1, \"男\")); System.out.println(mapper.getStudentBySidAndSex(1, \"男\")); } } } 我们发现，两次获取学生信息，只有第一次打开了数据库连接，而第二次并没有。 现在我们学习了日志系统，那么我们来尝试使用日志系统输出Mybatis的日志信息： \u003csetting name=\"logImpl\" value=\"JDK_LOGGING\" /\u003e 将其配置为JDK_LOGGING表示使用JUL进行日志打印，因为Mybatis的日志级别都比较低，因此我们需要设置一下logging.properties默认的日志级别： handlers= java.util.logging.ConsoleHandler\r.level= ALL\rjava.util.logging.ConsoleHandler.level = ALL\r代码编写如下： @Log public class TestMain { private SqlSessionFactory sqlSessionFactory; @Before public void before(){ try { sqlSessionFactory = new SqlSessionFactoryBuilder() .build(new FileInputStream(\"mybatis-config.xml\")); LogManager manager = LogManager.getLogManager(); manager.readConfiguration(new FileInputStream(\"logging.properties\")); } catch (IOException e) { e.printStackTrace(); } } @Test public void test(){ try(SqlSession sqlSession = sqlSessionFactory.openSession(true)){ TestMapper mapper = sqlSession.getMapper(TestMapper.class); log.info(mapper.getStudentBySidAndSex(1, \"男\").toString()); log.info(mapper.getStudentBySidAndSex(1, \"男\").toString()); } } } 但是我们发现，这样的日志信息根本没法看，因此我们需要修改一下日志的打印格式，我们自己创建一个格式化类： public class TestFormatter extends Formatter { @Override public String format(LogRecord record) { SimpleDateFormat format = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss.SSS\"); String time = format.format(new Date(record.getMillis())); //格式化日志时间 return time + \" : \" + record.getMessage() + \"\\n\"; } } 现在再来修改一下默认的格式化实现： handlers= java.util.logging.ConsoleHandler\r.level= ALL\rjava.util.logging.ConsoleHandler.level = ALL\rjava.util.logging.ConsoleHandler.formatter = com.test.TestFormatter\r现在就好看多了，当然，我们还可以继续为Mybatis添加文件日志，这里就不做演示了。 ","date":"2022-02-16","objectID":"/posts/java%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93/:5:5","tags":["Java连接数据库"],"title":"Java连接数据库","uri":"/posts/java%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"categories":["JavaWeb笔记"],"content":"使用Maven管理项目 **注意：**开始之前，看看你C盘空间够不够，最好预留2GB空间以上！ **吐槽：**很多电脑预装系统C盘都给得巨少，就算不装软件，一些软件的缓存文件也能给你塞满，建议有时间重装一下系统重新分配一下磁盘空间。 Maven 翻译为\"专家”、“内行”，是 Apache 下的一个纯 Java 开发的开源项目。基于项目对象模型（缩写：POM）概念，Maven利用一个中央信息片断能管理一个项目的构建、报告和文档等步骤。Maven 是一个项目管理工具，可以对 Java 项目进行构建、依赖管理。Maven 也可被用于构建和管理各种项目，例如 C#，Ruby，Scala 和其他语言编写的项目。Maven 曾是 Jakarta 项目的子项目，现为由 Apache 软件基金会主持的独立 Apache 项目。 通过Maven，可以帮助我们做： 项目的自动构建，包括代码的编译、测试、打包、安装、部署等操作。 依赖管理，项目使用到哪些依赖，可以快速完成导入。 我们之前并没有讲解如何将我们的项目打包为Jar文件运行，同时，我们导入依赖的时候，每次都要去下载对应的Jar包，这样其实是很麻烦的，并且还有可能一个Jar包依赖于另一个Jar包，就像之前使用JUnit一样，因此我们需要一个更加方便的包管理机制。 Maven也需要安装环境，但是IDEA已经自带了Maven环境，因此我们不需要再去进行额外的环境安装（无IDEA也能使用Maven，但是配置过程很麻烦，并且我们现在使用的都是IDEA的集成开发环境，所以这里就不讲解Maven命令行操作了）我们直接创建一个新的Maven项目即可。 ","date":"2022-02-16","objectID":"/posts/java%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93/:6:0","tags":["Java连接数据库"],"title":"Java连接数据库","uri":"/posts/java%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"categories":["JavaWeb笔记"],"content":"Maven项目结构 我们可以来看一下，一个Maven项目和我们普通的项目有什么区别： 那么首先，我们需要了解一下POM文件，它相当于是我们整个Maven项目的配置文件，它也是使用XML编写的： \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003cproject xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"\u003e \u003cmodelVersion\u003e4.0.0\u003c/modelVersion\u003e \u003cgroupId\u003eorg.example\u003c/groupId\u003e \u003cartifactId\u003eMavenTest\u003c/artifactId\u003e \u003cversion\u003e1.0-SNAPSHOT\u003c/version\u003e \u003cproperties\u003e \u003cmaven.compiler.source\u003e8\u003c/maven.compiler.source\u003e \u003cmaven.compiler.target\u003e8\u003c/maven.compiler.target\u003e \u003c/properties\u003e \u003c/project\u003e 我们可以看到，Maven的配置文件是以project为根节点，而modelVersion定义了当前模型的版本，一般是4.0.0，我们不用去修改。 groupId、artifactId、version这三个元素合在一起，用于唯一区别每个项目，别人如果需要将我们编写的代码作为依赖，那么就必须通过这三个元素来定位我们的项目，我们称为一个项目的基本坐标，所有的项目一般都有自己的Maven坐标，因此我们通过Maven导入其他的依赖只需要填写这三个基本元素就可以了，无需再下载Jar文件，而是Maven自动帮助我们下载依赖并导入。 groupId 一般用于指定组名称，命名规则一般和包名一致，比如我们这里使用的是org.example，一个组下面可以有很多个项目。 artifactId 一般用于指定项目在当前组中的唯一名称，也就是说在组中用于区分于其他项目的标记。 version 代表项目版本，随着我们项目的开发和改进，版本号也会不断更新，就像LOL一样，每次赛季更新都会有一个大版本更新，我们的Maven项目也是这样，我们可以手动指定当前项目的版本号，其他人使用我们的项目作为依赖时，也可以根本版本号进行选择（这里的SNAPSHOT代表快照，一般表示这是一个处于开发中的项目，正式发布项目一般只带版本号） properties中一般都是一些变量和选项的配置，我们这里指定了JDK的源代码和编译版本为1.8，无需进行修改。 ","date":"2022-02-16","objectID":"/posts/java%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93/:6:1","tags":["Java连接数据库"],"title":"Java连接数据库","uri":"/posts/java%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"categories":["JavaWeb笔记"],"content":"Maven依赖导入 现在我们尝试使用Maven来帮助我们快速导入依赖，我们需要导入之前的JDBC驱动依赖、JUnit依赖、Mybatis依赖、Lombok依赖，那么如何使用Maven来管理依赖呢？ 我们可以创建一个dependencies节点： \u003cdependencies\u003e //里面填写的就是所有的依赖 \u003c/dependencies\u003e 那么现在就可以向节点中填写依赖了，那么我们如何知道每个依赖的坐标呢？我们可以在：https://mvnrepository.com/ 进行查询（可能打不开，建议用流量，或是直接百度某个项目的Maven依赖），我们直接搜索lombok即可，打开后可以看到已经给我们写出了依赖的坐标： \u003cdependency\u003e \u003cgroupId\u003eorg.projectlombok\u003c/groupId\u003e \u003cartifactId\u003elombok\u003c/artifactId\u003e \u003cversion\u003e1.18.22\u003c/version\u003e \u003cscope\u003eprovided\u003c/scope\u003e \u003c/dependency\u003e 我们直接将其添加到dependencies节点中即可，现在我们来编写一个测试用例看看依赖导入成功了没有： public class Main { public static void main(String[] args) { Student student = new Student(\"小明\", 18); System.out.println(student); } } @Data @AllArgsConstructor public class Student { String name; int age; } 项目运行成功，表示成功导入了依赖。那么，Maven是如何进行依赖管理呢，以致于如此便捷的导入依赖，我们来看看Maven项目的依赖管理流程： 通过流程图我们得知，一个项目依赖一般是存储在中央仓库中，也有可能存储在一些其他的远程仓库（私服），几乎所有的依赖都被放到了中央仓库中，因此，Maven可以直接从中央仓库中下载大部分的依赖（Maven第一次导入依赖是需要联网的），远程仓库中下载之后 ，会暂时存储在本地仓库，我们会发现我们本地存在一个.m2文件夹，这就是Maven本地仓库文件夹，默认建立在C盘，如果你C盘空间不足，会出现问题！ 在下次导入依赖时，如果Maven发现本地仓库中就已经存在某个依赖，那么就不会再去远程仓库下载了。 可能在导入依赖时，小小伙伴们会出现卡顿的问题，我们建议配置一下IDEA自带的Maven插件远程仓库地址，我们打开IDEA的安装目录，找到安装根目录/plugins/maven/lib/maven3/conf文件夹，找到settings.xml文件，打开编辑： 找到mirros标签，添加以下内容： \u003cmirror\u003e \u003cid\u003enexus-aliyun\u003c/id\u003e \u003cmirrorOf\u003e*\u003c/mirrorOf\u003e \u003cname\u003eNexus aliyun\u003c/name\u003e \u003curl\u003ehttp://maven.aliyun.com/nexus/content/groups/public\u003c/url\u003e \u003c/mirror\u003e 这样，我们就将默认的远程仓库地址（国外），配置为国内的阿里云仓库地址了（依赖的下载速度就会快起来了） ","date":"2022-02-16","objectID":"/posts/java%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93/:6:2","tags":["Java连接数据库"],"title":"Java连接数据库","uri":"/posts/java%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"categories":["JavaWeb笔记"],"content":"Maven依赖作用域 除了三个基本的属性用于定位坐标外，依赖还可以添加以下属性： type：依赖的类型，对于项目坐标定义的packaging。大部分情况下，该元素不必声明，其默认值为jar scope：依赖的范围（作用域，着重讲解） optional：标记依赖是否可选 exclusions：用来排除传递性依赖（一个项目有可能依赖于其他项目，就像我们的项目，如果别人要用我们的项目作为依赖，那么就需要一起下载我们项目的依赖，如Lombok） 我们着重来讲解一下scope属性，它决定了依赖的作用域范围： compile ：为默认的依赖有效范围。如果在定义依赖关系的时候，没有明确指定依赖有效范围的话，则默认采用该依赖有效范围。此种依赖，在编译、运行、测试时均有效。 provided ：在编译、测试时有效，但是在运行时无效，也就是说，项目在运行时，不需要此依赖，比如我们上面的Lombok，我们只需要在编译阶段使用它，编译完成后，实际上已经转换为对应的代码了，因此Lombok不需要在项目运行时也存在。 runtime ：在运行、测试时有效，但是在编译代码时无效。比如我们如果需要自己写一个JDBC实现，那么肯定要用到JDK为我们指定的接口，但是实际上在运行时是不用自带JDK的依赖，因此只保留我们自己写的内容即可。 test ：只在测试时有效，例如：JUnit，我们一般只会在测试阶段使用JUnit，而实际项目运行时，我们就用不到测试了，那么我们来看看，导入JUnit的依赖： 同样的，我们可以在网站上搜索Junit的依赖，我们这里导入最新的JUnit5作为依赖： \u003cdependency\u003e \u003cgroupId\u003eorg.junit.jupiter\u003c/groupId\u003e \u003cartifactId\u003ejunit-jupiter\u003c/artifactId\u003e \u003cversion\u003e5.8.1\u003c/version\u003e \u003cscope\u003etest\u003c/scope\u003e \u003c/dependency\u003e 我们所有的测试用例全部编写到Maven项目给我们划分的test目录下，位于此目录下的内容不会在最后被打包到项目中，只用作开发阶段测试使用： public class MainTest { @Test public void test(){ System.out.println(\"测试\"); //Assert在JUnit5时名称发生了变化Assertions Assertions.assertArrayEquals(new int[]{1, 2, 3}, new int[]{1, 2}); } } 因此，一般仅用作测试的依赖如JUnit只保留在测试中即可，那么现在我们再来添加JDBC和Mybatis的依赖： \u003cdependency\u003e \u003cgroupId\u003emysql\u003c/groupId\u003e \u003cartifactId\u003emysql-connector-java\u003c/artifactId\u003e \u003cversion\u003e8.0.27\u003c/version\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.mybatis\u003c/groupId\u003e \u003cartifactId\u003emybatis\u003c/artifactId\u003e \u003cversion\u003e3.5.7\u003c/version\u003e \u003c/dependency\u003e 我们发现，Maven还给我们提供了一个resource文件夹，我们可以将一些静态资源，比如配置文件，放入到这个文件夹中，项目在打包时会将资源文件夹中文件一起打包的Jar中，比如我们在这里编写一个Mybatis的配置文件： \u003c?xml version=\"1.0\" encoding=\"UTF-8\" ?\u003e \u003c!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\"\u003e \u003cconfiguration\u003e \u003csettings\u003e \u003csetting name=\"mapUnderscoreToCamelCase\" value=\"true\"/\u003e \u003csetting name=\"cacheEnabled\" value=\"true\"/\u003e \u003csetting name=\"logImpl\" value=\"JDK_LOGGING\" /\u003e \u003c/settings\u003e \u003c!-- 需要在environments的上方 --\u003e \u003ctypeAliases\u003e \u003cpackage name=\"com.test.entity\"/\u003e \u003c/typeAliases\u003e \u003cenvironments default=\"development\"\u003e \u003cenvironment id=\"development\"\u003e \u003ctransactionManager type=\"JDBC\"/\u003e \u003cdataSource type=\"POOLED\"\u003e \u003cproperty name=\"driver\" value=\"com.mysql.cj.jdbc.Driver\"/\u003e \u003cproperty name=\"url\" value=\"jdbc:mysql://localhost:3306/study\"/\u003e \u003cproperty name=\"username\" value=\"test\"/\u003e \u003cproperty name=\"password\" value=\"123456\"/\u003e \u003c/dataSource\u003e \u003c/environment\u003e \u003c/environments\u003e \u003cmappers\u003e \u003cmapper class=\"com.test.mapper.TestMapper\"/\u003e \u003c/mappers\u003e \u003c/configuration\u003e 现在我们创建一下测试用例，顺便带大家了解一下Junit5的一些比较方便的地方： public class MainTest { //因为配置文件位于内部，我们需要使用Resources类的getResourceAsStream来获取内部的资源文件 private static SqlSessionFactory factory; //在JUnit5中@Before被废弃，它被细分了： @BeforeAll // 一次性开启所有测试案例只会执行一次 (方法必须是static) // @BeforeEach 一次性开启所有测试案例每个案例开始之前都会执行一次 @SneakyThrows public static void before(){ factory = new SqlSessionFactoryBuilder() .build(Resources.getResourceAsStream(\"mybatis.xml\")); } @DisplayName(\"Mybatis数据库测试\") //自定义测试名称 @RepeatedTest(3) //自动执行多次测试 public void test(){ try (SqlSession sqlSession = factory.openSession(true)){ TestMapper testMapper = sqlSession.getMapper(TestMapper.class); System.out.println(testMapper.getStudentBySid(1)); } } } 那么就有人提问了，如果我需要的依赖没有上传的远程仓库，而是只有一个Jar怎么办呢？我们可以使用第四种作用域： system：作用域和provided是一样的，但是它不是从远程仓库获取，而是直接导入本地Jar包： \u003cdependency\u003e \u003cgroupId\u003ejavax.jntm\u003c/groupId\u003e \u003cartifactId\u003elbwnb\u003c/artifactId\u003e \u003cversion\u003e2.0\u003c/version\u003e \u003cscope\u003esystem\u003c/scope\u003e \u003csystemPath\u003eC://学习资料/4K高清无码/test.jar\u003c/systemPath\u003e \u003c/dependency\u003e 比如上面的例子，如果scope为system，那么我们需要添加一个systemPath来指定jar文件的位置，这里就不再演示了。 ","date":"2022-02-16","objectID":"/posts/java%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93/:6:3","tags":["Java连接数据库"],"title":"Java连接数据库","uri":"/posts/java%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"categories":["JavaWeb笔记"],"content":"Maven可选依赖 当项目中的某些依赖不希望被使用此项目作为依赖的项目使用时，我们可以给依赖添加optional标签表示此依赖是可选的，默认在导入依赖时，不会导入可选的依赖： \u003coptional\u003etrue\u003c/optional\u003e 比如Mybatis的POM文件中，就存在大量的可选依赖： \u003cdependency\u003e \u003cgroupId\u003eorg.slf4j\u003c/groupId\u003e \u003cartifactId\u003eslf4j-api\u003c/artifactId\u003e \u003cversion\u003e1.7.30\u003c/version\u003e \u003coptional\u003etrue\u003c/optional\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.slf4j\u003c/groupId\u003e \u003cartifactId\u003eslf4j-log4j12\u003c/artifactId\u003e \u003cversion\u003e1.7.30\u003c/version\u003e \u003coptional\u003etrue\u003c/optional\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003elog4j\u003c/groupId\u003e \u003cartifactId\u003elog4j\u003c/artifactId\u003e \u003cversion\u003e1.2.17\u003c/version\u003e \u003coptional\u003etrue\u003c/optional\u003e \u003c/dependency\u003e ... 由于Mybatis要支持多种类型的日志，需要用到很多种不同的日志框架，因此需要导入这些依赖来做兼容，但是我们项目中并不一定会使用这些日志框架作为Mybatis的日志打印器，因此这些日志框架仅Mybatis内部做兼容需要导入使用，而我们可以选择不使用这些框架或是选择其中一个即可，也就是说我们导入Mybatis之后想用什么日志框架再自己加就可以了。 ","date":"2022-02-16","objectID":"/posts/java%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93/:6:4","tags":["Java连接数据库"],"title":"Java连接数据库","uri":"/posts/java%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"categories":["JavaWeb笔记"],"content":"Maven排除依赖 我们了解了可选依赖，现在我们可以让使用此项目作为依赖的项目默认不使用可选依赖，但是如果存在那种不是可选依赖，但是我们导入此项目有不希望使用此依赖该怎么办呢，这个时候我们就可以通过排除依赖来防止添加不必要的依赖： \u003cdependency\u003e \u003cgroupId\u003eorg.junit.jupiter\u003c/groupId\u003e \u003cartifactId\u003ejunit-jupiter\u003c/artifactId\u003e \u003cversion\u003e5.8.1\u003c/version\u003e \u003cscope\u003etest\u003c/scope\u003e \u003cexclusions\u003e \u003cexclusion\u003e \u003cgroupId\u003eorg.junit.jupiter\u003c/groupId\u003e \u003cartifactId\u003ejunit-jupiter-engine\u003c/artifactId\u003e \u003c/exclusion\u003e \u003c/exclusions\u003e \u003c/dependency\u003e 我们这里演示了排除JUnit的一些依赖，我们可以在外部库中观察排除依赖之后和之前的效果。 ","date":"2022-02-16","objectID":"/posts/java%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93/:6:5","tags":["Java连接数据库"],"title":"Java连接数据库","uri":"/posts/java%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"categories":["JavaWeb笔记"],"content":"Maven继承关系 一个Maven项目可以继承自另一个Maven项目，比如多个子项目都需要父项目的依赖，我们就可以使用继承关系来快速配置。 我们右键左侧栏，新建一个模块，来创建一个子项目： \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003cproject xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"\u003e \u003cparent\u003e \u003cartifactId\u003eMavenTest\u003c/artifactId\u003e \u003cgroupId\u003eorg.example\u003c/groupId\u003e \u003cversion\u003e1.0-SNAPSHOT\u003c/version\u003e \u003c/parent\u003e \u003cmodelVersion\u003e4.0.0\u003c/modelVersion\u003e \u003cartifactId\u003eChildModel\u003c/artifactId\u003e \u003cproperties\u003e \u003cmaven.compiler.source\u003e8\u003c/maven.compiler.source\u003e \u003cmaven.compiler.target\u003e8\u003c/maven.compiler.target\u003e \u003c/properties\u003e \u003c/project\u003e 我们可以看到，IDEA默认给我们添加了一个parent节点，表示此Maven项目是父Maven项目的子项目，子项目直接继承父项目的groupId，子项目会直接继承父项目的所有依赖，除非依赖添加了optional标签，我们来编写一个测试用例尝试一下: import lombok.extern.java.Log; @Log public class Main { public static void main(String[] args) { log.info(\"我是日志信息\"); } } 可以看到，子项目也成功继承了Lombok依赖。 我们还可以让父Maven项目统一管理所有的依赖，包括版本号等，子项目可以选取需要的作为依赖，而版本全由父项目管理，我们可以将dependencies全部放入dependencyManagement节点，这样父项目就完全作为依赖统一管理。 \u003cdependencyManagement\u003e \u003cdependencies\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.projectlombok\u003c/groupId\u003e \u003cartifactId\u003elombok\u003c/artifactId\u003e \u003cversion\u003e1.18.22\u003c/version\u003e \u003cscope\u003eprovided\u003c/scope\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.junit.jupiter\u003c/groupId\u003e \u003cartifactId\u003ejunit-jupiter\u003c/artifactId\u003e \u003cversion\u003e5.8.1\u003c/version\u003e \u003cscope\u003etest\u003c/scope\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003emysql\u003c/groupId\u003e \u003cartifactId\u003emysql-connector-java\u003c/artifactId\u003e \u003cversion\u003e8.0.27\u003c/version\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.mybatis\u003c/groupId\u003e \u003cartifactId\u003emybatis\u003c/artifactId\u003e \u003cversion\u003e3.5.7\u003c/version\u003e \u003c/dependency\u003e \u003c/dependencies\u003e \u003c/dependencyManagement\u003e 我们发现，子项目的依赖失效了，因为现在父项目没有依赖，而是将所有的依赖进行集中管理，子项目需要什么再拿什么即可，同时子项目无需指定版本，所有的版本全部由父项目决定，子项目只需要使用即可： \u003cdependencies\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.projectlombok\u003c/groupId\u003e \u003cartifactId\u003elombok\u003c/artifactId\u003e \u003cscope\u003eprovided\u003c/scope\u003e \u003c/dependency\u003e \u003c/dependencies\u003e 当然，父项目如果还存在dependencies节点的话，里面的内依赖依然是直接继承： \u003cdependencies\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.junit.jupiter\u003c/groupId\u003e \u003cartifactId\u003ejunit-jupiter\u003c/artifactId\u003e \u003cversion\u003e5.8.1\u003c/version\u003e \u003cscope\u003etest\u003c/scope\u003e \u003c/dependency\u003e \u003c/dependencies\u003e \u003cdependencyManagement\u003e \u003cdependencies\u003e ... ","date":"2022-02-16","objectID":"/posts/java%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93/:6:6","tags":["Java连接数据库"],"title":"Java连接数据库","uri":"/posts/java%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"categories":["JavaWeb笔记"],"content":"Maven常用命令 我们可以看到在IDEA右上角Maven板块中，每个Maven项目都有一个生命周期，实际上这些是Maven的一些插件，每个插件都有各自的功能，比如： clean命令，执行后会清理整个target文件夹，在之后编写Springboot项目时可以解决一些缓存没更新的问题。 validate命令可以验证项目的可用性。 compile命令可以将项目编译为.class文件。 install命令可以将当前项目安装到本地仓库，以供其他项目导入作为依赖使用 verify命令可以按顺序执行每个默认生命周期阶段（validate，compile，package等） ","date":"2022-02-16","objectID":"/posts/java%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93/:6:7","tags":["Java连接数据库"],"title":"Java连接数据库","uri":"/posts/java%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"categories":["JavaWeb笔记"],"content":"Maven测试项目 通过使用test命令，可以一键测试所有位于test目录下的测试案例，请注意有以下要求： 测试类的名称必须是以Test结尾，比如MainTest 测试方法上必须标注@Test注解，实测@RepeatedTest无效 这是由于JUnit5比较新，我们需要重新配置插件升级到高版本，才能完美的兼容Junit5： \u003cbuild\u003e \u003cplugins\u003e \u003cplugin\u003e \u003cgroupId\u003eorg.apache.maven.plugins\u003c/groupId\u003e \u003cartifactId\u003emaven-surefire-plugin\u003c/artifactId\u003e \u003c!-- JUnit 5 requires Surefire version 2.22.0 or higher --\u003e \u003cversion\u003e2.22.0\u003c/version\u003e \u003c/plugin\u003e \u003c/plugins\u003e \u003c/build\u003e 现在@RepeatedTest、@BeforeAll也能使用了。 ","date":"2022-02-16","objectID":"/posts/java%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93/:6:8","tags":["Java连接数据库"],"title":"Java连接数据库","uri":"/posts/java%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"categories":["JavaWeb笔记"],"content":"Maven打包项目 我们的项目在编写完成之后，要么作为Jar依赖，供其他模型使用，要么就作为一个可以执行的程序，在控制台运行，我们只需要直接执行package命令就可以直接对项目的代码进行打包，生成jar文件。 当然，以上方式仅适用于作为Jar依赖的情况，如果我们需要打包一个可执行文件，那么我不仅需要将自己编写的类打包到Jar中，同时还需要将依赖也一并打包到Jar中，因为我们使用了别人为我们通过的框架，自然也需要运行别人的代码，我们需要使用另一个插件来实现一起打包： \u003cplugin\u003e \u003cartifactId\u003emaven-assembly-plugin\u003c/artifactId\u003e \u003cversion\u003e3.1.0\u003c/version\u003e \u003cconfiguration\u003e \u003cdescriptorRefs\u003e \u003cdescriptorRef\u003ejar-with-dependencies\u003c/descriptorRef\u003e \u003c/descriptorRefs\u003e \u003carchive\u003e \u003cmanifest\u003e \u003caddClasspath\u003etrue\u003c/addClasspath\u003e \u003cmainClass\u003ecom.test.Main\u003c/mainClass\u003e \u003c/manifest\u003e \u003c/archive\u003e \u003c/configuration\u003e \u003cexecutions\u003e \u003cexecution\u003e \u003cid\u003emake-assembly\u003c/id\u003e \u003cphase\u003epackage\u003c/phase\u003e \u003cgoals\u003e \u003cgoal\u003esingle\u003c/goal\u003e \u003c/goals\u003e \u003c/execution\u003e \u003c/executions\u003e \u003c/plugin\u003e 在打包之前也会执行一次test命令，来保证项目能够正常运行，当测试出现问题时，打包将无法完成，我们也可以手动跳过，选择执行Maven目标来手动执行Maven命令，输入mvn package -Dmaven.test.skip=true 来以跳过测试的方式进行打包。 最后得到我们的Jar文件，在同级目录下输入java -jar xxxx.jar来运行我们打包好的Jar可执行程序（xxx代表文件名称） deploy命令用于发布项目到本地仓库和远程仓库，一般情况下用不到，这里就不做讲解了。 site命令用于生成当前项目的发布站点，暂时不需要了解。 我们之前还讲解了多模块项目，那么多模块下父项目存在一个packing打包类型标签，所有的父级项目的packing都为pom，packing默认是jar类型，如果不作配置，maven会将该项目打成jar包。作为父级项目，还有一个重要的属性，那就是modules，通过modules标签将项目的所有子项目引用进来，在build父级项目时，会根据子模块的相互依赖关系整理一个build顺序，然后依次build。 ","date":"2022-02-16","objectID":"/posts/java%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93/:6:9","tags":["Java连接数据库"],"title":"Java连接数据库","uri":"/posts/java%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"categories":["JavaWeb笔记"],"content":"实战：基于Mybatis+JUL+Lombok+Maven的图书管理系统（带单元测试） 项目需求： 在线录入学生信息和书籍信息 查询书籍信息列表 查询学生信息列表 查询借阅信息列表 完整的日志系统 ","date":"2022-02-16","objectID":"/posts/java%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93/:7:0","tags":["Java连接数据库"],"title":"Java连接数据库","uri":"/posts/java%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"categories":["手写数据结构"],"content":"徒手写的AVL竟然比STL中的红黑树效率更高？✨","date":"2022-02-16","objectID":"/posts/%E5%BE%92%E6%89%8B%E5%86%99%E7%9A%84avl%E7%AB%9F%E7%84%B6%E6%AF%94stl%E4%B8%AD%E7%9A%84%E7%BA%A2%E9%BB%91%E6%A0%91%E6%95%88%E7%8E%87%E6%9B%B4%E9%AB%98/","tags":["徒手写的AVL竟然比STL中的红黑树效率更高？✨"],"title":"徒手写的AVL竟然比STL中的红黑树效率更高？✨","uri":"/posts/%E5%BE%92%E6%89%8B%E5%86%99%E7%9A%84avl%E7%AB%9F%E7%84%B6%E6%AF%94stl%E4%B8%AD%E7%9A%84%E7%BA%A2%E9%BB%91%E6%A0%91%E6%95%88%E7%8E%87%E6%9B%B4%E9%AB%98/"},{"categories":["手写数据结构"],"content":"AVL树简介 AVL树的名字来源于它的发明作者G.M. Adelson-Velsky 和 E.M. Landis。AVL树是最先发明的自平衡二叉查找树（Self-Balancing Binary Search Tree,简称平衡二叉树）。 一棵AVL树有如下必要条件： 条件一：它必须是二叉查找树。 条件二：每个节点的左子树和右子树的高度差至多为1。 图一中左边二叉树的节点45的左孩子46比45大，不满足二叉搜索树的条件，因此它也不是一棵平衡二叉树。 右边二叉树满足二叉搜索树的条件，同时它满足条件二，因此它是一棵平衡二叉树。 左边二叉树的节点45左子树高度2，右子树高度0，左右子树高度差为2-0=2，不满足条件二；右边二叉树的节点均满足左右子树高度差至多为1，同时它满足二叉搜索树的要求，因此它是一棵平衡二叉树。 AVL树的查找、插入、删除操作在平均和最坏的情况下都是O（logn），这得益于它时刻维护着二叉树的平衡。但由于每次插入都需要不断的调整和维护，所以，实际上如果插入操作次数太多则同样会陷入超时的死局，最具优势的操作在于查找，因为它的底层设计使得它无论插入多少个元素，这颗二叉树总是严格平衡的，所以AVL树适用于插入操作不是很频繁，但查找操作极度频繁的情况，如果需要在插入和查找操作找一个均衡点，那么就只能选择红黑树了。 ","date":"2022-02-16","objectID":"/posts/%E5%BE%92%E6%89%8B%E5%86%99%E7%9A%84avl%E7%AB%9F%E7%84%B6%E6%AF%94stl%E4%B8%AD%E7%9A%84%E7%BA%A2%E9%BB%91%E6%A0%91%E6%95%88%E7%8E%87%E6%9B%B4%E9%AB%98/:1:0","tags":["徒手写的AVL竟然比STL中的红黑树效率更高？✨"],"title":"徒手写的AVL竟然比STL中的红黑树效率更高？✨","uri":"/posts/%E5%BE%92%E6%89%8B%E5%86%99%E7%9A%84avl%E7%AB%9F%E7%84%B6%E6%AF%94stl%E4%B8%AD%E7%9A%84%E7%BA%A2%E9%BB%91%E6%A0%91%E6%95%88%E7%8E%87%E6%9B%B4%E9%AB%98/"},{"categories":["手写数据结构"],"content":"AVL树的相关概念 平衡因子：将二叉树上节点的左子树高度减去右子树高度的值称为该节点的平衡因子BF(Balance Factor)。 在图二右边的AVL树上： 节点50的左子树高度为3，右子树高度为2，BF= 3-2 = 1； 节点45的左子树高度为2，右子树高度为1，BF= 2-1 = 1； 节点46的左子树高度为0，右子树高度为0，BF= 0-0 = 0； 节点65的左子树高度为0，右子树高度为1，BF= 0-1 = -1； 对于平衡二叉树，BF的取值范围为[-1,1]。如果发现某个节点的BF值不在此范围，则需要对树进行调整。 最小不平衡树：距离插入节点最近的，且平衡因子的绝对值大于1的节点为根的子树。 在图三中，左边二叉树的节点45的BF = 1，插入节点43后，节点45的BF = 2。节点45是距离插入点43最近的BF不在[-1,1]范围内的节点，因此以节点45为根的子树为最小不平衡子树。(这正好对应了递归的后序返回操作 中序的前驱和后继：顾名思义，就是中序遍历下的前一个结点和后一个结点，由于时二叉搜索树，所以中序遍历的前一个结点对应比这个结点小的最大结点，而后一个结点对应比这个结点大的最小结点。(这个可以看后面代码再进行理解)这个概念在进行删除结点的操作时很有用，因为删除结点后需要同时保证仍然为二叉搜索树。 关于对前驱和后继的一些寻找方法，请看我的另一篇博客：面试题 04.06. 后继者 ","date":"2022-02-16","objectID":"/posts/%E5%BE%92%E6%89%8B%E5%86%99%E7%9A%84avl%E7%AB%9F%E7%84%B6%E6%AF%94stl%E4%B8%AD%E7%9A%84%E7%BA%A2%E9%BB%91%E6%A0%91%E6%95%88%E7%8E%87%E6%9B%B4%E9%AB%98/:2:0","tags":["徒手写的AVL竟然比STL中的红黑树效率更高？✨"],"title":"徒手写的AVL竟然比STL中的红黑树效率更高？✨","uri":"/posts/%E5%BE%92%E6%89%8B%E5%86%99%E7%9A%84avl%E7%AB%9F%E7%84%B6%E6%AF%94stl%E4%B8%AD%E7%9A%84%E7%BA%A2%E9%BB%91%E6%A0%91%E6%95%88%E7%8E%87%E6%9B%B4%E9%AB%98/"},{"categories":["手写数据结构"],"content":"AVL树的实现详解 总体思维导图实现。 ","date":"2022-02-16","objectID":"/posts/%E5%BE%92%E6%89%8B%E5%86%99%E7%9A%84avl%E7%AB%9F%E7%84%B6%E6%AF%94stl%E4%B8%AD%E7%9A%84%E7%BA%A2%E9%BB%91%E6%A0%91%E6%95%88%E7%8E%87%E6%9B%B4%E9%AB%98/:3:0","tags":["徒手写的AVL竟然比STL中的红黑树效率更高？✨"],"title":"徒手写的AVL竟然比STL中的红黑树效率更高？✨","uri":"/posts/%E5%BE%92%E6%89%8B%E5%86%99%E7%9A%84avl%E7%AB%9F%E7%84%B6%E6%AF%94stl%E4%B8%AD%E7%9A%84%E7%BA%A2%E9%BB%91%E6%A0%91%E6%95%88%E7%8E%87%E6%9B%B4%E9%AB%98/"},{"categories":["手写数据结构"],"content":"1. 结点结构 struct node { int val; int depth; node *lchild; node *rchild; node() : val(0), lchild(nullptr), rchild(nullptr) {} node(int x) : val(x), lchild(nullptr), rchild(nullptr) {} }; val，结点的值。 depth，该结点的高度(它的左右子树中最高的高度+1)。 lchild，左孩子。 rchild，右孩子。 ","date":"2022-02-16","objectID":"/posts/%E5%BE%92%E6%89%8B%E5%86%99%E7%9A%84avl%E7%AB%9F%E7%84%B6%E6%AF%94stl%E4%B8%AD%E7%9A%84%E7%BA%A2%E9%BB%91%E6%A0%91%E6%95%88%E7%8E%87%E6%9B%B4%E9%AB%98/:3:1","tags":["徒手写的AVL竟然比STL中的红黑树效率更高？✨"],"title":"徒手写的AVL竟然比STL中的红黑树效率更高？✨","uri":"/posts/%E5%BE%92%E6%89%8B%E5%86%99%E7%9A%84avl%E7%AB%9F%E7%84%B6%E6%AF%94stl%E4%B8%AD%E7%9A%84%E7%BA%A2%E9%BB%91%E6%A0%91%E6%95%88%E7%8E%87%E6%9B%B4%E9%AB%98/"},{"categories":["手写数据结构"],"content":"2. AVL树的抽象数据结构（ADT） class AVLTree { /*date part*/ node *head; int length; public: /*construct and destruct part*/ AVLTree() : head(nullptr), length(0) {} AVLTree(int x) : head(new node(x)), length(1) {} ~AVLTree() { destroy(head); } public: /*iterator part*/ class iterator {//封装迭代器：内部类--只能调用外部类的静态函数 node *head; node *root; public: iterator(node *head, node *root) : head(head), root(root) {} iterator \u0026operator++(); bool operator==(const iterator \u0026x); bool operator!=(const iterator \u0026x); iterator operator++(int); iterator \u0026operator--(); iterator operator--(int); int operator*(); }; private: /*static member function*/ /*Rotate Part*/ static node *rotateRight(node *root); static node *rotateLeft(node *root); static node *rotateLeftRight(node *root); static node *rotateRightLeft(node *root); /*Destruct*/ static void destroy(node *root); /*Getter*/ static node *getNext(node *root, node *p); static node *getPre(node *root, node *p); static node *getMinNode(node *root); static node *getMaxNode(node *root); static int get_depth(node *root); static void update_depth(node *root); /*Insert\u0026Remove*/ static node *Insert(int x, node *root, int \u0026size); static node *remove(int x, node *root, int \u0026size); /*print_order*/ static void inorder(node *root); public: /*public interface*/ /*clear\u0026empty*/ void clear(); bool isEmpty(); /*find*/ bool find(int x); /*insert\u0026remove*/ void insert(int x); void remove(int x); /*size*/ int size(); /*begin\u0026end*/ iterator begin(); iterator end(); /*print*/ void inorder_print(); }; ","date":"2022-02-16","objectID":"/posts/%E5%BE%92%E6%89%8B%E5%86%99%E7%9A%84avl%E7%AB%9F%E7%84%B6%E6%AF%94stl%E4%B8%AD%E7%9A%84%E7%BA%A2%E9%BB%91%E6%A0%91%E6%95%88%E7%8E%87%E6%9B%B4%E9%AB%98/:3:2","tags":["徒手写的AVL竟然比STL中的红黑树效率更高？✨"],"title":"徒手写的AVL竟然比STL中的红黑树效率更高？✨","uri":"/posts/%E5%BE%92%E6%89%8B%E5%86%99%E7%9A%84avl%E7%AB%9F%E7%84%B6%E6%AF%94stl%E4%B8%AD%E7%9A%84%E7%BA%A2%E9%BB%91%E6%A0%91%E6%95%88%E7%8E%87%E6%9B%B4%E9%AB%98/"},{"categories":["手写数据结构"],"content":"3. AVL树高度相关操作 得到高度 static int get_depth(node *root) {//得到深度 if (root == nullptr) return 0; return root-\u003edepth; } 更新高度 static void update_depth(node *root) { if (root == nullptr) return; root-\u003edepth = std::max(get_depth(root-\u003elchild), get_depth(root-\u003erchild)) + 1; } ","date":"2022-02-16","objectID":"/posts/%E5%BE%92%E6%89%8B%E5%86%99%E7%9A%84avl%E7%AB%9F%E7%84%B6%E6%AF%94stl%E4%B8%AD%E7%9A%84%E7%BA%A2%E9%BB%91%E6%A0%91%E6%95%88%E7%8E%87%E6%9B%B4%E9%AB%98/:3:3","tags":["徒手写的AVL竟然比STL中的红黑树效率更高？✨"],"title":"徒手写的AVL竟然比STL中的红黑树效率更高？✨","uri":"/posts/%E5%BE%92%E6%89%8B%E5%86%99%E7%9A%84avl%E7%AB%9F%E7%84%B6%E6%AF%94stl%E4%B8%AD%E7%9A%84%E7%BA%A2%E9%BB%91%E6%A0%91%E6%95%88%E7%8E%87%E6%9B%B4%E9%AB%98/"},{"categories":["手写数据结构"],"content":"4. 得到子树中最大/最小结点 原理：根据二叉搜索树中结点的左子树一定小于该结点，右子树一定大于该结点。 得到最大：直接遍历得出该结点的最右结点。 static node* getMaxNode(node* root) { if (root == nullptr) return nullptr; while (root-\u003erchild != nullptr) root = root-\u003erchild; return root; } 得到最小：直接遍历得出该结点的最左结点。 static node* getMinNode(node* root) { if (root == nullptr) return nullptr; while (root-\u003elchild != nullptr) root = root-\u003elchild; return root; } ","date":"2022-02-16","objectID":"/posts/%E5%BE%92%E6%89%8B%E5%86%99%E7%9A%84avl%E7%AB%9F%E7%84%B6%E6%AF%94stl%E4%B8%AD%E7%9A%84%E7%BA%A2%E9%BB%91%E6%A0%91%E6%95%88%E7%8E%87%E6%9B%B4%E9%AB%98/:3:4","tags":["徒手写的AVL竟然比STL中的红黑树效率更高？✨"],"title":"徒手写的AVL竟然比STL中的红黑树效率更高？✨","uri":"/posts/%E5%BE%92%E6%89%8B%E5%86%99%E7%9A%84avl%E7%AB%9F%E7%84%B6%E6%AF%94stl%E4%B8%AD%E7%9A%84%E7%BA%A2%E9%BB%91%E6%A0%91%E6%95%88%E7%8E%87%E6%9B%B4%E9%AB%98/"},{"categories":["手写数据结构"],"content":"5. 得到结点的前驱和后继 注意：二叉搜索树的前驱后继一般指的是它中序遍历的前一个和后一个结点，也就是从小到大排的前一个和后一个结点。 具体可以看我之前的博客–后继者 后继结点求解：如果有右子树，就是右子树的最小结点，如果没有，则是距离该节点最近的处于该节点右边的父节点。 static node* getNext(node* root, node* p) { //得到p节点的后继结点 if (root == nullptr || p == nullptr) return nullptr; if (p-\u003eval \u003e= root-\u003eval) { return getNext(root-\u003erchild, p); } else { node* left = getNext(root-\u003elchild, p); return left ? left : root; } } 前驱结点求解：如果有左子树，就是左子树的最大结点，如果没有，则是距离该节点最近的处于该节点左边的父节点。 static node* getPre(node* root, node* p) { //得到p节点的前驱结点 if (root == nullptr || p == nullptr)return nullptr; if (p-\u003eval \u003c= root-\u003eval) { return getPre(root-\u003elchild, p); } else { node* right = getPre(root-\u003erchild, p); return right ? right : root; } } ","date":"2022-02-16","objectID":"/posts/%E5%BE%92%E6%89%8B%E5%86%99%E7%9A%84avl%E7%AB%9F%E7%84%B6%E6%AF%94stl%E4%B8%AD%E7%9A%84%E7%BA%A2%E9%BB%91%E6%A0%91%E6%95%88%E7%8E%87%E6%9B%B4%E9%AB%98/:3:5","tags":["徒手写的AVL竟然比STL中的红黑树效率更高？✨"],"title":"徒手写的AVL竟然比STL中的红黑树效率更高？✨","uri":"/posts/%E5%BE%92%E6%89%8B%E5%86%99%E7%9A%84avl%E7%AB%9F%E7%84%B6%E6%AF%94stl%E4%B8%AD%E7%9A%84%E7%BA%A2%E9%BB%91%E6%A0%91%E6%95%88%E7%8E%87%E6%9B%B4%E9%AB%98/"},{"categories":["手写数据结构"],"content":"6. AVL树失衡的调整 节点的插入或删除都有可能导致AVL树失去平衡，因此，失衡调整是插入与删除操作的基础。 AVL树的失衡调整可以分为四种情况，我们逐一分析。 假设我们要为数组a[]={4，5，6，3，2，8，7，0，1}构建一棵AVL树。 情况一：左旋 首先插入{4，5，6}，在插入元素6后出现不平衡的情况： 当我们在右子树插入右孩子导致AVL失衡时，我们需要进行单左旋调整。旋转围绕最小失衡子树的根节点进行。 在删除新节点时也有可能会出现需要单左旋的情况。 左旋代码如下： static node *rotateLeft(node *root) { node *son = root-\u003erchild; root-\u003erchild = son-\u003elchild; son-\u003elchild = root; update_depth(root); update_depth(son); return son; } 情况二：右旋 我们继续插入元素{3，2}，此时二叉树为： 插入3、2后出现了不平衡的情况。此时的插入情况是“在左子树上插入左孩子导致AVL树失衡”，我们需要进行单右旋调整。 右旋代码： static node *rotateRight(node *root) {//右旋 node *son = root-\u003elchild; root-\u003elchild = son-\u003erchild; son-\u003erchild = root; update_depth(root);//更新深度(右旋只会对这两结点产生影响 update_depth(son); return son; } 情况三：先左旋后右旋 需要进行两次旋转的原因是第一次旋转后，AVL树仍旧处于不平衡的状态，第二次旋转再次进行调整。 我们继续插入元素{8，7} 这种情况，总结起来就是“在右子树上插入左孩子导致AVL树失衡\",此时我们需要进行先右旋后左旋的调整。 调整的代码为： static node *rotateLeftRight(node *root) { root-\u003elchild = rotateLeft(root-\u003elchild); return rotateRight(root); } 结合例子进行分析： 首先对最小不平衡子树的根节点（也就是节点6）的右孩子（也就是8）进行右旋操作 再对节点6进行一次左旋操作 情况四：先右旋再左旋 根据对称性原理，当我们“在左子树上插入右孩子导致AVL树失衡\",此时我们需要进行先左旋后右旋的调整。如果你不理解接着看图。 我们接着插入节点{0，1} 调整的代码: static node *rotateRightLeft(node *root) { root-\u003erchild = rotateRight(root-\u003erchild); return rotateLeft(root); } 结合例子进行分析： 首先对最小不平衡子树的根节点（也就是节点2）的左孩子（也就是0）进行左旋操作 再对节点2进行一次右旋操作 总结：四种失衡调整 ","date":"2022-02-16","objectID":"/posts/%E5%BE%92%E6%89%8B%E5%86%99%E7%9A%84avl%E7%AB%9F%E7%84%B6%E6%AF%94stl%E4%B8%AD%E7%9A%84%E7%BA%A2%E9%BB%91%E6%A0%91%E6%95%88%E7%8E%87%E6%9B%B4%E9%AB%98/:3:6","tags":["徒手写的AVL竟然比STL中的红黑树效率更高？✨"],"title":"徒手写的AVL竟然比STL中的红黑树效率更高？✨","uri":"/posts/%E5%BE%92%E6%89%8B%E5%86%99%E7%9A%84avl%E7%AB%9F%E7%84%B6%E6%AF%94stl%E4%B8%AD%E7%9A%84%E7%BA%A2%E9%BB%91%E6%A0%91%E6%95%88%E7%8E%87%E6%9B%B4%E9%AB%98/"},{"categories":["手写数据结构"],"content":"7. 插入新结点 //需要是否兼容相等的元素，可通过对 x\u003croot-\u003eval 或 x\u003eroot-\u003eval 这两个中的一个取等号即可 static node *Insert(int x, node *root, int\u0026 size) { //所有的deep的更新都在后序遍历后 if (root == nullptr) { root = new node(x); size++;//创建结点后size++ } else if (x \u003c root-\u003eval) { root-\u003elchild = Insert(x, root-\u003elchild, size); //由于在更新该root结点之前，当平衡度未达到该要求之前肯定以及是进行了update_depth操作 if (get_depth(root-\u003elchild) - get_depth(root-\u003erchild) == 2) root = x \u003c root-\u003elchild-\u003eval ? rotateRight(root) : rotateLeftRight(root); } else if (x \u003e root-\u003eval) { root-\u003erchild = Insert(x, root-\u003erchild, size); if (get_depth(root-\u003elchild) - get_depth(root-\u003erchild) == -2) root = x \u003e root-\u003erchild-\u003eval ? rotateLeft(root) : rotateRightLeft(root); } update_depth(root); return root; } ","date":"2022-02-16","objectID":"/posts/%E5%BE%92%E6%89%8B%E5%86%99%E7%9A%84avl%E7%AB%9F%E7%84%B6%E6%AF%94stl%E4%B8%AD%E7%9A%84%E7%BA%A2%E9%BB%91%E6%A0%91%E6%95%88%E7%8E%87%E6%9B%B4%E9%AB%98/:3:7","tags":["徒手写的AVL竟然比STL中的红黑树效率更高？✨"],"title":"徒手写的AVL竟然比STL中的红黑树效率更高？✨","uri":"/posts/%E5%BE%92%E6%89%8B%E5%86%99%E7%9A%84avl%E7%AB%9F%E7%84%B6%E6%AF%94stl%E4%B8%AD%E7%9A%84%E7%BA%A2%E9%BB%91%E6%A0%91%E6%95%88%E7%8E%87%E6%9B%B4%E9%AB%98/"},{"categories":["手写数据结构"],"content":"8. 删除结点 失衡的处理： 删除节点也可能导致AVL树的失衡，实际上删除节点和插入节点是一种互逆的操作： 删除右子树的节点导致AVL树失衡时，相当于在左子树插入节点导致AVL树失衡，即情况情况二或情况四。 删除左子树的节点导致AVL树失衡时，相当于在右子树插入节点导致AVL树失衡，即情况情况一或情况三。 维持排序树的处理： 另外，AVL树也是一棵二叉排序树，因此在删除节点时也要维护二叉排序树的性质。 如果删除结点为叶子结点，则直接删除，并不会改变搜索树的性质。 如果删除结点只有左子树或者右子树，则直接把要删除的结点的数据用下一个结点覆盖，然后删除下一个结点，由于复制了下一层的左右孩子指针，所以不会出现断层的。 如果删除结点左右子树都有，则找出该节点的前驱结点或后继结点的值进行覆盖(不覆盖指针，这样便仍然是排序二叉树了，然后**继续递归寻找对应的前驱或者后继结点进行删除，**因为左右子树都有，所以它们的前驱或者后继只能是叶子结点，找到直接删除即可。 删除处理代码： 我这里对删除操作进行了进一步优化，如果被删除结点的左右子树都存在，则查看左右子树的高度，如果左边高于右边则选择前驱结点进行删除，反之则后继。 static node *remove(int x, node *root, int\u0026 size) { if (root == nullptr) return nullptr; if (x == root-\u003eval) { /*左右子树均不为空---用中序的前驱或者后继来进行替换*/ if (root-\u003elchild != nullptr \u0026\u0026 root-\u003erchild != nullptr) { /*根据左右子树的深度来选择删除替换哪边的*/ if (get_depth(root-\u003elchild) \u003e get_depth(root-\u003erchild)) { node* t = getMaxNode(root-\u003elchild); root-\u003eval = t-\u003eval; root-\u003elchild = remove(t-\u003eval, root-\u003elchild, size); } else { node* t = getMinNode(root-\u003erchild); root-\u003eval = t-\u003eval; root-\u003erchild = remove(t-\u003eval, root-\u003erchild, size); } } /*左右子树至少有一个为空的情况，直接往下走一步即可*/ else { node* tmp = root-\u003elchild == nullptr ? root-\u003erchild : nullptr; if (tmp != nullptr) { *root = *tmp; delete tmp; } else { delete root; root = nullptr; } //删除时size-- size--; } } else if (x \u003c root-\u003eval) { root-\u003elchild = remove(x, root-\u003elchild, size); if (get_depth(root-\u003elchild) - get_depth(root-\u003erchild) == -2) root = get_depth(root-\u003erchild-\u003elchild) \u003e get_depth(root-\u003erchild-\u003erchild) ? rotateRightLeft(root) : rotateLeft(root); } else { root-\u003erchild = remove(x, root-\u003erchild, size); if (get_depth(root-\u003elchild) - get_depth(root-\u003erchild) == 2) root = get_depth(root-\u003elchild-\u003erchild) \u003e get_depth(root-\u003elchild-\u003elchild) ? rotateLeftRight(root) : rotateRight(root); } return root; } ","date":"2022-02-16","objectID":"/posts/%E5%BE%92%E6%89%8B%E5%86%99%E7%9A%84avl%E7%AB%9F%E7%84%B6%E6%AF%94stl%E4%B8%AD%E7%9A%84%E7%BA%A2%E9%BB%91%E6%A0%91%E6%95%88%E7%8E%87%E6%9B%B4%E9%AB%98/:3:8","tags":["徒手写的AVL竟然比STL中的红黑树效率更高？✨"],"title":"徒手写的AVL竟然比STL中的红黑树效率更高？✨","uri":"/posts/%E5%BE%92%E6%89%8B%E5%86%99%E7%9A%84avl%E7%AB%9F%E7%84%B6%E6%AF%94stl%E4%B8%AD%E7%9A%84%E7%BA%A2%E9%BB%91%E6%A0%91%E6%95%88%E7%8E%87%E6%9B%B4%E9%AB%98/"},{"categories":["手写数据结构"],"content":"9. 查找元素 二叉树是一种递归的定义，因此，二叉树的许多操作都可以通过递归简单地实现，例如遍历二叉树、查找指定元素、销毁二叉树等。 这里使用了迭代方式。 bool find(int x) { //查找直接迭代方式即可 node *f = head; while (f != nullptr) { if (x == f-\u003eval) return true; else if (x \u003c f-\u003eval) f = f-\u003elchild; else f = f-\u003erchild; } return false; } ","date":"2022-02-16","objectID":"/posts/%E5%BE%92%E6%89%8B%E5%86%99%E7%9A%84avl%E7%AB%9F%E7%84%B6%E6%AF%94stl%E4%B8%AD%E7%9A%84%E7%BA%A2%E9%BB%91%E6%A0%91%E6%95%88%E7%8E%87%E6%9B%B4%E9%AB%98/:3:9","tags":["徒手写的AVL竟然比STL中的红黑树效率更高？✨"],"title":"徒手写的AVL竟然比STL中的红黑树效率更高？✨","uri":"/posts/%E5%BE%92%E6%89%8B%E5%86%99%E7%9A%84avl%E7%AB%9F%E7%84%B6%E6%AF%94stl%E4%B8%AD%E7%9A%84%E7%BA%A2%E9%BB%91%E6%A0%91%E6%95%88%E7%8E%87%E6%9B%B4%E9%AB%98/"},{"categories":["手写数据结构"],"content":"10. 遍历二叉树 我这里只提供了中序遍历的打印，方便验证二叉搜索树的情况。 static void inorder(node *root) { if (root != nullptr) { inorder(root-\u003elchild); printf(\"%d \", root-\u003eval); inorder(root-\u003erchild); } } ","date":"2022-02-16","objectID":"/posts/%E5%BE%92%E6%89%8B%E5%86%99%E7%9A%84avl%E7%AB%9F%E7%84%B6%E6%AF%94stl%E4%B8%AD%E7%9A%84%E7%BA%A2%E9%BB%91%E6%A0%91%E6%95%88%E7%8E%87%E6%9B%B4%E9%AB%98/:3:10","tags":["徒手写的AVL竟然比STL中的红黑树效率更高？✨"],"title":"徒手写的AVL竟然比STL中的红黑树效率更高？✨","uri":"/posts/%E5%BE%92%E6%89%8B%E5%86%99%E7%9A%84avl%E7%AB%9F%E7%84%B6%E6%AF%94stl%E4%B8%AD%E7%9A%84%E7%BA%A2%E9%BB%91%E6%A0%91%E6%95%88%E7%8E%87%E6%9B%B4%E9%AB%98/"},{"categories":["手写数据结构"],"content":"11. AVL树的销毁 直接利用后序先处理完左右子树再处理根节点。 static void destroy(node *root) { if (root == nullptr) return; destroy(root-\u003elchild); destroy(root-\u003erchild); delete root; root = nullptr; } ","date":"2022-02-16","objectID":"/posts/%E5%BE%92%E6%89%8B%E5%86%99%E7%9A%84avl%E7%AB%9F%E7%84%B6%E6%AF%94stl%E4%B8%AD%E7%9A%84%E7%BA%A2%E9%BB%91%E6%A0%91%E6%95%88%E7%8E%87%E6%9B%B4%E9%AB%98/:3:11","tags":["徒手写的AVL竟然比STL中的红黑树效率更高？✨"],"title":"徒手写的AVL竟然比STL中的红黑树效率更高？✨","uri":"/posts/%E5%BE%92%E6%89%8B%E5%86%99%E7%9A%84avl%E7%AB%9F%E7%84%B6%E6%AF%94stl%E4%B8%AD%E7%9A%84%E7%BA%A2%E9%BB%91%E6%A0%91%E6%95%88%E7%8E%87%E6%9B%B4%E9%AB%98/"},{"categories":["手写数据结构"],"content":"12. 迭代器的设计 关于C++里面的迭代器，其实就是方便遍历容器中的元素，而迭代器需要模拟指针的行为，所以在C++中迭代器其实就是对指针特别包装的类，对其进行一些运算符的重载即可。 内部类充当迭代器 由于需要满足顺序容器的迭代顺序，所以++和–操作对应后继和前驱。 /*iterator part*/ class iterator { //封装迭代器 node* head; node* root; public: iterator(node* head, node* root): head(head), root(root) {} iterator\u0026 operator++() { //直接把root加为当前的后继结点 root = getNext(head, root); return *this; } bool operator==(const iterator\u0026 x) { return this-\u003eroot == x.root; } bool operator!=(const iterator\u0026 x) { return this-\u003eroot != x.root; } iterator operator++(int) { iterator t = *this; root = getNext(head, root); return t; } iterator\u0026 operator--() { //直接把root赋值为前驱结点 root = getPre(head, root); return *this; } iterator operator--(int) { iterator t = *this; root = getPre(head, root); return t; } node\u0026 operator*() { //解引用的重载 return *root; } }; 外部类提供外界begin()和end()接口得到迭代器的始端和末端 iterator begin() { node* min = getMinNode(head); return iterator(head, min); } iterator end() { //end表示结束标记 return iterator(head, nullptr); } ","date":"2022-02-16","objectID":"/posts/%E5%BE%92%E6%89%8B%E5%86%99%E7%9A%84avl%E7%AB%9F%E7%84%B6%E6%AF%94stl%E4%B8%AD%E7%9A%84%E7%BA%A2%E9%BB%91%E6%A0%91%E6%95%88%E7%8E%87%E6%9B%B4%E9%AB%98/:3:12","tags":["徒手写的AVL竟然比STL中的红黑树效率更高？✨"],"title":"徒手写的AVL竟然比STL中的红黑树效率更高？✨","uri":"/posts/%E5%BE%92%E6%89%8B%E5%86%99%E7%9A%84avl%E7%AB%9F%E7%84%B6%E6%AF%94stl%E4%B8%AD%E7%9A%84%E7%BA%A2%E9%BB%91%E6%A0%91%E6%95%88%E7%8E%87%E6%9B%B4%E9%AB%98/"},{"categories":["手写数据结构"],"content":"完整代码 我的GitHub ","date":"2022-02-16","objectID":"/posts/%E5%BE%92%E6%89%8B%E5%86%99%E7%9A%84avl%E7%AB%9F%E7%84%B6%E6%AF%94stl%E4%B8%AD%E7%9A%84%E7%BA%A2%E9%BB%91%E6%A0%91%E6%95%88%E7%8E%87%E6%9B%B4%E9%AB%98/:4:0","tags":["徒手写的AVL竟然比STL中的红黑树效率更高？✨"],"title":"徒手写的AVL竟然比STL中的红黑树效率更高？✨","uri":"/posts/%E5%BE%92%E6%89%8B%E5%86%99%E7%9A%84avl%E7%AB%9F%E7%84%B6%E6%AF%94stl%E4%B8%AD%E7%9A%84%E7%BA%A2%E9%BB%91%E6%A0%91%E6%95%88%E7%8E%87%E6%9B%B4%E9%AB%98/"},{"categories":["手写数据结构"],"content":"AVLTree.h // // Created by Alone on 2021/10/12. // #include \u003calgorithm\u003e#include \u003ccstdio\u003e#include \u003ccassert\u003e #ifndef MY_TINY_STL_AVLTREE_H #define MY_TINY_STL_AVLTREE_H namespace L_B__ { struct node { int val; int depth; node *lchild; node *rchild; node() : val(0), lchild(nullptr), rchild(nullptr) {} node(int x) : val(x), lchild(nullptr), rchild(nullptr) {} }; class AVLTree { /*date part*/ node *head; int length; public: /*construct and destruct part*/ AVLTree() : head(nullptr), length(0) {} AVLTree(int x) : head(new node(x)), length(1) {} ~AVLTree() { destroy(head); } public: /*iterator part*/ class iterator {//封装迭代器：内部类--只能调用外部类的静态函数 node *head; node *root; public: iterator(node *head, node *root) : head(head), root(root) {} iterator \u0026operator++(); bool operator==(const iterator \u0026x); bool operator!=(const iterator \u0026x); iterator operator++(int); iterator \u0026operator--(); iterator operator--(int); int operator*(); }; private: /*static member function*/ /*Rotate Part*/ static node *rotateRight(node *root); static node *rotateLeft(node *root); static node *rotateLeftRight(node *root); static node *rotateRightLeft(node *root); /*Destruct*/ static void destroy(node *root); /*Getter*/ static node *getNext(node *root, node *p); static node *getPre(node *root, node *p); static node *getMinNode(node *root); static node *getMaxNode(node *root); static int get_depth(node *root); static void update_depth(node *root); /*Insert\u0026Remove*/ static node *Insert(int x, node *root, int \u0026size); static node *remove(int x, node *root, int \u0026size); /*print_order*/ static void inorder(node *root); public: /*public interface*/ /*clear\u0026empty*/ void clear(); bool isEmpty(); /*find*/ bool find(int x); /*insert\u0026remove*/ void insert(int x); void remove(int x); /*size*/ int size(); /*begin\u0026end*/ iterator begin(); iterator end(); /*print*/ void inorder_print(); }; } #endif //MY_TINY_STL_AVLTREE_H ","date":"2022-02-16","objectID":"/posts/%E5%BE%92%E6%89%8B%E5%86%99%E7%9A%84avl%E7%AB%9F%E7%84%B6%E6%AF%94stl%E4%B8%AD%E7%9A%84%E7%BA%A2%E9%BB%91%E6%A0%91%E6%95%88%E7%8E%87%E6%9B%B4%E9%AB%98/:4:1","tags":["徒手写的AVL竟然比STL中的红黑树效率更高？✨"],"title":"徒手写的AVL竟然比STL中的红黑树效率更高？✨","uri":"/posts/%E5%BE%92%E6%89%8B%E5%86%99%E7%9A%84avl%E7%AB%9F%E7%84%B6%E6%AF%94stl%E4%B8%AD%E7%9A%84%E7%BA%A2%E9%BB%91%E6%A0%91%E6%95%88%E7%8E%87%E6%9B%B4%E9%AB%98/"},{"categories":["手写数据结构"],"content":"AVLTree.cpp // // Created by Alone on 2021/10/12. // #include \"AVLTree.h\" /*Rotate*/ L_B__::node *L_B__::AVLTree::rotateRight(L_B__::node *root) {//右旋 node *son = root-\u003elchild; root-\u003elchild = son-\u003erchild; son-\u003erchild = root; update_depth(root);//更新深度(右旋只会对这两结点产生影响 update_depth(son); return son; } L_B__::node *L_B__::AVLTree::rotateLeft(L_B__::node *root) { node *son = root-\u003erchild; root-\u003erchild = son-\u003elchild; son-\u003elchild = root; update_depth(root); update_depth(son); return son; } L_B__::node *L_B__::AVLTree::rotateLeftRight(L_B__::node *root) { root-\u003elchild = rotateLeft(root-\u003elchild); return rotateRight(root); } L_B__::node *L_B__::AVLTree::rotateRightLeft(L_B__::node *root) { root-\u003erchild = rotateRight(root-\u003erchild); return rotateLeft(root); } /*Destruct*/ void L_B__::AVLTree::destroy(L_B__::node *root) { if (root == nullptr) return; destroy(root-\u003elchild); destroy(root-\u003erchild); delete root; root = nullptr; } /*Getter*/ L_B__::node *L_B__::AVLTree::getNext(L_B__::node *root, L_B__::node *p) { if (root == nullptr || p == nullptr) return nullptr; if (p-\u003eval \u003e= root-\u003eval) { return getNext(root-\u003erchild, p); } else { node *left = getNext(root-\u003elchild, p); return left ? left : root; } } L_B__::node *L_B__::AVLTree::getPre(L_B__::node *root, L_B__::node *p) { if (root == nullptr || p == nullptr)return nullptr; if (p-\u003eval \u003c= root-\u003eval) { return getPre(root-\u003elchild, p); } else { node *right = getPre(root-\u003erchild, p); return right ? right : root; } } L_B__::node *L_B__::AVLTree::getMinNode(L_B__::node *root) { if (root == nullptr) return nullptr; while (root-\u003elchild != nullptr) root = root-\u003elchild; return root; } L_B__::node *L_B__::AVLTree::getMaxNode(L_B__::node *root) { if (root == nullptr) return nullptr; while (root-\u003erchild != nullptr) root = root-\u003erchild; return root; } int L_B__::AVLTree::get_depth(L_B__::node *root) { if (root == nullptr) return 0; return root-\u003edepth; } void L_B__::AVLTree::update_depth(L_B__::node *root) { if (root == nullptr) return; root-\u003edepth = std::max(get_depth(root-\u003elchild), get_depth(root-\u003erchild)) + 1; } /*Insert\u0026remove*/ L_B__::node *L_B__::AVLTree::Insert(int x, L_B__::node *root, int \u0026size) { if (root == nullptr) { root = new node(x); size++;//创建结点后size++ } else if (x \u003c root-\u003eval) { root-\u003elchild = Insert(x, root-\u003elchild, size); //由于在更新该root结点之前，当平衡度未达到该要求之前肯定以及是进行了update_depth操作 if (get_depth(root-\u003elchild) - get_depth(root-\u003erchild) == 2) root = x \u003c root-\u003elchild-\u003eval ? rotateRight(root) : rotateLeftRight(root); } else if (x \u003e root-\u003eval) { root-\u003erchild = Insert(x, root-\u003erchild, size); if (get_depth(root-\u003elchild) - get_depth(root-\u003erchild) == -2) root = x \u003e root-\u003erchild-\u003eval ? rotateLeft(root) : rotateRightLeft(root); } update_depth(root); return root; } L_B__::node *L_B__::AVLTree::remove(int x, L_B__::node *root, int \u0026size) { if (root == nullptr) return nullptr; if (x == root-\u003eval) { /*左右子树均不为空---用中序的前驱或者后继来进行替换*/ if (root-\u003elchild != nullptr \u0026\u0026 root-\u003erchild != nullptr) { /*根据左右子树的深度来选择删除替换哪边的*/ if (get_depth(root-\u003elchild) \u003e get_depth(root-\u003erchild)) { node *t = getMaxNode(root-\u003elchild); root-\u003eval = t-\u003eval; root-\u003elchild = remove(t-\u003eval, root-\u003elchild, size); } else { node *t = getMinNode(root-\u003erchild); root-\u003eval = t-\u003eval; root-\u003erchild = remove(t-\u003eval, root-\u003erchild, size); } } /*左右子树至少有一个为空的情况，直接往下走一步即可*/ else { node *tmp = root-\u003elchild == nullptr ? root-\u003erchild : nullptr; if (tmp != nullptr) { *root = *tmp; delete tmp; } else { delete root; root = nullptr; } //删除时size-- size--; } } else if (x \u003c root-\u003eval) { root-\u003elchild = remove(x, root-\u003elchild, size); if (get_depth(root-\u003elchild) - get_depth(root-\u003erchild) == -2) root = get_depth(root-\u003erchild-\u003elchild) \u003e get_depth(root-\u003erchild-\u003erchild) ? rotateRightLeft(root) : rotateLeft(root); } else { root-\u003erchild = remove(x, root-\u003erchild, size); if (get_depth(root-\u003elchild) - get_depth(root-\u003erchild) == 2) root = get_depth(root-\u003elchild-\u003erchild) \u003e get_depth(root-\u003elchild-\u003elchild) ? rotateLeftRight(root) : rotateRight(root); } return root; } /*print part*/ void L_B__::AVL","date":"2022-02-16","objectID":"/posts/%E5%BE%92%E6%89%8B%E5%86%99%E7%9A%84avl%E7%AB%9F%E7%84%B6%E6%AF%94stl%E4%B8%AD%E7%9A%84%E7%BA%A2%E9%BB%91%E6%A0%91%E6%95%88%E7%8E%87%E6%9B%B4%E9%AB%98/:4:2","tags":["徒手写的AVL竟然比STL中的红黑树效率更高？✨"],"title":"徒手写的AVL竟然比STL中的红黑树效率更高？✨","uri":"/posts/%E5%BE%92%E6%89%8B%E5%86%99%E7%9A%84avl%E7%AB%9F%E7%84%B6%E6%AF%94stl%E4%B8%AD%E7%9A%84%E7%BA%A2%E9%BB%91%E6%A0%91%E6%95%88%E7%8E%87%E6%9B%B4%E9%AB%98/"},{"categories":["手写数据结构"],"content":"测试 注意：以下数据由于存在大量相同的值，而我写的这个AVLTree并未对相同的值进行存储，所以节省了大量插入时候的调整时间，所以才能达到不错的插入性能，实际上只要实际插入的数据够多，和红黑树的差距就越大，我之前试过十亿不重复数据插入AVL和RB的测试，AVL运行几分钟，而RB一分钟内解决。但查找和删除方面AVL仍然是吊打RB(毕竟严格平衡树 与STL中的set（红黑树）进行对比： ","date":"2022-02-16","objectID":"/posts/%E5%BE%92%E6%89%8B%E5%86%99%E7%9A%84avl%E7%AB%9F%E7%84%B6%E6%AF%94stl%E4%B8%AD%E7%9A%84%E7%BA%A2%E9%BB%91%E6%A0%91%E6%95%88%E7%8E%87%E6%9B%B4%E9%AB%98/:5:0","tags":["徒手写的AVL竟然比STL中的红黑树效率更高？✨"],"title":"徒手写的AVL竟然比STL中的红黑树效率更高？✨","uri":"/posts/%E5%BE%92%E6%89%8B%E5%86%99%E7%9A%84avl%E7%AB%9F%E7%84%B6%E6%AF%94stl%E4%B8%AD%E7%9A%84%E7%BA%A2%E9%BB%91%E6%A0%91%E6%95%88%E7%8E%87%E6%9B%B4%E9%AB%98/"},{"categories":["手写数据结构"],"content":"测试代码 int main() { using namespace std; AVLTree x; set\u003cint\u003eQ; printf(\"插入测试\\n\"); auto start = clock(); for (int i = 0; i \u003c 100000000; ++i) { x.insert(i%10000000); } std::cout\u003c\u003c\"AVLTree\"\u003c\u003cclock()-start\u003c\u003c\"ms\"\u003c\u003cstd::endl; start = clock(); for (int i = 0; i \u003c 100000000; ++i) { Q.insert(i%10000000); } std::cout\u003c\u003c\"RBTree\"\u003c\u003cclock()-start\u003c\u003c\"ms\"\u003c\u003cstd::endl; printf(\"迭代测试\\n\"); start = clock(); for(auto it = x.begin();it!=x.end();++it){ continue; } std::cout\u003c\u003c\"AVLTree\"\u003c\u003cclock()-start\u003c\u003c\"ms\"\u003c\u003cstd::endl; start = clock(); for(auto it = Q.begin();it!=Q.end();++it){ continue; } std::cout\u003c\u003c\"RBTree\"\u003c\u003cclock()-start\u003c\u003c\"ms\"\u003c\u003cstd::endl; printf(\"查找测试\\n\"); start = clock(); for (int i = 0; i \u003c 100000000; ++i) { x.find(i); } std::cout\u003c\u003c\"AVLTree\"\u003c\u003cclock()-start\u003c\u003c\"ms\"\u003c\u003cstd::endl; start = clock(); for(int i = 0;i\u003c100000000;++i){ Q.count(i); } std::cout\u003c\u003c\"RBTree\"\u003c\u003cclock()-start\u003c\u003c\"ms\"\u003c\u003cstd::endl; printf(\"删除测试\\n\"); start = clock(); for(int i=0;i\u003c10000000;i++){ x.remove(i); } std::cout\u003c\u003c\"AVLTree\"\u003c\u003cclock()-start\u003c\u003c\"ms\"\u003c\u003c\"length\"\u003c\u003cx.size()\u003c\u003cstd::endl; start = clock(); for(int i=0;i\u003c10000000;i++){ Q.erase(i); } std::cout\u003c\u003c\"RBTree\"\u003c\u003cclock()-start\u003c\u003c\"ms\"\u003c\u003c\"length\"\u003c\u003cQ.size()\u003c\u003cstd::endl; return 0; } ","date":"2022-02-16","objectID":"/posts/%E5%BE%92%E6%89%8B%E5%86%99%E7%9A%84avl%E7%AB%9F%E7%84%B6%E6%AF%94stl%E4%B8%AD%E7%9A%84%E7%BA%A2%E9%BB%91%E6%A0%91%E6%95%88%E7%8E%87%E6%9B%B4%E9%AB%98/:5:1","tags":["徒手写的AVL竟然比STL中的红黑树效率更高？✨"],"title":"徒手写的AVL竟然比STL中的红黑树效率更高？✨","uri":"/posts/%E5%BE%92%E6%89%8B%E5%86%99%E7%9A%84avl%E7%AB%9F%E7%84%B6%E6%AF%94stl%E4%B8%AD%E7%9A%84%E7%BA%A2%E9%BB%91%E6%A0%91%E6%95%88%E7%8E%87%E6%9B%B4%E9%AB%98/"},{"categories":["手写数据结构"],"content":"测试总结 通过不断对比红黑树(RB)和AVL，得出以下结论： 插入操作红黑树比AVL快很多，数据量越大优势越明显。 查找和删除操作红黑树却是比AVL慢很多，同样也是数据量越大越明显。 总的来说，如果所需要管理的数据量很大，并且需要频繁的插入，那么红黑树更适合你，如果只需要插入一次后，对数据进行查找管理，那么AVL更加的适合你！ ","date":"2022-02-16","objectID":"/posts/%E5%BE%92%E6%89%8B%E5%86%99%E7%9A%84avl%E7%AB%9F%E7%84%B6%E6%AF%94stl%E4%B8%AD%E7%9A%84%E7%BA%A2%E9%BB%91%E6%A0%91%E6%95%88%E7%8E%87%E6%9B%B4%E9%AB%98/:5:2","tags":["徒手写的AVL竟然比STL中的红黑树效率更高？✨"],"title":"徒手写的AVL竟然比STL中的红黑树效率更高？✨","uri":"/posts/%E5%BE%92%E6%89%8B%E5%86%99%E7%9A%84avl%E7%AB%9F%E7%84%B6%E6%AF%94stl%E4%B8%AD%E7%9A%84%E7%BA%A2%E9%BB%91%E6%A0%91%E6%95%88%E7%8E%87%E6%9B%B4%E9%AB%98/"},{"categories":["手写数据结构"],"content":"解题测试 OJ平台 在以上设计的基础上加个get_head方法即可。 #include \u003cbits/stdc++.h\u003e struct node { int val; int depth; node *lchild; node *rchild; node() : val(0), lchild(nullptr), rchild(nullptr) {} node(int x) : val(x), lchild(nullptr), rchild(nullptr) {} }; class AVLTree { /*date part*/ node *head; int size; public: /*construct and destruct part*/ AVLTree() : head(nullptr),size(0) {} AVLTree(int x) : head(new node(x)),size(1) {} ~AVLTree() { destroy(head); } private: /*static function part*/ static node *rotateRight(node *root) {//右旋 node *son = root-\u003elchild; root-\u003elchild = son-\u003erchild; son-\u003erchild = root; update_depth(root);//更新深度(右旋只会对这两结点产生影响 update_depth(son); return son; } static node *rotateLeft(node *root) { node *son = root-\u003erchild; root-\u003erchild = son-\u003elchild; son-\u003elchild = root; update_depth(root); update_depth(son); return son; } static node *rotateLeftRight(node *root) { root-\u003elchild = rotateLeft(root-\u003elchild); return rotateRight(root); } static node *rotateRightLeft(node *root) { root-\u003erchild = rotateRight(root-\u003erchild); return rotateLeft(root); } static void destroy(node *root) { if (root == nullptr) return; destroy(root-\u003elchild); destroy(root-\u003erchild); delete root; root = nullptr; } static node* getMinNode(node* root){ if(root== nullptr) return nullptr; while(root-\u003elchild!= nullptr) root = root-\u003elchild; return root; } static node* getMaxNode(node* root){ if(root== nullptr) return nullptr; while(root-\u003erchild!= nullptr) root = root-\u003erchild; return root; } static int get_depth(node *root) {//得到深度 if (root == nullptr) return 0; return root-\u003edepth; } static void update_depth(node *root) { if (root == nullptr) return; root-\u003edepth = std::max(get_depth(root-\u003elchild), get_depth(root-\u003erchild)) + 1; } static node *Insert(int x, node *root) {//所有的deep的更新都在后序遍历后 if (root == nullptr) { root = new node(x); } else if (x \u003c= root-\u003eval) { root-\u003elchild = Insert(x, root-\u003elchild); //由于在更新该root结点之前，当平衡度未达到该要求之前肯定以及是进行了update_depth操作 if (get_depth(root-\u003elchild) - get_depth(root-\u003erchild) == 2) root = x \u003c= root-\u003elchild-\u003eval ? rotateRight(root) : rotateLeftRight(root); } else if (x \u003e root-\u003eval) { root-\u003erchild = Insert(x, root-\u003erchild); if (get_depth(root-\u003elchild) - get_depth(root-\u003erchild) == -2) root = x \u003e= root-\u003erchild-\u003eval ? rotateLeft(root) : rotateRightLeft(root); } update_depth(root); return root; } static node *remove(int x, node *root) { if (root == nullptr) return nullptr; if (x == root-\u003eval) { /*左右子树均不为空---用中序的前驱或者后继来进行替换*/ if (root-\u003elchild != nullptr \u0026\u0026 root-\u003erchild != nullptr) { /*根据左右子树的深度来选择删除替换哪边的*/ if(get_depth(root-\u003elchild)\u003eget_depth(root-\u003erchild)){ node* t = getMaxNode(root-\u003elchild); root-\u003eval = t-\u003eval; root-\u003elchild = remove(t-\u003eval,root-\u003elchild); }else{ node* t = getMinNode(root-\u003erchild); root-\u003eval = t-\u003eval; root-\u003erchild = remove(t-\u003eval,root-\u003erchild); } } /*左右子树至少有一个为空的情况，直接往下走一步即可*/ else{ node* tmp = root-\u003elchild== nullptr?root-\u003erchild: nullptr; if(tmp!= nullptr){ *root = *tmp; delete tmp; } else{ delete root; root = nullptr; } } } else if (x \u003c root-\u003eval) { root-\u003elchild = remove(x, root-\u003elchild); if(get_depth(root-\u003elchild)-get_depth(root-\u003erchild)==-2) root = get_depth(root-\u003erchild-\u003elchild)\u003eget_depth(root-\u003erchild-\u003erchild)?rotateRightLeft(root): rotateLeft(root); } else { root-\u003erchild = remove(x, root-\u003erchild); if(get_depth(root-\u003elchild)-get_depth(root-\u003erchild)==2) root = get_depth(root-\u003elchild-\u003erchild)\u003eget_depth(root-\u003elchild-\u003elchild)?rotateLeftRight(root): rotateRight(root); } return root; } static void inorder(node *root) { if (root != nullptr) { inorder(root-\u003elchild); printf(\"%d \", root-\u003eval); inorder(root-\u003erchild); } } public: /*public function part*/ void insert(int x) { //递归方式插入，方便后续处理 head = Insert(x, head); size++; } void remove(int x){ assert(size!=0); head = remove(x,head); size--; } void clear() { destroy(head); } bool isEmpty() { return head == nullptr; } bool find(int x) { //查找直接迭代方式即可 node *f = head; while (f != nullptr) { if (x == f-\u003eval) return true; else if (x \u003c f-\u003eval) f = f-\u003elchild; else f = f-\u003erchild; } return false; } void i","date":"2022-02-16","objectID":"/posts/%E5%BE%92%E6%89%8B%E5%86%99%E7%9A%84avl%E7%AB%9F%E7%84%B6%E6%AF%94stl%E4%B8%AD%E7%9A%84%E7%BA%A2%E9%BB%91%E6%A0%91%E6%95%88%E7%8E%87%E6%9B%B4%E9%AB%98/:6:0","tags":["徒手写的AVL竟然比STL中的红黑树效率更高？✨"],"title":"徒手写的AVL竟然比STL中的红黑树效率更高？✨","uri":"/posts/%E5%BE%92%E6%89%8B%E5%86%99%E7%9A%84avl%E7%AB%9F%E7%84%B6%E6%AF%94stl%E4%B8%AD%E7%9A%84%E7%BA%A2%E9%BB%91%E6%A0%91%E6%95%88%E7%8E%87%E6%9B%B4%E9%AB%98/"},{"categories":["手写数据结构"],"content":"新手用C++写了个泛型堆，效率竟比STL的更快？","date":"2022-02-16","objectID":"/posts/%E6%96%B0%E6%89%8B%E7%94%A8c++%E5%86%99%E4%BA%86%E4%B8%AA%E6%B3%9B%E5%9E%8B%E5%A0%86%E6%95%88%E7%8E%87%E7%AB%9F%E6%AF%94stl%E7%9A%84%E6%9B%B4%E5%BF%AB/","tags":["新手用C++写了个泛型堆，效率竟比STL的更快？"],"title":"新手用C++写了个泛型堆，效率竟比STL的更快？","uri":"/posts/%E6%96%B0%E6%89%8B%E7%94%A8c++%E5%86%99%E4%BA%86%E4%B8%AA%E6%B3%9B%E5%9E%8B%E5%A0%86%E6%95%88%E7%8E%87%E7%AB%9F%E6%AF%94stl%E7%9A%84%E6%9B%B4%E5%BF%AB/"},{"categories":["手写数据结构"],"content":"关于为什么突然想写一个模板类？ 嗯。。主要是因为最近在翻看《STL源码剖析》，然后发现原来STL源码是如此的庞大且复杂，而又及其具有条理，而其中最难的就是各个组件的关系，而对外所展现的效果就是泛型编程，对我这个初入门菜鸟来说的话，我之前对模板仅仅停留在知道，但没用过的阶段🤣 由于STL库中对模板的骚操作一个接一个，没个模板的基础，根本就看不懂，所以我痛定思痛，一定要亲手用模板实现一个数据结构(之前用非模板实现过一些)。 好了，目标有了，用模板实现一个数据结构，那数据结构这么多，我到底实现哪个呢？要不就把堆给冲了？我一拍大腿，可行！👍 最后关于它的具体实现，我肯定不会像STL那样考虑的那么周到，组件分工齐全，毕竟STL是包含六大组件的！ 具体如下图： ","date":"2022-02-16","objectID":"/posts/%E6%96%B0%E6%89%8B%E7%94%A8c++%E5%86%99%E4%BA%86%E4%B8%AA%E6%B3%9B%E5%9E%8B%E5%A0%86%E6%95%88%E7%8E%87%E7%AB%9F%E6%AF%94stl%E7%9A%84%E6%9B%B4%E5%BF%AB/:1:0","tags":["新手用C++写了个泛型堆，效率竟比STL的更快？"],"title":"新手用C++写了个泛型堆，效率竟比STL的更快？","uri":"/posts/%E6%96%B0%E6%89%8B%E7%94%A8c++%E5%86%99%E4%BA%86%E4%B8%AA%E6%B3%9B%E5%9E%8B%E5%A0%86%E6%95%88%E7%8E%87%E7%AB%9F%E6%AF%94stl%E7%9A%84%E6%9B%B4%E5%BF%AB/"},{"categories":["手写数据结构"],"content":"对刚用模板的C++新手而言的几大坑点 ","date":"2022-02-16","objectID":"/posts/%E6%96%B0%E6%89%8B%E7%94%A8c++%E5%86%99%E4%BA%86%E4%B8%AA%E6%B3%9B%E5%9E%8B%E5%A0%86%E6%95%88%E7%8E%87%E7%AB%9F%E6%AF%94stl%E7%9A%84%E6%9B%B4%E5%BF%AB/:2:0","tags":["新手用C++写了个泛型堆，效率竟比STL的更快？"],"title":"新手用C++写了个泛型堆，效率竟比STL的更快？","uri":"/posts/%E6%96%B0%E6%89%8B%E7%94%A8c++%E5%86%99%E4%BA%86%E4%B8%AA%E6%B3%9B%E5%9E%8B%E5%A0%86%E6%95%88%E7%8E%87%E7%AB%9F%E6%AF%94stl%E7%9A%84%E6%9B%B4%E5%BF%AB/"},{"categories":["手写数据结构"],"content":"习惯性写.h和.cpp文件 对于对C++有一定掌握，但基本没用过模板的人而言，声明与定义早就烂熟于心的.h和.cpp文件。 然而，当你使用模板的时候，再去吧声明和定义分开，将会产生一个错误！除非在.h文件末尾有包含.cpp文件。然而这样的操作是很多余的！ 所以在用模板实现类的时候，最好只写一个.h文件！ ","date":"2022-02-16","objectID":"/posts/%E6%96%B0%E6%89%8B%E7%94%A8c++%E5%86%99%E4%BA%86%E4%B8%AA%E6%B3%9B%E5%9E%8B%E5%A0%86%E6%95%88%E7%8E%87%E7%AB%9F%E6%AF%94stl%E7%9A%84%E6%9B%B4%E5%BF%AB/:2:1","tags":["新手用C++写了个泛型堆，效率竟比STL的更快？"],"title":"新手用C++写了个泛型堆，效率竟比STL的更快？","uri":"/posts/%E6%96%B0%E6%89%8B%E7%94%A8c++%E5%86%99%E4%BA%86%E4%B8%AA%E6%B3%9B%E5%9E%8B%E5%A0%86%E6%95%88%E7%8E%87%E7%AB%9F%E6%AF%94stl%E7%9A%84%E6%9B%B4%E5%BF%AB/"},{"categories":["手写数据结构"],"content":"对模板特化运用和理解很少 我现在就处于这个状态，说不上来该怎么规范🤣 ","date":"2022-02-16","objectID":"/posts/%E6%96%B0%E6%89%8B%E7%94%A8c++%E5%86%99%E4%BA%86%E4%B8%AA%E6%B3%9B%E5%9E%8B%E5%A0%86%E6%95%88%E7%8E%87%E7%AB%9F%E6%AF%94stl%E7%9A%84%E6%9B%B4%E5%BF%AB/:2:2","tags":["新手用C++写了个泛型堆，效率竟比STL的更快？"],"title":"新手用C++写了个泛型堆，效率竟比STL的更快？","uri":"/posts/%E6%96%B0%E6%89%8B%E7%94%A8c++%E5%86%99%E4%BA%86%E4%B8%AA%E6%B3%9B%E5%9E%8B%E5%A0%86%E6%95%88%E7%8E%87%E7%AB%9F%E6%AF%94stl%E7%9A%84%E6%9B%B4%E5%BF%AB/"},{"categories":["手写数据结构"],"content":"我的Heap实现 ","date":"2022-02-16","objectID":"/posts/%E6%96%B0%E6%89%8B%E7%94%A8c++%E5%86%99%E4%BA%86%E4%B8%AA%E6%B3%9B%E5%9E%8B%E5%A0%86%E6%95%88%E7%8E%87%E7%AB%9F%E6%AF%94stl%E7%9A%84%E6%9B%B4%E5%BF%AB/:3:0","tags":["新手用C++写了个泛型堆，效率竟比STL的更快？"],"title":"新手用C++写了个泛型堆，效率竟比STL的更快？","uri":"/posts/%E6%96%B0%E6%89%8B%E7%94%A8c++%E5%86%99%E4%BA%86%E4%B8%AA%E6%B3%9B%E5%9E%8B%E5%A0%86%E6%95%88%E7%8E%87%E7%AB%9F%E6%AF%94stl%E7%9A%84%E6%9B%B4%E5%BF%AB/"},{"categories":["手写数据结构"],"content":"总览Heap类 这是我画的树状图，我设计的Heap一共分为以下三个部分： 一、 成员变量 这部分没啥好说的，就用一个 nums 指针存储变量数据，length 记录当前的 nums 已经使用的长度，capacity 存储当前 nums 的最大容量。 二、 静态成员函数 我将堆的基本操作封装为静态成员变量的初衷是方便，对外实现堆化的功能，即使使用外部数组也能实现堆。 下面简单的介绍一下这几个函数（后面再详解）： sift_down()：接受四个参数，依次是用于向下堆化的数组，起始的堆化位置，结束的堆化位置，以及一个仿函数(用于设定最大/最小堆)。 static void sift_down(T \u0026nums, size_t start, size_t len, _CMP cmp); sift_up()：向上堆化的操作，与上面的类似，少了结束信息，因为结束信息一般都是0. static void sift_up(T \u0026nums, size_t start, _CMP cmp); heapify()：调用向下堆化函数，实现完全堆化，接收两个参数，待堆化数组和数组长度 static void heapify(T \u0026nums, size_t len); print()：主要实现一个用于测试功能的泛型打印接口，接收的参数肯定就是数组和数组长度了。(略过，不重要) 三、类的内部成员函数(放源代码详解) 构造和析构函数：很简单的，我直接放源代码出来。 Heap() : length(0), capacity(1) {//暂时没有对构造函数拓展的打算 nums = new _T[capacity]; } ~Heap(){ delete []nums; } push()：每次入队后进行一次向上堆化，这个简单，直接调上面的静态接口就行了。注意：我这里采用的是倍增的方式进行延伸内存，一旦出现capacity不够用的情况，就重新分配内存，其中数据拷贝方面用了copy函数。 void push(_T val) { if (length \u003e= capacity) {//两倍两倍的扩容 _T *t = nums; capacity *= 2; nums = new _T[capacity]; std::copy(t, t + length, nums); delete[] t; } nums[length] = val; sift_up(nums, length, _CMP()); length++; } pop()：这个操作是需要一点技巧的–为了不破坏整体堆化的结构，我们直接把根部与尾部元素进行交换，再从根部往下重新堆化一次(注意此时堆化的终点应该要比原来小1)。 还采取了C语言的断言方式，防止pop操作的时候，堆中已经没有元素。 void pop() { if (length == 0) assert(0); length--; std::swap(nums[0], nums[length]);//实际上pop操作就相当于堆排的一次过程 sift_down(nums, 0, length, _CMP()); } top()：直接取根节点的值。 _T top() { if (length == 0) assert(0); return nums[0]; } print()：用于打印内部数据的接口。 void print() {//内部print方便测试 print(nums, length);//调用静态print } ","date":"2022-02-16","objectID":"/posts/%E6%96%B0%E6%89%8B%E7%94%A8c++%E5%86%99%E4%BA%86%E4%B8%AA%E6%B3%9B%E5%9E%8B%E5%A0%86%E6%95%88%E7%8E%87%E7%AB%9F%E6%AF%94stl%E7%9A%84%E6%9B%B4%E5%BF%AB/:3:1","tags":["新手用C++写了个泛型堆，效率竟比STL的更快？"],"title":"新手用C++写了个泛型堆，效率竟比STL的更快？","uri":"/posts/%E6%96%B0%E6%89%8B%E7%94%A8c++%E5%86%99%E4%BA%86%E4%B8%AA%E6%B3%9B%E5%9E%8B%E5%A0%86%E6%95%88%E7%8E%87%E7%AB%9F%E6%AF%94stl%E7%9A%84%E6%9B%B4%E5%BF%AB/"},{"categories":["手写数据结构"],"content":"关于堆化函数的实现 我直接开放代码实现，具体的理解靠大家了。 sift_down() template\u003ctypename T\u003e static void sift_down(T \u0026nums, size_t start, size_t len, _CMP cmp) {//最小堆还是最大堆由cmp决定 int end = len; int parent = start; int child = parent * 2 + 1; while (child \u003c end) { if (child + 1 \u003c end \u0026\u0026 cmp(nums[child], nums[child + 1])) child++; if (!cmp(nums[parent], nums[child])) { break; } else { std::swap(nums[parent], nums[child]); parent = child; child = parent * 2 + 1; } } } sift_up template\u003ctypename T\u003e static void sift_up(T \u0026nums, size_t start, _CMP cmp) {//最小堆还是最大堆由cmp决定 int end = 0; int child = start; int parent = (child - 1) / 2; while (child \u003e end) { if (!cmp(nums[parent], nums[child])) { break; } else { std::swap(nums[parent], nums[child]); child = parent; parent = (child - 1) / 2; } } } heapify() template\u003ctypename T\u003e static void heapify(T \u0026nums, size_t len) {//用于对数组进行堆化 for (int i = len - 1; i \u003e= 0; i--) { sift_down\u003cT\u003e(nums, i, len, _CMP()); } } print() template\u003ctypename T\u003e static void print(T \u0026nums, size_t length) { for (int i = 0; i \u003c length; i++) { std::cout \u003c\u003c nums[i] \u003c\u003c ' '; } } ","date":"2022-02-16","objectID":"/posts/%E6%96%B0%E6%89%8B%E7%94%A8c++%E5%86%99%E4%BA%86%E4%B8%AA%E6%B3%9B%E5%9E%8B%E5%A0%86%E6%95%88%E7%8E%87%E7%AB%9F%E6%AF%94stl%E7%9A%84%E6%9B%B4%E5%BF%AB/:3:2","tags":["新手用C++写了个泛型堆，效率竟比STL的更快？"],"title":"新手用C++写了个泛型堆，效率竟比STL的更快？","uri":"/posts/%E6%96%B0%E6%89%8B%E7%94%A8c++%E5%86%99%E4%BA%86%E4%B8%AA%E6%B3%9B%E5%9E%8B%E5%A0%86%E6%95%88%E7%8E%87%E7%AB%9F%E6%AF%94stl%E7%9A%84%E6%9B%B4%E5%BF%AB/"},{"categories":["手写数据结构"],"content":"关于所用模板的说明 类模板(全局均可用的类型参数)： 其中 _T 用于表示数组元素的类型，默认为int，_CMP 则是一个类(仿函数)的类型，默认为已经提供的cmp仿函数，所以如果为自定义类型构建堆，则一定要自己写好相应的仿函数进行传递。 template\u003ctypename T = int\u003e //用于默认排序的仿函数，默认为大顶堆 class cmp { public: bool operator()(T \u0026a, T \u0026b) { return a \u003c b; } }; template\u003ctypename _T = int, typename _CMP = cmp\u003c_T\u003e\u003e 成员函数模板 为了便于外界使用静态成员函数进行相应的操作，所以每个静态成员函数都提供了对应的类型模板，但比较操作的仿函数用的还是和类模板一样的类型。 如： template\u003ctypename T\u003e static void sift_up(T \u0026nums, size_t start, _CMP cmp) {//最小堆还是最大堆由cmp决定 int end = 0; int child = start; int parent = (child - 1) / 2; while (child \u003e end) { if (!cmp(nums[parent], nums[child])) { break; } else { std::swap(nums[parent], nums[child]); child = parent; parent = (child - 1) / 2; } } } ","date":"2022-02-16","objectID":"/posts/%E6%96%B0%E6%89%8B%E7%94%A8c++%E5%86%99%E4%BA%86%E4%B8%AA%E6%B3%9B%E5%9E%8B%E5%A0%86%E6%95%88%E7%8E%87%E7%AB%9F%E6%AF%94stl%E7%9A%84%E6%9B%B4%E5%BF%AB/:3:3","tags":["新手用C++写了个泛型堆，效率竟比STL的更快？"],"title":"新手用C++写了个泛型堆，效率竟比STL的更快？","uri":"/posts/%E6%96%B0%E6%89%8B%E7%94%A8c++%E5%86%99%E4%BA%86%E4%B8%AA%E6%B3%9B%E5%9E%8B%E5%A0%86%E6%95%88%E7%8E%87%E7%AB%9F%E6%AF%94stl%E7%9A%84%E6%9B%B4%E5%BF%AB/"},{"categories":["手写数据结构"],"content":"整合所有代码，实现Heap类模板 这里用一个命名空间套住是最好，防止命名冲突！我这里用的自己常用的网名hhh // // Created by Alone on 2021/10/2. // #ifndef MY_TINY_STL_HEAP_H #define MY_TINY_STL_HEAP_H #include \u003ciostream\u003e#include \u003ccassert\u003e#include \u003calgorithm\u003e namespace L_B__ { template\u003ctypename T=int\u003e//用于默认排序的仿函数，默认为大顶堆 class cmp { public: bool operator()(T \u0026a, T \u0026b) { return a \u003c b; } }; //@模板类的实现 template\u003ctypename _T=int, typename _CMP = cmp\u003c_T\u003e\u003e class Heap { //私有成员 _T *nums; size_t length; size_t capacity; public://@静态成员函数，对外对内都能实现功能 template\u003ctypename T\u003e static void sift_down(T \u0026nums, size_t start, size_t len, _CMP cmp) {//最小堆还是最大堆由cmp决定 int end = len; int parent = start; int child = parent * 2 + 1; while (child \u003c end) { if (child + 1 \u003c end \u0026\u0026 cmp(nums[child], nums[child + 1])) child++; if (!cmp(nums[parent], nums[child])) { break; } else { std::swap(nums[parent], nums[child]); parent = child; child = parent * 2 + 1; } } } template\u003ctypename T\u003e static void sift_up(T \u0026nums, size_t start, _CMP cmp) {//最小堆还是最大堆由cmp决定 int end = 0; int child = start; int parent = (child - 1) / 2; while (child \u003e end) { if (!cmp(nums[parent], nums[child])) { break; } else { std::swap(nums[parent], nums[child]); child = parent; parent = (child - 1) / 2; } } } template\u003ctypename T\u003e static void heapify(T \u0026nums, size_t len) {//用于对数组进行堆化 for (int i = len - 1; i \u003e= 0; i--) { sift_down\u003cT\u003e(nums, i, len, _CMP()); } } template\u003ctypename T\u003e static void print(T \u0026nums, size_t length) {//专为打印原始数组 for (int i = 0; i \u003c length; i++) { std::cout \u003c\u003c nums[i] \u003c\u003c ' '; } } public://@基本的内部成员函数 Heap() : length(0), capacity(1) {//暂时没有对构造函数拓展的打算 nums = new _T[capacity]; } ~Heap() { delete[]nums; } void push(_T val) { if (length \u003e= capacity) {//两倍两倍的扩容 _T *t = nums; capacity *= 2; nums = new _T[capacity]; std::copy(t, t + length, nums); delete[] t; } nums[length] = val; sift_up(nums, length, _CMP()); length++; } void pop() { if (length == 0) assert(0); length--; std::swap(nums[0], nums[length]);//实际上pop操作就相当于堆排的一次过程 sift_down(nums, 0, length, _CMP()); } _T top() { if (length == 0) assert(0); return nums[0]; } void print() {//内部print方便测试 print(nums, length); } }; } #endif //MY_TINY_STL_HEAP_H ","date":"2022-02-16","objectID":"/posts/%E6%96%B0%E6%89%8B%E7%94%A8c++%E5%86%99%E4%BA%86%E4%B8%AA%E6%B3%9B%E5%9E%8B%E5%A0%86%E6%95%88%E7%8E%87%E7%AB%9F%E6%AF%94stl%E7%9A%84%E6%9B%B4%E5%BF%AB/:3:4","tags":["新手用C++写了个泛型堆，效率竟比STL的更快？"],"title":"新手用C++写了个泛型堆，效率竟比STL的更快？","uri":"/posts/%E6%96%B0%E6%89%8B%E7%94%A8c++%E5%86%99%E4%BA%86%E4%B8%AA%E6%B3%9B%E5%9E%8B%E5%A0%86%E6%95%88%E7%8E%87%E7%AB%9F%E6%AF%94stl%E7%9A%84%E6%9B%B4%E5%BF%AB/"},{"categories":["手写数据结构"],"content":"我的Heap测试 ","date":"2022-02-16","objectID":"/posts/%E6%96%B0%E6%89%8B%E7%94%A8c++%E5%86%99%E4%BA%86%E4%B8%AA%E6%B3%9B%E5%9E%8B%E5%A0%86%E6%95%88%E7%8E%87%E7%AB%9F%E6%AF%94stl%E7%9A%84%E6%9B%B4%E5%BF%AB/:4:0","tags":["新手用C++写了个泛型堆，效率竟比STL的更快？"],"title":"新手用C++写了个泛型堆，效率竟比STL的更快？","uri":"/posts/%E6%96%B0%E6%89%8B%E7%94%A8c++%E5%86%99%E4%BA%86%E4%B8%AA%E6%B3%9B%E5%9E%8B%E5%A0%86%E6%95%88%E7%8E%87%E7%AB%9F%E6%AF%94stl%E7%9A%84%E6%9B%B4%E5%BF%AB/"},{"categories":["手写数据结构"],"content":"正确性测试(与STL priority_queue对比) 经历这数千万数据的测试，仍然和STL的正确性是一样的，说明正确性是有了保障的。 测试代码 #include \"Heap.h\"#include \u003cctime\u003e#include \u003cqueue\u003eusing namespace std; #define MAX_SIZE 10000000 int main() { L_B__::Heap\u003cint\u003e a; priority_queue\u003cint\u003e Q; int step = 1; for(int i=1;i\u003cMAX_SIZE;i++){ a.push(step%i); Q.push(step%i); step += 2; } cout\u003c\u003c\"STL-\u003e\"; for (int i = 0; i \u003c 10; i++) { auto t = move(Q.top()); cout \u003c\u003c t\u003c\u003c' '; Q.pop(); } cout \u003c\u003c endl; cout \u003c\u003c \"My-\u003e\"; for (int i = 0; i \u003c 10; i++) { auto t = move(a.top()); cout \u003c\u003c t\u003c\u003c' '; a.pop(); } } ","date":"2022-02-16","objectID":"/posts/%E6%96%B0%E6%89%8B%E7%94%A8c++%E5%86%99%E4%BA%86%E4%B8%AA%E6%B3%9B%E5%9E%8B%E5%A0%86%E6%95%88%E7%8E%87%E7%AB%9F%E6%AF%94stl%E7%9A%84%E6%9B%B4%E5%BF%AB/:4:1","tags":["新手用C++写了个泛型堆，效率竟比STL的更快？"],"title":"新手用C++写了个泛型堆，效率竟比STL的更快？","uri":"/posts/%E6%96%B0%E6%89%8B%E7%94%A8c++%E5%86%99%E4%BA%86%E4%B8%AA%E6%B3%9B%E5%9E%8B%E5%A0%86%E6%95%88%E7%8E%87%E7%AB%9F%E6%AF%94stl%E7%9A%84%E6%9B%B4%E5%BF%AB/"},{"categories":["手写数据结构"],"content":"效率测试(与STL priority_queue对比) 1000w数据两者的push和pop速度对比 欧耶！比STL快两倍！！🐱‍🏍 其实这样不是很奇怪，STL本来就要实现和考虑很多事情，各种组件的套娃，而我们只是实现了这样一个简单的堆，那当然快很多了。 测试源代码 #include \"Heap.h\"#include \u003cctime\u003e#include \u003cqueue\u003eusing namespace std; #define MAX_SIZE 10000000 int main() { L_B__::Heap\u003cint\u003e a; priority_queue\u003cint\u003e Q; auto start = clock(); //@push测试 int step = 1; for(int i=1;i\u003cMAX_SIZE;i++){ Q.push(step%i); step += 2; } cout\u003c\u003c\"STL Push:\"\u003c\u003cclock()-start\u003c\u003c\"ms\"\u003c\u003cendl; start = clock(); step = 1; for(int i=1;i\u003cMAX_SIZE;i++){ a.push(step%i); step += 2; } cout\u003c\u003c\"My Push:\"\u003c\u003cclock()-start\u003c\u003c\"ms\"\u003c\u003cendl; //@pop测试 start = clock(); for(int i=1;i\u003cMAX_SIZE;i++){ Q.pop(); } cout\u003c\u003c\"STL Pop:\"\u003c\u003cclock()-start\u003c\u003c\"ms\"\u003c\u003cendl; start = clock(); for(int i=1;i\u003cMAX_SIZE;i++){ a.pop(); } cout\u003c\u003c\"My Pop:\"\u003c\u003cclock()-start\u003c\u003c\"ms\"\u003c\u003cendl; } ","date":"2022-02-16","objectID":"/posts/%E6%96%B0%E6%89%8B%E7%94%A8c++%E5%86%99%E4%BA%86%E4%B8%AA%E6%B3%9B%E5%9E%8B%E5%A0%86%E6%95%88%E7%8E%87%E7%AB%9F%E6%AF%94stl%E7%9A%84%E6%9B%B4%E5%BF%AB/:4:2","tags":["新手用C++写了个泛型堆，效率竟比STL的更快？"],"title":"新手用C++写了个泛型堆，效率竟比STL的更快？","uri":"/posts/%E6%96%B0%E6%89%8B%E7%94%A8c++%E5%86%99%E4%BA%86%E4%B8%AA%E6%B3%9B%E5%9E%8B%E5%A0%86%E6%95%88%E7%8E%87%E7%AB%9F%E6%AF%94stl%E7%9A%84%E6%9B%B4%E5%BF%AB/"},{"categories":["手写数据结构"],"content":"解题实测(LeetCode 347. 前 K 个高频元素) 我去，果然比stl的快不少🤣 直接把代码cv放到LC前面，然后测试使用自定义类型的情况。 解题代码： struct S{ int a,b; }; class cmp{ public: bool operator()(S\u0026a,S\u0026b){ return a.b\u003cb.b; } }; namespace L_B__ { template\u003ctypename T=int\u003e//用于默认排序的仿函数，默认为大顶堆 class cmp { public: bool operator()(T \u0026a, T \u0026b) { return a \u003c b; } }; //@模板类的实现 template\u003ctypename _T=int, typename _CMP = cmp\u003c_T\u003e\u003e class Heap { //私有成员 _T *nums; size_t length; size_t capacity; public://@静态成员函数，对外对内都能实现功能 template\u003ctypename T\u003e static void sift_down(T \u0026nums, size_t start, size_t len, _CMP cmp) {//最小堆还是最大堆由cmp决定 int end = len; int parent = start; int child = parent * 2 + 1; while (child \u003c end) { if (child + 1 \u003c end \u0026\u0026 cmp(nums[child], nums[child + 1])) child++; if (!cmp(nums[parent], nums[child])) { break; } else { std::swap(nums[parent], nums[child]); parent = child; child = parent * 2 + 1; } } } template\u003ctypename T\u003e static void sift_up(T \u0026nums, size_t start, _CMP cmp) {//最小堆还是最大堆由cmp决定 int end = 0; int child = start; int parent = (child - 1) / 2; while (child \u003e end) { if (!cmp(nums[parent], nums[child])) { break; } else { std::swap(nums[parent], nums[child]); child = parent; parent = (child - 1) / 2; } } } template\u003ctypename T\u003e static void heapify(T \u0026nums, size_t len) {//用于对数组进行堆化 for (int i = len - 1; i \u003e= 0; i--) { sift_down\u003cT\u003e(nums, i, len, _CMP()); } } template\u003ctypename T\u003e static void print(T \u0026nums, size_t length) {//专为打印原始数组 for (int i = 0; i \u003c length; i++) { std::cout \u003c\u003c nums[i] \u003c\u003c ' '; } } public://@基本的内部成员函数 Heap() : length(0), capacity(1) {//暂时没有对构造函数拓展的打算 nums = new _T[capacity]; } ~Heap() { delete[]nums; } void push(_T val) { if (length \u003e= capacity) {//两倍两倍的扩容 _T *t = nums; capacity *= 2; nums = new _T[capacity]; std::copy(t, t + length, nums); delete[] t; } nums[length] = val; sift_up(nums, length, _CMP()); length++; } void pop() { if (length == 0) assert(0); length--; std::swap(nums[0], nums[length]);//实际上pop操作就相当于堆排的一次过程 sift_down(nums, 0, length, _CMP()); } _T top() { if (length == 0) assert(0); return nums[0]; } void print() {//内部print方便测试 print(nums, length); } }; } class Solution { public: vector\u003cint\u003e topKFrequent(vector\u003cint\u003e\u0026 nums, int k) { unordered_map\u003cint,int\u003et; //开始映射hashmap for(int s:nums){ t[s]++; } L_B__::Heap\u003cS,cmp\u003eQ; for(unordered_map\u003cint,int\u003e::iterator it=t.begin();it!=t.end();it++){ Q.push({it-\u003efirst,it-\u003esecond}); } vector\u003cint\u003eres; //得到前k个最大的元素 for(int i=0;i\u003ck;i++){ auto t = Q.top();Q.pop(); res.push_back(t.a); } return res; } }; ","date":"2022-02-16","objectID":"/posts/%E6%96%B0%E6%89%8B%E7%94%A8c++%E5%86%99%E4%BA%86%E4%B8%AA%E6%B3%9B%E5%9E%8B%E5%A0%86%E6%95%88%E7%8E%87%E7%AB%9F%E6%AF%94stl%E7%9A%84%E6%9B%B4%E5%BF%AB/:4:3","tags":["新手用C++写了个泛型堆，效率竟比STL的更快？"],"title":"新手用C++写了个泛型堆，效率竟比STL的更快？","uri":"/posts/%E6%96%B0%E6%89%8B%E7%94%A8c++%E5%86%99%E4%BA%86%E4%B8%AA%E6%B3%9B%E5%9E%8B%E5%A0%86%E6%95%88%E7%8E%87%E7%AB%9F%E6%AF%94stl%E7%9A%84%E6%9B%B4%E5%BF%AB/"},{"categories":["手写数据结构"],"content":"总结 对于模板的运用，现在才刚开始入门(入门都不到…)，给我的感觉是STL源码的包袱很重，各个组件高度关联，所以能够通过一个容器实现的算法有很多很多！我这个新手还不配高攀，只能仰望了，当然平时随便写写乐色代码也是可以滴，至少可以吹牛说比STL还快了🤣 ","date":"2022-02-16","objectID":"/posts/%E6%96%B0%E6%89%8B%E7%94%A8c++%E5%86%99%E4%BA%86%E4%B8%AA%E6%B3%9B%E5%9E%8B%E5%A0%86%E6%95%88%E7%8E%87%E7%AB%9F%E6%AF%94stl%E7%9A%84%E6%9B%B4%E5%BF%AB/:5:0","tags":["新手用C++写了个泛型堆，效率竟比STL的更快？"],"title":"新手用C++写了个泛型堆，效率竟比STL的更快？","uri":"/posts/%E6%96%B0%E6%89%8B%E7%94%A8c++%E5%86%99%E4%BA%86%E4%B8%AA%E6%B3%9B%E5%9E%8B%E5%A0%86%E6%95%88%E7%8E%87%E7%AB%9F%E6%AF%94stl%E7%9A%84%E6%9B%B4%E5%BF%AB/"},{"categories":["手写数据结构"],"content":"来自上帝的骰子---Treap(树堆)详解","date":"2022-02-16","objectID":"/posts/%E6%9D%A5%E8%87%AA%E4%B8%8A%E5%B8%9D%E7%9A%84%E9%AA%B0%E5%AD%90-treap%E6%A0%91%E5%A0%86%E8%AF%A6%E8%A7%A3/","tags":["来自上帝的骰子---Treap(树堆)详解"],"title":"来自上帝的骰子---Treap(树堆)详解","uri":"/posts/%E6%9D%A5%E8%87%AA%E4%B8%8A%E5%B8%9D%E7%9A%84%E9%AA%B0%E5%AD%90-treap%E6%A0%91%E5%A0%86%E8%AF%A6%E8%A7%A3/"},{"categories":["手写数据结构"],"content":"为什么说是上帝的骰子？ 解释这个问题，首先由这个数据结构的名字开始，Treap = Tree + Heap，即为树堆之意，然而实际上用到堆的地方就是利用了一个随机的值标记每个结点，然后根据这个值对树进行左旋、右旋操作来调整父子树直接的关系，你可以严格让它遵循小根堆也可以遵循大根堆，这都无所谓。 也就是说每个结点的结构需要额外存储一个随机值，来决定它是否旋转调整，这对比普通的BST就要优越很多了，但这个也看运气，如果骰子没摇好，出现极端的情况，则可能即便是旋转了多次还是效率低下，我后面对BST、Treap、AVL进行了各方面的对比。 相对AVL，它不需要记录深度，不需要根据深度来判断是否旋转，旋转这件事就完全交给老天了，而且也不存在复杂的旋转情况，只有左旋和右旋。 注意：我写的这个Treap是以大根堆的方式进行维护的！也就是父节点大于子节点的随机值。 ","date":"2022-02-16","objectID":"/posts/%E6%9D%A5%E8%87%AA%E4%B8%8A%E5%B8%9D%E7%9A%84%E9%AA%B0%E5%AD%90-treap%E6%A0%91%E5%A0%86%E8%AF%A6%E8%A7%A3/:1:0","tags":["来自上帝的骰子---Treap(树堆)详解"],"title":"来自上帝的骰子---Treap(树堆)详解","uri":"/posts/%E6%9D%A5%E8%87%AA%E4%B8%8A%E5%B8%9D%E7%9A%84%E9%AA%B0%E5%AD%90-treap%E6%A0%91%E5%A0%86%E8%AF%A6%E8%A7%A3/"},{"categories":["手写数据结构"],"content":"Treap实现 ","date":"2022-02-16","objectID":"/posts/%E6%9D%A5%E8%87%AA%E4%B8%8A%E5%B8%9D%E7%9A%84%E9%AA%B0%E5%AD%90-treap%E6%A0%91%E5%A0%86%E8%AF%A6%E8%A7%A3/:2:0","tags":["来自上帝的骰子---Treap(树堆)详解"],"title":"来自上帝的骰子---Treap(树堆)详解","uri":"/posts/%E6%9D%A5%E8%87%AA%E4%B8%8A%E5%B8%9D%E7%9A%84%E9%AA%B0%E5%AD%90-treap%E6%A0%91%E5%A0%86%E8%AF%A6%E8%A7%A3/"},{"categories":["手写数据结构"],"content":"1. 结点的结构 struct node { //值、优先级(随机数、该数的总结点数、该结点的val次数 int val, priority, length, cnt; node *lchild; node *rchild; node() : val(0), length(1), cnt(1), lchild(nullptr), rchild(nullptr) { srand((unsigned) time(NULL));//记得重新设定种子 priority = rand(); } node(int val) : val(val), length(1), cnt(1), lchild(nullptr), rchild(nullptr) { srand((unsigned) time(NULL)); priority = rand(); } void update() { length = cnt; if (lchild != nullptr)length += lchild-\u003elength; if (rchild != nullptr)length += rchild-\u003elength; } }; ","date":"2022-02-16","objectID":"/posts/%E6%9D%A5%E8%87%AA%E4%B8%8A%E5%B8%9D%E7%9A%84%E9%AA%B0%E5%AD%90-treap%E6%A0%91%E5%A0%86%E8%AF%A6%E8%A7%A3/:2:1","tags":["来自上帝的骰子---Treap(树堆)详解"],"title":"来自上帝的骰子---Treap(树堆)详解","uri":"/posts/%E6%9D%A5%E8%87%AA%E4%B8%8A%E5%B8%9D%E7%9A%84%E9%AA%B0%E5%AD%90-treap%E6%A0%91%E5%A0%86%E8%AF%A6%E8%A7%A3/"},{"categories":["手写数据结构"],"content":"2. Treap的抽象数据结构 class Treap { node *head; int length; public: /*construct\u0026destruct*/ Treap() : head(nullptr), length(0) {} Treap(int val) : head(new node(val)), length(1) {} public://内部类设计迭代器 class iterator { node *head; node *root; public: /*迭代器部分*/ iterator(node *head, node *root) : head(head), root(root) {} iterator \u0026operator++() { root = queryNext(head, root-\u003eval); return *this; } iterator operator++(int) { iterator t = *this; root = queryNext(head, root-\u003eval); return t; } iterator \u0026operator--() { root = queryPre(head, root-\u003eval); return *this; } iterator operator--(int) { iterator t = *this; root = queryPre(head, root-\u003eval); return t; } int operator*() { return root-\u003eval; } bool operator!=(const iterator \u0026t) { return t.root != root; } }; private: /*static function*/ /*rotate*/ static node *rotateLeft(node *root); static node *rotateRight(node *root); /*insert\u0026remove*/ static node *insert(node *root, int val, int \u0026size); static node *remove(node *root, int val, int \u0026size); /*query rank\u0026value*/ static int getLength(node *root); static int queryRank(node *root, int val);//快速查询val的排名 static int queryValue(node *root, int rank);//快速查询排名为rank的数 /*query pre\u0026next*/ static node *queryPre(node *root, int val); static node *queryNext(node *root, int val); static void inorder_print(node *root); static void destroy(node *root); public: /*public function*/ /*insert\u0026remove*/ void insert(int val) { head = insert(head, val, length); } void remove(int val) { head = remove(head, val, length); } int size() { return length; } bool isEmpty() { return length == 0; } /*query rank\u0026value*/ int queryRank(int val) { return queryRank(head, val); } int queryValue(int rank) { return queryValue(head, rank); } void inorder_print() { inorder_print(head); } /*begin\u0026end*/ iterator begin() { node *t = head; while (t-\u003elchild != nullptr) { t = t-\u003elchild; } return iterator(head, t); } iterator end() { return iterator(head, nullptr); } }; ","date":"2022-02-16","objectID":"/posts/%E6%9D%A5%E8%87%AA%E4%B8%8A%E5%B8%9D%E7%9A%84%E9%AA%B0%E5%AD%90-treap%E6%A0%91%E5%A0%86%E8%AF%A6%E8%A7%A3/:2:2","tags":["来自上帝的骰子---Treap(树堆)详解"],"title":"来自上帝的骰子---Treap(树堆)详解","uri":"/posts/%E6%9D%A5%E8%87%AA%E4%B8%8A%E5%B8%9D%E7%9A%84%E9%AA%B0%E5%AD%90-treap%E6%A0%91%E5%A0%86%E8%AF%A6%E8%A7%A3/"},{"categories":["手写数据结构"],"content":"3. 左旋和右旋 具体可以看我之前AVL树对左旋右旋的描述,这里只开发源码查看，文章链接 左旋： node *Treap::rotateLeft(node *root) { node *son = root-\u003erchild; root-\u003erchild = son-\u003elchild; son-\u003elchild = root; root-\u003eupdate();//记得先更新底下的情况 son-\u003eupdate(); return son; } 右旋： node *Treap::rotateRight(node *root) { node *son = root-\u003elchild; root-\u003elchild = son-\u003erchild; son-\u003erchild = root; root-\u003eupdate(); son-\u003eupdate(); return son; } ","date":"2022-02-16","objectID":"/posts/%E6%9D%A5%E8%87%AA%E4%B8%8A%E5%B8%9D%E7%9A%84%E9%AA%B0%E5%AD%90-treap%E6%A0%91%E5%A0%86%E8%AF%A6%E8%A7%A3/:2:3","tags":["来自上帝的骰子---Treap(树堆)详解"],"title":"来自上帝的骰子---Treap(树堆)详解","uri":"/posts/%E6%9D%A5%E8%87%AA%E4%B8%8A%E5%B8%9D%E7%9A%84%E9%AA%B0%E5%AD%90-treap%E6%A0%91%E5%A0%86%E8%AF%A6%E8%A7%A3/"},{"categories":["手写数据结构"],"content":"4. 插入和删除 插入： node *Treap::insert(node *root, int val, int \u0026size) { if (root == nullptr) { ++size; return new node(val); } if (root-\u003eval == val) { root-\u003ecnt++; size++; } else if (root-\u003eval \u003e val) { root-\u003elchild = insert(root-\u003elchild, val, size); //根据优先级判断是否右旋，因为只可能在左边增加长度，通过维持优先级的大根堆 if (root-\u003epriority \u003c root-\u003elchild-\u003epriority) root = rotateRight(root); } else if (root-\u003eval \u003c val) { root-\u003erchild = insert(root-\u003erchild, val, size); if (root-\u003epriority \u003c root-\u003erchild-\u003epriority) root = rotateLeft(root); } root-\u003eupdate();//注意更新长度信息 return root; } 删除： 删除这里还是详解一下： 找到要删除的目标节点后，我们根据让树旋转使得优先级较大的孩子替换掉父亲（目标节点）。然后继续追杀父亲结点，直到该结点被逼到叶子结点，删除即可。 node *Treap::remove(node *root, int val, int \u0026size) { if (root == nullptr)return nullptr;//没找到 if (root-\u003eval == val) { //含有多个相同值，直接操作cnt即可 if (root-\u003ecnt \u003e 1) { root-\u003ecnt--; --size; } //分为两类情况：叶子结点情况和非叶子结点情况 else if (root-\u003elchild != nullptr || root-\u003erchild != nullptr) { //只有左子树或者左子树优先级大于右子树情况 if (root-\u003erchild == nullptr || root-\u003elchild != nullptr \u0026\u0026 root-\u003elchild-\u003epriority \u003e root-\u003erchild-\u003epriority) { root = rotateRight(root);//右旋后继续追杀 root-\u003erchild = remove(root-\u003erchild, val, size); } else {//只有右子树或者右子树优先级大于左子树的情况 root = rotateLeft(root);//左旋后继续追杀 root-\u003elchild = remove(root-\u003elchild, val, size); } } else {//叶子结点情况，直接删除，然后把 delete root; root = nullptr; --size; } } else if (root-\u003eval \u003e val) { root-\u003elchild = remove(root-\u003elchild, val, size); } else if (root-\u003eval \u003c val) { root-\u003erchild = remove(root-\u003erchild, val, size); } if (root) root-\u003eupdate(); return root; } ","date":"2022-02-16","objectID":"/posts/%E6%9D%A5%E8%87%AA%E4%B8%8A%E5%B8%9D%E7%9A%84%E9%AA%B0%E5%AD%90-treap%E6%A0%91%E5%A0%86%E8%AF%A6%E8%A7%A3/:2:4","tags":["来自上帝的骰子---Treap(树堆)详解"],"title":"来自上帝的骰子---Treap(树堆)详解","uri":"/posts/%E6%9D%A5%E8%87%AA%E4%B8%8A%E5%B8%9D%E7%9A%84%E9%AA%B0%E5%AD%90-treap%E6%A0%91%E5%A0%86%E8%AF%A6%E8%A7%A3/"},{"categories":["手写数据结构"],"content":"5. 查询排名 原理：由于是排序二叉树，而且记录了树的结点个数，所以我们根据左边个数（小于当前结点的个数），如果我们的值小于当前结点的值，则小于它的个数范围肯定是在当前结点的左边，直接迁移到左孩子即可，如果大于当前结点，则当前结点的左边大小+它自身也是无法满足要查询的值的排名，rank加上该值后root继续右移。如果出现找到该元素的情况，则直接返回rank+左边长度。如果其中不存在，则最后得出的rank肯定是需要+1的。 inline int Treap::getLength(node *root) { if (root == nullptr) return 0; return root-\u003elength; } int Treap::queryRank(node *root, int val) {//相当于查询有多少个数小于等于val int rank = 0; while (root != nullptr) { if (root-\u003eval == val)return rank + getLength(root-\u003elchild) + root-\u003ecnt; else if (root-\u003eval \u003e val)root = root-\u003elchild; else rank += getLength(root-\u003elchild) + root-\u003ecnt, root = root-\u003erchild; } return rank + 1;//如果未找到，则在原来的基础上+1 } ","date":"2022-02-16","objectID":"/posts/%E6%9D%A5%E8%87%AA%E4%B8%8A%E5%B8%9D%E7%9A%84%E9%AA%B0%E5%AD%90-treap%E6%A0%91%E5%A0%86%E8%AF%A6%E8%A7%A3/:2:5","tags":["来自上帝的骰子---Treap(树堆)详解"],"title":"来自上帝的骰子---Treap(树堆)详解","uri":"/posts/%E6%9D%A5%E8%87%AA%E4%B8%8A%E5%B8%9D%E7%9A%84%E9%AA%B0%E5%AD%90-treap%E6%A0%91%E5%A0%86%E8%AF%A6%E8%A7%A3/"},{"categories":["手写数据结构"],"content":"6. 按排名查询值 inline int Treap::getLength(node *root) { if (root == nullptr) return 0; return root-\u003elength; } int Treap::queryValue(node *root, int rank) {//相当于得到第k大的数：支持重复元素是最骚的！！！ while (root != nullptr) { if (getLength(root-\u003elchild) + root-\u003ecnt \u003e rank) { if (getLength(root-\u003elchild) + 1 \u003e rank) root = root-\u003elchild; else return root-\u003eval; } else if (getLength(root-\u003elchild) + root-\u003ecnt \u003c rank) { rank -= getLength(root-\u003elchild) + root-\u003ecnt; root = root-\u003erchild; } else {//rank与左子树的大小相等的情况 return root-\u003eval; } } return 0; } ","date":"2022-02-16","objectID":"/posts/%E6%9D%A5%E8%87%AA%E4%B8%8A%E5%B8%9D%E7%9A%84%E9%AA%B0%E5%AD%90-treap%E6%A0%91%E5%A0%86%E8%AF%A6%E8%A7%A3/:2:6","tags":["来自上帝的骰子---Treap(树堆)详解"],"title":"来自上帝的骰子---Treap(树堆)详解","uri":"/posts/%E6%9D%A5%E8%87%AA%E4%B8%8A%E5%B8%9D%E7%9A%84%E9%AA%B0%E5%AD%90-treap%E6%A0%91%E5%A0%86%E8%AF%A6%E8%A7%A3/"},{"categories":["手写数据结构"],"content":"7. 查询前驱后继 前驱： node *Treap::queryPre(node *root, int val) {//一样的道理：如果有左子树，就是左子树中最大的结点，如果没有则是最接近该结点的父节点(应在它的右侧 node *res = nullptr; while (root != nullptr) { if (root-\u003eval \u003c val)res = root, root = root-\u003erchild; else root = root-\u003erchild; } return res; } 后继： node *Treap::queryNext(node *root, int val) {//寻找后继 node *res = nullptr; while (root != nullptr) { if (root-\u003eval \u003e val)res = root, root = root-\u003elchild; else root = root-\u003erchild; } return res; } ","date":"2022-02-16","objectID":"/posts/%E6%9D%A5%E8%87%AA%E4%B8%8A%E5%B8%9D%E7%9A%84%E9%AA%B0%E5%AD%90-treap%E6%A0%91%E5%A0%86%E8%AF%A6%E8%A7%A3/:2:7","tags":["来自上帝的骰子---Treap(树堆)详解"],"title":"来自上帝的骰子---Treap(树堆)详解","uri":"/posts/%E6%9D%A5%E8%87%AA%E4%B8%8A%E5%B8%9D%E7%9A%84%E9%AA%B0%E5%AD%90-treap%E6%A0%91%E5%A0%86%E8%AF%A6%E8%A7%A3/"},{"categories":["手写数据结构"],"content":"8. 销毁Treap void Treap::destroy(node *root) { if (root == nullptr) return; destroy(root-\u003elchild); destroy(root-\u003erchild); delete root; root = nullptr; } ","date":"2022-02-16","objectID":"/posts/%E6%9D%A5%E8%87%AA%E4%B8%8A%E5%B8%9D%E7%9A%84%E9%AA%B0%E5%AD%90-treap%E6%A0%91%E5%A0%86%E8%AF%A6%E8%A7%A3/:2:8","tags":["来自上帝的骰子---Treap(树堆)详解"],"title":"来自上帝的骰子---Treap(树堆)详解","uri":"/posts/%E6%9D%A5%E8%87%AA%E4%B8%8A%E5%B8%9D%E7%9A%84%E9%AA%B0%E5%AD%90-treap%E6%A0%91%E5%A0%86%E8%AF%A6%E8%A7%A3/"},{"categories":["手写数据结构"],"content":"9. 迭代器的设计 public://内部类设计迭代器 class iterator { node *head; node *root; public: /*迭代器部分*/ iterator(node *head, node *root) : head(head), root(root) {} iterator \u0026operator++() { root = queryNext(head, root-\u003eval); return *this; } iterator operator++(int) { iterator t = *this; root = queryNext(head, root-\u003eval); return t; } iterator \u0026operator--() { root = queryPre(head, root-\u003eval); return *this; } iterator operator--(int) { iterator t = *this; root = queryPre(head, root-\u003eval); return t; } int operator*() { return root-\u003eval; } bool operator!=(const iterator \u0026t) { return t.root != root; } }; ","date":"2022-02-16","objectID":"/posts/%E6%9D%A5%E8%87%AA%E4%B8%8A%E5%B8%9D%E7%9A%84%E9%AA%B0%E5%AD%90-treap%E6%A0%91%E5%A0%86%E8%AF%A6%E8%A7%A3/:2:9","tags":["来自上帝的骰子---Treap(树堆)详解"],"title":"来自上帝的骰子---Treap(树堆)详解","uri":"/posts/%E6%9D%A5%E8%87%AA%E4%B8%8A%E5%B8%9D%E7%9A%84%E9%AA%B0%E5%AD%90-treap%E6%A0%91%E5%A0%86%E8%AF%A6%E8%A7%A3/"},{"categories":["手写数据结构"],"content":"完整源代码 ","date":"2022-02-16","objectID":"/posts/%E6%9D%A5%E8%87%AA%E4%B8%8A%E5%B8%9D%E7%9A%84%E9%AA%B0%E5%AD%90-treap%E6%A0%91%E5%A0%86%E8%AF%A6%E8%A7%A3/:3:0","tags":["来自上帝的骰子---Treap(树堆)详解"],"title":"来自上帝的骰子---Treap(树堆)详解","uri":"/posts/%E6%9D%A5%E8%87%AA%E4%B8%8A%E5%B8%9D%E7%9A%84%E9%AA%B0%E5%AD%90-treap%E6%A0%91%E5%A0%86%E8%AF%A6%E8%A7%A3/"},{"categories":["手写数据结构"],"content":"Treap.h // // Created by Alone on 2021/10/14. // #ifndef MY_TINY_STL_TREAP_H #define MY_TINY_STL_TREAP_H #include \u003ccstdio\u003e#include \u003ccstdlib\u003e#include \u003cctime\u003e struct node { int val, priority, length, cnt; node *lchild; node *rchild; node() : val(0), length(1), cnt(1), lchild(nullptr), rchild(nullptr) { srand((unsigned) time(NULL));//记得重新设定种子 priority = rand(); } node(int val) : val(val), length(1), cnt(1), lchild(nullptr), rchild(nullptr) { srand((unsigned) time(NULL)); priority = rand(); } void update() { length = cnt; if (lchild != nullptr)length += lchild-\u003elength; if (rchild != nullptr)length += rchild-\u003elength; } }; class Treap { node *head; int length; public: /*construct\u0026destruct*/ Treap() : head(nullptr), length(0) {} Treap(int val) : head(new node(val)), length(1) {} ~Treap(){ destroy(head); } public://内部类设计迭代器 class iterator { node *head; node *root; public: /*迭代器部分*/ iterator(node *head, node *root) : head(head), root(root) {} iterator \u0026operator++() { root = queryNext(head, root-\u003eval); return *this; } iterator operator++(int) { iterator t = *this; root = queryNext(head, root-\u003eval); return t; } iterator \u0026operator--() { root = queryPre(head, root-\u003eval); return *this; } iterator operator--(int) { iterator t = *this; root = queryPre(head, root-\u003eval); return t; } int operator*() { return root-\u003eval; } bool operator!=(const iterator \u0026t) { return t.root != root; } }; private: /*static function*/ /*rotate*/ static node *rotateLeft(node *root); static node *rotateRight(node *root); /*insert\u0026remove*/ static node *insert(node *root, int val, int \u0026size); static node *remove(node *root, int val, int \u0026size); /*query rank\u0026value*/ static int getLength(node *root); static int queryRank(node *root, int val);//快速查询val的排名 static int queryValue(node *root, int rank);//快速查询排名为rank的数 /*query pre\u0026next*/ static node *queryPre(node *root, int val); static node *queryNext(node *root, int val); static void inorder_print(node *root); static void destroy(node *root); public: /*public function*/ /*insert\u0026remove*/ void insert(int val) { head = insert(head, val, length); } void remove(int val) { head = remove(head, val, length); } int size() { return length; } bool isEmpty() { return length == 0; } /*query rank\u0026value*/ int queryRank(int val) { return queryRank(head, val); } int queryValue(int rank) { return queryValue(head, rank); } void inorder_print() { inorder_print(head); } /*begin\u0026end*/ iterator begin() { node *t = head; while (t-\u003elchild != nullptr) { t = t-\u003elchild; } return iterator(head, t); } iterator end() { return iterator(head, nullptr); } }; #endif //MY_TINY_STL_TREAP_H ","date":"2022-02-16","objectID":"/posts/%E6%9D%A5%E8%87%AA%E4%B8%8A%E5%B8%9D%E7%9A%84%E9%AA%B0%E5%AD%90-treap%E6%A0%91%E5%A0%86%E8%AF%A6%E8%A7%A3/:3:1","tags":["来自上帝的骰子---Treap(树堆)详解"],"title":"来自上帝的骰子---Treap(树堆)详解","uri":"/posts/%E6%9D%A5%E8%87%AA%E4%B8%8A%E5%B8%9D%E7%9A%84%E9%AA%B0%E5%AD%90-treap%E6%A0%91%E5%A0%86%E8%AF%A6%E8%A7%A3/"},{"categories":["手写数据结构"],"content":"Treap.cpp // // Created by Alone on 2021/10/14. // #include \"Treap.h\" node *Treap::rotateLeft(node *root) { node *son = root-\u003erchild; root-\u003erchild = son-\u003elchild; son-\u003elchild = root; root-\u003eupdate();//记得先更新底下的情况 son-\u003eupdate(); return son; } node *Treap::rotateRight(node *root) { node *son = root-\u003elchild; root-\u003elchild = son-\u003erchild; son-\u003erchild = root; root-\u003eupdate(); son-\u003eupdate(); return son; } node *Treap::insert(node *root, int val, int \u0026size) { if (root == nullptr) { ++size; return new node(val); } if (root-\u003eval == val) { root-\u003ecnt++; size++; } else if (root-\u003eval \u003e val) { root-\u003elchild = insert(root-\u003elchild, val, size); //根据优先级判断是否右旋，因为只可能在左边增加长度，通过维持优先级的大根堆 if (root-\u003epriority \u003c root-\u003elchild-\u003epriority) root = rotateRight(root); } else if (root-\u003eval \u003c val) { root-\u003erchild = insert(root-\u003erchild, val, size); if (root-\u003epriority \u003c root-\u003erchild-\u003epriority) root = rotateLeft(root); } root-\u003eupdate(); return root; } node *Treap::remove(node *root, int val, int \u0026size) { if (root == nullptr)return nullptr;//没找到 if (root-\u003eval == val) { //含有多个相同值，直接操作cnt即可 if (root-\u003ecnt \u003e 1) { root-\u003ecnt--; --size; } //分为两类情况：叶子结点情况和非叶子结点情况 else if (root-\u003elchild != nullptr || root-\u003erchild != nullptr) { //只有左子树或者左子树优先级大于右子树情况 if (root-\u003erchild == nullptr || root-\u003elchild != nullptr \u0026\u0026 root-\u003elchild-\u003epriority \u003e root-\u003erchild-\u003epriority) { root = rotateRight(root);//右旋后继续追杀 root-\u003erchild = remove(root-\u003erchild, val, size); } else {//只有右子树或者右子树优先级大于左子树的情况 root = rotateLeft(root);//左旋后继续追杀 root-\u003elchild = remove(root-\u003elchild, val, size); } } else {//叶子结点情况，直接删除，然后把 delete root; root = nullptr; --size; } } else if (root-\u003eval \u003e val) { root-\u003elchild = remove(root-\u003elchild, val, size); } else if (root-\u003eval \u003c val) { root-\u003erchild = remove(root-\u003erchild, val, size); } if (root) root-\u003eupdate(); return root; } int Treap::queryRank(node *root, int val) {//相当于查询有多少个数小于等于val int rank = 0; while (root != nullptr) { if (root-\u003eval == val)return rank + getLength(root-\u003elchild) + root-\u003ecnt; else if (root-\u003eval \u003e val)root = root-\u003elchild; else rank += getLength(root-\u003elchild) + root-\u003ecnt, root = root-\u003erchild; } return rank + 1;//如果未找到，则在原来的基础上+1 } int Treap::queryValue(node *root, int rank) {//相当于得到第k大的数：支持重复元素是最骚的！！！ while (root != nullptr) { if (getLength(root-\u003elchild) + root-\u003ecnt \u003e rank) { if (getLength(root-\u003elchild) + 1 \u003e rank) root = root-\u003elchild; else return root-\u003eval; } else if (getLength(root-\u003elchild) + root-\u003ecnt \u003c rank) { rank -= getLength(root-\u003elchild) + root-\u003ecnt; root = root-\u003erchild; } else {//rank与左子树的大小相等的情况 return root-\u003eval; } } return 0; } node *Treap::queryPre(node *root, int val) {//一样的道理：如果有左子树，就是左子树中最大的结点，如果没有则是最接近该结点的父节点(应在它的右侧 node *res = nullptr; while (root != nullptr) { if (root-\u003eval \u003c val)res = root, root = root-\u003erchild; else root = root-\u003erchild; } return res; } node *Treap::queryNext(node *root, int val) {//寻找后继 node *res = nullptr; while (root != nullptr) { if (root-\u003eval \u003e val)res = root, root = root-\u003elchild; else root = root-\u003erchild; } return res; } void Treap::inorder_print(node *root) { if (root == nullptr) return; inorder_print(root-\u003elchild); printf(\"%d \", root-\u003eval); inorder_print(root-\u003erchild); } void Treap::destroy(node *root) { if (root == nullptr) return; destroy(root-\u003elchild); destroy(root-\u003erchild); delete root; root = nullptr; } inline int Treap::getLength(node *root) { if (root == nullptr) return 0; return root-\u003elength; } ","date":"2022-02-16","objectID":"/posts/%E6%9D%A5%E8%87%AA%E4%B8%8A%E5%B8%9D%E7%9A%84%E9%AA%B0%E5%AD%90-treap%E6%A0%91%E5%A0%86%E8%AF%A6%E8%A7%A3/:3:2","tags":["来自上帝的骰子---Treap(树堆)详解"],"title":"来自上帝的骰子---Treap(树堆)详解","uri":"/posts/%E6%9D%A5%E8%87%AA%E4%B8%8A%E5%B8%9D%E7%9A%84%E9%AA%B0%E5%AD%90-treap%E6%A0%91%E5%A0%86%E8%AF%A6%E8%A7%A3/"},{"categories":["手写数据结构"],"content":"测试 ","date":"2022-02-16","objectID":"/posts/%E6%9D%A5%E8%87%AA%E4%B8%8A%E5%B8%9D%E7%9A%84%E9%AA%B0%E5%AD%90-treap%E6%A0%91%E5%A0%86%E8%AF%A6%E8%A7%A3/:4:0","tags":["来自上帝的骰子---Treap(树堆)详解"],"title":"来自上帝的骰子---Treap(树堆)详解","uri":"/posts/%E6%9D%A5%E8%87%AA%E4%B8%8A%E5%B8%9D%E7%9A%84%E9%AA%B0%E5%AD%90-treap%E6%A0%91%E5%A0%86%E8%AF%A6%E8%A7%A3/"},{"categories":["手写数据结构"],"content":"AVL vs Treap vs 普通BST 测试数据量：1000w 直接来结论： AVL极端情况下(插入的数据有序)，完爆所有平衡树。 Treap随机情况的插入表示不错！大部分时间可以和AVL持平。 BST别想了，这个1000w数据只有随机情况能用几分钟过，如果极端情况直接程序运行出错！ 整体小结： 第一轮：insert操作 随机情况Treap(看运气，毕竟随机事件) \u003e=\u003c AVL\u003e\u003e BST 极端情况AVL \u003e\u003e Treap， BST直接暴毙 第二轮: remove操作–Treap被AVL吊打，BST就别提了 下面就没得继续展开的比较了，总结就是Treap相对好写一点，效率高不高看运气。 还有就是Treap在直接处理第K大的值具有优势，以及按排位查找具有优势。 优势：由于treap每个结点都含有它整个结点个数的记录，所以可以很快的查出值的排名和排名的值。 ","date":"2022-02-16","objectID":"/posts/%E6%9D%A5%E8%87%AA%E4%B8%8A%E5%B8%9D%E7%9A%84%E9%AA%B0%E5%AD%90-treap%E6%A0%91%E5%A0%86%E8%AF%A6%E8%A7%A3/:4:1","tags":["来自上帝的骰子---Treap(树堆)详解"],"title":"来自上帝的骰子---Treap(树堆)详解","uri":"/posts/%E6%9D%A5%E8%87%AA%E4%B8%8A%E5%B8%9D%E7%9A%84%E9%AA%B0%E5%AD%90-treap%E6%A0%91%E5%A0%86%E8%AF%A6%E8%A7%A3/"},{"categories":["算法——二段性相关(二分)"],"content":"leetcode情人节特辑——寻找单身狗","date":"2022-02-14","objectID":"/posts/leetcode%E6%83%85%E4%BA%BA%E8%8A%82%E7%89%B9%E8%BE%91%E5%AF%BB%E6%89%BE%E5%8D%95%E8%BA%AB%E7%8B%97/","tags":["leetcode情人节特辑——寻找单身狗"],"title":"leetcode情人节特辑——寻找单身狗","uri":"/posts/leetcode%E6%83%85%E4%BA%BA%E8%8A%82%E7%89%B9%E8%BE%91%E5%AF%BB%E6%89%BE%E5%8D%95%E8%BA%AB%E7%8B%97/"},{"categories":["算法——二段性相关(二分)"],"content":"题目 题目链接 ","date":"2022-02-14","objectID":"/posts/leetcode%E6%83%85%E4%BA%BA%E8%8A%82%E7%89%B9%E8%BE%91%E5%AF%BB%E6%89%BE%E5%8D%95%E8%BA%AB%E7%8B%97/:1:0","tags":["leetcode情人节特辑——寻找单身狗"],"title":"leetcode情人节特辑——寻找单身狗","uri":"/posts/leetcode%E6%83%85%E4%BA%BA%E8%8A%82%E7%89%B9%E8%BE%91%E5%AF%BB%E6%89%BE%E5%8D%95%E8%BA%AB%E7%8B%97/"},{"categories":["算法——二段性相关(二分)"],"content":"题目详解 这题本应是简单题，就是简单的异或规律，但是题目要求使用 O(logn) 时间复杂度， O(1) 空间复杂度，而如果直接异或，只会是 O(n) 的时间复杂度。 那么该如何去做呢？ 这题有二段性，什么叫二段性呢，就是能有一个分界点把特性一分为二。比如此题由于数据是有序的，所以数量为两个的元素会挨在一起，而且在 单身狗 左边连续的元素下标会有以下规律：两个相邻的相同元素中，第一个元素下标会是偶数，第二个是奇数。右边的连续元素下标会有以下规律：两个相邻的相同元素中，第一个元素下标是奇数，第二个是偶数。 根据以上二段性可很快构建出二分版本的代码！ ","date":"2022-02-14","objectID":"/posts/leetcode%E6%83%85%E4%BA%BA%E8%8A%82%E7%89%B9%E8%BE%91%E5%AF%BB%E6%89%BE%E5%8D%95%E8%BA%AB%E7%8B%97/:2:0","tags":["leetcode情人节特辑——寻找单身狗"],"title":"leetcode情人节特辑——寻找单身狗","uri":"/posts/leetcode%E6%83%85%E4%BA%BA%E8%8A%82%E7%89%B9%E8%BE%91%E5%AF%BB%E6%89%BE%E5%8D%95%E8%BA%AB%E7%8B%97/"},{"categories":["算法——二段性相关(二分)"],"content":"解题代码 未简化二分版本 class Solution { public: int singleNonDuplicate(vector\u003cint\u003e\u0026 nums) { int l=0,r=nums.size()-1; int maxr = r; int mid; while(l\u003cr){ mid = (l+r)/2; if(mid\u003cmaxr\u0026\u0026nums[mid+1]==nums[mid]){ if(mid%2==0){ l = mid+2; }else{ r = mid; } }else if(mid\u003e0\u0026\u0026nums[mid-1]==nums[mid]){ if((mid-1)%2==0){ l = mid+1; }else{ r = mid; } }else{ return nums[mid]; } } return nums[l]; } }; 简化的二分版本 class Solution { public: int singleNonDuplicate(vector\u003cint\u003e\u0026 nums) { int low = 0, high = nums.size() - 1; while (low \u003c high) { int mid = (high - low) / 2 + low; if (nums[mid] == nums[mid ^ 1]) { low = mid + 1; } else { high = mid; } } return nums[low]; } }; ","date":"2022-02-14","objectID":"/posts/leetcode%E6%83%85%E4%BA%BA%E8%8A%82%E7%89%B9%E8%BE%91%E5%AF%BB%E6%89%BE%E5%8D%95%E8%BA%AB%E7%8B%97/:3:0","tags":["leetcode情人节特辑——寻找单身狗"],"title":"leetcode情人节特辑——寻找单身狗","uri":"/posts/leetcode%E6%83%85%E4%BA%BA%E8%8A%82%E7%89%B9%E8%BE%91%E5%AF%BB%E6%89%BE%E5%8D%95%E8%BA%AB%E7%8B%97/"},{"categories":["算法——二段性相关(二分)"],"content":"牛客-wyh的物品——通过验证得出二分的搜索区间","date":"2022-02-14","objectID":"/posts/%E7%89%9B%E5%AE%A2-wyh%E7%9A%84%E7%89%A9%E5%93%81%E9%80%9A%E8%BF%87%E9%AA%8C%E8%AF%81%E5%BE%97%E5%87%BA%E4%BA%8C%E5%88%86%E7%9A%84%E6%90%9C%E7%B4%A2%E5%8C%BA%E9%97%B4/","tags":["牛客-wyh的物品——通过验证得出二分的搜索区间"],"title":"牛客-wyh的物品——通过验证得出二分的搜索区间","uri":"/posts/%E7%89%9B%E5%AE%A2-wyh%E7%9A%84%E7%89%A9%E5%93%81%E9%80%9A%E8%BF%87%E9%AA%8C%E8%AF%81%E5%BE%97%E5%87%BA%E4%BA%8C%E5%88%86%E7%9A%84%E6%90%9C%E7%B4%A2%E5%8C%BA%E9%97%B4/"},{"categories":["算法——二段性相关(二分)"],"content":"题目 题目链接 ","date":"2022-02-14","objectID":"/posts/%E7%89%9B%E5%AE%A2-wyh%E7%9A%84%E7%89%A9%E5%93%81%E9%80%9A%E8%BF%87%E9%AA%8C%E8%AF%81%E5%BE%97%E5%87%BA%E4%BA%8C%E5%88%86%E7%9A%84%E6%90%9C%E7%B4%A2%E5%8C%BA%E9%97%B4/:1:0","tags":["牛客-wyh的物品——通过验证得出二分的搜索区间"],"title":"牛客-wyh的物品——通过验证得出二分的搜索区间","uri":"/posts/%E7%89%9B%E5%AE%A2-wyh%E7%9A%84%E7%89%A9%E5%93%81%E9%80%9A%E8%BF%87%E9%AA%8C%E8%AF%81%E5%BE%97%E5%87%BA%E4%BA%8C%E5%88%86%E7%9A%84%E6%90%9C%E7%B4%A2%E5%8C%BA%E9%97%B4/"},{"categories":["算法——二段性相关(二分)"],"content":"题目详解 以下为手写详解 下面总结这个做题步骤： 二分搜索可能的最大单位价值。 根据这个值得到每个数的单位价值情况s，根据s的值排序，得到前k大的s，相加得出我们枚举的这个最大单位价值是大了还是小了，方便后续二分！ 最后按保留两位小数，输出即可。 ","date":"2022-02-14","objectID":"/posts/%E7%89%9B%E5%AE%A2-wyh%E7%9A%84%E7%89%A9%E5%93%81%E9%80%9A%E8%BF%87%E9%AA%8C%E8%AF%81%E5%BE%97%E5%87%BA%E4%BA%8C%E5%88%86%E7%9A%84%E6%90%9C%E7%B4%A2%E5%8C%BA%E9%97%B4/:2:0","tags":["牛客-wyh的物品——通过验证得出二分的搜索区间"],"title":"牛客-wyh的物品——通过验证得出二分的搜索区间","uri":"/posts/%E7%89%9B%E5%AE%A2-wyh%E7%9A%84%E7%89%A9%E5%93%81%E9%80%9A%E8%BF%87%E9%AA%8C%E8%AF%81%E5%BE%97%E5%87%BA%E4%BA%8C%E5%88%86%E7%9A%84%E6%90%9C%E7%B4%A2%E5%8C%BA%E9%97%B4/"},{"categories":["算法——二段性相关(二分)"],"content":"解题代码 #include\u003cbits/stdc++.h\u003eusing namespace std; const int maxn = 1e5+5; int w[maxn],v[maxn]; double s[maxn]; //TODO 存下用于比对实际单位价值的信息 int n,k; using namespace std; int solve(double mid) { double ss = 0; for(int i = 0;i\u003cn;i++) { s[i] = 1.0*v[i] - w[i]*mid; } sort(s,s+n,greater\u003cdouble\u003e());//TODO 从大到小排序，因为要取前k个最大值 for(int i = 0;i\u003ck;i++) ss += s[i]; //TODO 得到前k个最大的s信息的和， // 如果大于0，则说明取小了，小于0则取大了，等于0则正好满足！ if(ss\u003e0) return 1; else if(ss==0)return -1; else return 0; } int main() { int t; cin\u003e\u003et; while(t--) { scanf(\"%d %d\",\u0026n,\u0026k); double low = 0,high = 100000,mid; for(int i = 0;i\u003cn;i++) { scanf(\"%d %d\",\u0026w[i],\u0026v[i]); } //TODO 二分搜索，由于double类型的二分，故取一个小数形式进行比对 // 注意double类型的二分，千万别+1或者-1！这个跨度太大了，因为我们搜的是个分数！ while(high - low \u003e0.00001) { mid = (low + high)/2.0; int flag = solve(mid); if(flag==1) low = mid;//TODO 收缩左边界 else if(flag == -1)break;//TODO 枚举得到答案 else high = mid;//TODO 收缩右边界 } printf(\"%.2lf\\n\",mid); } return 0; } ","date":"2022-02-14","objectID":"/posts/%E7%89%9B%E5%AE%A2-wyh%E7%9A%84%E7%89%A9%E5%93%81%E9%80%9A%E8%BF%87%E9%AA%8C%E8%AF%81%E5%BE%97%E5%87%BA%E4%BA%8C%E5%88%86%E7%9A%84%E6%90%9C%E7%B4%A2%E5%8C%BA%E9%97%B4/:3:0","tags":["牛客-wyh的物品——通过验证得出二分的搜索区间"],"title":"牛客-wyh的物品——通过验证得出二分的搜索区间","uri":"/posts/%E7%89%9B%E5%AE%A2-wyh%E7%9A%84%E7%89%A9%E5%93%81%E9%80%9A%E8%BF%87%E9%AA%8C%E8%AF%81%E5%BE%97%E5%87%BA%E4%BA%8C%E5%88%86%E7%9A%84%E6%90%9C%E7%B4%A2%E5%8C%BA%E9%97%B4/"},{"categories":["C++实战"],"content":"Hugo博客图形化写作工具","date":"2022-02-12","objectID":"/posts/hugo%E5%8D%9A%E5%AE%A2%E5%9B%BE%E5%BD%A2%E5%8C%96%E5%86%99%E4%BD%9C%E5%B7%A5%E5%85%B7/","tags":["Hugo博客图形化写作工具"],"title":"Hugo博客图形化写作工具","uri":"/posts/hugo%E5%8D%9A%E5%AE%A2%E5%9B%BE%E5%BD%A2%E5%8C%96%E5%86%99%E4%BD%9C%E5%B7%A5%E5%85%B7/"},{"categories":["C++实战"],"content":"软件使用 视频教程 ","date":"2022-02-12","objectID":"/posts/hugo%E5%8D%9A%E5%AE%A2%E5%9B%BE%E5%BD%A2%E5%8C%96%E5%86%99%E4%BD%9C%E5%B7%A5%E5%85%B7/:1:0","tags":["Hugo博客图形化写作工具"],"title":"Hugo博客图形化写作工具","uri":"/posts/hugo%E5%8D%9A%E5%AE%A2%E5%9B%BE%E5%BD%A2%E5%8C%96%E5%86%99%E4%BD%9C%E5%B7%A5%E5%85%B7/"},{"categories":["C++实战"],"content":"项目介绍 项目所在地 温馨提示：如果本地还未搭建 hugo 博客，可以使用我的另一个 hugo 博客自动搭建工具 QtRun： 介绍：一个用纯 C++ 写的命令行工具。 主要作用：根据提供的 hugo 博客本地地址进行命令行式的自动化写作，会把每一篇文章的图片、分类、标题等内容自动化完成。 构建方式：确保生成 exe 文件的目录下含有以下文件，且确保编译器支持 C++17。 BlogPath.txt #提供本地hugo博客路径 categories.txt #提供可供选择的分类(没有也没关系) initImg.txt #提供可选择的图片 mob.txt #提供用于生成的模板 ed_Path.txt #提供打开的编辑器路径(没有也没关系) 使用方式：可查看源码得到更详尽的解答 QtRun [title name] [category name] Qtrun [-op] QtRunBlog： 介绍：使用 Qt+cmake 搭建的图形化 hugo 自动化工具，写作的相关部分都是调用的 QtRun ，所以运行时 QtRun 的配置文件和 QtRun 都必须在它的 exe 目录之下。而其他其他部分调用的 git 命令行，所以需要本地有 git 工具。 主要作用：提供图形化的 hugo 写作体验。 构建方式：本地需要 Qt6 环境，选择本项目目录便可完成构建。 ","date":"2022-02-12","objectID":"/posts/hugo%E5%8D%9A%E5%AE%A2%E5%9B%BE%E5%BD%A2%E5%8C%96%E5%86%99%E4%BD%9C%E5%B7%A5%E5%85%B7/:2:0","tags":["Hugo博客图形化写作工具"],"title":"Hugo博客图形化写作工具","uri":"/posts/hugo%E5%8D%9A%E5%AE%A2%E5%9B%BE%E5%BD%A2%E5%8C%96%E5%86%99%E4%BD%9C%E5%B7%A5%E5%85%B7/"},{"categories":["C++实战"],"content":"QtRun C++ 源代码 实现了自动化命令行写作，QtRunBlog图形化界面调用的就是它的命令行 // // Created by Alone on 2022-1-24. // //TODO aaaaaaa得出感悟：1.数据较为复杂的情况下尽量不要使用全局变量 2.在构造函数初始化的时候千万不要直接new空间给它，记得随时随地nullptr #include \u003cfstream\u003e#include \u003ciostream\u003e#include \u003cstring\u003e#include \u003csys/stat.h\u003e#include \u003cunistd.h\u003e#include \u003cwindows.h\u003e#include \u003cvector\u003e#include \u003cunordered_map\u003e#include \u003cctime\u003e#include \u003cfilesystem\u003e#include \u003crandom\u003e #define IMGS_PATH \"./initImg.txt\" #define MOB_PATH \"./mob.txt\" #define CATEGORIES_PATH \"./categories.txt\" #define BLOG_SRC \"./BlogPath.txt\" std::filesystem::path POSTS_PATH;//用于获取post_path using namespace std; //TODO 建立枚举映射 enum class SHOW_ARGS : int { EMPTY, CATEGORIES, IMG, BLOG_PATH }; //TODO 命令行参数的枚举映射 unordered_map\u003cstring, SHOW_ARGS\u003e MAP{ {\"-sc\", SHOW_ARGS::CATEGORIES}, {\"-si\", SHOW_ARGS::IMG}, {\"-sp\", SHOW_ARGS::BLOG_PATH} }; //TODO 封装文件读取类 class FileReader { stringstream in_buf; ifstream reader; public: FileReader() = default; FileReader(const FileReader \u0026) = delete; FileReader(FileReader \u0026\u0026) = delete; ~FileReader() { if (reader.is_open()) reader.close(); } void open(const string \u0026path) { reader.open(path); if (!reader.is_open()) { perror(\"reader open failed\"); exit(1); } in_buf \u003c\u003c reader.rdbuf(); } bool readAll(string \u0026dst) { if (in_buf.good()) dst = in_buf.str(); else return false; return true; } bool readline(string \u0026dst) { if (in_buf.good()) getline(in_buf, dst); else return false; return true; } }; //TODO 封装文件写入类 class FileWriter { char *out_buf; ofstream writer; size_t cur_buf_size; size_t max_buf_size; private: void _write() { //缓冲区写满，写入文件中 writer.write(out_buf, max_buf_size); cur_buf_size = 0; } public: FileWriter() : cur_buf_size(0), max_buf_size(512), out_buf(nullptr) {}; FileWriter(const FileReader \u0026) = delete; FileWriter(FileReader \u0026\u0026) = delete; FileWriter(const string \u0026path, ios::openmode mode = ios::out) { writer.open(path, mode); if (!writer.is_open()) { perror(\"writer open failed\"); exit(1); } cur_buf_size = 0; max_buf_size = 512; out_buf = new char[max_buf_size + 5]; } ~FileWriter() { if (cur_buf_size \u003e 0) { writer.write(out_buf, cur_buf_size); cur_buf_size = 0; } delete[] out_buf; out_buf = nullptr; writer.flush(); writer.close(); } static bool exist(const string \u0026path) { return (access(path.c_str(), F_OK) != -1); } void open(const string \u0026path, ios::openmode mode = ios::out) { writer.open(path, mode); if (!writer.is_open()) { perror(\"writer open failed\"); exit(1); } out_buf = new char[max_buf_size + 5]; } void write(const string \u0026src) {//TODO 缓冲机制的重要组成 if (writer.is_open()) {//只有在open文件后才能写入 if (src.empty()) return; if (cur_buf_size == max_buf_size) _write(); size_t psize = src.size() + cur_buf_size;//如果全盘写入缓冲区后，缓冲区需要的大小 int startp = 0, maxLen; while (psize \u003e max_buf_size) { //当这次写入缓冲区的数据量大于缓冲区的大小，则进行不断写满更新操作 maxLen = max_buf_size - cur_buf_size; copy(src.begin() + startp, src.begin() + startp + maxLen, out_buf + cur_buf_size);//copy到满状态，再来一次write _write(); startp += maxLen; psize -= max_buf_size; } //如果写入数据不超出缓冲区大小，则直接写入 copy(src.begin() + startp, src.end(), out_buf + cur_buf_size); cur_buf_size += src.size() - startp; } } FileWriter \u0026append(const string \u0026src) {//TODO 和write没区别，只是支持链式调用 write(src); return *this; } }; //TODO 整个项目需要操作的变量（很不推荐用全局变量，我就是因为这玩意就导致了bug） FileReader readImg, readText, readCategories;//用于文件io的变量 FileWriter appendCategories, fileWriter; vector\u003cstring\u003e imgs, categories; //用于存下磁盘到内存的数据，根据名字判断存的啥 time_t now = time(NULL); //TODO 打开typora软件 void open_exe_from_path(const char *path) { WinExec(path, SW_SHOWNORMAL); cout \u003c\u003c \"open your custom editor successfully!\" \u003c\u003c endl; } //TODO 打印内容 void show(vector\u003cstring\u003e \u0026src) { for (int i = 0; i \u003c src.size(); i++) { if (!src[i].empty()) printf(\"%d: %s\\n\", i, src[i].c_str()); } } //TODO 替换string的内容 void to_replace(string \u0026s, const string \u0026target, const string \u0026replacement) { int i = 0; int find_ret; int tar_len = target.size(); while ((find_ret = s.find(target, i)) != -1) { s.replace(find_ret, tar_len, replacement); i = find_ret; } } //TODO 打印出错的信息，并退出程序 void exit_print(","date":"2022-02-12","objectID":"/posts/hugo%E5%8D%9A%E5%AE%A2%E5%9B%BE%E5%BD%A2%E5%8C%96%E5%86%99%E4%BD%9C%E5%B7%A5%E5%85%B7/:3:0","tags":["Hugo博客图形化写作工具"],"title":"Hugo博客图形化写作工具","uri":"/posts/hugo%E5%8D%9A%E5%AE%A2%E5%9B%BE%E5%BD%A2%E5%8C%96%E5%86%99%E4%BD%9C%E5%B7%A5%E5%85%B7/"},{"categories":["算法——搜索类问题"],"content":"leetcode每日一题——1020飞地的数量","date":"2022-02-12","objectID":"/posts/leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%981020%E9%A3%9E%E5%9C%B0%E7%9A%84%E6%95%B0%E9%87%8F/","tags":["leetcode每日一题——1020飞地的数量"],"title":"并查集/dfs解决——leetcode每日一题——1020飞地的数量","uri":"/posts/leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%981020%E9%A3%9E%E5%9C%B0%E7%9A%84%E6%95%B0%E9%87%8F/"},{"categories":["算法——搜索类问题"],"content":"题目描述 题目链接 ","date":"2022-02-12","objectID":"/posts/leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%981020%E9%A3%9E%E5%9C%B0%E7%9A%84%E6%95%B0%E9%87%8F/:1:0","tags":["leetcode每日一题——1020飞地的数量"],"title":"并查集/dfs解决——leetcode每日一题——1020飞地的数量","uri":"/posts/leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%981020%E9%A3%9E%E5%9C%B0%E7%9A%84%E6%95%B0%E9%87%8F/"},{"categories":["算法——搜索类问题"],"content":"题目解析 一、以边界值为对象进行搜索解决 一开始很快就想到用比较暴力的直接dfs深搜，然后就超时了。 注意此题由于以 1 是否能延申到整个边界以外来判断是否为有效的 1 所以我们需要取巧，应该以所有边界的 1 为对象先把所有能超出的 1 搜出来，然后剩余的 1 就是答案了。 二、并查集合并+是否接壤边界属性更新 创建一个并查集，用一维数组存下所有二维数组的元素，同时再增加一个一维数组用于判断是否边界接壤，每次 merge 操作的时候判断需要同时执行合并操作和是否接壤的更新。 先利用并查集 merge 所有的 1，然后再挨个判断是否接壤即可。 ","date":"2022-02-12","objectID":"/posts/leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%981020%E9%A3%9E%E5%9C%B0%E7%9A%84%E6%95%B0%E9%87%8F/:2:0","tags":["leetcode每日一题——1020飞地的数量"],"title":"并查集/dfs解决——leetcode每日一题——1020飞地的数量","uri":"/posts/leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%981020%E9%A3%9E%E5%9C%B0%E7%9A%84%E6%95%B0%E9%87%8F/"},{"categories":["算法——搜索类问题"],"content":"解题代码 dfs方法： class Solution { public: vector\u003cvector\u003cint\u003e\u003e dirs = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}}; int numEnclaves(vector\u003cvector\u003cint\u003e\u003e\u0026 grid) { this-\u003em = grid.size(); this-\u003en = grid[0].size(); this-\u003evisited = vector\u003cvector\u003cbool\u003e\u003e(m, vector\u003cbool\u003e(n, false)); for (int i = 0; i \u003c m; i++) { dfs(grid, i, 0); dfs(grid, i, n - 1); } for (int j = 1; j \u003c n - 1; j++) { dfs(grid, 0, j); dfs(grid, m - 1, j); } int enclaves = 0; for (int i = 1; i \u003c m - 1; i++) { for (int j = 1; j \u003c n - 1; j++) { if (grid[i][j] == 1 \u0026\u0026 !visited[i][j]) { enclaves++; } } } return enclaves; } void dfs(const vector\u003cvector\u003cint\u003e\u003e \u0026 grid, int row, int col) { if (row \u003c 0 || row \u003e= m || col \u003c 0 || col \u003e= n || grid[row][col] == 0 || visited[row][col]) { return; } visited[row][col] = true; for (auto \u0026 dir : dirs) { dfs(grid, row + dir[0], col + dir[1]); } } private: int m, n; vector\u003cvector\u003cbool\u003e\u003e visited; }; 并查集方法： //这个并查集写的好 class UnionFind { public: UnionFind(const vector\u003cvector\u003cint\u003e\u003e \u0026 grid) { int m = grid.size(), n = grid[0].size(); this-\u003eparent = vector\u003cint\u003e(m * n); //存储并查集的联通关系 this-\u003eonEdge = vector\u003cbool\u003e(m * n, false);//查找是否有在边界元素的关键所在 this-\u003erank = vector\u003cint\u003e(m * n); for (int i = 0; i \u003c m; i++) { //根据传过来的二维数组更新并查集，同时更新onEdge边界元素为true for (int j = 0; j \u003c n; j++) { if (grid[i][j] == 1) { int index = i * n + j; parent[index] = index; if (i == 0 || i == m - 1 || j == 0 || j == n - 1) { onEdge[index] = true; } } } } } int find(int i) { if (parent[i] != i) { parent[i] = find(parent[i]); } return parent[i]; } void uni(int x, int y) { int rootx = find(x); int rooty = find(y); if (rootx != rooty) { if (rank[rootx] \u003e rank[rooty]) {//这里时按秩优化处理 parent[rooty] = rootx; onEdge[rootx] = onEdge[rootx] | onEdge[rooty];//每次合并元素的时候同时把这一堆是否与边界接壤的关系更新 } else if (rank[rootx] \u003c rank[rooty]) { parent[rootx] = rooty; onEdge[rooty] = onEdge[rooty] | onEdge[rootx]; } else { parent[rooty] = rootx; onEdge[rootx] = onEdge[rootx] | onEdge[rooty]; rank[rootx]++; } } } bool isOnEdge(int i) { return onEdge[find(i)]; } private: vector\u003cint\u003e parent; //并查集的必备 vector\u003cbool\u003e onEdge; //判断是否接壤边界 vector\u003cint\u003e rank; //按秩 }; class Solution { public: int numEnclaves(vector\u003cvector\u003cint\u003e\u003e\u0026 grid) { int m = grid.size(), n = grid[0].size(); UnionFind uf(grid); //先把所有的1连接起来，然后再判断是否接壤边界即可 //由于循环是从上往下，从左往右，故左和上方向不需要考虑 for (int i = 0; i \u003c m; i++) { for (int j = 0; j \u003c n; j++) { if (grid[i][j] == 1) { int index = i * n + j; if (j + 1 \u003c n \u0026\u0026 grid[i][j + 1] == 1) { uf.uni(index, index + 1); } if (i + 1 \u003c m \u0026\u0026 grid[i + 1][j] == 1) { uf.uni(index, index + n); } } } } //判断这个1是否和边界接壤 int enclaves = 0; for (int i = 1; i \u003c m - 1; i++) { for (int j = 1; j \u003c n - 1; j++) { if (grid[i][j] == 1 \u0026\u0026 !uf.isOnEdge(i * n + j)) { enclaves++; } } } return enclaves; } }; ","date":"2022-02-12","objectID":"/posts/leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%981020%E9%A3%9E%E5%9C%B0%E7%9A%84%E6%95%B0%E9%87%8F/:3:0","tags":["leetcode每日一题——1020飞地的数量"],"title":"并查集/dfs解决——leetcode每日一题——1020飞地的数量","uri":"/posts/leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%981020%E9%A3%9E%E5%9C%B0%E7%9A%84%E6%95%B0%E9%87%8F/"},{"categories":["C++实战"],"content":"自动化搭建博客工具","date":"2022-02-12","objectID":"/posts/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E5%B7%A5%E5%85%B7/","tags":["自动化搭建博客工具"],"title":"自动化搭建博客工具","uri":"/posts/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E5%B7%A5%E5%85%B7/"},{"categories":["C++实战"],"content":"软件使用 使用前请下载好git工具 视频教程 ","date":"2022-02-12","objectID":"/posts/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E5%B7%A5%E5%85%B7/:1:0","tags":["自动化搭建博客工具"],"title":"自动化搭建博客工具","uri":"/posts/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E5%B7%A5%E5%85%B7/"},{"categories":["C++实战"],"content":"项目介绍 项目所在地 温馨提示：本地搭建完网站框架后，每次新建文章的写作体验较差，可以看看我的另一个 hugo 博客自动化写作工具 src目录：存放图形化项目的源代码，使用 Qt6 可直接启动 QHugoInit 项目。 bin目录：存放项目的可执行二进制文件。 exec_code.bat：用于写入代码执行脚本 hugo.exe：构建博客的基石 QHugoInit.exe：软件启动程序 log.txt：整个程序执行的日志 ","date":"2022-02-12","objectID":"/posts/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E5%B7%A5%E5%85%B7/:2:0","tags":["自动化搭建博客工具"],"title":"自动化搭建博客工具","uri":"/posts/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E5%B7%A5%E5%85%B7/"},{"categories":["C++实战"],"content":"项目关键源码 通过多线程防止下载步骤把画面给阻塞 //TODO 简单封装一个用于多线程通信的类 class run_thread:public QThread{ public: run_thread() = delete; run_thread(const std::function\u003cvoid()\u003e\u0026Runnable,QObject* parent = nullptr):m_task(nullptr){ m_task = Runnable; } void run()override{ if(m_task!=nullptr); m_task(); } private: std::function\u003cvoid()\u003em_task; }; 通过文件io控制命令行的代码执行来执行对应的每一步 void MainWindow::on_right_Btn_clicked() { auto path = ui-\u003einput-\u003etext(); if(!QDir(path).exists()||path.isEmpty()){ QMessageBox::warning(nullptr,\"提示\",\"文件夹路径不存在\"); return; } ui-\u003ew2-\u003esetVisible(false); ui-\u003ew4-\u003esetVisible(false); ui-\u003ew3-\u003esetVisible(true); ui-\u003el1-\u003esetText(\"一切即将准备就绪\"); ui-\u003el2-\u003esetText(\"正在初始化您的hugo网站\"); ui-\u003el3-\u003esetOpenExternalLinks(true); ui-\u003el3-\u003esetText(R\"(\u003chtml\u003e \u003cstyle\u003e a { color:#3281b8; } \u003c/style\u003e\u003chead/\u003e\u003cbody\u003e\u003cp\u003e这可能会耗费几分钟，请不要强制关闭应用程序\u003cbr/\u003e\u003cbr/\u003e闲得无聊？\u003ca href=\"https://github.com/ACking-you/AutoHugoSetup\"\u003e给个star\u003c/a\u003e\u003c/p\u003e\u003c/body\u003e\u003c/html\u003e)\"); QProcess qp; std::ofstream writer; m_Path = path; auto std_str = m_Path.toStdString(); //first step writer.open(\"./exec_code.bat\"); if(!writer.is_open()){ QMessageBox::warning(nullptr,\"提示\",\"第一次写入文件打开失败\"); writer.close(); QCoreApplication::exit(1); } ui-\u003einfo_text-\u003esetText(\"正在初始化 hugo 博客\"); std::replace(std_str.begin(),std_str.end(),'/','\\\\'); //这里注意：cmd32命令只支持反斜杠！ writer\u003c\u003cR\"(chcp 65001)\"\u003c\u003c'\\n'; //设置编码为utf-8 writer\u003c\u003cR\"(copy .\\hugo.exe )\"\u003c\u003cstd_str\u003c\u003c'\\n'; //copy一份hugo.exe到目标目录下 writer\u003c\u003c\"cd /d\"\u003c\u003cstd_str\u003c\u003c'\\n'; //切换到创建目录，这里/d代表直接一步到位的切换目录 writer\u003c\u003cR\"(.\\hugo new site myBlog)\"\u003c\u003c'\\n'; //初始化hugo命令 writer.close(); qp.startCommand(R\"(.\\exec_code.bat)\"); if(qp.waitForFinished()){ QString str = qp.readAll(); m_logWriter\u003c\u003c\"-----1st step-----\\n\\r\"\u003c\u003cstr.toStdString()\u003c\u003c'\\n'; ui-\u003einfo_text-\u003esetText(\" hugo 博客初始化完成\"); } //second step：执行此步之前先判断git是否可用，此步执行时间最久，不要让它卡死主线程，故需要用到多线程技术 qp.startCommand(\"git\"); if(!qp.waitForFinished()){ QMessageBox::warning(nullptr,\"提示\",\"未安装git工具或未设置到环境变量\"); QCoreApplication::exit(1); } writer.open(\"./exec_code.bat\"); if(!writer.is_open()){ QMessageBox::warning(nullptr,\"提示\",\"第二次写入文件打开失败\"); writer.close(); QCoreApplication::exit(1); } ui-\u003einfo_text-\u003esetText(\"正在下载 FeelIt 主题\"); std::filesystem::path blog_path = std_str; blog_path /= \"myBlog\"; m_Path = blog_path.string().c_str(); writer\u003c\u003c\"cd /d\"\u003c\u003cblog_path\u003c\u003c\"\\\\themes\"\u003c\u003c'\\n'; //cd到themes文件夹目录下 writer\u003c\u003c\"git clone https://gitee.com/acking-you/FeelIt.git\"\u003c\u003c'\\n';//开始通过git下载主题包 writer.close(); QThread* sub_thread = new run_thread([\u0026]{ //最耗时间的工作别去干扰主线程的正常运行，否则主线程可能看起来会陷入瘫痪 QProcess tqp; //信号槽机制，主线程等待子线程完成任务发送信号后再执行最后的步骤，因为这个过程肯定是要同步进行，故需要信号槽来等待 connect(\u0026tqp,\u0026QProcess::finished,[\u0026](int exitCode, QProcess::ExitStatus exitStatus){ //step third std::ofstream writer; QProcess qp; writer.open(\"./exec_code.bat\"); if(!writer.is_open()){ QMessageBox::warning(nullptr,\"提示\",\"第三次写入文件打开失败\"); writer.close(); QCoreApplication::exit(1); } ui-\u003einfo_text-\u003esetText(\"配置本地主题中...\"); writer\u003c\u003c\"cd /d\"\u003c\u003cm_Path.toStdString()\u003c\u003c'\\n'; //cd到blog_path writer\u003c\u003cR\"(del .\\config.toml)\"\u003c\u003c'\\n'; //删除原本的config文件 writer\u003c\u003cR\"(move .\\themes\\FeelIt\\config.toml .\\)\"\u003c\u003c'\\n'; //将我的配置文件放到顶级目录去 writer\u003c\u003cR\"(move .\\themes\\FeelIt\\exampleSite\\static\\* .\\static\\)\"\u003c\u003c'\\n';//移动static图片资源 writer\u003c\u003cR\"(move ..\\hugo.exe .\\)\"\u003c\u003c'\\n';//将之前的hugo.exe移动到真正的博客目录下 writer\u003c\u003cR\"(mkdir .\\content\\posts)\"\u003c\u003c'\\n'; //创建用于写文章的目录 writer.close(); qp.startCommand(R\"(.\\exec_code.bat)\"); if(qp.waitForFinished(120000)){ ui-\u003einfo_text-\u003esetText(\"配置完成 \"); ending(); m_logWriter\u003c\u003c\"-----3rd step-----\\n\\r\"\u003c\u003cqp.readAll().toStdString(); } }); tqp.startCommand(R\"(.\\exec_code.bat)\"); if(!tqp.waitForFinished(120000)){ QMessageBox::warning(nullptr,\"提示\",\"下载主题响应超时\"); QCoreApplication::exit(1); }else{ m_logWriter\u003c\u003c\"-----2nd step-----\\n\\r\"\u003c\u003ctqp.readAll().toStdString(); } }); sub_thread-\u003estart(); } ","date":"2022-02-12","objectID":"/posts/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E5%B7%A5%E5%85%B7/:3:0","tags":["自动化搭建博客工具"],"title":"自动化搭建博客工具","uri":"/posts/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E5%B7%A5%E5%85%B7/"},{"categories":["JavaWeb笔记"],"content":"数据库基础","date":"2022-02-09","objectID":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/","tags":["数据库基础"],"title":"数据库基础","uri":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/"},{"categories":["JavaWeb笔记"],"content":"数据库基础 数据库是学习JavaWeb的一个前置，只有了解了数据库的操作和使用，我们才能更好地组织和管理网站应用产生的数据。 ","date":"2022-02-09","objectID":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/:0:0","tags":["数据库基础"],"title":"数据库基础","uri":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/"},{"categories":["JavaWeb笔记"],"content":"什么是数据库 数据库是数据管理的有效技术，是由一批数据构成的有序集合，这些数据被存放在结构化的数据表里。数据表之间相互关联，反映客观事物间的本质联系。数据库能有效地帮助一个组织或企业科学地管理各类信息资源。简而言之，我们的数据可以交给数据库来帮助我们进行管理，同时数据库能够为我们提供高效的访问性能。 在JavaSE学习阶段中，我们学习了如何使用文件I/O来将数据保存到本地，这样就可以将一个数据持久地存储在本地，即使程序重新打开，我们也能加载回上一次的数据，但是当我们的数据变得非常多的时候，这样的方式就显得不太方便了。同时我们如果需要查找众多数据的中的某一个，就只能加载到内存再进行查找，这样显然是很难受的！ 而数据库就是专门做这事的，我们可以快速查找想要的数据，便捷地插入、修改和删除数据，并且数据库不仅能做这些事，还能提供更多便于管理数据和操作数据的功能！ ","date":"2022-02-09","objectID":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/:1:0","tags":["数据库基础"],"title":"数据库基础","uri":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/"},{"categories":["JavaWeb笔记"],"content":"常见的数据库 常见的数据库有很多种，包括但不限于： MySQL - 免费，用的最多的，开源数据库，适用于中小型 Microsoft SQL Server - 收钱的，但是提供技术支持，适用于Windows Server Oracle - 收钱的，大型数据库系统 而我们要学习的是MySQL数据，其实无论学习哪种数据库，SQL语句大部分都是通用的，只有少许语法是不通用的，因此我们只需要学习一种数据库其他的也就差不多都会了。 ","date":"2022-02-09","objectID":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/:1:1","tags":["数据库基础"],"title":"数据库基础","uri":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/"},{"categories":["JavaWeb笔记"],"content":"数据模型 数据模型与现实世界中的模型一样，是对现实世界数据特征的一种抽象。实际上，我们之前学习的类就是对现实世界数据的一种抽象，比如一个学生的特征包括姓名，年龄，年级，学号，专业等，这些特征也称为实体的一种属性，属性具有以下特点： 属性不可再分 一个实体的属性可以有很多个 用于唯一区分不同实体的的属性，称为Key，比如每个同学的学号都是不一样的 属性取值可以有一定的约束，比如性别只能是男或是女 实体或是属性之间可以具有一定的联系，比如一个老师可以教很多个学生，而学生相对于老师就是被教授的关系；又比如每个同学都有一个学号与其唯一对应，因此学号和学生之间也有一种联系。而像一个老师教多个学生的联系就是一种一对多的联系（1:n），而学号唯一对应，就是一种一对一的联系（1:1）；每一个老师不仅可以教多个学生，每一个学生也可以有多个教师，这就是一种多对多的联系（n:m） MySQL就是一种关系型数据库，通过使用关系型数据库，我们就可以很好地存储这样带有一定联系的数据。 通过构建一个ER图，我们就能很好地理清不同数据模型之间的关系和特点。 ","date":"2022-02-09","objectID":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/:1:2","tags":["数据库基础"],"title":"数据库基础","uri":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/"},{"categories":["JavaWeb笔记"],"content":"数据库的创建 既然了解了属性和联系，那么我们就来尝试创建一个数据库，并在数据库中添加用于存放数据的表，每一张表都代表一种实体的数据。首先我们要明确，我们需要创建什么样子的表： 学生表：用于存放所有学生的数据，学生（学号，姓名，性别） 教师表：用于存放所有教师的数据，教师（教师号，姓名） 授课表：用于存放教师与学生的授课信息，授课（学号，教师号） 其中，标注下划线的属性，作为Key，用于区别于其他实体数据的唯一标记。 为了理解起来更加轻松，我们从图形界面操作再讲到SQL语句，请不要着急。我们现在通过Navicat或idea自带的数据库客户端来创建一个数据库和上述三个表。 ","date":"2022-02-09","objectID":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/:2:0","tags":["数据库基础"],"title":"数据库基础","uri":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/"},{"categories":["JavaWeb笔记"],"content":"数据库的规范化 要去设计存放一个实体的表，我们就需要了解数据库的关系规范化，尽可能减少“不好”的关系存在，如何设计一个优良的关系模型是最关键的内容！简而言之，我们要学习一下每一个表该如何去设计。 ","date":"2022-02-09","objectID":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/:3:0","tags":["数据库基础"],"title":"数据库基础","uri":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/"},{"categories":["JavaWeb笔记"],"content":"第一范式（1NF） 第一范式是指数据库的每一列都是不可分割的基本数据项，而下面这样的就存在可分割的情况： 学生（姓名，电话号码） 电话号码实际上包括了家用座机电话和移动电话，因此它可以被拆分为： 学生（姓名，座机号码，手机号码） 满足第一范式是关系型数据库最基本的要求！ ","date":"2022-02-09","objectID":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/:3:1","tags":["数据库基础"],"title":"数据库基础","uri":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/"},{"categories":["JavaWeb笔记"],"content":"第二范式（2NF） 第二范式要求表中必须存在主键，且其他的属性必须完全依赖于主键，比如： 学生（学号，姓名，性别） 学号是每个学生的唯一标识，每个学生都有着不同的学号，因此此表中存在一个主键，并且每个学生的所有属性都依赖于学号，学号发生改变就代表学生发生改变，姓名和性别都会因此发生改变，所有此表满足第二范式。 ","date":"2022-02-09","objectID":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/:3:2","tags":["数据库基础"],"title":"数据库基础","uri":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/"},{"categories":["JavaWeb笔记"],"content":"第三范式（3NF） 在满足第二范式的情况下，所有的属性都不传递依赖于主键，满足第三范式。 学生借书情况（借阅编号，学生学号，书籍编号，书籍名称，书籍作者） 实际上书籍编号依赖于借阅编号，而书籍名称和书籍作者依赖于书籍编号，因此存在传递依赖的情况，我们可以将书籍信息进行单独拆分为另一张表： 学生借书情况（借阅编号，学生学号，书籍编号） 书籍（书籍编号，书籍名称，书籍作者） 这样就消除了传递依赖，从而满足第三范式。 ","date":"2022-02-09","objectID":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/:3:3","tags":["数据库基础"],"title":"数据库基础","uri":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/"},{"categories":["JavaWeb笔记"],"content":"BCNF BCNF作为第三范式的补充，假设仓库管理关系表为StorehouseManage(仓库ID, 存储物品ID, 管理员ID, 数量)，且有一个管理员只在一个仓库工作；一个仓库可以存储多种物品。这个数据库表中存在如下决定关系： (仓库ID, 存储物品ID) →(管理员ID, 数量) (管理员ID, 存储物品ID) → (仓库ID, 数量) 所以，(仓库ID, 存储物品ID)和(管理员ID, 存储物品ID)都是StorehouseManage的候选关键字，表中的唯一非关键字段为数量，它是符合第三范式的。但是，由于存在如下决定关系： (仓库ID) → (管理员ID) (管理员ID) → (仓库ID) 即存在关键字段决定关键字段的情况，如果修改管理员ID，那么就必须逐一进行修改，所以其不符合BCNF范式。 ","date":"2022-02-09","objectID":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/:3:4","tags":["数据库基础"],"title":"数据库基础","uri":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/"},{"categories":["JavaWeb笔记"],"content":"认识SQL语句 结构化查询语言（Structured Query Language）简称SQL，这是一种特殊的语言，它专门用于数据库的操作。每一种数据库都支持SQL，但是他们之间会存在一些细微的差异，因此不同的数据库都存在自己的“方言”。 SQL语句不区分大小写（关键字推荐使用大写），它支持多行，并且需要使用;进行结尾！ SQL也支持注释，通过使用--或是#来编写注释内容，也可以使用/*来进行多行注释。 我们要学习的就是以下四种类型的SQL语言： 数据查询语言（Data Query Language, DQL）基本结构是由SELECT子句，FROM子句，WHERE子句组成的查询块。 数据操纵语言（Data Manipulation Language, DML）是SQL语言中，负责对数据库对象运行数据访问工作的指令集，以INSERT、UPDATE、DELETE三种指令为核心，分别代表插入、更新与删除，是开发以数据为中心的应用程序必定会使用到的指令。 数据库定义语言DDL(Data Definition Language)，是用于描述数据库中要存储的现实世界实体的语言。 DCL（Data Control Language）是数据库控制语言。是用来设置或更改数据库用户或角色权限的语句，包括（grant,deny,revoke等）语句。在默认状态下，只有sysadmin,dbcreator,db_owner或db_securityadmin等人员才有权力执行DCL。 我们平时所说的CRUD其实就是增删改查（Create/Retrieve/Update/Delete） ","date":"2022-02-09","objectID":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/:4:0","tags":["数据库基础"],"title":"数据库基础","uri":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/"},{"categories":["JavaWeb笔记"],"content":"数据库定义语言（DDL） ","date":"2022-02-09","objectID":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/:5:0","tags":["数据库基础"],"title":"数据库基础","uri":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/"},{"categories":["JavaWeb笔记"],"content":"数据库操作 我们可以通过create database来创建一个数据库： createdatabase数据库名为了能够支持中文，我们在创建时可以设定编码格式： CREATEDATABASEIFNOTEXISTS数据库名DEFAULTCHARSETutf8COLLATEutf8_general_ci;如果我们创建错误了，我们可以将此数据库删除，通过使用drop database来删除一个数据库： dropdatabase数据库名","date":"2022-02-09","objectID":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/:5:1","tags":["数据库基础"],"title":"数据库基础","uri":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/"},{"categories":["JavaWeb笔记"],"content":"创建表 数据库创建完成后，我们一般通过create table语句来创建一张表： createtable表名(列名数据类型[列级约束条件],列名数据类型[列级约束条件],...[,表级约束条件])","date":"2022-02-09","objectID":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/:5:2","tags":["数据库基础"],"title":"数据库基础","uri":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/"},{"categories":["JavaWeb笔记"],"content":"SQL数据类型 以下的数据类型用于字符串存储： char(n)可以存储任意字符串，但是是固定长度为n，如果插入的长度小于定义长度时，则用空格填充。 varchar(n)也可以存储任意数量字符串，长度不固定，但不能超过n，不会用空格填充。 以下数据类型用于存储数字： smallint用于存储小的整数，范围在 (-32768，32767) int用于存储一般的整数，范围在 (-2147483648，2147483647) bigint用于存储大型整数，范围在 (-9,223,372,036,854,775,808，9,223,372,036,854,775,807) float用于存储单精度小数 double用于存储双精度的小数 以下数据类型用于存储时间： date存储日期 time存储时间 year存储年份 datetime用于混合存储日期+时间 ","date":"2022-02-09","objectID":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/:5:3","tags":["数据库基础"],"title":"数据库基础","uri":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/"},{"categories":["JavaWeb笔记"],"content":"列级约束条件 列级约束有六种：主键Primary key、外键foreign key 、唯一 unique、检查 check （MySQL不支持）、默认default 、非空/空值 not null/ null ","date":"2022-02-09","objectID":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/:5:4","tags":["数据库基础"],"title":"数据库基础","uri":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/"},{"categories":["JavaWeb笔记"],"content":"表级约束条件 表级约束有四种：主键、外键、唯一、检查 现在我们通过SQL语句来创建我们之前提到的三张表。 [CONSTRAINT\u003c外键名\u003e]FOREIGNKEY字段名[，字段名2，…]REFERENCES\u003c主表名\u003e主键列1[，主键列2，…]","date":"2022-02-09","objectID":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/:5:5","tags":["数据库基础"],"title":"数据库基础","uri":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/"},{"categories":["JavaWeb笔记"],"content":"修改表 如果我们想修改表结构，我们可以通过alter table来进行修改： ALTERTABLE表名[ADD新列名数据类型[列级约束条件]][DROPCOLUMN列名[restrict|cascade]][ALTERCOLUMN列名新数据类型]我们可以通过ADD来添加一个新的列，通过DROP来删除一个列，不过我们可以添加restrict或cascade，默认是restrict，表示如果此列作为其他表的约束或视图引用到此列时，将无法删除，而cascade会强制连带引用此列的约束、视图一起删除。还可以通过ALTER来修改此列的属性。 ","date":"2022-02-09","objectID":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/:5:6","tags":["数据库基础"],"title":"数据库基础","uri":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/"},{"categories":["JavaWeb笔记"],"content":"删除表 我们可以通过drop table来删除一个表： DROPTABLE表名[restrict|cascade]其中restrict和cascade上面的效果一致。 ","date":"2022-02-09","objectID":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/:5:7","tags":["数据库基础"],"title":"数据库基础","uri":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/"},{"categories":["JavaWeb笔记"],"content":"数据库操纵语言（DML） 前面我们已经学习了如何使用SQL语句来创建、修改、删除数据库以及表，而如何向数据库中插入、删除、更新数据，将是本版块讨论的重点。 ","date":"2022-02-09","objectID":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/:6:0","tags":["数据库基础"],"title":"数据库基础","uri":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/"},{"categories":["JavaWeb笔记"],"content":"插入数据 通过使用insert into语句来向数据库中插入一条数据（一条记录）： INSERTINTO表名VALUES(值1,值2,值3)如果插入的数据与列一一对应，那么可以省略列名，但是如果希望向指定列上插入数据，就需要给出列名： INSERTINTO表名(列名1,列名2)VALUES(值1,值2)我们也可以一次性向数据库中插入多条数据： INSERTINTO表名(列名1,列名2)VALUES(值1,值2),(值1,值2),(值1,值2)我们来试试看向我们刚刚创建的表中添加三条数据。 ","date":"2022-02-09","objectID":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/:6:1","tags":["数据库基础"],"title":"数据库基础","uri":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/"},{"categories":["JavaWeb笔记"],"content":"修改数据 我们可以通过update语句来更新表中的数据： UPDATE表名SET列名=值,...WHERE条件注意，SQL语句中的等于判断是= **警告：**如果忘记添加WHERE字句来限定条件，将使得整个表中此列的所有数据都被修改！ ","date":"2022-02-09","objectID":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/:6:2","tags":["数据库基础"],"title":"数据库基础","uri":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/"},{"categories":["JavaWeb笔记"],"content":"删除数据 我们可以通过使用delete来删除表中的数据： DELETEFROM表名通过这种方式，将删除表中全部数据，我们也可以使用where来添加条件，只删除指定的数据： DELETEFROM表名WHERE条件 ","date":"2022-02-09","objectID":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/:6:3","tags":["数据库基础"],"title":"数据库基础","uri":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/"},{"categories":["JavaWeb笔记"],"content":"数据库查询语言（DQL） 数据库的查询是我们整个数据库学习中的重点内容，面对数据库中庞大的数据，该如何去寻找我们想要的数据，就是我们主要讨论的问题。 ","date":"2022-02-09","objectID":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/:7:0","tags":["数据库基础"],"title":"数据库基础","uri":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/"},{"categories":["JavaWeb笔记"],"content":"单表查询 单表查询是最简单的一种查询，我们只需要在一张表中去查找数据即可，通过使用select语句来进行单表查询： -- 指定查询某一列数据 SELECT列名[,列名]FROM表名-- 会以别名显示此列 SELECT列名别名FROM表名-- 查询所有的列数据 SELECT*FROM表名-- 只查询不重复的值 SELECTDISTINCT列名FROM表名我们也可以添加where字句来限定查询目标： SELECT*FROM表名WHERE条件","date":"2022-02-09","objectID":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/:7:1","tags":["数据库基础"],"title":"数据库基础","uri":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/"},{"categories":["JavaWeb笔记"],"content":"常用查询条件 一般的比较运算符，包括=、\u003e、\u003c、\u003e=、\u003c=、!=等。 是否在集合中：in、not in 字符模糊匹配：like，not like 多重条件连接查询：and、or、not 我们来尝试使用一下上面这几种条件。 ","date":"2022-02-09","objectID":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/:7:2","tags":["数据库基础"],"title":"数据库基础","uri":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/"},{"categories":["JavaWeb笔记"],"content":"排序查询 我们可以通过order by来将查询结果进行排序： SELECT*FROM表名WHERE条件ORDERBY列名ASC|DESC使用ASC表示升序排序，使用DESC表示降序排序，默认为升序。 我们也可以可以同时添加多个排序： SELECT*FROM表名WHERE条件ORDERBY列名1ASC|DESC,列名2ASC|DESC这样会先按照列名1进行排序，每组列名1相同的数据再按照列名2排序。 ","date":"2022-02-09","objectID":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/:7:3","tags":["数据库基础"],"title":"数据库基础","uri":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/"},{"categories":["JavaWeb笔记"],"content":"聚集函数 聚集函数一般用作统计，包括： count([distinct]*)统计所有的行数（distinct表示去重再统计，下同） count([distinct]列名)统计某列的值总和 sum([distinct]列名)求一列的和（注意必须是数字类型的） avg([distinct]列名)求一列的平均值（注意必须是数字类型） max([distinct]列名)求一列的最大值 min([distinct]列名)求一列的最小值 一般聚集函数是这样使用的： SELECTcount(distinct列名)FROM表名WHERE条件","date":"2022-02-09","objectID":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/:7:4","tags":["数据库基础"],"title":"数据库基础","uri":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/"},{"categories":["JavaWeb笔记"],"content":"分组和分页查询 通过使用group by来对查询结果进行分组，它需要结合聚合函数一起使用： SELECTsum(*)FROM表名WHERE条件GROUPBY列名我们还可以添加having来限制分组条件： SELECTsum(*)FROM表名WHERE条件GROUPBY列名HAVING约束条件我们可以通过limit来限制查询的数量，只取前n个结果： SELECT*FROM表名LIMIT数量我们也可以进行分页： SELECT*FROM表名LIMIT起始位置,数量","date":"2022-02-09","objectID":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/:7:5","tags":["数据库基础"],"title":"数据库基础","uri":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/"},{"categories":["JavaWeb笔记"],"content":"多表查询 多表查询是同时查询的两个或两个以上的表，多表查询会提通过连接转换为单表查询。 SELECT*FROM表1,表2直接这样查询会得到两张表的笛卡尔积，也就是每一项数据和另一张表的每一项数据都结合一次，会产生庞大的数据。 SELECT*FROM表1,表2WHERE条件这样，只会从笛卡尔积的结果中得到满足条件的数据。 **注意：**如果两个表中都带有此属性吗，需要添加表名前缀来指明是哪一个表的数据。 ","date":"2022-02-09","objectID":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/:7:6","tags":["数据库基础"],"title":"数据库基础","uri":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/"},{"categories":["JavaWeb笔记"],"content":"自身连接查询 自身连接，就是将表本身和表进行笛卡尔积计算，得到结果，但是由于表名相同，因此要先起一个别名： SELECT*FROM表名别名1,表名别名2其实自身连接查询和前面的是一样的，只是连接对象变成自己和自己了。 ","date":"2022-02-09","objectID":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/:7:7","tags":["数据库基础"],"title":"数据库基础","uri":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/"},{"categories":["JavaWeb笔记"],"content":"外连接查询 外连接就是专门用于联合查询情景的，比如现在有一个存储所有用户的表，还有一张用户详细信息的表，我希望将这两张表结合到一起来查看完整的数据，我们就可以通过使用外连接来进行查询，外连接有三种方式： 通过使用inner join进行内连接，只会返回两个表满足条件的交集部分： 通过使用left join进行左连接，不仅会返回两个表满足条件的交集部分，也会返回左边表中的全部数据，而在右表中缺失的数据会使用null来代替（右连接right join同理，只是反过来而已，这里就不再介绍了）： ","date":"2022-02-09","objectID":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/:7:8","tags":["数据库基础"],"title":"数据库基础","uri":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/"},{"categories":["JavaWeb笔记"],"content":"嵌套查询 我们可以将查询的结果作为另一个查询的条件，比如： SELECT*FROM表名WHERE列名=(SELECT列名FROM表名WHERE条件)我们来再次尝试编写一下在最开始我们查找某教师所有学生的SQL语句。 ","date":"2022-02-09","objectID":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/:7:9","tags":["数据库基础"],"title":"数据库基础","uri":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/"},{"categories":["JavaWeb笔记"],"content":"数据库控制语言（DCL） 庞大的数据库不可能由一个人来管理，我们需要更多的用户来一起管理整个数据库。 ","date":"2022-02-09","objectID":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/:8:0","tags":["数据库基础"],"title":"数据库基础","uri":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/"},{"categories":["JavaWeb笔记"],"content":"创建用户 我们可以通过create user来创建用户： CREATEUSER用户名identifiedby密码;也可以不带密码： CREATEUSER用户名;我们可以通过@来限制用户登录的登录IP地址，%表示匹配所有的IP地址，默认使用的就是任意IP地址。 ","date":"2022-02-09","objectID":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/:8:1","tags":["数据库基础"],"title":"数据库基础","uri":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/"},{"categories":["JavaWeb笔记"],"content":"登陆用户 首先需要添加一个环境变量，然后我们通过cmd去登陆mysql： login-u用户名-p输入密码后即可登陆此用户，我们输入以下命令来看看能否访问所有数据库： showdatabases;我们发现，虽然此用户能够成功登录，但是并不能查看完整的数据库列表，这是因为此用户还没有权限！ ","date":"2022-02-09","objectID":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/:8:2","tags":["数据库基础"],"title":"数据库基础","uri":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/"},{"categories":["JavaWeb笔记"],"content":"用户授权 我们可以通过使用grant来为一个数据库用户进行授权： grantall|权限1,权限2...(列1,...)on数据库.表to用户[withgrantoption]其中all代表授予所有权限，当数据库和表为*，代表为所有的数据库和表都授权。如果在最后添加了with grant option，那么被授权的用户还能将已获得的授权继续授权给其他用户。 我们可以使用revoke来收回一个权限： revokeall|权限1,权限2...(列1,...)on数据库.表from用户 ","date":"2022-02-09","objectID":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/:8:3","tags":["数据库基础"],"title":"数据库基础","uri":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/"},{"categories":["JavaWeb笔记"],"content":"视图 视图本质就是一个查询的结果，不过我们每次都可以通过打开视图来按照我们想要的样子查看数据。既然视图本质就是一个查询的结果，那么它本身就是一个虚表，并不是真实存在的，数据实际上还是存放在原来的表中。 我们可以通过create view来创建视图; CREATEVIEW视图名称(列名)as子查询语句[WITHCHECKOPTION];WITH CHECK OPTION是指当创建后，如果更新视图中的数据，是否要满足子查询中的条件表达式，不满足将无法插入，创建后，我们就可以使用select语句来直接查询视图上的数据了，因此，还能在视图的基础上，导出其他的视图。 若视图是由两个以上基本表导出的，则此视图不允许更新。 若视图的字段来自字段表达式或常数，则不允许对此视图执行INSERT和UPDATE操作，但允许执行DELETE操作。 若视图的字段来自集函数，则此视图不允许更新。 若视图定义中含有GROUP BY子句，则此视图不允许更新。 若视图定义中含有DISTINCT短语，则此视图不允许更新。 若视图定义中有嵌套查询，并且内层查询的FROM子句中涉及的表也是导出该视图的基本表，则此视图不允许更新。例如将成绩在平均成绩之上的元组定义成一个视图GOOD_SC： CREATE VIEW GOOD_SC AS SELECT Sno, Cno, Grade FROM SC WHERE Grade \u003e (SELECT AVG(Grade) FROM SC); 导出视图GOOD_SC的基本表是SC，内层查询中涉及的表也是SC，所以视图GOOD_SC是不允许更新的。 一个不允许更新的视图上定义的视图也不允许更新 通过drop来删除一个视图： dropviewapptest ","date":"2022-02-09","objectID":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/:9:0","tags":["数据库基础"],"title":"数据库基础","uri":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/"},{"categories":["JavaWeb笔记"],"content":"索引 在数据量变得非常庞大时，通过创建索引，能够大大提高我们的查询效率，就像Hash表一样，它能够快速地定位元素存放的位置，我们可以通过下面的命令创建索引： -- 创建索引 CREATEINDEX索引名称ON表名(列名)-- 查看表中的索引 showINDEXFROMstudent我们也可以通过下面的命令删除一个索引： dropindex索引名称on表名虽然添加索引后会使得查询效率更高，但是我们不能过度使用索引，索引为我们带来高速查询效率的同时，也会在数据更新时产生额外建立索引的开销，同时也会占用磁盘资源。 ","date":"2022-02-09","objectID":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/:10:0","tags":["数据库基础"],"title":"数据库基础","uri":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/"},{"categories":["JavaWeb笔记"],"content":"触发器 触发器就像其名字一样，在某种条件下会自动触发，在select/update/delete时，会自动执行我们预先设定的内容，触发器通常用于检查内容的安全性，相比直接添加约束，触发器显得更加灵活。 触发器所依附的表称为基本表，当触发器表上发生select/update/delete等操作时，会自动生成两个临时的表（new表和old表，只能由触发器使用） 比如在insert操作时，新的内容会被插入到new表中；在delete操作时，旧的内容会被移到old表中，我们仍可在old表中拿到被删除的数据；在update操作时，旧的内容会被移到old表中，新的内容会出现在new表中。 CREATETRIGGER触发器名称[BEFORE|AFTER][INSERT|UPDATE|DELETE]ON表名/视图名FOREACHROWDELETEFROMstudentWHEREstudent.sno=new.snoFOR EACH ROW表示针对每一行都会生效，无论哪行进行指定操作都会执行触发器！ 通过下面的命令来查看触发器： SHOWTRIGGERS如果不需要，我们就可以删除此触发器： DROPTRIGGER触发器名称 ","date":"2022-02-09","objectID":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/:11:0","tags":["数据库基础"],"title":"数据库基础","uri":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/"},{"categories":["JavaWeb笔记"],"content":"事务 当我们要进行的操作非常多时，比如要依次删除很多个表的数据，我们就需要执行大量的SQL语句来完成，这些数据库操作语句就可以构成一个事务！只有Innodb引擎支持事务，我们可以这样来查看支持的引擎： SHOWENGINES;MySQL默认采用的是Innodb引擎，我们也可以去修改为其他的引擎。 事务具有以下特性： **原子性：**一个事务（transaction）中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。 **一致性：**在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设规则，这包含资料的精确度、串联性以及后续数据库可以自发性地完成预定的工作。 **隔离性：**数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括读未提交（Read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（Serializable）。 **持久性：**事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。 我们通过以下例子来探究以下事务： begin;#开始事务...rollback;#回滚事务savepoint回滚点;#添加回滚点rollbackto回滚点;#回滚到指定回滚点...commit;#提交事务-- 一旦提交，就无法再进行回滚了！ ","date":"2022-02-09","objectID":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/:12:0","tags":["数据库基础"],"title":"数据库基础","uri":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/"},{"categories":["JavaWeb笔记"],"content":"选学内容 函数和存储过程并没有包含在我们的教程当中，但是这并不代表它们就不重要，通过学习它们能够让你的数据库管理能力更上一层楼，它们能够捆绑一组SQL语句运行，并且可以反复使用，大大提高工作效率。 ","date":"2022-02-09","objectID":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/:13:0","tags":["数据库基础"],"title":"数据库基础","uri":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/"},{"categories":["算法——最短路问题"],"content":"BellmanFord和SPFA算法详解","date":"2022-02-07","objectID":"/posts/bellmanford%E5%92%8Cspfa%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3/","tags":["BellmanFord和SPFA算法详解"],"title":"BellmanFord和SPFA算法详解","uri":"/posts/bellmanford%E5%92%8Cspfa%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3/"},{"categories":["算法——最短路问题"],"content":"*关于Bellman ford和SPFA算法的详解 我是白嫖的leetcode会员，然后看了关于图单源最短路径的讲解，讲解的非常好(虽然没代码演示，但基本上一看思路就有了)。 为了让大家也白嫖到视频资源，我把视频上传到了YouTube(国内会有版权问题，发不出) 大家有能力上油管的建议去看看，否则这代码肯定是看不懂的。。。 视频链接： Bellman ford算法详解(两种方式及其优化) 由Bellman ford算法的缺陷引出SPFA算法 适用性分析(先看视频) Blellman ford算法 DP方法：以 dp[i][j] 表示选择最多 i 条边，从起点到 j 的最短距离。每次的更新依赖于上一行 dp[i-1][j] 的答案，故可滚动数组优化为一维数组。时间复杂度O(N^3) 多次遍历边的更新方法：提前记录好哪两个结点有边，每进行一次整个边的遍历，就相当于完成了最多选择一条边到达目的地的最短距离的效果。平均时间复杂度 O(N*V)（V是边的个数，极端情况下会掉到 O(N*N*V)的复杂度，因为最多是可以进行 N-1 次循环的) 很明显无论是哪种方式实现，最终都是依赖选择多少条边的结果，所以该算法适用于指定最多经过k条边的最短路径题目。 正好有道例题适合他 K 站中转内最便宜的航班 SPFA算法 这个算法只是Bellman ford算法的再优化，使得每次选择的边的关系达到最优，大大减少了边的遍历次数,时间复杂度较为稳定(相对Bellmanford稳定很多)的在 O(N*V)。 这个原本也是基于Bellmanford算法优化的，除了无法表示最多经过k条边，其余效率比之前的算法更快，所以适用于求存在负权值的单源最短路径问题，而无法精确为最多经过了多少条边。 以题代讲 ","date":"2022-02-07","objectID":"/posts/bellmanford%E5%92%8Cspfa%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3/:0:0","tags":["BellmanFord和SPFA算法详解"],"title":"BellmanFord和SPFA算法详解","uri":"/posts/bellmanford%E5%92%8Cspfa%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3/"},{"categories":["算法——最短路问题"],"content":"蓝桥杯–最短路 ","date":"2022-02-07","objectID":"/posts/bellmanford%E5%92%8Cspfa%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3/:1:0","tags":["BellmanFord和SPFA算法详解"],"title":"BellmanFord和SPFA算法详解","uri":"/posts/bellmanford%E5%92%8Cspfa%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3/"},{"categories":["算法——最短路问题"],"content":"Bellman ford的动态规划解决(超时,过三个) #include\u003cbits/stdc++.h\u003eusing namespace std; #define LL long long int n,m; vector\u003cint\u003edp(20001,INT_MAX/2); map\u003cint,map\u003cint,int\u003e \u003e MAP; LL read() { LL res = 0; bool f = 1; char c; //先耗掉一个getchar来进行判断符号 c = getchar(); if(c == '-')f = 0; else res+= (c-'0'); while (isdigit(c = getchar())) { res = (LL)res * 10 + (c-'0'); } if (f) return res; return res*-1; } int main(){ n = read(); m = read(); for(int i=0;i\u003cm;i++){ int a =read(),c = read(),len = read(); MAP[a][c] = len; if(a == 1) dp[c] = len; } dp[1] = 0; vector\u003cint\u003epre = dp; //外层循环经过最多i条路到达该结点的最短距离，最多经过n-1条 //里面几层都是用于更新没一行的数据 for(int i=2;i\u003c=n-1;i++){ for(int j=2;j\u003c=n;j++){ for(int k = 1;k\u003c=n;k++){ int t = MAP[k][j]; if(t) dp[j] = min(dp[j],pre[k]+t); } } pre = dp; } for(int i=2;i\u003c=n;i++){ cout\u003c\u003cdp[i]\u003c\u003cendl; } } ","date":"2022-02-07","objectID":"/posts/bellmanford%E5%92%8Cspfa%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3/:2:0","tags":["BellmanFord和SPFA算法详解"],"title":"BellmanFord和SPFA算法详解","uri":"/posts/bellmanford%E5%92%8Cspfa%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3/"},{"categories":["算法——最短路问题"],"content":"Bellman ford按边遍历解决(速度竟比SPFA快，我惊了) #include\u003cbits/stdc++.h\u003eusing namespace std; #define LL long long int n,m; //以边为单位遍历更新 struct pos{ int i; int j; int len; }; vector\u003cint\u003edp(20001,INT_MAX/2); LL read() { LL res = 0; bool f = 1; char c; //先耗掉一个getchar来进行判断符号 c = getchar(); if(c == '-')f = 0; else res+= (c-'0'); while (isdigit(c = getchar())) { res = (LL)res * 10 + (c-'0'); } if (f) return res; return res*-1; } int main(){ n = read(); m = read(); //记录m条边的关系 pos MAP[m]; for(int i=0;i\u003cm;i++){ int a =read(),c = read(),len = read(); MAP[i] = {a,c,len}; } dp[1] = 0; //外面一层代表遍历边的次数，最多为n-1次 for(int i=1;i\u003c=n-1;i++){ bool flag = true; for(int k=0;k\u003cm;k++){ if(dp[MAP[k].j]\u003edp[MAP[k].i]+MAP[k].len){ dp[MAP[k].j] = dp[MAP[k].i]+MAP[k].len; flag = false; } } //一旦有一轮遍历未更新一次，则弹出循环，得出答案 if(flag) break; } for(int i=2;i\u003c=n;i++){ cout\u003c\u003cdp[i]\u003c\u003cendl; } } ","date":"2022-02-07","objectID":"/posts/bellmanford%E5%92%8Cspfa%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3/:3:0","tags":["BellmanFord和SPFA算法详解"],"title":"BellmanFord和SPFA算法详解","uri":"/posts/bellmanford%E5%92%8Cspfa%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3/"},{"categories":["算法——最短路问题"],"content":"最终优化–SPFA算法 毕竟SPFA的全称为Shortest Path Faster Algorithm，也得当担得起这个名字啊🤣 主要因为用STL容器存储数据的原因，所以似乎稍慢。 #include\u003cbits/stdc++.h\u003eusing namespace std; #define LL long long int n,m; //以边为单位遍历更新,再进一步优化便得到得到SPFA算法 //我们需要构造一个以任一点为起点的，它所连接的通路的结构，以方便队列进行操作，用哈希表进行映射最好 map\u003cint,vector\u003cpair\u003cint,int\u003e \u003e \u003eMAP; vector\u003cint\u003edp(20001,INT_MAX/2); queue\u003cint\u003eQ; //标记结点是否在队列之中 bool check[20001] = {false}; LL read() { LL res = 0; bool f = 1; char c; //先耗掉一个getchar来进行判断符号 c = getchar(); if(c == '-')f = 0; else res+= (c-'0'); while (isdigit(c = getchar())) { res = (LL)res * 10 + (c-'0'); } if (f) return res; return res*-1; } int main(){ n = read(); m = read(); for(int i=0;i\u003cm;i++){ int a =read(),c = read(),len = read(); MAP[a].push_back(make_pair(c,len)); } dp[1] = 0; Q.push(1); check[1] = true; while(!Q.empty()){ int node = Q.front();Q.pop();check[node] = false; vector\u003cpair\u003cint,int\u003e \u003e\u0026 t = MAP[node]; //以node为起点开始更新，一旦被更新且队中无该结点，则入队。 for(int i=0;i\u003ct.size();i++) { if(dp[t[i].first]\u003edp[node]+t[i].second){ dp[t[i].first] = dp[node]+t[i].second; //入队操作 if(!check[t[i].first]) Q.push(t[i].first); check[t[i].first] = true; } } } for(int i=2;i\u003c=n;i++){ cout\u003c\u003cdp[i]\u003c\u003cendl; } } ","date":"2022-02-07","objectID":"/posts/bellmanford%E5%92%8Cspfa%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3/:4:0","tags":["BellmanFord和SPFA算法详解"],"title":"BellmanFord和SPFA算法详解","uri":"/posts/bellmanford%E5%92%8Cspfa%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3/"},{"categories":["算法——最短路问题"],"content":"Dijkstra算法模板讲解","date":"2022-02-07","objectID":"/posts/dijkstra%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E8%AE%B2%E8%A7%A3/","tags":["Dijkstra算法模板讲解"],"title":"Dijkstra算法模板讲解","uri":"/posts/dijkstra%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E8%AE%B2%E8%A7%A3/"},{"categories":["算法——最短路问题"],"content":"(也就5min)先点开链接把Dijkstra算法过程看一看(否则肯定看不懂代码). 视频详解Dijkstra算法过程 此方法最短路径的适用范围：单源带权图，要是不带权完全可以用bfs。 详解代码实现过程(请结合视频过程分析) ","date":"2022-02-07","objectID":"/posts/dijkstra%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E8%AE%B2%E8%A7%A3/:0:0","tags":["Dijkstra算法模板讲解"],"title":"Dijkstra算法模板讲解","uri":"/posts/dijkstra%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E8%AE%B2%E8%A7%A3/"},{"categories":["算法——最短路问题"],"content":"用到的基本数据表示 根据视频中讲解的实现原理，我们需要通过多个数组来实现该过程。 dist[i]数组(下标表示第几个结点)用于标记起点S到i的最短距离，初始值全为无穷大，这个值只要足够大就行。 visit[i]数组(下标同上)用于标记每个已经得到最短距离的结点，初始值全为false,表示该结点还未找到最短距离。 path[i]数组(下标同上)用于标记每个已经得到最短距离的结点的前驱(最短路径中的上一个结点)，初始值全为-1。 Graph[i][j]这是一个带权矩阵，表示任意i结点到j结点间边的距离,若两者间无边则初始为无穷大。 ","date":"2022-02-07","objectID":"/posts/dijkstra%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E8%AE%B2%E8%A7%A3/:1:0","tags":["Dijkstra算法模板讲解"],"title":"Dijkstra算法模板讲解","uri":"/posts/dijkstra%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E8%AE%B2%E8%A7%A3/"},{"categories":["算法——最短路问题"],"content":"各个函数模块实现(重在Dijkstra函数) init() void init()//在读入数据之前初始化图 {//Graph和dist在读取数据之前都初始化为INF，path初始化为-1 for(int i = 1; i \u003c= N; i++){ path[i] = -1; dist[i] = INF; for(int j = 1; j \u003c= N; j++){ Graph[j][i] = INF;//INF为自定义的较大的值 } } memset(visit,0,sizeof(visit));//起初，没有一个结点被标记 } FIndMin() int FindMin()//找出未被visit标记的结点中最小的距离结点,并返回该结点 { int minV = S;//初始为S，如果未被更新则路径更新过程结束 int minDist = INF; for(int i = 0; i \u003c N; i++){ if(!visit[i] \u0026\u0026 dist[i] \u003c minDist){//没有被标记\u0026\u0026距离最小 minV = i; minDist = dist[i]; } }//返回没有被标记的最小结点 return minV; } Dijkstra() void Dijkstra() {//S表示起点，T表示终点 dist[S] = 0;//起点到自己的距离设为0 visit[S] = true;//将起点标记 for(int i = 1; i \u003c= N; i++){ //更新与起点S相连的结点的距离值 int t = Graph[i][S]; if(t \u003c INF){ dist[i] = t; path[i] = S; } } //要么无法到达，要么就是找到到达终点的最小值，否则一直循环。 while(1){ //得到未被标记的最小结点，将其标记 int v = FindMin(); if(v==S)//如果未被更新，则无需再更新了，要么全被标记，要么就是剩下的无法到达 return; visit[v] = true;//将该结点标记 if(visit[T])return;//一旦T被标记，则说明到达终点的最小值已经找到 for(int i = 1; i \u003c= N; i++){ //这个结合视频的更新过程想想就懂了 if(!visit[i]\u0026\u0026Graph[v][i]!=INF){//没被标记\u0026\u0026两者之间存在边 if(dist[v] + Graph[v][i] \u003c dist[i]){ dist[i] = dist[v] + Graph[v][i]; path[i] = v; } } } } } 以题代讲–具体实现 ","date":"2022-02-07","objectID":"/posts/dijkstra%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E8%AE%B2%E8%A7%A3/:2:0","tags":["Dijkstra算法模板讲解"],"title":"Dijkstra算法模板讲解","uri":"/posts/dijkstra%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E8%AE%B2%E8%A7%A3/"},{"categories":["算法——最短路问题"],"content":"蓝桥杯–文化之旅 看完题目，唯一的区别在于还需要额外判断文化是否排斥，这个在函数中多添加一个判断条件就行。 ","date":"2022-02-07","objectID":"/posts/dijkstra%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E8%AE%B2%E8%A7%A3/:3:0","tags":["Dijkstra算法模板讲解"],"title":"Dijkstra算法模板讲解","uri":"/posts/dijkstra%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E8%AE%B2%E8%A7%A3/"},{"categories":["算法——最短路问题"],"content":"解题过程 我们按照上述的过程三步走试试： 初始化过程(我比较习惯用vector容器所以就没有单独写init函数了) //vector容器的初始化方法--vector\u003c类型\u003e变量名(长度,初始值); const int size = 505;//用于初始化一个size长度的数组 vector\u003cint\u003epath(size,-1); vector\u003cint\u003edist(size,INT_MAX); vector\u003cbool\u003evisit(size,false); vector\u003cvector\u003cint\u003e \u003eGraphics(size,vector\u003cint\u003e(size,INT_MAX)); //下面两个是本题新加的属性，我们建立所属文化以及文化关系数组来存储。 vector\u003cint\u003ecultures(size); bool cultureLinks[size][size] = {false}; 找最小结点的函数FindMin() int FindMin() { int minV = S; int minDist = INT_MAX; for(int i = 1; i \u003c= N; i++){ if(!visit[i] \u0026\u0026 dist[i] \u003c minDist){ minV = i; minDist = dist[i]; } } return minV; } Dijkstra() 函数 void Dijkstra() { dist[S] = 0; visit[S] = true; for(int i = 1; i \u003c= N; i++){ int t = Graphics[S][i]; if(t \u003c INT_MAX\u0026\u0026!cultureLinks[cultures[i]][cultures[S]]){ dist[i] = t; path[i] = S;} } while(1){ int v = FindMin(); if(v==S) return; visit[v] = true;//将此次最小路径结点标记 //一旦T终点被标记则说明答案已经出现 if(visit[T])return; for(int i = 1; i \u003c= N; i++){ if(!visit[i]\u0026\u0026Graphics[v][i]!=INT_MAX\u0026\u0026!cultureLinks[cultures[i]][cultures[v]]){//只有结点未被标记 \u0026\u0026 文化不会排斥 \u0026\u0026 路径长度不是无穷大 if(dist[v] + Graphics[v][i] \u003c dist[i]){ dist[i] = dist[v] + Graphics[v][i]; path[i] = v; } } } } } main函数测试接口 int main(){ cin\u003e\u003eN\u003e\u003eK\u003e\u003eM\u003e\u003eS\u003e\u003eT; for(int i=1;i\u003c=N;i++) cin\u003e\u003ecultures[i]; for(int i=1;i\u003c=K;i++) for(int j=1;j\u003c=K;j++) cin\u003e\u003ecultureLinks[i][j]; for(int i=1;i\u003c=M;i++){ int u,v,d;cin\u003e\u003eu\u003e\u003ev\u003e\u003ed;//无向图 Graphics[u][v] = Graphics[v][u] = d; } Dijkstra(); if(dist[T]!=INT_MAX) cout\u003c\u003cdist[T]; else cout\u003c\u003c-1; return 0; } ","date":"2022-02-07","objectID":"/posts/dijkstra%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E8%AE%B2%E8%A7%A3/:4:0","tags":["Dijkstra算法模板讲解"],"title":"Dijkstra算法模板讲解","uri":"/posts/dijkstra%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E8%AE%B2%E8%A7%A3/"},{"categories":["算法——最短路问题"],"content":"汇总代码提交 #include\u003cbits/stdc++.h\u003eusing namespace std; const int size = 505; vector\u003cint\u003epath(size,-1); vector\u003cint\u003edist(size,INT_MAX); vector\u003cbool\u003evisit(size,false); vector\u003cvector\u003cint\u003e \u003eGraphics(size,vector\u003cint\u003e(size,INT_MAX)); vector\u003cint\u003ecultures(size); bool cultureLinks[size][size] = {false}; int N,K,M,S,T; int FindMin() { int minV = S; int minDist = INT_MAX; for(int i = 1; i \u003c= N; i++){ if(!visit[i] \u0026\u0026 dist[i] \u003c minDist){ minV = i; minDist = dist[i]; } } return minV; } void Dijkstra() { dist[S] = 0; visit[S] = true; for(int i = 1; i \u003c= N; i++){ int t = Graphics[S][i]; if(t \u003c INT_MAX\u0026\u0026!cultureLinks[cultures[i]][cultures[S]]){ dist[i] = t; path[i] = S;} } while(1){ int v = FindMin(); if(v==S) return; visit[v] = true;//将此次最小路径结点标记 //一旦T终点被标记则说明答案已经出现 if(visit[T])return; for(int i = 1; i \u003c= N; i++){ if(!visit[i]\u0026\u0026Graphics[v][i]!=INT_MAX\u0026\u0026!cultureLinks[cultures[i]][cultures[v]]){//只有结点未被标记 \u0026\u0026 文化不会排斥 \u0026\u0026 路径长度不是无穷大 if(dist[v] + Graphics[v][i] \u003c dist[i]){ dist[i] = dist[v] + Graphics[v][i]; path[i] = v; } } } } } int main(){ cin\u003e\u003eN\u003e\u003eK\u003e\u003eM\u003e\u003eS\u003e\u003eT; for(int i=1;i\u003c=N;i++) cin\u003e\u003ecultures[i]; for(int i=1;i\u003c=K;i++) for(int j=1;j\u003c=K;j++) cin\u003e\u003ecultureLinks[i][j]; for(int i=1;i\u003c=M;i++){ int u,v,d;cin\u003e\u003eu\u003e\u003ev\u003e\u003ed;//无向图 Graphics[u][v] = Graphics[v][u] = d; } Dijkstra(); if(dist[T]!=INT_MAX) cout\u003c\u003cdist[T]; else cout\u003c\u003c-1; return 0; } ","date":"2022-02-07","objectID":"/posts/dijkstra%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E8%AE%B2%E8%A7%A3/:5:0","tags":["Dijkstra算法模板讲解"],"title":"Dijkstra算法模板讲解","uri":"/posts/dijkstra%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E8%AE%B2%E8%A7%A3/"},{"categories":["C++实战"],"content":"C++图形化实现学生管理系统","date":"2022-02-05","objectID":"/posts/c++%E5%9B%BE%E5%BD%A2%E5%8C%96%E5%AE%9E%E7%8E%B0%E5%AD%A6%E7%94%9F%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/","tags":["C++图形化实现学生管理系统"],"title":"C++图形化实现学生管理系统","uri":"/posts/c++%E5%9B%BE%E5%BD%A2%E5%8C%96%E5%AE%9E%E7%8E%B0%E5%AD%A6%E7%94%9F%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/"},{"categories":["C++实战"],"content":"Qt学生管理系统 想查看源码或者直接下载软件安装包可以到下面的链接： 软件安装包大概在这个位置 GitHub地址：链接 Gitee地址(方便国内访问)：链接 ","date":"2022-02-05","objectID":"/posts/c++%E5%9B%BE%E5%BD%A2%E5%8C%96%E5%AE%9E%E7%8E%B0%E5%AD%A6%E7%94%9F%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/:0:0","tags":["C++图形化实现学生管理系统"],"title":"C++图形化实现学生管理系统","uri":"/posts/c++%E5%9B%BE%E5%BD%A2%E5%8C%96%E5%AE%9E%E7%8E%B0%E5%AD%A6%E7%94%9F%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/"},{"categories":["C++实战"],"content":"基本源码介绍 本项目基于Qt6+cmake，故直接拿到源码是无法跑起来的，需要Qt6的库。上传源码主要是记录源码里面的一些思路。 以下是源码的解析图：（其中的ui布局界面和qss界面美化是最耗时间的部分！） ui界面布局用到的特殊之处： 重写界面顶部逻辑。 重写一些事件。 增加软件运行效率的特殊之处： 通过开一个线程将数据库中的数据提前载入内存，后续的任何查询等操作都是直接和内存打交道，大大加快了运行效率。 对数据库的增删，不是一次一次的进行，而是开一个缓冲区，当缓冲满了，再一次性增或者删。减少了磁盘io次数，大大增加了软件运行效率。 使用的数据库为Qt自带的sqlite数据库。 ","date":"2022-02-05","objectID":"/posts/c++%E5%9B%BE%E5%BD%A2%E5%8C%96%E5%AE%9E%E7%8E%B0%E5%AD%A6%E7%94%9F%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/:1:0","tags":["C++图形化实现学生管理系统"],"title":"C++图形化实现学生管理系统","uri":"/posts/c++%E5%9B%BE%E5%BD%A2%E5%8C%96%E5%AE%9E%E7%8E%B0%E5%AD%A6%E7%94%9F%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/"},{"categories":["C++实战"],"content":"实现效果 基本学生/用户数据的增删改查。 数据存储的持久化。 较为优美的图形化界面。 还有很多功能没有进行拓展：比如用户权限没有进行任何的限制，比如Excle表格读取没有进行任何的设置，只是把excle读取的功能给加上了，具体读取到的数据没有进行任何操作，这些大家都可以后续有兴趣添加一个。 ","date":"2022-02-05","objectID":"/posts/c++%E5%9B%BE%E5%BD%A2%E5%8C%96%E5%AE%9E%E7%8E%B0%E5%AD%A6%E7%94%9F%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/:2:0","tags":["C++图形化实现学生管理系统"],"title":"C++图形化实现学生管理系统","uri":"/posts/c++%E5%9B%BE%E5%BD%A2%E5%8C%96%E5%AE%9E%E7%8E%B0%E5%AD%A6%E7%94%9F%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/"},{"categories":["现代C++语法"],"content":"C++右值语义的基石——完美转发","date":"2022-02-04","objectID":"/posts/c++%E5%8F%B3%E5%80%BC%E8%AF%AD%E4%B9%89%E7%9A%84%E5%9F%BA%E7%9F%B3%E5%AE%8C%E7%BE%8E%E8%BD%AC%E5%8F%91/","tags":["C++右值语义的基石——完美转发"],"title":"C++右值语义的基石——完美转发","uri":"/posts/c++%E5%8F%B3%E5%80%BC%E8%AF%AD%E4%B9%89%E7%9A%84%E5%9F%BA%E7%9F%B3%E5%AE%8C%E7%BE%8E%E8%BD%AC%E5%8F%91/"},{"categories":["现代C++语法"],"content":"什么是完美转发？ 熟悉现代C++语法的都应该清楚，C++把变量分为左值和右值，为了实现对资源的转移而不是拷贝，右值和对应的移动构造函数应运而生，但我们发现，很多时候我们并不能把左值和右值精确的传递给对应版本的函数进行处理，比如下面一个简单的代码，你会发现即使我们把函数的参数类型设置为右值引用，但当拿它去调用对应的构造函数时，它给出的竟然是拷贝构造！故这个转发还不够完美！ #include\u003ciostream\u003eusing namespace std; class test{ public: test() = default; test(test\u0026\u0026 p){ cout\u003c\u003c\"move construct call\"\u003c\u003cendl; } test(const test\u0026 p){ cout\u003c\u003c\"copy construct call\"\u003c\u003cendl; } }; void test_fun(test\u0026\u0026 p){ test q(p); return; } int main() { test_fun(test()); return 0; } 为什么会出现这种情况呢？ 因为无论传入的形参是左值还是右值，对于函数内部来说，形参既有名称又能寻址，因此它都被认为是左值。 ","date":"2022-02-04","objectID":"/posts/c++%E5%8F%B3%E5%80%BC%E8%AF%AD%E4%B9%89%E7%9A%84%E5%9F%BA%E7%9F%B3%E5%AE%8C%E7%BE%8E%E8%BD%AC%E5%8F%91/:1:0","tags":["C++右值语义的基石——完美转发"],"title":"C++右值语义的基石——完美转发","uri":"/posts/c++%E5%8F%B3%E5%80%BC%E8%AF%AD%E4%B9%89%E7%9A%84%E5%9F%BA%E7%9F%B3%E5%AE%8C%E7%BE%8E%E8%BD%AC%E5%8F%91/"},{"categories":["现代C++语法"],"content":"如何实现完美转发？ 实现完美转发很简单，我们在现代C++中只需要 forward\u003cT\u003e 这个模板函数即可完成，其实际原理就是利用的 C++11 模板中提供的折叠引用的语法，最终达到的效果就是，把参数的类型强制转换为它该有的类型，是左值就转为左值，是右值就转为右值，从而实现该调用哪个版本的函数就调用哪个版本的函数，不再只被认定为右值了！ 先前的代码可以如此实现完美转发： #include\u003ciostream\u003eusing namespace std; class test{ public: test() = default; test(test\u0026\u0026 p){ cout\u003c\u003c\"move construct call\"\u003c\u003cendl; } test(const test\u0026 p){ cout\u003c\u003c\"copy construct call\"\u003c\u003cendl; } }; void test_fun(test\u0026\u0026 p){ test q(forward\u003ctest\u003e(p)); //修改的地方 return; } int main() { test_fun(test()); return 0; } ","date":"2022-02-04","objectID":"/posts/c++%E5%8F%B3%E5%80%BC%E8%AF%AD%E4%B9%89%E7%9A%84%E5%9F%BA%E7%9F%B3%E5%AE%8C%E7%BE%8E%E8%BD%AC%E5%8F%91/:2:0","tags":["C++右值语义的基石——完美转发"],"title":"C++右值语义的基石——完美转发","uri":"/posts/c++%E5%8F%B3%E5%80%BC%E8%AF%AD%E4%B9%89%E7%9A%84%E5%9F%BA%E7%9F%B3%E5%AE%8C%E7%BE%8E%E8%BD%AC%E5%8F%91/"},{"categories":["现代C++语法"],"content":"任何模板库都离不开完美转发 其实现在只要是C++的模板库，没有哪个是不用完美转发的，同时完美转发的问题也是产生自模板，而 forward 函数的实现其实也不是什么难事，实际就是利用 C++11 对模板提供的万能折叠语义： 当实参为左值或者左值引用（A\u0026）时，函数模板中 T\u0026\u0026 将转变为 A\u0026（A\u0026 \u0026\u0026 = A\u0026）； 当实参为右值或者右值引用（A\u0026\u0026）时，函数模板中 T\u0026\u0026 将转变为 A\u0026\u0026（A\u0026\u0026 \u0026\u0026 = A\u0026\u0026）。 以下为一个简单的利用完美转发设计的创建工厂： #include\u003ciostream\u003e#include \u003cmemory\u003e using namespace std; class test{ public: test() = default; test(int\u0026\u0026 arg):m_iData(arg){ cout\u003c\u003c\"move construct call\"\u003c\u003cendl; } test(const int\u0026 arg):m_iData(arg){ cout\u003c\u003c\"copy construct call\"\u003c\u003cendl; } private: int m_iData; }; template\u003ctypename T,typename Arg\u003e //不直接用T\u0026\u0026的原因在于，如果只使用一个模板参数会导致factory参数无法获得万能引用的效果 shared_ptr\u003cT\u003e factory(Arg\u0026\u0026 arg){ return shared_ptr\u003cT\u003e(new T(forward\u003cArg\u003e(arg)));//使用完美转发调用正确的构造函数 } int main() { int val = 5; auto p1 = factory\u003ctest\u003e(val); auto p2 = factory\u003ctest\u003e(5); return 0; } ","date":"2022-02-04","objectID":"/posts/c++%E5%8F%B3%E5%80%BC%E8%AF%AD%E4%B9%89%E7%9A%84%E5%9F%BA%E7%9F%B3%E5%AE%8C%E7%BE%8E%E8%BD%AC%E5%8F%91/:3:0","tags":["C++右值语义的基石——完美转发"],"title":"C++右值语义的基石——完美转发","uri":"/posts/c++%E5%8F%B3%E5%80%BC%E8%AF%AD%E4%B9%89%E7%9A%84%E5%9F%BA%E7%9F%B3%E5%AE%8C%E7%BE%8E%E8%BD%AC%E5%8F%91/"},{"categories":["现代C++语法"],"content":"std::forward的实现原理 gcc 的源代码实现如下： template\u003ctypename _Tp\u003e constexpr _Tp \u0026\u0026 forward(typename std::remove_reference\u003c_Tp\u003e::type \u0026__t) noexcept { return static_cast\u003c_Tp \u0026\u0026\u003e(__t); } template\u003ctypename _Tp\u003e constexpr _Tp \u0026\u0026 forward(typename std::remove_reference\u003c_Tp\u003e::type \u0026\u0026__t) noexcept { static_assert(!std::is_lvalue_reference\u003c_Tp\u003e::value, \"template argument\" \" substituting _Tp is an lvalue reference type\"); return static_cast\u003c_Tp \u0026\u0026\u003e(__t); } 我们发现，源代码中实现了两个模板特化，_Tp\u0026 和 _Tp\u0026\u0026 但最终都是通过 static_cast + 折叠引用的特性来实现强制转化的。也就是简单的强转而已！ ","date":"2022-02-04","objectID":"/posts/c++%E5%8F%B3%E5%80%BC%E8%AF%AD%E4%B9%89%E7%9A%84%E5%9F%BA%E7%9F%B3%E5%AE%8C%E7%BE%8E%E8%BD%AC%E5%8F%91/:4:0","tags":["C++右值语义的基石——完美转发"],"title":"C++右值语义的基石——完美转发","uri":"/posts/c++%E5%8F%B3%E5%80%BC%E8%AF%AD%E4%B9%89%E7%9A%84%E5%9F%BA%E7%9F%B3%E5%AE%8C%E7%BE%8E%E8%BD%AC%E5%8F%91/"},{"categories":["现代C++语法"],"content":"收获 在设计模板库的时候，如果需要根据左值右值语义比较清晰的实现转发，一定要用forward，否则参数只会被当作左值！ ","date":"2022-02-04","objectID":"/posts/c++%E5%8F%B3%E5%80%BC%E8%AF%AD%E4%B9%89%E7%9A%84%E5%9F%BA%E7%9F%B3%E5%AE%8C%E7%BE%8E%E8%BD%AC%E5%8F%91/:5:0","tags":["C++右值语义的基石——完美转发"],"title":"C++右值语义的基石——完美转发","uri":"/posts/c++%E5%8F%B3%E5%80%BC%E8%AF%AD%E4%B9%89%E7%9A%84%E5%9F%BA%E7%9F%B3%E5%AE%8C%E7%BE%8E%E8%BD%AC%E5%8F%91/"},{"categories":["算法——贪心"],"content":"leetcode每日一题——和为K的最少斐波那契数字数目","date":"2022-02-03","objectID":"/posts/leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E5%92%8C%E4%B8%BAk%E7%9A%84%E6%9C%80%E5%B0%91%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%AD%97%E6%95%B0%E7%9B%AE/","tags":["fib的贪心可行性"],"title":"leetcode每日一题——和为K的最少斐波那契数字数目","uri":"/posts/leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E5%92%8C%E4%B8%BAk%E7%9A%84%E6%9C%80%E5%B0%91%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%AD%97%E6%95%B0%E7%9B%AE/"},{"categories":["算法——贪心"],"content":"题目 题目链接 ","date":"2022-02-03","objectID":"/posts/leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E5%92%8C%E4%B8%BAk%E7%9A%84%E6%9C%80%E5%B0%91%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%AD%97%E6%95%B0%E7%9B%AE/:1:0","tags":["fib的贪心可行性"],"title":"leetcode每日一题——和为K的最少斐波那契数字数目","uri":"/posts/leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E5%92%8C%E4%B8%BAk%E7%9A%84%E6%9C%80%E5%B0%91%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%AD%97%E6%95%B0%E7%9B%AE/"},{"categories":["算法——贪心"],"content":"题目详解 我开始是想着构造好fib数组的值，然后用背包问题去解决它。可惜，直接超时了！ 后面直接用最简单的贪心方式没想到真的可行。。 然后看了题解才知道原来fib的「每次选择不超过当前 k 的最大数」这是一个特有的结论，然后大家都在证明他，虽然我看不懂，但我大受震撼😂 详解链接 ","date":"2022-02-03","objectID":"/posts/leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E5%92%8C%E4%B8%BAk%E7%9A%84%E6%9C%80%E5%B0%91%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%AD%97%E6%95%B0%E7%9B%AE/:2:0","tags":["fib的贪心可行性"],"title":"leetcode每日一题——和为K的最少斐波那契数字数目","uri":"/posts/leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E5%92%8C%E4%B8%BAk%E7%9A%84%E6%9C%80%E5%B0%91%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%AD%97%E6%95%B0%E7%9B%AE/"},{"categories":["算法——贪心"],"content":"解题代码 class Solution { public: int findMinFibonacciNumbers(int k) { vector\u003cint\u003eitems(2,1); int ret = 0; while(items.back()\u003ck){ items.push_back(items.back()+items[items.size()-2]); } for(int i=items.size()-1;i\u003e=0;i--){ ret += k/items[i]; k %= items[i]; } return ret; } }; ","date":"2022-02-03","objectID":"/posts/leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E5%92%8C%E4%B8%BAk%E7%9A%84%E6%9C%80%E5%B0%91%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%AD%97%E6%95%B0%E7%9B%AE/:3:0","tags":["fib的贪心可行性"],"title":"leetcode每日一题——和为K的最少斐波那契数字数目","uri":"/posts/leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E5%92%8C%E4%B8%BAk%E7%9A%84%E6%9C%80%E5%B0%91%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%AD%97%E6%95%B0%E7%9B%AE/"},{"categories":["算法——字符串"],"content":"字符串类型滑动窗口或递归分治解被ban字符求最长子串","date":"2022-02-01","objectID":"/posts/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B1%BB%E5%9E%8B%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%88%96%E9%80%92%E5%BD%92%E5%88%86%E6%B2%BB%E8%A7%A3%E8%A2%ABban%E5%AD%97%E7%AC%A6%E6%B1%82%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/","tags":["递归分治、滑动窗口、位运算"],"title":"字符串类型滑动窗口或递归分治解被ban字符求最长子串","uri":"/posts/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B1%BB%E5%9E%8B%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%88%96%E9%80%92%E5%BD%92%E5%88%86%E6%B2%BB%E8%A7%A3%E8%A2%ABban%E5%AD%97%E7%AC%A6%E6%B1%82%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/"},{"categories":["算法——字符串"],"content":"题目一：至少有 K 个重复字符的最长子串 395. 至少有 K 个重复字符的最长子串 ","date":"2022-02-01","objectID":"/posts/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B1%BB%E5%9E%8B%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%88%96%E9%80%92%E5%BD%92%E5%88%86%E6%B2%BB%E8%A7%A3%E8%A2%ABban%E5%AD%97%E7%AC%A6%E6%B1%82%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/:1:0","tags":["递归分治、滑动窗口、位运算"],"title":"字符串类型滑动窗口或递归分治解被ban字符求最长子串","uri":"/posts/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B1%BB%E5%9E%8B%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%88%96%E9%80%92%E5%BD%92%E5%88%86%E6%B2%BB%E8%A7%A3%E8%A2%ABban%E5%AD%97%E7%AC%A6%E6%B1%82%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/"},{"categories":["算法——字符串"],"content":"题目解析 有两种方法： 递归分治解决：该分治法的应用对象：解决那种不会去跨越任何一个段更新答案的题目。比如此题这种关于字符串子串的题。首先在整个字符串大范围内可以确定哪些字符没有达到k次，故只要存在这些字符的子串都被排除在外。具体到递归分治的代码上就是： 分治的每一段都不含上一个总字符串的被 ban (被禁)字符，故每个分治的对象都要进行以下几个步骤： 一、计算 [l,r] 之间所有字符的出现次数。 二、根据出现次数计算出被 ban 掉的字符类型。 三、根据是否有被 ban 的字符类型，来确定是否还需要再往下递归分治，如果没有被 ban 的字符类型，则该字符串就是一个符合条件的字符串。否则继续往下递归分治，分治的子对象都不能含有该被 ban 字符类型。 根据枚举类型的滑动窗口解决：按照字符类型的滑动窗口技巧，最外层用于枚举固定当前窗口内最多有多少类型。这个技巧就是，当我们无法直接找到滑动窗口的边界时，我们可以根据有限的类型来构造滑动窗口的边界，由于最多有26个类型的字符，而我们滑动窗口过程可以根据某个类型的字符数量是否符合条件来得到窗口内符合条件的类型数量，只要窗口内的类型数量等于符合条件的类型数量，那么该窗口内的字符串即为一个答案。但问题是，我们不清楚窗口内的类型数量是多大，这也就是我们没有明确的边界，此时我们根据枚举 1~26 个类型来进行窗口的滑动限制即可。 ","date":"2022-02-01","objectID":"/posts/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B1%BB%E5%9E%8B%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%88%96%E9%80%92%E5%BD%92%E5%88%86%E6%B2%BB%E8%A7%A3%E8%A2%ABban%E5%AD%97%E7%AC%A6%E6%B1%82%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/:1:1","tags":["递归分治、滑动窗口、位运算"],"title":"字符串类型滑动窗口或递归分治解被ban字符求最长子串","uri":"/posts/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B1%BB%E5%9E%8B%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%88%96%E9%80%92%E5%BD%92%E5%88%86%E6%B2%BB%E8%A7%A3%E8%A2%ABban%E5%AD%97%E7%AC%A6%E6%B1%82%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/"},{"categories":["算法——字符串"],"content":"解题代码 法一：递归分治 class Solution { public: int dfs(string\u0026 s,int l,int r,int k){ int cnt[26] = {0}; for(int i=l;i\u003c=r;i++){//计算字符的次数方便计算ban掉的字符类型 cnt[s[i]-'a']++; } char split = 0; for(int i=0;i\u003c26;i++){ if(cnt[i]!=0\u0026\u0026cnt[i]\u003ck){ //很明显在这个大范围内要是这个字符类型次数都小于k了，肯定就是要被ban的 split = i+'a'; break; } } if(split==0)//如果该段字符串没有被ban的字符类型则该字符串就是符合条件的字符串 return r-l+1; int ret = 0; //开始枚举分治到下面去 while(l\u003c=r){ while(l\u003c=r\u0026\u0026s[l]==split){//不让起始点从被ban的字符开始 l++; } if(l\u003er) break;//说明全是被ban的字符 int start = l; while(l\u003c=r\u0026\u0026s[l]!=split){//计算本次分段的长度（结束位置） l++; } int length = dfs(s,start,l-1,k); ret = max(ret,length); } return ret; } int longestSubstring(string s, int k) { return dfs(s,0,s.size()-1,k); } }; 法二：枚举类型的滑动窗口 class Solution { public: int longestSubstring(string s, int k) { int n = s.size(); int cnt[26]{0};//用于记录窗口内字符的出现次数 int maxLen = 0; for(int i=1;i\u003c=26;i++){ memset(cnt,0,sizeof(cnt)); for(int l=0,r=0,sum=0,tot=0;r\u003cn;r++){//sum、tot分别表示窗口内的有效字符种类数和总的种类数 cnt[s[r]-'a']++; if(cnt[s[r]-'a']==1) //增加种类数 tot++; if(cnt[s[r]-'a']==k) //为了防止多次更新千万别取大于号 sum++; //增加有效种类数 while(tot\u003ei){ //达到收缩窗口条件，因为窗口内的种类数限制为i个 int dup = (s[l++]-'a'); cnt[dup]--; if(cnt[dup]==0) //种类数此时需要-1 tot--; if(cnt[dup]==k-1)//有效种类数-1 sum--; } if(sum==tot) maxLen = max(maxLen,r-l+1); } } return maxLen; } }; ","date":"2022-02-01","objectID":"/posts/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B1%BB%E5%9E%8B%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%88%96%E9%80%92%E5%BD%92%E5%88%86%E6%B2%BB%E8%A7%A3%E8%A2%ABban%E5%AD%97%E7%AC%A6%E6%B1%82%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/:1:2","tags":["递归分治、滑动窗口、位运算"],"title":"字符串类型滑动窗口或递归分治解被ban字符求最长子串","uri":"/posts/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B1%BB%E5%9E%8B%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%88%96%E9%80%92%E5%BD%92%E5%88%86%E6%B2%BB%E8%A7%A3%E8%A2%ABban%E5%AD%97%E7%AC%A6%E6%B1%82%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/"},{"categories":["算法——字符串"],"content":"题目二：最长的美好子字符串 最长的美好子字符串 ","date":"2022-02-01","objectID":"/posts/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B1%BB%E5%9E%8B%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%88%96%E9%80%92%E5%BD%92%E5%88%86%E6%B2%BB%E8%A7%A3%E8%A2%ABban%E5%AD%97%E7%AC%A6%E6%B1%82%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/:2:0","tags":["递归分治、滑动窗口、位运算"],"title":"字符串类型滑动窗口或递归分治解被ban字符求最长子串","uri":"/posts/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B1%BB%E5%9E%8B%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%88%96%E9%80%92%E5%BD%92%E5%88%86%E6%B2%BB%E8%A7%A3%E8%A2%ABban%E5%AD%97%E7%AC%A6%E6%B1%82%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/"},{"categories":["算法——字符串"],"content":"题目解析 这题虽然由于数据量的关系，被划分为简单题，但实际上完全不亚于第一题。甚至还得用上一些位运算的思想。 这题我会的做法只有两种： 普通位运算枚举法：其实就是此题的暴力解法，只是用了位运算使得更为优雅，由于此题需要求最长的大小写都包含的字符串，我们用一个int位来表示所有小写字母的出现，用另一个int位来表示所有大写字母的出现，则对于每个字符串，都可以通过这两个int是否相等来判断是否正好是大小写都含有，然后就是暴力的遍历所有子串的过程了。 递归分治法：此题和上题差不多，也是不会跨越任何一个段去更新答案，所以也能使用递归分治的方式来进行解决。但前期处理被ban字符和上题是不一样的，其余都一样，这题要根据 [l,r] 之间字符的位运算结果 lower 和 upper 再与运算得到两者的交集来判断是否有被 ban 字符，或者是不被ban的字符。 ","date":"2022-02-01","objectID":"/posts/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B1%BB%E5%9E%8B%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%88%96%E9%80%92%E5%BD%92%E5%88%86%E6%B2%BB%E8%A7%A3%E8%A2%ABban%E5%AD%97%E7%AC%A6%E6%B1%82%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/:2:1","tags":["递归分治、滑动窗口、位运算"],"title":"字符串类型滑动窗口或递归分治解被ban字符求最长子串","uri":"/posts/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B1%BB%E5%9E%8B%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%88%96%E9%80%92%E5%BD%92%E5%88%86%E6%B2%BB%E8%A7%A3%E8%A2%ABban%E5%AD%97%E7%AC%A6%E6%B1%82%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/"},{"categories":["算法——字符串"],"content":"解题代码 方法一：位运算+暴力遍历 class Solution { public: string longestNiceSubstring(string s) { int sz = s.size(); int start,len=0; for(int i=0;i\u003csz;i++){ int lower = 0,upper = 0; for(int j=i;j\u003csz;j++){ if(islower(s[j])){ lower |= (1\u003c\u003c(s[j]-'a')); }else{ upper |= (1\u003c\u003c(s[j]-'A')); } if(lower==upper\u0026\u0026(j-i+1\u003elen)){ start = i; len = j-i+1; } } } return len==0?\"\":s.substr(start,len); } }; 方法二：递归分治 class Solution { public: void dfs(string \u0026s, int l, int r, pair\u003cint, int\u003e \u0026ret) { int lower = 0, upper = 0; for (int i = l; i \u003c= r; i++) { if (islower(s[i])) { lower |= (1 \u003c\u003c (s[i] - 'a')); } else { upper |= (1 \u003c\u003c (s[i] - 'A')); } } if (lower == upper) {//我之前这里的判断条件导致了无限循环，一旦满足第一个条件，但不满足第二个条件，就发生无限循环！！！所以注意放到下面去 if (r - l + 1 \u003e ret.second) { ret.first = l; ret.second = r - l + 1; } return; } int valid = lower \u0026 upper;//这两的交集代表大小写都出现的类型，为符合条件的类型，而被ban的就是不处于这里面的字符类型 int start; while (l \u003c= r) { while (l \u003c= r \u0026\u0026 !(valid \u0026 (1 \u003c\u003c (tolower(s[l]) - 'a')))) {//让start处于符合条件的类型 l++; } if (l \u003e r) break; start = l; while (l \u003c= r \u0026\u0026 (valid \u0026 (1 \u003c\u003c (tolower(s[l]) - 'a')))) {//得到符合条件的分段右端点 l++; } dfs(s, start, l - 1, ret); } } string longestNiceSubstring(string s) { pair\u003cint, int\u003e ret{0, 0}; dfs(s, 0, s.size() - 1, ret); return s.substr(ret.first, ret.second); } }; ","date":"2022-02-01","objectID":"/posts/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B1%BB%E5%9E%8B%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%88%96%E9%80%92%E5%BD%92%E5%88%86%E6%B2%BB%E8%A7%A3%E8%A2%ABban%E5%AD%97%E7%AC%A6%E6%B1%82%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/:2:2","tags":["递归分治、滑动窗口、位运算"],"title":"字符串类型滑动窗口或递归分治解被ban字符求最长子串","uri":"/posts/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B1%BB%E5%9E%8B%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%88%96%E9%80%92%E5%BD%92%E5%88%86%E6%B2%BB%E8%A7%A3%E8%A2%ABban%E5%AD%97%E7%AC%A6%E6%B1%82%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/"},{"categories":["算法——动态规划"],"content":"划分数问题","date":"2022-01-30","objectID":"/posts/%E5%88%92%E5%88%86%E6%95%B0%E9%97%AE%E9%A2%98/","tags":["划分数问题"],"title":"划分数问题","uri":"/posts/%E5%88%92%E5%88%86%E6%95%B0%E9%97%AE%E9%A2%98/"},{"categories":["算法——动态规划"],"content":"题目 题目链接 ","date":"2022-01-30","objectID":"/posts/%E5%88%92%E5%88%86%E6%95%B0%E9%97%AE%E9%A2%98/:1:0","tags":["划分数问题"],"title":"划分数问题","uri":"/posts/%E5%88%92%E5%88%86%E6%95%B0%E9%97%AE%E9%A2%98/"},{"categories":["算法——动态规划"],"content":"题目详解 划分数类型题目都是dp解决，而且都有固定的套路和公式，但我们还是需要在前人的公式上加以理解！ 划分数问题dp总结 我这里就提两个比较常见的划分数问题的dp原理： 如果对数字划分较为抽象，那么我们把这个数字可以比作苹果，即有n个苹果需要划分到m个盘子里面，而这几个盘子的顺序肯定是不考虑的，也就是5个苹果划分给3个盘子，则1 2 2和2 1 2是完全一样的情况，只看具体的数字组合不看内部排列！ 将n划分成不大于m的划分。 $dp[n][m] = dp[n-m][m]+dp[n][m-1]$ 对于以上的状态转移方程， dp[n-m][m] 表示n个苹果放入m个盘子中，无空盘的情况。 dp[n][m-1] 表示n个苹果放入m个盘子中，有空盘的情况(这就是划分成不大于m盘的关键所在)。这么写肯定是有些难以理解，但当你去举例子，将它递归往下写的时候，你就会发现这个dp[n][m-1] 包含了从 dp[n][1] 到 dp[n][m-1] 的所有情况！ 底层的基本case有： 当 n==1||m==1 ，即盘子或者苹果数量为1个的时候，那肯定就只有一种情况。即dp[n][m]=1。 当 n\u003em ，则还能继续划分即dp[n][m] = dp[n-m][m]+dp[n][m-1]。 当 n==m ，则有两种情况，当划分为m个时，结果为1，然后继续空盘子划分，即 dp[n][m]=dp[n][m-1]+1。 当 n\u003cm，由于可以空盘，所以是允许存在的，但此时不可能满盘，所以等于空盘的情况，即 dp[n][m] = dp[n][m-1]。 写成代码形式就是（我比较喜欢写记忆化dfs，毕竟不需要考虑初始化问题，只需考虑最后的跳出）： 以下的两个判断条件就把所有是以上四种情况包含在内了！ int memo[202][8];//记忆化的备忘录 //TODO 划分数记忆化方式 int dfs(int n,int m){ if(n\u003c0||m\u003c0) return 0; if(n==1||n==0||m==1) return 1; return memo[n][m] = dfs(n-m,m)+dfs(n,m-1); } 将n严格划分为m个数。(即n个苹果严格划分为m盘，不要有空位！) $dp[n][m] = dp[n-m][m]+dp[n-1][m-1]$ 下面给出我的一段手写推导： base case也在手写题解里面提到了，所以直接上代码： int memo[202][8]; //TODO 划分数n划成k份的记忆化方式 int dfs(int n,int k){ if(n\u003ck) return 0; if(n==k||k==1) return 1; if(memo[n][k])return memo[n][k]; return memo[n][k] = dfs(n-k, k) + dfs(n-1,k-1); } ","date":"2022-01-30","objectID":"/posts/%E5%88%92%E5%88%86%E6%95%B0%E9%97%AE%E9%A2%98/:2:0","tags":["划分数问题"],"title":"划分数问题","uri":"/posts/%E5%88%92%E5%88%86%E6%95%B0%E9%97%AE%E9%A2%98/"},{"categories":["算法——动态规划"],"content":"解题代码 前面已经介绍了两种划分数的dp，那么本题就属于第二种划分数的dp！ 直接把上面的代码拿下来直接秒！ #include\u003cbits/stdc++.h\u003eusing namespace std; using ll = long long; ll memo[202][8]; int n,k; //TODO 划分数记忆化方式 ll dfs(int a,int b){ if(a\u003cb) return 0; if(a==b||b==1) return 1; if(memo[a][b])return memo[a][b]; return memo[a][b] = dfs(a-b, b) + dfs(a-1,b-1); } int main(){ cin\u003e\u003en\u003e\u003ek; cout\u003c\u003cdfs(n, k); return 0; } ","date":"2022-01-30","objectID":"/posts/%E5%88%92%E5%88%86%E6%95%B0%E9%97%AE%E9%A2%98/:3:0","tags":["划分数问题"],"title":"划分数问题","uri":"/posts/%E5%88%92%E5%88%86%E6%95%B0%E9%97%AE%E9%A2%98/"},{"categories":["算法——路径更新问题"],"content":"leetcode每日一题——地图中的最高点","date":"2022-01-29","objectID":"/posts/leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E5%9C%B0%E5%9B%BE%E4%B8%AD%E7%9A%84%E6%9C%80%E9%AB%98%E7%82%B9/","tags":["leetcode每日一题——地图中的最高点"],"title":"leetcode每日一题——地图中的最高点","uri":"/posts/leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E5%9C%B0%E5%9B%BE%E4%B8%AD%E7%9A%84%E6%9C%80%E9%AB%98%E7%82%B9/"},{"categories":["算法——路径更新问题"],"content":"题目 题目链接 ","date":"2022-01-29","objectID":"/posts/leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E5%9C%B0%E5%9B%BE%E4%B8%AD%E7%9A%84%E6%9C%80%E9%AB%98%E7%82%B9/:1:0","tags":["leetcode每日一题——地图中的最高点"],"title":"leetcode每日一题——地图中的最高点","uri":"/posts/leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E5%9C%B0%E5%9B%BE%E4%B8%AD%E7%9A%84%E6%9C%80%E9%AB%98%E7%82%B9/"},{"categories":["算法——路径更新问题"],"content":"解题思路 两种解题思路，都是根据题目的意思更新路径信息即可： bfs思路：由于相邻的两个格子必须高度差为1，而水域必须高度为0，所以，直接以水域为bfs源点，进行bfs把整个区域的值给更新就行了。这是bfs思路。 dp思路：由于dp都依赖上一次更新的结果，而我们一般就是从左到右的遍历更新，而这题是和四个位置相关，所以，我们分为：从上到下从左到右更新，可以把依赖上和左的答案给更新，从下到上，从右到左更新，可以把依赖下和右的结果给更新完。 ","date":"2022-01-29","objectID":"/posts/leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E5%9C%B0%E5%9B%BE%E4%B8%AD%E7%9A%84%E6%9C%80%E9%AB%98%E7%82%B9/:2:0","tags":["leetcode每日一题——地图中的最高点"],"title":"leetcode每日一题——地图中的最高点","uri":"/posts/leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E5%9C%B0%E5%9B%BE%E4%B8%AD%E7%9A%84%E6%9C%80%E9%AB%98%E7%82%B9/"},{"categories":["算法——路径更新问题"],"content":"解题代码 BFS代码 class Solution { public: const int dx[4]={-1,1,0,0}; const int dy[4]={0,0,-1,1}; int n,m; bool isValid(int x,int y){ return x\u003cn\u0026\u0026x\u003e=0\u0026\u0026y\u003cm\u0026\u0026y\u003e=0; } const int maxn = 1e3+5; vector\u003cvector\u003cint\u003e\u003e highestPeak(vector\u003cvector\u003cint\u003e\u003e\u0026 isWater) { n = isWater.size(); m = isWater[0].size(); bool visit[maxn][maxn]; memset(visit,0,sizeof(visit)); queue\u003cpair\u003cint,int\u003e\u003eQ; for(int i=0;i\u003cn;i++){ for(int j=0;j\u003cm;j++){ if(isWater[i][j]){ visit[i][j] = 1; isWater[i][j] = 0; Q.push({i,j}); } } } int step = 1; while(!Q.empty()){ for(int i=Q.size();i\u003e0;i--){ auto[x,y] = Q.front();Q.pop(); for(int k=0;k\u003c4;k++){ int nx = x+dx[k]; int ny = y+dy[k]; if(isValid(nx,ny)\u0026\u0026!visit[nx][ny]){ visit[nx][ny] = 1; isWater[nx][ny] = step; Q.push({nx,ny}); } } } step++; } return isWater; } }; dp代码 class Solution { public: vector\u003cvector\u003cint\u003e\u003e highestPeak(vector\u003cvector\u003cint\u003e\u003e\u0026 isWater) { int n = isWater.size(); int m = isWater[0].size(); vector\u003cvector\u003cint\u003e\u003e dp(n, vector\u003cint\u003e(m, 1e9+7)); for(int i=0; i\u003cn; i++) { //从上到下从左到右 for(int j=0; j\u003cm; j++) { if(isWater[i][j]) dp[i][j] = 0; else { if(i \u003e 0) dp[i][j] = min(dp[i][j], dp[i-1][j]+1); if(j \u003e 0) dp[i][j] = min(dp[i][j], dp[i][j-1]+1); } } } for(int i=n-1; i\u003e=0; i--) { //从下到上从右到左 for(int j=m-1; j\u003e=0; j--) { if(isWater[i][j]) dp[i][j] = 0; else { if(i \u003c n-1) dp[i][j] = min(dp[i][j], dp[i+1][j]+1); if(j \u003c m-1) dp[i][j] = min(dp[i][j], dp[i][j+1]+1); } } } return dp; } }; ","date":"2022-01-29","objectID":"/posts/leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E5%9C%B0%E5%9B%BE%E4%B8%AD%E7%9A%84%E6%9C%80%E9%AB%98%E7%82%B9/:3:0","tags":["leetcode每日一题——地图中的最高点"],"title":"leetcode每日一题——地图中的最高点","uri":"/posts/leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E5%9C%B0%E5%9B%BE%E4%B8%AD%E7%9A%84%E6%9C%80%E9%AB%98%E7%82%B9/"},{"categories":["算法——贪心"],"content":"leetcode每日一题-游戏中弱角色的数量","date":"2022-01-28","objectID":"/posts/leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-%E6%B8%B8%E6%88%8F%E4%B8%AD%E5%BC%B1%E8%A7%92%E8%89%B2%E7%9A%84%E6%95%B0%E9%87%8F/","tags":["利用排序基于遍历过程处理的贪心-游戏中弱角色的数量"],"title":"leetcode每日一题-游戏中弱角色的数量","uri":"/posts/leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-%E6%B8%B8%E6%88%8F%E4%B8%AD%E5%BC%B1%E8%A7%92%E8%89%B2%E7%9A%84%E6%95%B0%E9%87%8F/"},{"categories":["算法——贪心"],"content":"题目 题目链接 ","date":"2022-01-28","objectID":"/posts/leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-%E6%B8%B8%E6%88%8F%E4%B8%AD%E5%BC%B1%E8%A7%92%E8%89%B2%E7%9A%84%E6%95%B0%E9%87%8F/:1:0","tags":["利用排序基于遍历过程处理的贪心-游戏中弱角色的数量"],"title":"leetcode每日一题-游戏中弱角色的数量","uri":"/posts/leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-%E6%B8%B8%E6%88%8F%E4%B8%AD%E5%BC%B1%E8%A7%92%E8%89%B2%E7%9A%84%E6%95%B0%E9%87%8F/"},{"categories":["算法——贪心"],"content":"解题思路 一句话解决：以第一个字段为标准从大到小排序，然后再遍历数组，对比第二字段的最大值即可。 关键细节： 为了避免第一个字段相同的情况下被更新，所以在排序时采取，攻击力降序防御力升序的方式(关键)来进行。 这样就让第一个字段相同时，按照从左到右的遍历顺序是不可能把第一个字段相同的情况拿来更新 cnt 。 ","date":"2022-01-28","objectID":"/posts/leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-%E6%B8%B8%E6%88%8F%E4%B8%AD%E5%BC%B1%E8%A7%92%E8%89%B2%E7%9A%84%E6%95%B0%E9%87%8F/:2:0","tags":["利用排序基于遍历过程处理的贪心-游戏中弱角色的数量"],"title":"leetcode每日一题-游戏中弱角色的数量","uri":"/posts/leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-%E6%B8%B8%E6%88%8F%E4%B8%AD%E5%BC%B1%E8%A7%92%E8%89%B2%E7%9A%84%E6%95%B0%E9%87%8F/"},{"categories":["算法——贪心"],"content":"解题代码 注意：golang 的代码中的断言型函数接口有点不一样。。它调用时用的是数组下标的形式来调用。 cpp version class Solution { public: //一句话解决：以第一个字段为标准从大到小排序，然后再遍历数组，对比第二字段的最大值即可。 //但为了避免第一个字段相同的情况下被更新，所以在排序时采取，攻击力降序防御力升序的方式(关键)来进行 //这样就让第一个字段相同时，按照从左到右的遍历顺序是不可能把第一个字段相同的情况拿来更新cnt。 int numberOfWeakCharacters(vector\u003cvector\u003cint\u003e\u003e\u0026 properties) { int n = properties.size(); auto cmp = [](vector\u003cint\u003e\u0026 t1,vector\u003cint\u003e\u0026t2){return t1[0]==t2[0]?t1[1]\u003ct2[1]:t1[0]\u003et2[0];}; sort(properties.begin(),properties.end(),cmp); int mx = INT_MIN; int cnt = 0; for(int i=0;i\u003cn;i++){ if(mx\u003eproperties[i][1]) cnt++; mx = max(mx,properties[i][1]); } return cnt; } }; java version class Solution { public int numberOfWeakCharacters(int[][] properties) { Arrays.sort(properties,(o1,o2)-\u003e o1[0]==o2[0]?o1[1]-o2[1]:o2[0]-o1[0]); int max = -1,cnt = 0; for(int[] p : properties){ if(p[1]\u003cmax) cnt++; max = Math.max(max,p[1]); } return cnt; } } golang version func numberOfWeakCharacters(properties [][]int) int { sort.Slice(properties,func (i int,j int) bool{//注意这个接口被写死只能用int型 p, q := properties[i], properties[j] return p[0] \u003e q[0] || p[0] == q[0] \u0026\u0026 p[1] \u003c q[1] }) var max = -1 cnt := 0 for _,v := range properties{ if max\u003ev[1] { cnt++ } max = int(math.Max(float64(max), float64(v[1]))) } return cnt } ","date":"2022-01-28","objectID":"/posts/leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-%E6%B8%B8%E6%88%8F%E4%B8%AD%E5%BC%B1%E8%A7%92%E8%89%B2%E7%9A%84%E6%95%B0%E9%87%8F/:3:0","tags":["利用排序基于遍历过程处理的贪心-游戏中弱角色的数量"],"title":"leetcode每日一题-游戏中弱角色的数量","uri":"/posts/leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-%E6%B8%B8%E6%88%8F%E4%B8%AD%E5%BC%B1%E8%A7%92%E8%89%B2%E7%9A%84%E6%95%B0%E9%87%8F/"},{"categories":["算法——贪心"],"content":"收获 被坑了，往二分+哈希表方向去写了。完全没想到之间排序+遍历就能解决。。。 排序的处理非常之精髓。 ","date":"2022-01-28","objectID":"/posts/leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-%E6%B8%B8%E6%88%8F%E4%B8%AD%E5%BC%B1%E8%A7%92%E8%89%B2%E7%9A%84%E6%95%B0%E9%87%8F/:4:0","tags":["利用排序基于遍历过程处理的贪心-游戏中弱角色的数量"],"title":"leetcode每日一题-游戏中弱角色的数量","uri":"/posts/leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-%E6%B8%B8%E6%88%8F%E4%B8%AD%E5%BC%B1%E8%A7%92%E8%89%B2%E7%9A%84%E6%95%B0%E9%87%8F/"},{"categories":["算法——计算几何"],"content":"leetcode每日一题-检测正方形","date":"2022-01-27","objectID":"/posts/leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-%E6%A3%80%E6%B5%8B%E6%AD%A3%E6%96%B9%E5%BD%A2/","tags":["leetcode每日一题-检测正方形"],"title":"leetcode每日一题-检测正方形","uri":"/posts/leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-%E6%A3%80%E6%B5%8B%E6%AD%A3%E6%96%B9%E5%BD%A2/"},{"categories":["算法——计算几何"],"content":"题目 题目链接 ","date":"2022-01-27","objectID":"/posts/leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-%E6%A3%80%E6%B5%8B%E6%AD%A3%E6%96%B9%E5%BD%A2/:1:0","tags":["leetcode每日一题-检测正方形"],"title":"leetcode每日一题-检测正方形","uri":"/posts/leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-%E6%A3%80%E6%B5%8B%E6%AD%A3%E6%96%B9%E5%BD%A2/"},{"categories":["算法——计算几何"],"content":"题目解析 注意此题为计算几何类型的题目，我认为这类问题最重要的就是把这个几何图形用好用的方法去表示出来。 三个重点： 点的表示：我们通过上下两点确定正方形的原则来表示，且点的存储方式一点不能用pair，这样效率及其低下，且难以有一定的自由度取操作 x，y 轴，我们采用哈希表套哈希表的方式取存储！ 点的记录：通过嵌套哈希表完成点的次数记录，比如： unordered_map\u003cint, unordered_map\u003cint, int\u003e\u003e cnt; cnt[y][x]++; 点的枚举：通过嵌套哈希表，可以很好的把 x，y 坐标的对应点数给限制住，所以我们要根据这点可以利用count方法直接把不是同一个纵轴的点给排除，比如： res += (colCnt.count(x) ? colCnt[x] : 0) * (yCnt.count(x + d) ? yCnt[x + d] : 0) * (colCnt.count(x + d)? colCnt[x + d] : 0); //一旦以上的count方法返回0，即表示该点不是同一个纵轴上的点，则得出结果0，整个res就相当于没有加任何数字。 再比如通过yCnt提前取出在同一个横轴的点： unordered_map\u003cint, int\u003e \u0026 yCnt = cnt[y]; //取和point在同一行的所有点 //这样后续的枚举过程直接可以套用yCnt[x+d]或者yCnt[x-d]来得到对应左右两种情况正方形的点个数。 最后一个优化：由于我们每次枚举同一纵轴上的点不确定是上面还是下面，实际上根本不重要，由于在计算时，我们都会把左右两种正方形的情况给计算完，而这个过程正好是两个相反的 +- 过程，所以无论枚举得到的正方形边长为正还是为负数，都不影响！ ","date":"2022-01-27","objectID":"/posts/leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-%E6%A3%80%E6%B5%8B%E6%AD%A3%E6%96%B9%E5%BD%A2/:2:0","tags":["leetcode每日一题-检测正方形"],"title":"leetcode每日一题-检测正方形","uri":"/posts/leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-%E6%A3%80%E6%B5%8B%E6%AD%A3%E6%96%B9%E5%BD%A2/"},{"categories":["算法——计算几何"],"content":"解题代码 非常详细的注释了 class DetectSquares { public: unordered_map\u003cint, unordered_map\u003cint, int\u003e\u003e cnt; DetectSquares() { } void add(vector\u003cint\u003e point) { int x = point[0], y = point[1]; cnt[y][x]++; } int count(vector\u003cint\u003e point) { int res = 0; int x = point[0], y = point[1]; if (!cnt.count(y)) { return 0; } unordered_map\u003cint, int\u003e \u0026 yCnt = cnt[y]; //取和point在同一行的所有点 for (auto \u0026 [col, colCnt] : cnt) { if (col != y) {//由于我们构造正方形是根据上下两条边，故此处枚举的另外一点不能在同一行 // 根据对称性，这里可以不用取绝对值，具体而言就是所有情况根据+-已经包括 int d = col - y;//得到正方形边长，根据这个值可以直接取到对应的另外几个点(如果存在的话) //这里的colCnt.count(x)用于判断是否和当前点在同一个纵轴，这样才可能构造上下两边，故下面只要有1个为0，则加的都是0 //由于我们指定了必须是同一个纵轴上的点，所以不可能构造出两个相同的正方形！ res += (colCnt.count(x) ? colCnt[x] : 0) * (yCnt.count(x + d) ? yCnt[x + d] : 0) * (colCnt.count(x + d)? colCnt[x + d] : 0); res += (colCnt.count(x) ? colCnt[x] : 0) * (yCnt.count(x - d) ? yCnt[x - d] : 0) * (colCnt.count(x - d) ? colCnt[x - d] : 0); } } return res; } }; ","date":"2022-01-27","objectID":"/posts/leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-%E6%A3%80%E6%B5%8B%E6%AD%A3%E6%96%B9%E5%BD%A2/:3:0","tags":["leetcode每日一题-检测正方形"],"title":"leetcode每日一题-检测正方形","uri":"/posts/leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-%E6%A3%80%E6%B5%8B%E6%AD%A3%E6%96%B9%E5%BD%A2/"},{"categories":["算法——计算几何"],"content":"总结 学到以下： 如何通过嵌套哈希表表示点，以及用它表示的而不用pair表示的好处。 重点好像也就上面那条。 ","date":"2022-01-27","objectID":"/posts/leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-%E6%A3%80%E6%B5%8B%E6%AD%A3%E6%96%B9%E5%BD%A2/:4:0","tags":["leetcode每日一题-检测正方形"],"title":"leetcode每日一题-检测正方形","uri":"/posts/leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-%E6%A3%80%E6%B5%8B%E6%AD%A3%E6%96%B9%E5%BD%A2/"},{"categories":["JavaWeb笔记"],"content":"Java网络编程","date":"2022-01-26","objectID":"/posts/java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/","tags":["JavaWeb第一节"],"title":"Java网络编程","uri":"/posts/java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"categories":["JavaWeb笔记"],"content":"Java网络编程 配套视频 在JavaSE阶段，我们学习了I/O流，既然I/O流如此强大，那么能否跨越不同的主机进行I/O操作呢？这就要提到Java的网络编程了。 注意：本章会涉及到计算机网络相关内容（只会讲解大致内容，不会完整的讲解计算机网络知识） 若没有计算机网络基础，实际上Java这里封装的Socket网络IO操作已经简单到完全不需要任何基础的，但是没有计算机网络相关的底层知识，以后的深入学习会非常不知所云。 ","date":"2022-01-26","objectID":"/posts/java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/:0:0","tags":["JavaWeb第一节"],"title":"Java网络编程","uri":"/posts/java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"categories":["JavaWeb笔记"],"content":"计算机网络基础 利用通信线路和通信设备，将地理位置不同的、功能独立的多台计算机互连起来，以功能完善的网络软件来实现资源共享和信息传递，就构成了计算机网络系统。 比如我们家里的路由器，通过将我们的设备（手机、平板、电脑、电视剧）连接到路由器，来实现对互联网的访问。实际上，我们的路由器连接在互联网上，而我们的设备又连接了路由器，这样我们的设备就可以通过路由器访问到互联网了。通过网络，我们可以直接访问互联网上的另一台主机，比如我们要把QQ的消息发送给我们的朋友，或是通过远程桌面管理来操作另一台电脑，也可以是连接本地网络上的打印机。 既然我们可以通过网络访问其他计算机，那么如何区别不同的计算机呢？通过IP地址，我们就可以区分不同的计算机了： 每一台电脑在同一个网络上都有一个自己的IP地址，用于区别于其他的电脑，我们可以通过对方主机的IP地址对其进行访问。那么我手机连接的移动流量，能访问到连接家里路由器的电脑吗？（不能，因为他们不属于同一个网络） 而我们的电脑上可能运行着大量的程序，每一个程序可能都需要通过网络来访问其他计算机，那这时该如何区分呢？我们可以通过端口号来区分： 因此，我们一般看到的是这样的：192.168.0.11:8080，通过IP:端口的形式来访问目标主机上的一个应用程序服务。注意端口号只能是0-65535之间的值！ IP地址分为IPv4和IPv6，IPv4类似于192.168.0.11，我们上面提到的例子都是使用的IPv4，它一共有四组数字，每组数字占8个bit位，IPv4地址0.0.0.0表示为2进制就是：00000000.00000000.00000000.00000000，共32个bit，最大为255.255.255.255，实际上，IPv4能够表示的所有地址，早就已经被用完了。IPv6能够保存128个bit位，因此它也可以表示更多的IP地址，一个IPv6地址看起来像这样：1030::C9B4:FF12:48AA:1A2B，目前也正在向IPv6的阶段过度。 TCP和UDP是两种不同的传输层协议： TCP：当一台计算机想要与另一台计算机通讯时，两台计算机之间的通信需要畅通且可靠（会进行三次握手，断开也会进行四次挥手），这样才能保证正确收发数据，因此TCP更适合一些可靠的数据传输场景。 UDP：它是一种无连接协议，数据想发就发，而且不会建立可靠传输，也就是说传输过程中有可能会导致部分数据丢失，但是它比TCP传输更加简单高效，适合视频直播之类的。 ","date":"2022-01-26","objectID":"/posts/java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/:1:0","tags":["JavaWeb第一节"],"title":"Java网络编程","uri":"/posts/java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"categories":["JavaWeb笔记"],"content":"了解Socket技术 通过Socket技术（它是计算机之间进行通信的一种约定或一种方式），我们就可以实现两台计算机之间的通信，Socket也被翻译为套接字，是操作系统底层提供的一项通信技术，它支持TCP和UDP。而Java就对socket底层支持进行了一套完整的封装，我们可以通过Java来实现Socket通信。 要实现Socket通信，我们必须创建一个数据发送者和一个数据接收者，也就是客户端和服务端，我们需要提前启动服务端，来等待客户端的连接，而客户端只需要随时启动去连接服务端即可！ //服务端 public static void main(String[] args) { try(ServerSocket server = new ServerSocket(8080)){ //将服务端创建在端口8080上 System.out.println(\"正在等待客户端连接...\"); Socket socket = server.accept(); //当没有客户端连接时，线程会阻塞，直到有客户端连接为止 System.out.println(\"客户端已连接，IP地址为：\"+socket.getInetAddress().getHostAddress()); }catch (IOException e){ e.printStackTrace(); } } //客户端 public static void main(String[] args) { try (Socket socket = new Socket(\"localhost\", 8080)){ System.out.println(\"已连接到服务端！\"); }catch (IOException e){ System.out.println(\"服务端连接失败！\"); e.printStackTrace(); } } 实际上它就是一个TCP连接的建立过程： 一旦TCP连接建立，服务端和客户端之间就可以相互发送数据，直到客户端主动关闭连接。当然，服务端不仅仅只可以让一个客户端进行连接，我们可以尝试让服务端一直运行来不断接受客户端的连接： public static void main(String[] args) { try(ServerSocket server = new ServerSocket(8080)){ //将服务端创建在端口8080上 System.out.println(\"正在等待客户端连接...\"); while (true){ //无限循环等待客户端连接 Socket socket = server.accept(); System.out.println(\"客户端已连接，IP地址为：\"+socket.getInetAddress().getHostAddress()); } }catch (IOException e){ e.printStackTrace(); } } 现在我们就可以多次去连接此服务端了。 ","date":"2022-01-26","objectID":"/posts/java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/:2:0","tags":["JavaWeb第一节"],"title":"Java网络编程","uri":"/posts/java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"categories":["JavaWeb笔记"],"content":"使用Socket进行数据传输 通过Socket对象，我们就可以获取到对应的I/O流进行网络数据传输： public static void main(String[] args) { try (Socket socket = new Socket(\"localhost\", 8080); Scanner scanner = new Scanner(System.in)){ System.out.println(\"已连接到服务端！\"); OutputStream stream = socket.getOutputStream(); OutputStreamWriter writer = new OutputStreamWriter(stream); //通过转换流来帮助我们快速写入内容 System.out.println(\"请输入要发送给服务端的内容：\"); String text = scanner.nextLine(); writer.write(text+'\\n'); //因为对方是readLine()这里加个换行符 writer.flush(); System.out.println(\"数据已发送：\"+text); }catch (IOException e){ System.out.println(\"服务端连接失败！\"); e.printStackTrace(); }finally { System.out.println(\"客户端断开连接！\"); } } } public static void main(String[] args) { try(ServerSocket server = new ServerSocket(8080)){ //将服务端创建在端口8080上 System.out.println(\"正在等待客户端连接...\"); Socket socket = server.accept(); System.out.println(\"客户端已连接，IP地址为：\"+socket.getInetAddress().getHostAddress()); BufferedReader reader = new BufferedReader(new InputStreamReader(socket.getInputStream())); //通过 System.out.print(\"接收到客户端数据：\"); System.out.println(reader.readLine()); socket.close(); //和服务端TCP连接完成之后，记得关闭socket }catch (IOException e){ e.printStackTrace(); } } 同理，既然服务端可以读取客户端的内容，客户端也可以在发送后等待服务端给予响应： public static void main(String[] args) { try (Socket socket = new Socket(\"localhost\", 8080); Scanner scanner = new Scanner(System.in)){ System.out.println(\"已连接到服务端！\"); OutputStream stream = socket.getOutputStream(); OutputStreamWriter writer = new OutputStreamWriter(stream); //通过转换流来帮助我们快速写入内容 System.out.println(\"请输入要发送给服务端的内容：\"); String text = scanner.nextLine(); writer.write(text+'\\n'); //因为对方是readLine()这里加个换行符 writer.flush(); System.out.println(\"数据已发送：\"+text); BufferedReader reader = new BufferedReader(new InputStreamReader(socket.getInputStream())); System.out.println(\"收到服务器返回：\"+reader.readLine()); }catch (IOException e){ System.out.println(\"服务端连接失败！\"); e.printStackTrace(); }finally { System.out.println(\"客户端断开连接！\"); } } public static void main(String[] args) { try(ServerSocket server = new ServerSocket(8080)){ //将服务端创建在端口8080上 System.out.println(\"正在等待客户端连接...\"); Socket socket = server.accept(); System.out.println(\"客户端已连接，IP地址为：\"+socket.getInetAddress().getHostAddress()); BufferedReader reader = new BufferedReader(new InputStreamReader(socket.getInputStream())); //通过 System.out.print(\"接收到客户端数据：\"); System.out.println(reader.readLine()); OutputStreamWriter writer = new OutputStreamWriter(socket.getOutputStream()); writer.write(\"已收到！\"); writer.flush(); }catch (IOException e){ e.printStackTrace(); } } 我们可以手动关闭单向的流： socket.shutdownOutput(); //关闭输出方向的流 socket.shutdownInput(); //关闭输入方向的流 如果我们不希望服务端等待太长的时间，我们可以通过调用setSoTimeout()方法来设定IO超时时间： socket.setSoTimeout(3000); 当超过设定时间都依然没有收到客户端或是服务端的数据时，会抛出异常： java.net.SocketTimeoutException: Read timed out at java.net.SocketInputStream.socketRead0(Native Method) at java.net.SocketInputStream.socketRead(SocketInputStream.java:116) at java.net.SocketInputStream.read(SocketInputStream.java:171) at java.net.SocketInputStream.read(SocketInputStream.java:141) at sun.nio.cs.StreamDecoder.readBytes(StreamDecoder.java:284) at sun.nio.cs.StreamDecoder.implRead(StreamDecoder.java:326) at sun.nio.cs.StreamDecoder.read(StreamDecoder.java:178) at java.io.InputStreamReader.read(InputStreamReader.java:184) at java.io.BufferedReader.fill(BufferedReader.java:161) at java.io.BufferedReader.readLine(BufferedReader.java:324) at java.io.BufferedReader.readLine(BufferedReader.java:389) at com.test.Main.main(Main.java:41) 我们之前使用的都是通过构造方法直接连接服务端，那么是否可以等到我们想要的时候再去连接呢？ try (Socket socket = new Socket(); //调用无参构造不会自动连接 Scanner scanner = new Scanner(System.in)){ socket.connect(new InetSocketAddress(\"localhost\", 8080), 1000); //手动调用connect方法进行连接 如果连接的双方发生意外而通知不到对方，导致一方还持有连接，这样就会占用资源，因此我们可以使用setKeepAlive()方法来防止此类情况发生： socket.setKeepAlive(true); 当客户端连接后，如果设置了keeplive为 true，当对方没有发送任何数据过来，超过一个时间(看系统内核参数配置)，那么我们这边会发送一个ack探测包发到对方，探测双方的TCP/IP连接是否有效。 TCP在传输过程中，实际上会有一个缓冲区用于数据的发送和接收： 此缓冲区大小为：8192，我们可以手动调整其大小来优化传输效率： socket.setReceiveBufferSize(25565); /","date":"2022-01-26","objectID":"/posts/java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/:3:0","tags":["JavaWeb第一节"],"title":"Java网络编程","uri":"/posts/java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"categories":["JavaWeb笔记"],"content":"使用Socket传输文件 既然Socket为我们提供了IO流便于数据传输，那么我们就可以轻松地实现文件传输了。 ","date":"2022-01-26","objectID":"/posts/java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/:4:0","tags":["JavaWeb第一节"],"title":"Java网络编程","uri":"/posts/java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"categories":["JavaWeb笔记"],"content":"使用浏览器访问Socket服务器 在了解了如何使用Socket传输文件后，我们来看看，浏览器是如何向服务器发起请求的： public static void main(String[] args) { try(ServerSocket server = new ServerSocket(8080)){ //将服务端创建在端口8080上 System.out.println(\"正在等待客户端连接...\"); Socket socket = server.accept(); System.out.println(\"客户端已连接，IP地址为：\"+socket.getInetAddress().getHostAddress()); InputStream in = socket.getInputStream(); //通过 System.out.println(\"接收到客户端数据：\"); while (true){ int i = in.read(); if(i == -1) break; System.out.print((char) i); } }catch (Exception e){ e.printStackTrace(); } } 我们现在打开浏览器，输入http://localhost:8080或是http://127.0.0.1:8080/，来连接我们本地开放的服务器。 我们发现浏览器是无法打开这个链接的，但是我们服务端却收到了不少的信息： GET / HTTP/1.1\rHost: 127.0.0.1:8080\rConnection: keep-alive\rCache-Control: max-age=0\rsec-ch-ua: \"Chromium\";v=\"94\", \"Google Chrome\";v=\"94\", \";Not A Brand\";v=\"99\"\rsec-ch-ua-mobile: ?0\rsec-ch-ua-platform: \"macOS\"\rUpgrade-Insecure-Requests: 1\rUser-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/94.0.4606.81 Safari/537.36\rAccept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9\rSec-Fetch-Site: none\rSec-Fetch-Mode: navigate\rSec-Fetch-User: ?1\rSec-Fetch-Dest: document\rAccept-Encoding: gzip, deflate, br\rAccept-Language: zh-CN,zh;q=0.9,und;q=0.8,en;q=0.7\r实际上这些内容都是Http协议规定的请求头内容。HTTP是一种应用层协议，全称为超文本传输协议，它本质也是基于TCP协议进行数据传输，因此我们的服务端能够读取HTTP请求。但是Http协议并不会保持长连接，在得到我们响应的数据后会立即关闭TCP连接。 既然使用的是Http连接，如果我们的服务器要支持响应HTTP请求，那么就需要按照HTTP协议的规则，返回一个规范的响应文本，首先是响应头，它至少要包含一个响应码： HTTP/1.1 200 Accpeted\r然后就是响应内容（注意一定要换行再写），我们尝试来编写一下支持HTTP协议的响应内容： public static void main(String[] args) { try(ServerSocket server = new ServerSocket(8080)){ //将服务端创建在端口8080上 System.out.println(\"正在等待客户端连接...\"); Socket socket = server.accept(); System.out.println(\"客户端已连接，IP地址为：\"+socket.getInetAddress().getHostAddress()); BufferedReader reader = new BufferedReader(new InputStreamReader(socket.getInputStream())); //通过 System.out.println(\"接收到客户端数据：\"); while (reader.ready()) System.out.println(reader.readLine()); //ready是判断当前流中是否还有可读内容 OutputStreamWriter writer = new OutputStreamWriter(socket.getOutputStream()); writer.write(\"HTTP/1.1 200 Accepted\\r\\n\"); //200是响应码，Http协议规定200为接受请求，400为错误的请求，404为找不到此资源（不止这些，还有很多） writer.write(\"\\r\\n\"); //在请求头写完之后还要进行一次换行，然后写入我们的响应实体（会在浏览器上展示的内容） writer.write(\"lbwnb!\"); writer.flush(); }catch (Exception e){ e.printStackTrace(); } } 我们可以打开浏览器的开发者模式（这里推荐使用Chrome/Edge浏览器，按下F12即可打开），我们来观察一下浏览器的实际请求过程。 ","date":"2022-01-26","objectID":"/posts/java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/:5:0","tags":["JavaWeb第一节"],"title":"Java网络编程","uri":"/posts/java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"categories":["Linux网络编程"],"content":"TCP网络编程中connect、listen、accept三者之间的关系","date":"2022-01-26","objectID":"/posts/tcp%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E4%B8%ADconnectlistenaccept%E4%B8%89%E8%80%85%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB/","tags":["TCP网络编程中connect、listen、accept三者之间的关系"],"title":"TCP网络编程中connect、listen、accept三者之间的关系","uri":"/posts/tcp%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E4%B8%ADconnectlistenaccept%E4%B8%89%E8%80%85%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB/"},{"categories":["Linux网络编程"],"content":" 基于 TCP 的网络编程开发分为服务器端和客户端两部分，常见的核心步骤和流程如下： 整个函数调用(image)\"\r整个函数调用(image)\r ","date":"2022-01-26","objectID":"/posts/tcp%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E4%B8%ADconnectlistenaccept%E4%B8%89%E8%80%85%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB/:0:0","tags":["TCP网络编程中connect、listen、accept三者之间的关系"],"title":"TCP网络编程中connect、listen、accept三者之间的关系","uri":"/posts/tcp%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E4%B8%ADconnectlistenaccept%E4%B8%89%E8%80%85%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB/"},{"categories":["Linux网络编程"],"content":"accept()函数 对于客户端的 connect() 函数，该函数的功能为客户端主动连接服务器，建立连接是通过三次握手，而这个连接的过程是由内核完成，不是这个函数完成的，这个函数的作用仅仅是通知 Linux 内核，让 Linux 内核自动完成 TCP 三次握手连接，最后把连接的结果返回给这个函数的返回值（成功连接为0， 失败为-1）。 通常的情况，客户端的 connect() 函数默认会一直阻塞，直到三次握手成功或超时失败才返回（正常的情况，这个过程很快完成）。 ","date":"2022-01-26","objectID":"/posts/tcp%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E4%B8%ADconnectlistenaccept%E4%B8%89%E8%80%85%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB/:1:0","tags":["TCP网络编程中connect、listen、accept三者之间的关系"],"title":"TCP网络编程中connect、listen、accept三者之间的关系","uri":"/posts/tcp%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E4%B8%ADconnectlistenaccept%E4%B8%89%E8%80%85%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB/"},{"categories":["Linux网络编程"],"content":"listen()函数 对于服务器，它是被动连接的。举一个生活中的例子，通常的情况下，移动的客服（相当于服务器）是等待着客户（相当于客户端）电话的到来。而这个过程，需要调用listen()函数。 #include\u003csys/socket.h\u003eint listen(int sockfd, int backlog); listen() 函数的主要作用就是将套接字( sockfd )变成被动的连接监听套接字（被动等待客户端的连接），至于参数 backlog 的作用是设置内核中连接队列的长度（这个长度有什么用，后面做详细的解释），TCP 三次握手也不是由这个函数完成，listen()的作用仅仅告诉内核一些信息。 这样的话，当有一个客户端主动连接 connect()，Linux 内核就自动完成TCP 三次握手，将建立好的链接自动存储到队列中，如此重复。 所以，只要 TCP 服务器调用了 listen()，客户端就可以通过 connect() 和服务器建立连接，而这个连接的过程是由内核完成。 三次握手\"\r三次握手\r 下面为测试的服务器和客户端代码，运行程序时，要先运行服务器，再运行客户端： 服务器： #include \u003cstdio.h\u003e#include \u003cstdlib.h\u003e#include \u003cstring.h\u003e #include \u003cunistd.h\u003e#include \u003csys/socket.h\u003e#include \u003cnetinet/in.h\u003e#include \u003carpa/inet.h\u003e int main(int argc, char *argv[]) { unsigned short port = 8000; int sockfd; sockfd = socket(AF_INET, SOCK_STREAM, 0);// 创建通信端点：套接字 if(sockfd \u003c 0) { perror(\"socket\"); exit(-1); } struct sockaddr_in my_addr; bzero(\u0026my_addr, sizeof(my_addr)); my_addr.sin_family = AF_INET; my_addr.sin_port = htons(port); my_addr.sin_addr.s_addr = htonl(INADDR_ANY); int err_log = bind(sockfd, (struct sockaddr*)\u0026my_addr, sizeof(my_addr)); if( err_log != 0) { perror(\"binding\"); close(sockfd); exit(-1); } err_log = listen(sockfd, 10); if(err_log != 0) { perror(\"listen\"); close(sockfd); exit(-1); } printf(\"listen client @port=%d...\\n\",port); sleep(10); // 延时10s system(\"netstat -an | grep 8000\"); // 查看连接状态 return 0; } 客户端 #include \u003cstdio.h\u003e#include \u003cunistd.h\u003e#include \u003cstring.h\u003e#include \u003cstdlib.h\u003e#include \u003carpa/inet.h\u003e#include \u003csys/socket.h\u003e#include \u003cnetinet/in.h\u003eint main(int argc, char *argv[]) { unsigned short port = 8000; // 服务器的端口号 char *server_ip = \"10.221.20.12\"; // 服务器ip地址 int sockfd; sockfd = socket(AF_INET, SOCK_STREAM, 0);// 创建通信端点：套接字 if(sockfd \u003c 0) { perror(\"socket\"); exit(-1); } struct sockaddr_in server_addr; bzero(\u0026server_addr,sizeof(server_addr)); // 初始化服务器地址 server_addr.sin_family = AF_INET; server_addr.sin_port = htons(port); inet_pton(AF_INET, server_ip, \u0026server_addr.sin_addr); int err_log = connect(sockfd, (struct sockaddr*)\u0026server_addr, sizeof(server_addr)); // 主动连接服务器 if(err_log != 0) { perror(\"connect\"); close(sockfd); exit(-1); } system(\"netstat -an | grep 8000\"); // 查看连接状态 while(1); return 0; } 运行结果： ","date":"2022-01-26","objectID":"/posts/tcp%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E4%B8%ADconnectlistenaccept%E4%B8%89%E8%80%85%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB/:2:0","tags":["TCP网络编程中connect、listen、accept三者之间的关系"],"title":"TCP网络编程中connect、listen、accept三者之间的关系","uri":"/posts/tcp%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E4%B8%ADconnectlistenaccept%E4%B8%89%E8%80%85%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB/"},{"categories":["Linux网络编程"],"content":"三次握手的连接队列 这里详细的介绍一下 listen() 函数的第二个参数（ backlog）的作用：告诉内核连接队列的长度。 为了更好的理解 backlog 参数，我们必须认识到内核为任何一个给定的监听套接口维护两个队列： 未完成连接队列（incomplete connection queue），以某个客户发出并到达服务器，而服务器正在等待完成相应的 TCP 三次握手过程。这些端口都处于处于 SYN_RCVD 状态。 已完成连接队列（completed connection queue），这些端口处于 ESTABLISHED 状态。 当来自客户的 SYN 到达时，TCP 在未完成连接队列中创建一个新项，然后响应以三次握手的第二个分节：服务器的 SYN 响应，其中稍带对客户 SYN 的 ACK（即SYN+ACK），这一项一直保留在未完成连接队列中，直到三次握手的第三个分节（客户对服务器 SYN 的 ACK ）到达或者该项超时为止（源自Berkeley的实现为这些未完成连接的项设置的超时值为75秒）。 如果三次握手正常完成，该项就从未完成连接队列移到已完成连接队列的队尾。 backlog 参数历史上被定义为上面两个队列的大小之和，大多数实现默认值为 5，当服务器把这个完成连接队列的某个连接取走后，这个队列的位置又空出一个，这样来回实现动态平衡，但在高并发 web 服务器中此值显然不够。 ","date":"2022-01-26","objectID":"/posts/tcp%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E4%B8%ADconnectlistenaccept%E4%B8%89%E8%80%85%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB/:3:0","tags":["TCP网络编程中connect、listen、accept三者之间的关系"],"title":"TCP网络编程中connect、listen、accept三者之间的关系","uri":"/posts/tcp%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E4%B8%ADconnectlistenaccept%E4%B8%89%E8%80%85%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB/"},{"categories":["Linux网络编程"],"content":"accept()函数 accept()函数功能是，从处于 established 状态的连接队列头部取出一个已经完成的连接，如果这个队列没有已经完成的连接，accept()函数就会阻塞，直到取出队列中已完成的用户连接为止。 如果，服务器不能及时调用 accept() 取走队列中已完成的连接，队列满掉后会怎样呢？UNP（《unix网络编程》）告诉我们，服务器的连接队列满掉后，服务器不会对再对建立新连接的syn进行应答，所以客户端的 connect 就会返回 ETIMEDOUT。但实际上Linux的并不是这样的！ ","date":"2022-01-26","objectID":"/posts/tcp%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E4%B8%ADconnectlistenaccept%E4%B8%89%E8%80%85%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB/:4:0","tags":["TCP网络编程中connect、listen、accept三者之间的关系"],"title":"TCP网络编程中connect、listen、accept三者之间的关系","uri":"/posts/tcp%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E4%B8%ADconnectlistenaccept%E4%B8%89%E8%80%85%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB/"},{"categories":["Linux网络编程"],"content":"实验 下面为测试代码，服务器 listen() 函数只指定队列长度为 2，客户端有 6 个不同的套接字主动连接服务器，同时，保证客户端的 6 个 connect()函数都先调用完毕，服务器的 accpet() 才开始调用。 服务端： #include \u003cstdio.h\u003e#include \u003cstdlib.h\u003e#include \u003cstring.h\u003e #include \u003cunistd.h\u003e#include \u003csys/socket.h\u003e#include \u003cnetinet/in.h\u003e#include \u003carpa/inet.h\u003e int main(int argc, char *argv[]) { unsigned short port = 8000; int sockfd = socket(AF_INET, SOCK_STREAM, 0); if(sockfd \u003c 0) { perror(\"socket\"); exit(-1); } struct sockaddr_in my_addr; bzero(\u0026my_addr, sizeof(my_addr)); my_addr.sin_family = AF_INET; my_addr.sin_port = htons(port); my_addr.sin_addr.s_addr = htonl(INADDR_ANY); int err_log = bind(sockfd, (struct sockaddr*)\u0026my_addr, sizeof(my_addr)); if( err_log != 0) { perror(\"binding\"); close(sockfd); exit(-1); } err_log = listen(sockfd, 2); // 等待队列为2 if(err_log != 0) { perror(\"listen\"); close(sockfd); exit(-1); } printf(\"after listen\\n\"); sleep(20); //延时 20秒 printf(\"listen client @port=%d...\\n\",port); int i = 0; while(1) { struct sockaddr_in client_addr; char cli_ip[INET_ADDRSTRLEN] = \"\"; socklen_t cliaddr_len = sizeof(client_addr); int connfd; connfd = accept(sockfd, (struct sockaddr*)\u0026client_addr, \u0026cliaddr_len); if(connfd \u003c 0) { perror(\"accept\"); continue; } inet_ntop(AF_INET, \u0026client_addr.sin_addr, cli_ip, INET_ADDRSTRLEN); printf(\"-----------%d------\\n\", ++i); printf(\"client ip=%s,port=%d\\n\", cli_ip,ntohs(client_addr.sin_port)); char recv_buf[512] = {0}; while( recv(connfd, recv_buf, sizeof(recv_buf), 0) \u003e 0 ) { printf(\"recv data ==%s\\n\",recv_buf); break; } close(connfd); //关闭已连接套接字 //printf(\"client closed!\\n\"); } close(sockfd); //关闭监听套接字 return 0; } 客户端： #include \u003cstdio.h\u003e#include \u003cunistd.h\u003e#include \u003cstring.h\u003e#include \u003cstdlib.h\u003e#include \u003carpa/inet.h\u003e#include \u003csys/socket.h\u003e#include \u003cnetinet/in.h\u003e void test_connect() { unsigned short port = 8000; // 服务器的端口号 char *server_ip = \"10.221.20.12\"; // 服务器ip地址 int sockfd; sockfd = socket(AF_INET, SOCK_STREAM, 0);// 创建通信端点：套接字 if(sockfd \u003c 0) { perror(\"socket\"); exit(-1); } struct sockaddr_in server_addr; bzero(\u0026server_addr,sizeof(server_addr)); // 初始化服务器地址 server_addr.sin_family = AF_INET; server_addr.sin_port = htons(port); inet_pton(AF_INET, server_ip, \u0026server_addr.sin_addr); int err_log = connect(sockfd, (struct sockaddr*)\u0026server_addr, sizeof(server_addr)); // 主动连接服务器 if(err_log != 0) { perror(\"connect\"); close(sockfd); exit(-1); } printf(\"err_log ========= %d\\n\", err_log); char send_buf[100]=\"this is for test\"; send(sockfd, send_buf, strlen(send_buf), 0); // 向服务器发送信息 system(\"netstat -an | grep 8000\"); // 查看连接状态 //close(sockfd); } int main(int argc, char *argv[]) { pid_t pid; pid = fork(); if(0 == pid){ test_connect(); // 1 pid_t pid = fork(); if(0 == pid){ test_connect(); // 2 }else if(pid \u003e 0){ test_connect(); // 3 } }else if(pid \u003e 0){ test_connect(); // 4 pid_t pid = fork(); if(0 == pid){ test_connect(); // 5 }else if(pid \u003e 0){ test_connect(); // 6 } } while(1); return 0; } 服务器调用 accept()函数前延时了 20 秒。保证了客户端的 connect() 全部调用完毕后再调用 accept(),运行结果如下： 客户端运行效果图： 按照 UNP 的说法，连接队列满后（这里设置长度为 2，发了 6 个连接），以后再调用 connect() 应该统统超时失败，但实际上测试结果是：有的 connect()立刻成功返回了，有的经过明显延迟后成功返回了。对于服务器 accpet() 函数也是这样的结果：有的立马成功返回，有的延迟后成功返回。 对于上面服务器的代码，我们把lisen()的第二个参数改为 0 ，重新运行程序，发现： 客户端 connect() 全部返回连接成功（有些会延时）： 服务器 accpet() 函数却不能把连接队列的所有连接都取出来： 对于上面服务器的代码，我们把lisen()的第二个参数改为大于 6 的数(如 10)，重新运行程序，发现，客户端 connect() 立马返回连接成功， 服务器 accpet() 函数也立马返回成功。 ","date":"2022-01-26","objectID":"/posts/tcp%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E4%B8%ADconnectlistenaccept%E4%B8%89%E8%80%85%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB/:4:1","tags":["TCP网络编程中connect、listen、accept三者之间的关系"],"title":"TCP网络编程中connect、listen、accept三者之间的关系","uri":"/posts/tcp%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E4%B8%ADconnectlistenaccept%E4%B8%89%E8%80%85%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB/"},{"categories":["Linux网络编程"],"content":"总结 TCP 的连接队列满后，Linux 不会如书中所说的拒绝连接，只是有些会延时连接，但千万注意此时accept()就不一定能把已经建立好的连接全部取出来（如：当队列的长度指定为 0 ），写程序时服务器的 listen() 的第二个参数最好还是根据需要填写，写太大不好（具体可以看cat /proc/sys/net/core/somaxconn，默认最大值限制是 128），浪费资源，写太小也不好，延时建立连接。 ","date":"2022-01-26","objectID":"/posts/tcp%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E4%B8%ADconnectlistenaccept%E4%B8%89%E8%80%85%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB/:4:2","tags":["TCP网络编程中connect、listen、accept三者之间的关系"],"title":"TCP网络编程中connect、listen、accept三者之间的关系","uri":"/posts/tcp%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E4%B8%ADconnectlistenaccept%E4%B8%89%E8%80%85%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB/"},{"categories":["现代C++语法"],"content":"C++与python文件系统对比","date":"2022-01-25","objectID":"/posts/c++%E4%B8%8Epython%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%AF%B9%E6%AF%94/","tags":["C++与python文件系统对比"],"title":"C++与python文件系统对比","uri":"/posts/c++%E4%B8%8Epython%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%AF%B9%E6%AF%94/"},{"categories":["现代C++语法"],"content":"C++17 和 python 中好用的文件操作 | filesystem | os | shutil C++ 17 python 功能 filesystem::path::is_absolute() os.path.isabs() 判断是否为绝对路径 filesystem::path::parent_path() os.path.dirname() 路径分割 filesystem::path::filename() os.path.basename() 路径分割 filesystem::operator/() os.path.join() 路径拼接 filesystem::current_path() os.getcwd() 获取当前路径 filesystem::directory_iterator os.listdir() 返回指定目录下的所有文件/文件夹 filesystem::recursive_directory_iterator os.walk() 递归返回指定目录下的所有文件/文件夹 filesystem::exists() os.path.exists() 判断路径是否存在 filesystem::is_regular_file() os.path.isfile() 判断路径是文件还是目录 filesystem::is_directory() os.path.isdir() 判断路径是文件还是目录 filesystem::absolute() os.path.abspath() 返回绝对路径 filesystem::copy_file() shutil.copyfile() 文件拷贝 filesystem::remove() os.remove() 文件删除 filesystem::copy() shutil.copytree 路径拷贝 filesystem::remove_all shutil.rmtree() 路径删除 ","date":"2022-01-25","objectID":"/posts/c++%E4%B8%8Epython%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%AF%B9%E6%AF%94/:0:0","tags":["C++与python文件系统对比"],"title":"C++与python文件系统对比","uri":"/posts/c++%E4%B8%8Epython%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%AF%B9%E6%AF%94/"},{"categories":["现代C++语法"],"content":"filesystem::path vs. os.path filesystem::path是一个类，里面封装了很多方法，我们通过实例化之后直接调用方法。 os.path是一个模块，里面有很多函数，可以直接调用。 ","date":"2022-01-25","objectID":"/posts/c++%E4%B8%8Epython%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%AF%B9%E6%AF%94/:1:0","tags":["C++与python文件系统对比"],"title":"C++与python文件系统对比","uri":"/posts/c++%E4%B8%8Epython%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%AF%B9%E6%AF%94/"},{"categories":["现代C++语法"],"content":"判断是否为绝对路径 什么是绝对路径？我个人的理解是从根目录开始的就是绝对路径，例如/usr/local和C:\\\\Users，其余都是相对路径。可以发现，在不同操作系统中路径的分割符是不同的。同时在相对路径中./和../有特殊含义，./表示当前目录，../表示上一层目录，相应地，../../就是上两层目录。 1.filesystem::path中提供了判断是否为绝对路径/相对路径方法。 _LIBCPP_INLINE_VISIBILITY bool is_absolute() const { return has_root_directory(); } _LIBCPP_INLINE_VISIBILITY bool is_relative() const { return !is_absolute(); } 可以发现，判断相对路径的结果就是绝对路径取反。 void eg1_1() { /*判断是否为绝对路径*/ // std::filesystem::path abs_path = \"C:\\\\Users\"; std::filesystem::path abs_path = \"/usr/local\"; // 注意，实例化path的时候可以直接用等号 std::cout \u003c\u003c \"abs_path.is_absolute() : \" \u003c\u003c abs_path.is_absolute() \u003c\u003c std::endl; std::cout \u003c\u003c \"abs_path.is_relative() : \" \u003c\u003c abs_path.is_relative() \u003c\u003c std::endl; std::filesystem::path rel_path = \"../\"; std::cout \u003c\u003c \"rel_path.is_absolute() : \" \u003c\u003c rel_path.is_absolute() \u003c\u003c std::endl; std::cout \u003c\u003c \"rel_path.is_relative() : \" \u003c\u003c rel_path.is_relative() \u003c\u003c std::endl; } abs_path.is_absolute() : 1 abs_path.is_relative() : 0 rel_path.is_absolute() : 0 rel_path.is_relative() : 1 os.path中提供了isabs()函数用于判断是否为绝对路径。 def eg1_1(): \"\"\"判断是否为绝对路径\"\"\" # abs_path = \"C:\\\\Users\" abs_path = \"/usr/local\" print(\"os.path.isabs({}) : {}\".format(abs_path, os.path.isabs(abs_path))) rel_path = \"../\" print(\"os.path.isabs({}) : {}\".format(rel_path, os.path.isabs(rel_path))) os.path.isabs(/usr/local) : True os.path.isabs(../) : False ","date":"2022-01-25","objectID":"/posts/c++%E4%B8%8Epython%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%AF%B9%E6%AF%94/:1:1","tags":["C++与python文件系统对比"],"title":"C++与python文件系统对比","uri":"/posts/c++%E4%B8%8Epython%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%AF%B9%E6%AF%94/"},{"categories":["现代C++语法"],"content":"路径分割 filesystem::path中提供了路径分割的方法。 // decomposition _LIBCPP_INLINE_VISIBILITY path root_name() const { return string_type(__root_name()); } _LIBCPP_INLINE_VISIBILITY path root_directory() const { return string_type(__root_directory()); } _LIBCPP_INLINE_VISIBILITY path root_path() const { return root_name().append(string_type(__root_directory())); } _LIBCPP_INLINE_VISIBILITY path relative_path() const { return string_type(__relative_path()); } _LIBCPP_INLINE_VISIBILITY path parent_path() const { return string_type(__parent_path()); } _LIBCPP_INLINE_VISIBILITY path filename() const { return string_type(__filename()); } _LIBCPP_INLINE_VISIBILITY path stem() const { return string_type(__stem()); } _LIBCPP_INLINE_VISIBILITY path extension() const { return string_type(__extension()); } void eg1_2() { /*路径分割*/ std::filesystem::path path = \"../test_dir/1.txt\"; std::cout \u003c\u003c \"path.relative_path() : \" \u003c\u003c path.relative_path() \u003c\u003c std::endl; std::cout \u003c\u003c \"path.parent_path() : \" \u003c\u003c path.parent_path() \u003c\u003c std::endl; std::cout \u003c\u003c \"path.filename() : \" \u003c\u003c path.filename() \u003c\u003c std::endl; std::cout \u003c\u003c \"path.stem() : \" \u003c\u003c path.stem() \u003c\u003c std::endl; std::cout \u003c\u003c \"path.extension() : \" \u003c\u003c path.extension() \u003c\u003c std::endl; } path.relative_path() : \"../test_dir/1.txt\" path.parent_path() : \"../test_dir\" path.filename() : \"1.txt\" path.stem() : \"1\" path.extension() : \".txt\" os.path中提供了分割函数split()以及dirname()，basename()。 def eg1_2(): \"\"\"路径分割\"\"\" path = \"../test_dir/1.txt\" print(\"os.path.split(path) : {}\".format(os.path.split(path))) print(\"os.path.dirname(path) : {}\".format(os.path.dirname(path))) print(\"os.path.basename(path) : {}\".format(os.path.basename(path))) os.path.split(path) : ('../test_dir', '1.txt') os.path.dirname(path) : ../test_dir os.path.basename(path) : 1.txt ","date":"2022-01-25","objectID":"/posts/c++%E4%B8%8Epython%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%AF%B9%E6%AF%94/:1:2","tags":["C++与python文件系统对比"],"title":"C++与python文件系统对比","uri":"/posts/c++%E4%B8%8Epython%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%AF%B9%E6%AF%94/"},{"categories":["现代C++语法"],"content":"路径拼接 filesystem::path中重载了符号/和/=。 friend _LIBCPP_INLINE_VISIBILITY path operator/(const path\u0026 __lhs, const path\u0026 __rhs) { path __result(__lhs); __result /= __rhs; return __result; } void eg1_3() { /*路径拼接*/ std::filesystem::path path = \"../test_dir\"; std::filesystem::path txt1_path = path / \"1.txt\"; std::filesystem::path txt2_path = path / \"1_dir\" / \"2.txt\"; std::cout \u003c\u003c \"txt1_path : \" \u003c\u003c txt1_path \u003c\u003c std::endl; std::cout \u003c\u003c \"txt2_path : \" \u003c\u003c txt2_path \u003c\u003c std::endl; path /= \"1.txt\"; std::cout \u003c\u003c \"path : \" \u003c\u003c path \u003c\u003c std::endl; } txt1_path : \"../test_dir/1.txt\" txt2_path : \"../test_dir/1_dir/2.txt\" path : \"../test_dir/1.txt\" os.path中提供了join()函数。 def eg1_3(): \"\"\"路径拼接\"\"\" path = \"../test_dir\" txt1_path = os.path.join(path, \"1.txt\") txt2_path = os.path.join(path, \"1_dir\", \"2.txt\") print(\"txt1_path : {}\".format(txt1_path)) print(\"txt2_path : {}\".format(txt2_path)) txt1_path : ../test_dir/1.txt txt2_path : ../test_dir/1_dir/2.txt 注意，不同操作系统的分隔符不同，所以在Windows中运行结果如下。 txt1_path : ../test_dir\\1.txt txt2_path : ../test_dir\\1_dir\\2.txt ","date":"2022-01-25","objectID":"/posts/c++%E4%B8%8Epython%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%AF%B9%E6%AF%94/:1:3","tags":["C++与python文件系统对比"],"title":"C++与python文件系统对比","uri":"/posts/c++%E4%B8%8Epython%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%AF%B9%E6%AF%94/"},{"categories":["现代C++语法"],"content":"filesystem vs. os ","date":"2022-01-25","objectID":"/posts/c++%E4%B8%8Epython%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%AF%B9%E6%AF%94/:2:0","tags":["C++与python文件系统对比"],"title":"C++与python文件系统对比","uri":"/posts/c++%E4%B8%8Epython%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%AF%B9%E6%AF%94/"},{"categories":["现代C++语法"],"content":"获取当前工作目录 filesystem提供了获取当前路径的函数current_path()，注意返回的是绝对路径。 void eg2_1() { /*获取当前路径*/ std::filesystem::path current_path = std::filesystem::current_path(); std::cout \u003c\u003c \"current_path : \" \u003c\u003c current_path \u003c\u003c std::endl; } current_path : \"/Users/xxx/Github/intro_to_C-python/xxx/cmake-build-debug\" os提供了函数getcwd()。 def eg2_1(): \"\"\"获取当前路径\"\"\" current_path = os.getcwd() print(\"current_path : {}\".format(current_path)) current_path : /Users/xxx/Github/intro_to_C-python/xxx 这里先展示一下目录树，方便理解后边的例子。 └── test_dir ├── 1.txt └── 1_dir ├── 2.txt └── empty_dir ","date":"2022-01-25","objectID":"/posts/c++%E4%B8%8Epython%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%AF%B9%E6%AF%94/:2:1","tags":["C++与python文件系统对比"],"title":"C++与python文件系统对比","uri":"/posts/c++%E4%B8%8Epython%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%AF%B9%E6%AF%94/"},{"categories":["现代C++语法"],"content":"返回指定目录下的所有文件/文件夹 filesystem的类directory_iterator可以实现该功能。 void eg2_2() { /*返回指定目录下的所有文件/文件夹*/ std::filesystem::directory_iterator iter(\"../test_dir\"); for(const auto \u0026i : iter) { std::cout \u003c\u003c i.path() \u003c\u003cstd::endl; } } \"../test_dir/1.txt\" \"../test_dir/1_dir\" os中提供了函数listdir()。 def eg2_2(): \"\"\"返回指定目录下的所有文件/文件夹\"\"\" for i in os.listdir(\"./test_dir\"): print(i) 1.txt 1_dir ","date":"2022-01-25","objectID":"/posts/c++%E4%B8%8Epython%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%AF%B9%E6%AF%94/:2:2","tags":["C++与python文件系统对比"],"title":"C++与python文件系统对比","uri":"/posts/c++%E4%B8%8Epython%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%AF%B9%E6%AF%94/"},{"categories":["现代C++语法"],"content":"递归返回指定目录下的所有文件/文件夹 filesystem的类recursive_directory_iterator可以实现该功能。 void eg2_3() { /*递归返回指定目录下的所有文件/文件夹*/ std::filesystem::recursive_directory_iterator iter(\"../test_dir\"); for(const auto \u0026i : iter) { std::cout \u003c\u003c i.path() \u003c\u003cstd::endl; } } \"../test_dir/1.txt\" \"../test_dir/1_dir\" \"../test_dir/1_dir/empty_dir\" \"../test_dir/1_dir/2.txt\" os中提供了函数walk()。 def eg2_3(): \"\"\"递归返回指定目录下的所有文件/文件夹\"\"\" for root, dirs, files in os.walk(\"./test_dir\"): print(\"root : {}, dirs : {}, files : {}\".format(root, dirs, files)) root : ./test_dir, dirs : ['1_dir'], files : ['1.txt'] root : ./test_dir/1_dir, dirs : ['empty_dir'], files : ['2.txt'] root : ./test_dir/1_dir/empty_dir, dirs : [], files : [] ","date":"2022-01-25","objectID":"/posts/c++%E4%B8%8Epython%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%AF%B9%E6%AF%94/:2:3","tags":["C++与python文件系统对比"],"title":"C++与python文件系统对比","uri":"/posts/c++%E4%B8%8Epython%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%AF%B9%E6%AF%94/"},{"categories":["现代C++语法"],"content":"判断路径是否存在 filesystem提供了判断路径是否存在的函数exists()。 void eg2_4() { /*判断路径是否存在*/ bool exist = std::filesystem::exists(\"C:\\\\Users\"); std::cout \u003c\u003c \"exist : \" \u003c\u003c exist \u003c\u003c std::endl; } exist : 0 os.path中提供了函数exists()。 def eg2_4(): \"\"\"判断路径是否存在\"\"\" path = \"C:\\\\Users\" print(\"os.path.exists({}) : {}\".format(path, os.path.exists(path))) os.path.exists(C:\\Users) : False ","date":"2022-01-25","objectID":"/posts/c++%E4%B8%8Epython%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%AF%B9%E6%AF%94/:2:4","tags":["C++与python文件系统对比"],"title":"C++与python文件系统对比","uri":"/posts/c++%E4%B8%8Epython%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%AF%B9%E6%AF%94/"},{"categories":["现代C++语法"],"content":"判断路径是文件还是目录 filesystem提供了判断路径是文件还是目录的函数。（比较多） inline _LIBCPP_INLINE_VISIBILITY bool is_block_file(file_status __s) noexcept { return __s.type() == file_type::block; } inline _LIBCPP_INLINE_VISIBILITY bool is_block_file(const path\u0026 __p) { return is_block_file(__status(__p)); } inline _LIBCPP_INLINE_VISIBILITY bool is_block_file(const path\u0026 __p, error_code\u0026 __ec) noexcept { return is_block_file(__status(__p, \u0026__ec)); } inline _LIBCPP_INLINE_VISIBILITY bool is_character_file(file_status __s) noexcept { return __s.type() == file_type::character; } inline _LIBCPP_INLINE_VISIBILITY bool is_character_file(const path\u0026 __p) { return is_character_file(__status(__p)); } inline _LIBCPP_INLINE_VISIBILITY bool is_character_file(const path\u0026 __p, error_code\u0026 __ec) noexcept { return is_character_file(__status(__p, \u0026__ec)); } inline _LIBCPP_INLINE_VISIBILITY bool is_directory(file_status __s) noexcept { return __s.type() == file_type::directory; } inline _LIBCPP_INLINE_VISIBILITY bool is_directory(const path\u0026 __p) { return is_directory(__status(__p)); } inline _LIBCPP_INLINE_VISIBILITY bool is_directory(const path\u0026 __p, error_code\u0026 __ec) noexcept { return is_directory(__status(__p, \u0026__ec)); } inline _LIBCPP_INLINE_VISIBILITY bool is_empty(const path\u0026 __p) { return __fs_is_empty(__p); } inline _LIBCPP_INLINE_VISIBILITY bool is_empty(const path\u0026 __p, error_code\u0026 __ec) { return __fs_is_empty(__p, \u0026__ec); } inline _LIBCPP_INLINE_VISIBILITY bool is_fifo(file_status __s) noexcept { return __s.type() == file_type::fifo; } inline _LIBCPP_INLINE_VISIBILITY bool is_fifo(const path\u0026 __p) { return is_fifo(__status(__p)); } inline _LIBCPP_INLINE_VISIBILITY bool is_fifo(const path\u0026 __p, error_code\u0026 __ec) noexcept { return is_fifo(__status(__p, \u0026__ec)); } inline _LIBCPP_INLINE_VISIBILITY bool is_regular_file(file_status __s) noexcept { return __s.type() == file_type::regular; } inline _LIBCPP_INLINE_VISIBILITY bool is_regular_file(const path\u0026 __p) { return is_regular_file(__status(__p)); } inline _LIBCPP_INLINE_VISIBILITY bool is_regular_file(const path\u0026 __p, error_code\u0026 __ec) noexcept { return is_regular_file(__status(__p, \u0026__ec)); } inline _LIBCPP_INLINE_VISIBILITY bool is_socket(file_status __s) noexcept { return __s.type() == file_type::socket; } inline _LIBCPP_INLINE_VISIBILITY bool is_socket(const path\u0026 __p) { return is_socket(__status(__p)); } inline _LIBCPP_INLINE_VISIBILITY bool is_socket(const path\u0026 __p, error_code\u0026 __ec) noexcept { return is_socket(__status(__p, \u0026__ec)); } inline _LIBCPP_INLINE_VISIBILITY bool is_symlink(file_status __s) noexcept { return __s.type() == file_type::symlink; } inline _LIBCPP_INLINE_VISIBILITY bool is_symlink(const path\u0026 __p) { return is_symlink(__symlink_status(__p)); } inline _LIBCPP_INLINE_VISIBILITY bool is_symlink(const path\u0026 __p, error_code\u0026 __ec) noexcept { return is_symlink(__symlink_status(__p, \u0026__ec)); } inline _LIBCPP_INLINE_VISIBILITY bool is_other(file_status __s) noexcept { return exists(__s) \u0026\u0026 !is_regular_file(__s) \u0026\u0026 !is_directory(__s) \u0026\u0026 !is_symlink(__s); } inline _LIBCPP_INLINE_VISIBILITY bool is_other(const path\u0026 __p) { return is_other(__status(__p)); } inline _LIBCPP_INLINE_VISIBILITY bool is_other(const path\u0026 __p, error_code\u0026 __ec) noexcept { return is_other(__status(__p, \u0026__ec)); } void eg2_5() { /*判断路径是文件还是目录*/ std::filesystem::path file_path = \"../test_dir/1.txt\"; std::filesystem::path dir_path = \"../test_dir/1_dir\"; std::cout \u003c\u003c \"is_regular_file(file_path) : \" \u003c\u003c std::filesystem::is_regular_file(file_path) \u003c\u003c std::endl; std::cout \u003c\u003c \"is_directory(dir_path) : \" \u003c\u003c std::filesystem::is_directory(dir_path) \u003c\u003c std::endl; } is_regular_file(file_path) : 1 is_directory(dir_path) : 1 os.path中提供了函数isfile()和isdir()。 def eg2_5(): \"\"\"判断路径是文件还是目录\"\"\" file_path = \"./test_dir/1.txt\" dir_path = \"./test_dir/1_dir\" print(\"os.path.isfile({}) : {}\".format(file_path, os.path.isfile(file_path))) print(\"os.path.isdir({}) : {}\".format(dir_path, os.path.isdir(dir_path))) os.path.isfile(./test_dir/1.txt) : True os.path.i","date":"2022-01-25","objectID":"/posts/c++%E4%B8%8Epython%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%AF%B9%E6%AF%94/:2:5","tags":["C++与python文件系统对比"],"title":"C++与python文件系统对比","uri":"/posts/c++%E4%B8%8Epython%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%AF%B9%E6%AF%94/"},{"categories":["现代C++语法"],"content":"返回绝对路径【神奇】 filesystem中提供了函数absolute()。 void eg2_6() { /*返回绝对路径*/ std::filesystem::path path = \"../test_dir\"; std::filesystem::path abs_path = std::filesystem::absolute(path); std::cout \u003c\u003c \"abs_path : \" \u003c\u003c abs_path \u003c\u003c std::endl; std::cout \u003c\u003c \"exists(abs_path) : \" \u003c\u003c std::filesystem::exists(abs_path) \u003c\u003c std::endl; } abs_path : \"/Users/xxx/Github/intro_to_C-python/xxx/cmake-build-debug/../test_dir\" exists(abs_path) : 1 在Windows系统中结果如下。 abs_path : \"D:\\\\GitHub\\\\intro_to_C-python\\\\xxx\\\\test_dir\" exists(abs_path) : 1 os.path中提供了函数abspath()。 def eg2_6(): \"\"\"返回绝对路径\"\"\" path = \"../../-PyTorch-\" abs_path = os.path.abspath(path) print(\"abs_path : {}\".format(abs_path)) print(\"os.path.exists({}) : {}\".format(abs_path, os.path.exists(abs_path))) abs_path : /Users/xxx/Github/-PyTorch- os.path.exists(/Users/xxx/Github/-PyTorch-) : True ","date":"2022-01-25","objectID":"/posts/c++%E4%B8%8Epython%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%AF%B9%E6%AF%94/:2:6","tags":["C++与python文件系统对比"],"title":"C++与python文件系统对比","uri":"/posts/c++%E4%B8%8Epython%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%AF%B9%E6%AF%94/"},{"categories":["现代C++语法"],"content":"filesystem vs. shutil shutil = shell + util，对os进行一些补充。 ","date":"2022-01-25","objectID":"/posts/c++%E4%B8%8Epython%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%AF%B9%E6%AF%94/:3:0","tags":["C++与python文件系统对比"],"title":"C++与python文件系统对比","uri":"/posts/c++%E4%B8%8Epython%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%AF%B9%E6%AF%94/"},{"categories":["现代C++语法"],"content":"文件拷贝 filesystem中提供了copy_file()函数，可以拷贝文件或空文件夹。 void eg3_1() { /*文件拷贝*/ std::cout \u003c\u003c \"~~~~~~before copy_file~~~~~~\" \u003c\u003c std::endl; for (const auto \u0026i :std::filesystem::directory_iterator(\"../test_dir\")) { std::cout \u003c\u003c i.path() \u003c\u003c std::endl; } std::filesystem::copy_file(\"../test_dir/1.txt\", \"../test_dir/eg3_1.txt\"); std::cout \u003c\u003c \"~~~~~~after copy_file~~~~~~\" \u003c\u003c std::endl; for (const auto \u0026i :std::filesystem::directory_iterator(\"../test_dir\")) { std::cout \u003c\u003c i.path() \u003c\u003c std::endl; } } ~~~~~~before copy_file~~~~~~ \"../test_dir/1.txt\" \"../test_dir/1_dir\" ~~~~~~after copy_file~~~~~~ \"../test_dir/eg3_1.txt\" \"../test_dir/1.txt\" \"../test_dir/1_dir\" shutil中提供函数copyfile()。 def eg3_1(): \"\"\"文件拷贝\"\"\" print(\"~~~~~~before copy_file~~~~~~\") for i in os.listdir(\"./test_dir\"): print(i) src_path = \"./test_dir/1.txt\" dst_path = \"./test_dir/eg3_1.txt\" shutil.copyfile(src_path, dst_path) print(\"~~~~~~after copy_file~~~~~~\") for i in os.listdir(\"./test_dir\"): print(i) ~~~~~~before copy_file~~~~~~ 1.txt 1_dir ~~~~~~after copy_file~~~~~~ eg3_1.txt 1.txt 1_dir ","date":"2022-01-25","objectID":"/posts/c++%E4%B8%8Epython%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%AF%B9%E6%AF%94/:3:1","tags":["C++与python文件系统对比"],"title":"C++与python文件系统对比","uri":"/posts/c++%E4%B8%8Epython%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%AF%B9%E6%AF%94/"},{"categories":["现代C++语法"],"content":"文件删除 filesystem中提供了remove()函数，可以删除文件或空文件夹。 void eg3_2() { /*文件删除*/ std::cout \u003c\u003c \"~~~~~~before remove~~~~~~\" \u003c\u003c std::endl; for (const auto \u0026i :std::filesystem::directory_iterator(\"../test_dir\")) { std::cout \u003c\u003c i.path() \u003c\u003c std::endl; } std::filesystem::remove(\"../test_dir/eg3_1.txt\"); std::cout \u003c\u003c \"~~~~~~after remove~~~~~~\" \u003c\u003c std::endl; for (const auto \u0026i :std::filesystem::directory_iterator(\"../test_dir\")) { std::cout \u003c\u003c i.path() \u003c\u003c std::endl; } } ~~~~~~before remove~~~~~~ \"../test_dir/eg3_1.txt\" \"../test_dir/1.txt\" \"../test_dir/1_dir\" ~~~~~~after remove~~~~~~ \"../test_dir/1.txt\" \"../test_dir/1_dir\" os中提供了函数remove()。 def eg3_2(): \"\"\"文件删除\"\"\" print(\"~~~~~~before remove~~~~~~\") for i in os.listdir(\"./test_dir\"): print(i) rm_path = \"./test_dir/eg3_1.txt\" os.remove(rm_path) print(\"~~~~~~after remove~~~~~~\") for i in os.listdir(\"./test_dir\"): print(i) ~~~~~~before remove~~~~~~ eg3_1.txt 1.txt 1_dir ~~~~~~after remove~~~~~~ 1.txt 1_dir ","date":"2022-01-25","objectID":"/posts/c++%E4%B8%8Epython%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%AF%B9%E6%AF%94/:3:2","tags":["C++与python文件系统对比"],"title":"C++与python文件系统对比","uri":"/posts/c++%E4%B8%8Epython%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%AF%B9%E6%AF%94/"},{"categories":["现代C++语法"],"content":"路径拷贝 filesystem中提供了copy()函数，可以按照选项（是否递归）拷贝文件或文件夹。 void eg3_3() { /*路径拷贝*/ std::cout \u003c\u003c \"~~~~~~before copy[1_dir]~~~~~~\" \u003c\u003c std::endl; for (const auto \u0026i :std::filesystem::directory_iterator(\"../test_dir/1_dir\")) { std::cout \u003c\u003c i.path() \u003c\u003c std::endl; } std::filesystem::copy(\"../test_dir/1_dir\", \"../test_dir/eg3_3_dir\", std::filesystem::copy_options::recursive); std::cout \u003c\u003c \"~~~~~~after copy[eg3_3_dir]~~~~~~\" \u003c\u003c std::endl; for (const auto \u0026i :std::filesystem::directory_iterator(\"../test_dir/eg3_3_dir\")) { std::cout \u003c\u003c i.path() \u003c\u003c std::endl; } } ~~~~~~before copy[1_dir]~~~~~~ \"../test_dir/1_dir/empty_dir\" \"../test_dir/1_dir/2.txt\" ~~~~~~after copy[eg3_3_dir]~~~~~~ \"../test_dir/eg3_3_dir/empty_dir\" \"../test_dir/eg3_3_dir/2.txt\" shutil提供了函数copytree()。 def eg3_3(): \"\"\"路径拷贝\"\"\" print(\"~~~~~~before copy[1_dir]~~~~~~\") for i in os.listdir(\"./test_dir/1_dir\"): print(i) src_path = \"./test_dir/1_dir\" dst_path = \"./test_dir/eg3_3_dir\" shutil.copytree(src_path, dst_path) print(\"~~~~~~after copy[eg3_3_dir]~~~~~~\") for i in os.listdir(\"./test_dir/eg3_3_dir\"): print(i) ~~~~~~before copy[1_dir]~~~~~~ empty_dir 2.txt ~~~~~~after copy[eg3_3_dir]~~~~~~ empty_dir 2.txt ","date":"2022-01-25","objectID":"/posts/c++%E4%B8%8Epython%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%AF%B9%E6%AF%94/:3:3","tags":["C++与python文件系统对比"],"title":"C++与python文件系统对比","uri":"/posts/c++%E4%B8%8Epython%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%AF%B9%E6%AF%94/"},{"categories":["现代C++语法"],"content":"递归删除 filesystem中提供了remove_all()函数，可以递归删除文件或文件夹。 void eg3_4() { /*递归删除*/ std::filesystem::path dir_path = \"../test_dir/eg3_3_dir\"; std::cout \u003c\u003c \"exists(dir_path) : \" \u003c\u003c std::filesystem::exists(dir_path) \u003c\u003c std::endl; std::filesystem::remove_all(dir_path); std::cout \u003c\u003c \"exists(dir_path) : \" \u003c\u003c std::filesystem::exists(dir_path) \u003c\u003c std::endl; } exists(dir_path) : 1 exists(dir_path) : 0 shutil提供了函数rmtree()。 def eg3_4(): \"\"\"递归删除\"\"\" dir_path = \"./test_dir/eg3_3_dir\" print(\"os.path.exists({}) : {}\".format(dir_path, os.path.exists(dir_path))) shutil.rmtree(dir_path) print(\"os.path.exists({}) : {}\".format(dir_path, os.path.exists(dir_path))) os.path.exists(./test_dir/eg3_3_dir) : True os.path.exists(./test_dir/eg3_3_dir) : False ","date":"2022-01-25","objectID":"/posts/c++%E4%B8%8Epython%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%AF%B9%E6%AF%94/:3:4","tags":["C++与python文件系统对比"],"title":"C++与python文件系统对比","uri":"/posts/c++%E4%B8%8Epython%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%AF%B9%E6%AF%94/"},{"categories":["JavaSE笔记"],"content":"Java I/O","date":"2022-01-23","objectID":"/posts/java-io/","tags":["Java I/O"],"title":"Java I/O","uri":"/posts/java-io/"},{"categories":["JavaSE笔记"],"content":"Java I/O 配套视频 注意：这块会涉及到操作系统和计算机组成原理相关内容。 I/O简而言之，就是输入输出，那么为什么会有I/O呢？其实I/O无时无刻都在我们的身边，比如读取硬盘上的文件，网络文件传输，鼠标键盘输入，也可以是接受单片机发回的数据，而能够支持这些操作的设备就是I/O设备。 我们可以大致看一下整个计算机的总线结构： 常见的I/O设备一般是鼠标、键盘这类通过USB进行传输的外设或者是通过Sata接口或是M.2连接的硬盘。一般情况下，这些设备是由CPU发出指令通过南桥芯片间接进行控制，而不是由CPU直接操作。 而我们在程序中，想要读取这些外部连接的I/O设备中的内容，就需要将数据传输到内存中。而需要实现这样的操作，单单凭借一个小的程序是无法做到的，而操作系统（如：Windows/Linux/MacOS）就是专门用于控制和管理计算机硬件和软件资源的软件，我们需要读取一个IO设备的内容时，可以向操作系统发出请求，由操作系统帮助我们来和底层的硬件交互以完成我们的读取/写入请求。从读取硬盘文件的角度来说，不同的操作系统有着不同的文件系统（也就是文件在硬盘中的存储排列方式，如Windows就是NTFS、MacOS就是APFS），硬盘只能存储一个个0和1这样的二进制数据，至于0和1如何排列，各自又代表什么意思，就是由操作系统的文件系统来决定的。从网络通信角度来说，网络信号通过网卡等设备翻译为二进制信号，再交给系统进行读取，最后再由操作系统来给到程序。 JDK提供了一套用于IO操作的框架，根据流的传输方向和读取单位，分为字节流InputStream和OutputStream以及字符流Reader和Writer，当然，这里的Stream并不是前面集合框架认识的Stream，这里的流指的是数据流，通过流，我们就可以一直从流中读取数据，直到读取到尽头，或是不断向其中写入数据，直到我们写入完成。而这类IO就是我们所说的BIO， 字节流一次读取一个字节，也就是一个byte的大小，而字符流顾名思义，就是一次读取一个字符，也就是一个char的大小（在读取纯文本文件的时候更加适合），有关这两种流，会在后面详细介绍，这个章节我们需要学习16个关键的流。 ","date":"2022-01-23","objectID":"/posts/java-io/:0:0","tags":["Java I/O"],"title":"Java I/O","uri":"/posts/java-io/"},{"categories":["JavaSE笔记"],"content":"文件流 要学习和使用IO，首先就要从最易于理解的读取文件开始说起。 ","date":"2022-01-23","objectID":"/posts/java-io/:1:0","tags":["Java I/O"],"title":"Java I/O","uri":"/posts/java-io/"},{"categories":["JavaSE笔记"],"content":"文件字节流 首先介绍一下FileInputStream，通过它来获取文件的输入流。 public static void main(String[] args) { try { FileInputStream inputStream = new FileInputStream(\"路径\"); //路径支持相对路径和绝对路径 } catch (FileNotFoundException e) { e.printStackTrace(); } } 相对路径是在当前运行的路径下寻找文件，而绝对路径，是从根目录开始寻找。路径分割符支持使用/或是\\\\，但是不能写为\\因为它是转义字符！ 在使用完成一个流之后，必须关闭这个流来完成对资源的释放，否则资源会被一直占用！ public static void main(String[] args) { FileInputStream inputStream = null; //定义可以先放在try外部 try { inputStream = new FileInputStream(\"路径\"); } catch (FileNotFoundException e) { e.printStackTrace(); } finally { try { //建议在finally中进行，因为这个是任何情况都必须要执行的！ if(inputStream != null) inputStream.close(); } catch (IOException e) { e.printStackTrace(); } } } 虽然这样的写法才是最保险的，但是显得过于繁琐了，尤其是finally中再次嵌套了一个try-catch块，因此在JDK1.7新增了try-with-resource语法，用于简化这样的写法（本质上还是和这样的操作一致，只是换了个写法） public static void main(String[] args) { //注意，这种语法只支持实现了AutoCloseable接口的类！ try(FileInputStream inputStream = new FileInputStream(\"路径\")) { //直接在try()中定义要在完成之后释放的资源 } catch (IOException e) { //这里变成IOException是因为调用close()可能会出现，而FileNotFoundException是继承自IOException的 e.printStackTrace(); } //无需再编写finally语句块，因为在最后自动帮我们调用了close() } 之后为了方便，我们都使用此语法进行教学。 public static void main(String[] args) { //test.txt：a try(FileInputStream inputStream = new FileInputStream(\"test.txt\")) { //使用read()方法进行字符读取 System.out.println((char) inputStream.read()); //读取一个字节的数据（英文字母只占1字节，中文占2字节） System.out.println(inputStream.read()); //唯一一个字节的内容已经读完了，再次读取返回-1表示没有内容了 }catch (IOException e){ e.printStackTrace(); } } 使用read可以直接读取一个字节的数据，注意，流的内容是有限的，读取一个少一个！我们如果想一次性全部读取的话，可以直接使用一个while循环来完成： public static void main(String[] args) { //test.txt：abcd try(FileInputStream inputStream = new FileInputStream(\"test.txt\")) { int tmp; while ((tmp = inputStream.read()) != -1){ //通过while循环来一次性读完内容 System.out.println((char)tmp); } }catch (IOException e){ e.printStackTrace(); } } 使用方法能查看当前可读的剩余字节数量（注意：并不一定真实的数据量就是这么多，尤其是在网络I/O操作时，这个方法只能进行一个预估也可以说是暂时能一次性读取的数量） try(FileInputStream inputStream = new FileInputStream(\"test.txt\")) { System.out.println(inputStream.available()); //查看剩余数量 }catch (IOException e){ e.printStackTrace(); } 当然，一个一个读取效率太低了，那能否一次性全部读取呢？我们可以预置一个合适容量的byte[]数组来存放。 public static void main(String[] args) { //test.txt：abcd try(FileInputStream inputStream = new FileInputStream(\"test.txt\")) { byte[] bytes = new byte[inputStream.available()]; //我们可以提前准备好合适容量的byte数组来存放 System.out.println(inputStream.read(bytes)); //一次性读取全部内容（返回值是读取的字节数） System.out.println(new String(bytes)); //通过String(byte[])构造方法得到字符串 }catch (IOException e){ e.printStackTrace(); } } 也可以控制要读取数量： System.out.println(inputStream.read(bytes, 1, 2)); //第二个参数是从给定数组的哪个位置开始放入内容，第三个参数是读取流中的字节数 注意：一次性读取同单个读取一样，当没有任何数据可读时，依然会返回-1 通过skip()方法可以跳过指定数量的字节： public static void main(String[] args) { //test.txt：abcd try(FileInputStream inputStream = new FileInputStream(\"test.txt\")) { System.out.println(inputStream.skip(1)); System.out.println((char) inputStream.read()); //跳过了一个字节 }catch (IOException e){ e.printStackTrace(); } } 注意：FileInputStream是不支持reset()的，虽然有这个方法，但是这里先不提及。 既然有输入流，那么文件输出流也是必不可少的： public static void main(String[] args) { //输出流也需要在最后调用close()方法，并且同样支持try-with-resource try(FileOutputStream outputStream = new FileOutputStream(\"output.txt\")) { //注意：若此文件不存在，会直接创建这个文件！ }catch (IOException e){ e.printStackTrace(); } } 输出流没有read()操作而是write()操作，使用方法同输入流一样，只不过现在的方向变为我们向文件里写入内容： public static void main(String[] args) { try(FileOutputStream outputStream = new FileOutputStream(\"output.txt\")) { outputStream.write('c'); //同read一样，可以直接写入内容 outputStream.write(\"lbwnb\".getBytes()); //也可以直接写入byte[] outputStream.write(\"lbwnb\".getBytes(), 0, 1); //同上输入流 outputStream.flush(); //建议在最后执行一次刷新操作（强制写入）来保证数据正确写入到硬盘文件中 }catch (IOException e){ e.printStackTrace(); } } 那么如果是我只想在文件尾部进行追加写入数据呢？我们可以调用另一个构造方法来实现： public static void main(String[] args) { try(FileOutputStream outputStream = new FileOutputStream(\"output.txt\", true)) { outputStream.write(\"lb\".getBytes()); //现在只会进行追加写入，而不是直接替换原文件内容 outputStream.flush(); }catch (IOException e){ e.printStackTrace(); } } ","date":"2022-01-23","objectID":"/posts/java-io/:1:1","tags":["Java I/O"],"title":"Java I/O","uri":"/posts/java-io/"},{"categories":["JavaSE笔记"],"content":"文件字符流 字符流不同于字节，字符流是以一个具体的字符进行读取，因此它只适合读纯文本的文件，如果是其他类型的文件不适用： public static void main(String[] args) { try(FileReader reader = new FileReader(\"test.txt\")){ reader.skip(1); //现在跳过的是一个字符 System.out.println((char) reader.read()); //现在是按字符进行读取，而不是字节，因此可以直接读取到中文字符 }catch (IOException e){ e.printStackTrace(); } } 同理，字符流只支持char[]类型作为存储： public static void main(String[] args) { try(FileReader reader = new FileReader(\"test.txt\")){ char[] str = new char[10]; reader.read(str); System.out.println(str); //直接读取到char[]中 }catch (IOException e){ e.printStackTrace(); } } 既然有了Reader肯定也有Writer： public static void main(String[] args) { try(FileWriter writer = new FileWriter(\"output.txt\")){ writer.getEncoding(); //支持获取编码（不同的文本文件可能会有不同的编码类型） writer.write('牛'); writer.append('牛'); //其实功能和write一样 writer.flush(); //刷新 }catch (IOException e){ e.printStackTrace(); } } 我们发现不仅有write()方法，还有一个append()方法，但是实际上他们效果是一样的，看源码： /** * Appends the specified character to this writer. * * \u003cp\u003e An invocation of this method of the form \u003ctt\u003eout.append(c)\u003c/tt\u003e * behaves in exactly the same way as the invocation * * \u003cpre\u003e * out.write(c) \u003c/pre\u003e * * @param c * The 16-bit character to append * * @return This writer * * @throws IOException * If an I/O error occurs * * @since 1.5 */ public Writer append(char c) throws IOException { write(c); return this; } append支持像StringBuilder那样的链式调用，返回的是Writer对象本身。 练习：尝试一下用Reader和Writer来拷贝纯文本文件 ","date":"2022-01-23","objectID":"/posts/java-io/:1:2","tags":["Java I/O"],"title":"Java I/O","uri":"/posts/java-io/"},{"categories":["JavaSE笔记"],"content":"File类 File类专门用于表示一个文件或文件夹，只不过它只是代表这个文件，但并不是这个文件本身。通过File对象，可以更好地管理和操作硬盘上的文件。 public static void main(String[] args) { File file = new File(\"test.txt\"); //直接创建文件对象，可以是相对路径，也可以是绝对路径 System.out.println(file.exists()); //此文件是否存在 System.out.println(file.length()); //获取文件的大小 System.out.println(file.isDirectory()); //是否为一个文件夹 System.out.println(file.canRead()); //是否可读 System.out.println(file.canWrite()); //是否可写 System.out.println(file.canExecute()); //是否可执行 } 通过File对象，我们就能快速得到文件的所有信息，如果是文件夹，还可以获取文件夹内部的文件列表等内容： File file = new File(\"/\"); System.out.println(Arrays.toString(file.list())); //快速获取文件夹下的文件名称列表 for (File f : file.listFiles()){ //所有子文件的File对象 System.out.println(f.getAbsolutePath()); //获取文件的绝对路径 } 如果我们希望读取某个文件的内容，可以直接将File作为参数传入字节流或是字符流： File file = new File(\"test.txt\"); try (FileInputStream inputStream = new FileInputStream(file)){ //直接做参数 System.out.println(inputStream.available()); }catch (IOException e){ e.printStackTrace(); } 练习：尝试拷贝文件夹下的所有文件到另一个文件夹 ","date":"2022-01-23","objectID":"/posts/java-io/:1:3","tags":["Java I/O"],"title":"Java I/O","uri":"/posts/java-io/"},{"categories":["JavaSE笔记"],"content":"缓冲流 虽然普通的文件流读取文件数据非常便捷，但是每次都需要从外部I/O设备去获取数据，由于外部I/O设备的速度一般都达不到内存的读取速度，很有可能造成程序反应迟钝，因此性能还不够高，而缓冲流正如其名称一样，它能够提供一个缓冲，提前将部分内容存入内存（缓冲区）在下次读取时，如果缓冲区中存在此数据，则无需再去请求外部设备。同理，当向外部设备写入数据时，也是由缓冲区处理，而不是直接向外部设备写入。 ","date":"2022-01-23","objectID":"/posts/java-io/:2:0","tags":["Java I/O"],"title":"Java I/O","uri":"/posts/java-io/"},{"categories":["JavaSE笔记"],"content":"缓冲字节流 要创建一个缓冲字节流，只需要将原本的流作为构造参数传入BufferedInputStream即可： public static void main(String[] args) { try (BufferedInputStream bufferedInputStream = new BufferedInputStream(new FileInputStream(\"test.txt\"))){ //传入FileInputStream System.out.println((char) bufferedInputStream.read()); //操作和原来的流是一样的 }catch (IOException e){ e.printStackTrace(); } } 实际上进行I/O操作的并不是BufferedInputStream，而是我们传入的FileInputStream，而BufferedInputStream虽然有着同样的方法，但是进行了一些额外的处理然后再调用FileInputStream的同名方法，这样的写法称为装饰者模式 public void close() throws IOException { byte[] buffer; while ( (buffer = buf) != null) { if (bufUpdater.compareAndSet(this, buffer, null)) { //CAS无锁算法，并发会用到，暂时不管 InputStream input = in; in = null; if (input != null) input.close(); return; } // Else retry in case a new buf was CASed in fill() } } 实际上这种模式是父类FilterInputStream提供的规范，后面我们还会讲到更多FilterInputStream的子类。 我们可以发现在BufferedInputStream中还存在一个专门用于缓存的数组： /** * The internal buffer array where the data is stored. When necessary, * it may be replaced by another array of * a different size. */ protected volatile byte buf[]; I/O操作一般不能重复读取内容（比如键盘发送的信号，主机接收了就没了），而缓冲流提供了缓冲机制，一部分内容可以被暂时保存，BufferedInputStream支持reset()和mark()操作，首先我们来看看mark()方法的介绍： /** * Marks the current position in this input stream. A subsequent * call to the \u003ccode\u003ereset\u003c/code\u003e method repositions this stream at * the last marked position so that subsequent reads re-read the same bytes. * \u003cp\u003e * The \u003ccode\u003ereadlimit\u003c/code\u003e argument tells this input stream to * allow that many bytes to be read before the mark position gets * invalidated. * \u003cp\u003e * This method simply performs \u003ccode\u003ein.mark(readlimit)\u003c/code\u003e. * * @param readlimit the maximum limit of bytes that can be read before * the mark position becomes invalid. * @see java.io.FilterInputStream#in * @see java.io.FilterInputStream#reset() */ public synchronized void mark(int readlimit) { in.mark(readlimit); } 当调用mark()之后，输入流会以某种方式保留之后读取的readlimit数量的内容，当读取的内容数量超过readlimit则之后的内容不会被保留，当调用reset()之后，会使得当前的读取位置回到mark()调用时的位置。 public static void main(String[] args) { try (BufferedInputStream bufferedInputStream = new BufferedInputStream(new FileInputStream(\"test.txt\"))){ bufferedInputStream.mark(1); //只保留之后的1个字符 System.out.println((char) bufferedInputStream.read()); System.out.println((char) bufferedInputStream.read()); bufferedInputStream.reset(); //回到mark时的位置 System.out.println((char) bufferedInputStream.read()); System.out.println((char) bufferedInputStream.read()); }catch (IOException e) { e.printStackTrace(); } } 我们发现虽然后面的部分没有保存，但是依然能够正常读取，其实mark()后保存的读取内容是取readlimit和BufferedInputStream类的缓冲区大小两者中的最大值，而并非完全由readlimit确定。因此我们限制一下缓冲区大小，再来观察一下结果： public static void main(String[] args) { try (BufferedInputStream bufferedInputStream = new BufferedInputStream(new FileInputStream(\"test.txt\"), 1)){ //将缓冲区大小设置为1 bufferedInputStream.mark(1); //只保留之后的1个字符 System.out.println((char) bufferedInputStream.read()); System.out.println((char) bufferedInputStream.read()); //已经超过了readlimit，继续读取会导致mark失效 bufferedInputStream.reset(); //mark已经失效，无法reset() System.out.println((char) bufferedInputStream.read()); System.out.println((char) bufferedInputStream.read()); }catch (IOException e) { e.printStackTrace(); } } 了解完了BufferedInputStream之后，我们再来看看BufferedOutputStream，其实和BufferedInputStream原理差不多，只是反向操作： public static void main(String[] args) { try (BufferedOutputStream outputStream = new BufferedOutputStream(new FileOutputStream(\"output.txt\"))){ outputStream.write(\"lbwnb\".getBytes()); outputStream.flush(); }catch (IOException e) { e.printStackTrace(); } } 操作和FileOutputStream一致，这里就不多做介绍了。 ","date":"2022-01-23","objectID":"/posts/java-io/:2:1","tags":["Java I/O"],"title":"Java I/O","uri":"/posts/java-io/"},{"categories":["JavaSE笔记"],"content":"缓冲字符流 缓存字符流和缓冲字节流一样，也有一个专门的缓冲区，BufferedReader构造时需要传入一个Reader对象： public static void main(String[] args) { try (BufferedReader reader = new BufferedReader(new FileReader(\"test.txt\"))){ System.out.println((char) reader.read()); }catch (IOException e) { e.printStackTrace(); } } 使用和reader也是一样的，内部也包含一个缓存数组： private char cb[]; 相比Reader更方便的是，它支持按行读取： public static void main(String[] args) { try (BufferedReader reader = new BufferedReader(new FileReader(\"test.txt\"))){ System.out.println(reader.readLine()); //按行读取 }catch (IOException e) { e.printStackTrace(); } } 读取后直接得到一个字符串，当然，它还能把每一行内容依次转换为集合类提到的Stream流： public static void main(String[] args) { try (BufferedReader reader = new BufferedReader(new FileReader(\"test.txt\"))){ reader .lines() .limit(2) .distinct() .sorted() .forEach(System.out::println); }catch (IOException e) { e.printStackTrace(); } } 它同样也支持mark()和reset()操作： public static void main(String[] args) { try (BufferedReader reader = new BufferedReader(new FileReader(\"test.txt\"))){ reader.mark(1); System.out.println((char) reader.read()); reader.reset(); System.out.println((char) reader.read()); }catch (IOException e) { e.printStackTrace(); } } BufferedReader处理纯文本文件时就更加方便了，BufferedWriter在处理时也同样方便： public static void main(String[] args) { try (BufferedWriter reader = new BufferedWriter(new FileWriter(\"output.txt\"))){ reader.newLine(); //使用newLine进行换行 reader.write(\"汉堡做滴彳亍不彳亍\"); //可以直接写入一个字符串 reader.flush(); //清空缓冲区 }catch (IOException e) { e.printStackTrace(); } } ","date":"2022-01-23","objectID":"/posts/java-io/:2:2","tags":["Java I/O"],"title":"Java I/O","uri":"/posts/java-io/"},{"categories":["JavaSE笔记"],"content":"转换流 有时会遇到这样一个很麻烦的问题：我这里读取的是一个字符串或是一个个字符，但是我只能往一个OutputStream里输出，但是OutputStream又只支持byte类型，如果要往里面写入内容，进行数据转换就会很麻烦，那么能否有更加简便的方式来做这样的事情呢？ public static void main(String[] args) { try(OutputStreamWriter writer = new OutputStreamWriter(new FileOutputStream(\"test.txt\"))){ //虽然给定的是FileOutputStream，但是现在支持以Writer的方式进行写入 writer.write(\"lbwnb\"); //以操作Writer的样子写入OutputStream }catch (IOException e){ e.printStackTrace(); } } 同样的，我们现在只拿到了一个InputStream，但是我们希望能够按字符的方式读取，我们就可以使用InputStreamReader来帮助我们实现： public static void main(String[] args) { try(InputStreamReader reader = new InputStreamReader(new FileInputStream(\"test.txt\"))){ //虽然给定的是FileInputStream，但是现在支持以Reader的方式进行读取 System.out.println((char) reader.read()); }catch (IOException e){ e.printStackTrace(); } } InputStreamReader和OutputStreamWriter本质也是Reader和Writer，因此可以直接放入BufferedReader来实现更加方便的操作。 ","date":"2022-01-23","objectID":"/posts/java-io/:3:0","tags":["Java I/O"],"title":"Java I/O","uri":"/posts/java-io/"},{"categories":["JavaSE笔记"],"content":"打印流 打印流其实我们从一开始就在使用了，比如System.out就是一个PrintStream，PrintStream也继承自FilterOutputStream类因此依然是装饰我们传入的输出流，但是它存在自动刷新机制，例如当向PrintStream流中写入一个字节数组后自动调用flush()方法。PrintStream也永远不会抛出异常，而是使用内部检查机制checkError()方法进行错误检查。最方便的是，它能够格式化任意的类型，将它们以字符串的形式写入到输出流。 public final static PrintStream out = null; 可以看到System.out也是PrintStream，不过默认是向控制台打印，我们也可以让它向文件中打印： public static void main(String[] args) { try(PrintStream stream = new PrintStream(new FileOutputStream(\"test.txt\"))){ stream.println(\"lbwnb\"); //其实System.out就是一个PrintStream }catch (IOException e){ e.printStackTrace(); } } 我们平时使用的println方法就是PrintStream中的方法，它会直接打印基本数据类型或是调用对象的toString()方法得到一个字符串，并将字符串转换为字符，放入缓冲区再经过转换流输出到给定的输出流上。 因此实际上内部还包含这两个内容： /** * Track both the text- and character-output streams, so that their buffers * can be flushed without flushing the entire stream. */ private BufferedWriter textOut; private OutputStreamWriter charOut; 与此相同的还有一个PrintWriter，不过他们的功能基本一致，PrintWriter的构造方法可以接受一个Writer作为参数，这里就不再做过多阐述了。 ","date":"2022-01-23","objectID":"/posts/java-io/:4:0","tags":["Java I/O"],"title":"Java I/O","uri":"/posts/java-io/"},{"categories":["JavaSE笔记"],"content":"数据流 数据流DataInputStream也是FilterInputStream的子类，同样采用装饰者模式，最大的不同是它支持基本数据类型的直接读取： public static void main(String[] args) { try (DataInputStream dataInputStream = new DataInputStream(new FileInputStream(\"test.txt\"))){ System.out.println(dataInputStream.readBoolean()); //直接将数据读取为任意基本数据类型 }catch (IOException e) { e.printStackTrace(); } } 用于写入基本数据类型： public static void main(String[] args) { try (DataOutputStream dataOutputStream = new DataOutputStream(new FileOutputStream(\"output.txt\"))){ dataOutputStream.writeBoolean(false); }catch (IOException e) { e.printStackTrace(); } } 注意，写入的是二进制数据，并不是写入的字符串，使用DataInputStream可以读取，一般他们是配合一起使用的。 ","date":"2022-01-23","objectID":"/posts/java-io/:5:0","tags":["Java I/O"],"title":"Java I/O","uri":"/posts/java-io/"},{"categories":["JavaSE笔记"],"content":"对象流 既然基本数据类型能够读取和写入基本数据类型，那么能否将对象也支持呢？ObjectOutputStream不仅支持基本数据类型，通过对对象的序列化操作，以某种格式保存对象，来支持对象类型的IO，注意：它不是继承自FilterInputStream的。 public static void main(String[] args) { try (ObjectOutputStream outputStream = new ObjectOutputStream(new FileOutputStream(\"output.txt\")); ObjectInputStream inputStream = new ObjectInputStream(new FileInputStream(\"output.txt\"))){ People people = new People(\"lbw\"); outputStream.writeObject(people); outputStream.flush(); people = (People) inputStream.readObject(); System.out.println(people.name); }catch (IOException | ClassNotFoundException e) { e.printStackTrace(); } } static class People implements Serializable{ //必须实现Serializable接口才能被序列化 String name; public People(String name){ this.name = name; } } 在我们后续的操作中，有可能会使得这个类的一些结构发生变化，而原来保存的数据只适用于之前版本的这个类，因此我们需要一种方法来区分类的不同版本： static class People implements Serializable{ private static final long serialVersionUID = 123456; //在序列化时，会被自动添加这个属性，它代表当前类的版本，我们也可以手动指定版本。 String name; public People(String name){ this.name = name; } } 当发生版本不匹配时，会无法反序列化为对象： java.io.InvalidClassException: com.test.Main$People; local class incompatible: stream classdesc serialVersionUID = 123456, local class serialVersionUID = 1234567 at java.io.ObjectStreamClass.initNonProxy(ObjectStreamClass.java:699) at java.io.ObjectInputStream.readNonProxyDesc(ObjectInputStream.java:2003) at java.io.ObjectInputStream.readClassDesc(ObjectInputStream.java:1850) at java.io.ObjectInputStream.readOrdinaryObject(ObjectInputStream.java:2160) at java.io.ObjectInputStream.readObject0(ObjectInputStream.java:1667) at java.io.ObjectInputStream.readObject(ObjectInputStream.java:503) at java.io.ObjectInputStream.readObject(ObjectInputStream.java:461) at com.test.Main.main(Main.java:27) 如果我们不希望某些属性参与到序列化中进行保存，我们可以添加transient关键字： public static void main(String[] args) { try (ObjectOutputStream outputStream = new ObjectOutputStream(new FileOutputStream(\"output.txt\")); ObjectInputStream inputStream = new ObjectInputStream(new FileInputStream(\"output.txt\"))){ People people = new People(\"lbw\"); outputStream.writeObject(people); outputStream.flush(); people = (People) inputStream.readObject(); System.out.println(people.name); //虽然能得到对象，但是name属性并没有保存，因此为null }catch (IOException | ClassNotFoundException e) { e.printStackTrace(); } } static class People implements Serializable{ private static final long serialVersionUID = 1234567; transient String name; public People(String name){ this.name = name; } } 其实我们可以看到，在一些JDK内部的源码中，也存在大量的transient关键字，使得某些属性不参与序列化，取消这些不必要保存的属性，可以节省数据空间占用以及减少序列化时间。 ","date":"2022-01-23","objectID":"/posts/java-io/:6:0","tags":["Java I/O"],"title":"Java I/O","uri":"/posts/java-io/"},{"categories":["JavaSE笔记"],"content":"Java I/O编程实战 ","date":"2022-01-23","objectID":"/posts/java-io/:7:0","tags":["Java I/O"],"title":"Java I/O","uri":"/posts/java-io/"},{"categories":["JavaSE笔记"],"content":"图书管理系统 要求实现一个图书管理系统（控制台），支持以下功能：保存书籍信息（要求持久化），查询、添加、删除、修改书籍信息。 参考代码： import java.io.*; import java.util.HashSet; import java.util.Objects; import java.util.Scanner; public class Library { static private HashSet\u003cBook\u003e MAP; public static void main(String[] args) { //TODO 注意先分配内存 Scanner scan = new Scanner(System.in); readData(); while (true) { System.out.println(\"============图书馆管理系统===========\"); System.out.println(\"1.插入数据\"); System.out.println(\"2.修改数据\"); System.out.println(\"3.查询图书列表\"); System.out.println(\"4.删除图书\"); System.out.println(\"(按下任意其他键退出程序)\"); String str = scan.nextLine(); switch (str) { case \"1\": insertBooks(scan); break; case \"2\": modifyBook(scan); break; case \"3\": showBooks(); break; case \"4\": deleteBooks(scan); break; default: saveData(); scan.close(); return; } } } //TODO 程序启动前，读取持久化数据 private static void readData(){ File file = new File(\"data\"); if(file.exists()){ try(ObjectInputStream inputStream = new ObjectInputStream(new FileInputStream(\"data\"))){ MAP = (HashSet\u003cBook\u003e) inputStream.readObject(); }catch (IOException|ClassNotFoundException e){ e.printStackTrace(); } }else { MAP = new HashSet\u003c\u003e(); } } //TODO 程序结束时，持久序列化保存数据 private static void saveData(){ try(ObjectOutputStream outputStream = new ObjectOutputStream(new FileOutputStream(\"data\"))){ outputStream.writeObject(MAP); outputStream.flush(); }catch (IOException e){ e.printStackTrace(); } } //TODO 修改图书数据 private static void modifyBook(Scanner scan) { showBooks(); System.out.println(\"输入您要修改书籍的索书号：\"); int index = scan.nextInt(); scan.nextLine(); Book t = new Book().setIndex(index); if (!MAP.contains(t)) { System.out.println(\"输入错误图书馆内无该书籍!\"); } else { System.out.println(\"请输入您要更改的信息：书名，作者，价格\"); String name = scan.nextLine(); String author = scan.nextLine(); double price = scan.nextDouble(); scan.nextLine(); for (Book tt : MAP) { if (tt.equals(t)) { tt.setAuthor(author); tt.setName(name); tt.setPrice(price); break; } } } } //TODO 删除书籍 private static void deleteBooks(Scanner scan) { showBooks(); System.out.println(\"请输入要删除书籍的索书号：\"); int index = scan.nextInt(); scan.nextLine(); Book t = new Book().setIndex(index); if (!MAP.contains(t)) { System.out.println(\"索书号出错没有这样的书籍\"); } else { System.out.printf(\"删除索书号为:%d 的书籍成功!\\n\", index); MAP.remove(t); } } //TODO 显示图书信息 private static void showBooks() { MAP.forEach(System.out::println); } //TODO 插入书籍 private static void insertBooks(Scanner scan) { System.out.println(\"请输入 索书号 书名 作者 价格。每输入一个信息按下回车键确认！\"); MAP.add(new Book().setIndex(scan.nextInt()) .setName(scan.nextLine() + scan.nextLine()) .setAuthor(scan.nextLine()) .setPrice(scan.nextDouble()) ); scan.nextLine(); } //TODO 书籍类 private static class Book implements Serializable{ int index;//索书号 String name;//书名 String author;//作者 double price;//价格 public Book setName(String name) { this.name = name; return this; } public Book setIndex(int index) { this.index = index; return this; } public Book setAuthor(String author) { this.author = author; return this; } public Book setPrice(double price) { this.price = price; return this; } @Override public String toString() { return \"书籍{\" + \"索书号=\" + index + \", 书名='\" + name + '\\'' + \", 作者='\" + author + '\\'' + \", 价格=\" + price + '}'; } @Override public boolean equals(Object o) { if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; Book book = (Book) o; return index == book.index; } @Override public int hashCode() { return Objects.hash(index); } } } ","date":"2022-01-23","objectID":"/posts/java-io/:7:1","tags":["Java I/O"],"title":"Java I/O","uri":"/posts/java-io/"},{"categories":["JavaSE笔记"],"content":"Java反射与注解","date":"2022-01-23","objectID":"/posts/java%E5%8F%8D%E5%B0%84%E4%B8%8E%E6%B3%A8%E5%B0%84/","tags":["Java反射与注解"],"title":"Java反射与注解","uri":"/posts/java%E5%8F%8D%E5%B0%84%E4%B8%8E%E6%B3%A8%E5%B0%84/"},{"categories":["JavaSE笔记"],"content":"Java反射和注解 配套视频 **注意：**本章节涉及到JVM相关底层原理，难度会有一些大。 反射就是把Java类中的各个成分映射成一个个的Java对象。即在运行状态中，对于任意一个类，都能够知道这个类所有的属性和方法，对于任意一个对象，都能调用它的任意一个方法和属性。这种动态获取信息及动态调用对象方法的功能叫Java的反射机制。 简而言之，我们可以通过反射机制，获取到类的一些属性，包括类里面有哪些字段，有哪些方法，继承自哪个类，甚至还能获取到泛型！它的权限非常高，慎重使用！ ","date":"2022-01-23","objectID":"/posts/java%E5%8F%8D%E5%B0%84%E4%B8%8E%E6%B3%A8%E5%B0%84/:0:0","tags":["Java反射与注解"],"title":"Java反射与注解","uri":"/posts/java%E5%8F%8D%E5%B0%84%E4%B8%8E%E6%B3%A8%E5%B0%84/"},{"categories":["JavaSE笔记"],"content":"Java类加载机制 在学习Java的反射机制之前，我们需要先了解一下类的加载机制，一个类是如何被加载和使用的： 在Java程序启动时，JVM会将一部分类（class文件）先加载（并不是所有的类都会在一开始加载），通过ClassLoader将类加载，在加载过程中，会将类的信息提取出来（存放在元空间中，JDK1.8之前存放在永久代），同时也会生成一个Class对象存放在内存（堆内存），注意此Class对象只会存在一个，与加载的类唯一对应！ **思考：**既然说和与加载的类唯一对应，那如果我们手动创建一个与JDK包名一样，同时类名也保持一致，那么JVM会加载这个类吗？ package java.lang; public class String { //JDK提供的String类也是 public static void main(String[] args) { System.out.println(\"我姓🐴，我叫🐴nb\"); } } 我们发现，会出现以下报错： 错误: 在类 java.lang.String 中找不到 main 方法, 请将 main 方法定义为: public static void main(String[] args) 但是我们明明在自己写的String类中定义了main方法啊，为什么会找不到此方法呢？实际上这是ClassLoader的双亲委派机制在保护Java程序的正常运行： 实际上我们的类最开始是由BootstarpClassLoader进行加载，BootstarpClassLoader用于加载JDK提供的类，而我们自己编写的类实际上是AppClassLoader，只有BootstarpClassLoader都没有加载的类，才会让AppClassLoader来加载，因此我们自己编写的同名包同名类不会被加载，而实际要去启动的是真正的String类，也就自然找不到main方法了！ public class Main { public static void main(String[] args) { System.out.println(Main.class.getClassLoader()); //查看当前类的类加载器 System.out.println(Main.class.getClassLoader().getParent()); //父加载器 System.out.println(Main.class.getClassLoader().getParent().getParent()); //爷爷加载器 System.out.println(String.class.getClassLoader()); //String类的加载器 } } 由于BootstarpClassLoader是C++编写的，我们在Java中是获取不到的。 ","date":"2022-01-23","objectID":"/posts/java%E5%8F%8D%E5%B0%84%E4%B8%8E%E6%B3%A8%E5%B0%84/:1:0","tags":["Java反射与注解"],"title":"Java反射与注解","uri":"/posts/java%E5%8F%8D%E5%B0%84%E4%B8%8E%E6%B3%A8%E5%B0%84/"},{"categories":["JavaSE笔记"],"content":"Class对象 通过前面，我们了解了类的加载，同时会提取一个类的信息生成Class对象存放在内存中，而反射机制其实就是利用这些存放的类信息，来获取类的信息和操作类。那么如何获取到每个类对应的Class对象呢，我们可以通过以下方式： public static void main(String[] args) throws ClassNotFoundException { Class\u003cString\u003e clazz = String.class; //使用class关键字，通过类名获取 Class\u003c?\u003e clazz2 = Class.forName(\"java.lang.String\"); //使用Class类静态方法forName()，通过包名.类名获取，注意返回值是Class\u003c?\u003e Class\u003c?\u003e clazz3 = new String(\"cpdd\").getClass(); //通过实例对象获取 } 注意Class类也是一个泛型类，只有第一种方法，能够直接获取到对应类型的Class对象，而以下两种方法使用了?通配符作为返回值，但是实际上都和第一个返回的是同一个对象： Class\u003cString\u003e clazz = String.class; //使用class关键字，通过类名获取 Class\u003c?\u003e clazz2 = Class.forName(\"java.lang.String\"); //使用Class类静态方法forName()，通过包名.类名获取，注意返回值是Class\u003c?\u003e Class\u003c?\u003e clazz3 = new String(\"cpdd\").getClass(); System.out.println(clazz == clazz2); System.out.println(clazz == clazz3); 通过比较，验证了我们一开始的结论，在JVM中每个类始终只存在一个Class对象，无论通过什么方法获取，都是一样的。现在我们再来看看这个问题： public static void main(String[] args) { Class\u003c?\u003e clazz = int.class; //基本数据类型有Class对象吗？ System.out.println(clazz); } 迷了，不是每个类才有Class对象吗，基本数据类型又不是类，这也行吗？实际上，基本数据类型也有对应的Class对象（反射操作可能需要用到），而且我们不仅可以通过class关键字获取，其实本质上是定义在对应的包装类中的： /** * The {@code Class} instance representing the primitive type * {@code int}. * * @since JDK1.1 */ @SuppressWarnings(\"unchecked\") public static final Class\u003cInteger\u003e TYPE = (Class\u003cInteger\u003e) Class.getPrimitiveClass(\"int\"); /* * Return the Virtual Machine's Class object for the named * primitive type */ static native Class\u003c?\u003e getPrimitiveClass(String name); //C++实现，并非Java定义 每个包装类中（包括Void），都有一个获取原始类型Class方法，注意，getPrimitiveClass获取的是原始类型，并不是包装类型，只是可以使用包装类来表示。 public static void main(String[] args) { Class\u003c?\u003e clazz = int.class; System.out.println(Integer.TYPE == int.class); } 通过对比，我们发现实际上包装类型都有一个TYPE，其实也就是基本类型的Class，那么包装类的Class和基本类的Class一样吗？ public static void main(String[] args) { System.out.println(Integer.TYPE == Integer.class); } 我们发现，包装类型的Class对象并不是基本类型Class对象。数组类型也是一种类型，只是编程不可见，因此我们可以直接获取数组的Class对象： public static void main(String[] args) { Class\u003cString[]\u003e clazz = String[].class; System.out.println(clazz.getName()); //获取类名称（得到的是包名+类名的完整名称） System.out.println(clazz.getSimpleName()); System.out.println(clazz.getTypeName()); System.out.println(clazz.getClassLoader()); //获取它的类加载器 System.out.println(clazz.cast(new Integer(\"10\"))); //强制类型转换 } ","date":"2022-01-23","objectID":"/posts/java%E5%8F%8D%E5%B0%84%E4%B8%8E%E6%B3%A8%E5%B0%84/:2:0","tags":["Java反射与注解"],"title":"Java反射与注解","uri":"/posts/java%E5%8F%8D%E5%B0%84%E4%B8%8E%E6%B3%A8%E5%B0%84/"},{"categories":["JavaSE笔记"],"content":"再谈instanceof 正常情况下，我们使用instanceof进行类型比较： public static void main(String[] args) { String str = \"\"; System.out.println(str instanceof String); } 它可以判断一个对象是否为此接口或是类的实现或是子类，而现在我们有了更多的方式去判断类型： public static void main(String[] args) { String str = \"\"; System.out.println(str.getClass() == String.class); //直接判断是否为这个类型 } 如果需要判断是否为子类或是接口/抽象类的实现，我们可以使用asSubClass()方法： public static void main(String[] args) { Integer i = 10; i.getClass().asSubclass(Number.class); //当Integer不是Number的子类时，会产生异常 } ","date":"2022-01-23","objectID":"/posts/java%E5%8F%8D%E5%B0%84%E4%B8%8E%E6%B3%A8%E5%B0%84/:2:1","tags":["Java反射与注解"],"title":"Java反射与注解","uri":"/posts/java%E5%8F%8D%E5%B0%84%E4%B8%8E%E6%B3%A8%E5%B0%84/"},{"categories":["JavaSE笔记"],"content":"获取父类信息 通过getSuperclass()方法，我们可以获取到父类的Class对象： public static void main(String[] args) { Integer i = 10; System.out.println(i.getClass().getSuperclass()); } 也可以通过getGenericSuperclass()获取父类的原始类型的Type： public static void main(String[] args) { Integer i = 10; Type type = i.getClass().getGenericSuperclass(); System.out.println(type); System.out.println(type instanceof Class); } 我们发现Type实际上是Class类的父接口，但是获取到的Type的实现并不一定是Class。 同理，我们也可以像上面这样获取父接口： public static void main(String[] args) { Integer i = 10; for (Class\u003c?\u003e anInterface : i.getClass().getInterfaces()) { System.out.println(anInterface.getName()); } for (Type genericInterface : i.getClass().getGenericInterfaces()) { System.out.println(genericInterface.getTypeName()); } } ","date":"2022-01-23","objectID":"/posts/java%E5%8F%8D%E5%B0%84%E4%B8%8E%E6%B3%A8%E5%B0%84/:2:2","tags":["Java反射与注解"],"title":"Java反射与注解","uri":"/posts/java%E5%8F%8D%E5%B0%84%E4%B8%8E%E6%B3%A8%E5%B0%84/"},{"categories":["JavaSE笔记"],"content":"创建类对象 既然我们拿到了类的定义，那么是否可以通过Class对象来创建对象、调用方法、修改变量呢？当然是可以的，那我们首先来探讨一下如何创建一个类的对象： public static void main(String[] args) throws InstantiationException, IllegalAccessException { Class\u003cStudent\u003e clazz = Student.class; Student student = clazz.newInstance(); student.test(); } static class Student{ public void test(){ System.out.println(\"萨日朗\"); } } 通过使用newInstance()方法来创建对应类型的实例，返回泛型T，注意它会抛出InstantiationException和IllegalAccessException异常，那么什么情况下会出现异常呢？ public static void main(String[] args) throws InstantiationException, IllegalAccessException { Class\u003cStudent\u003e clazz = Student.class; Student student = clazz.newInstance(); student.test(); } static class Student{ public Student(String text){ } public void test(){ System.out.println(\"萨日朗\"); } } 当类默认的构造方法被带参构造覆盖时，会出现InstantiationException异常，因为newInstance()只适用于默认无参构造。 public static void main(String[] args) throws InstantiationException, IllegalAccessException { Class\u003cStudent\u003e clazz = Student.class; Student student = clazz.newInstance(); student.test(); } static class Student{ private Student(){} public void test(){ System.out.println(\"萨日朗\"); } } 当默认无参构造的权限不是public时，会出现IllegalAccessException异常，表示我们无权去调用默认构造方法。在JDK9之后，不再推荐使用newInstance()方法了，而是使用我们接下来要介绍到的，通过获取构造器，来实例化对象： public static void main(String[] args) throws NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException { Class\u003cStudent\u003e clazz = Student.class; Student student = clazz.getConstructor(String.class).newInstance(\"what's up\"); student.test(); } static class Student{ public Student(String str){} public void test(){ System.out.println(\"萨日朗\"); } } 通过获取类的构造方法（构造器）来创建对象实例，会更加合理，我们可以使用getConstructor()方法来获取类的构造方法，同时我们需要向其中填入参数，也就是构造方法需要的类型，当然我们这里只演示了。那么，当访问权限不是public的时候呢？ public static void main(String[] args) throws NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException { Class\u003cStudent\u003e clazz = Student.class; Student student = clazz.getConstructor(String.class).newInstance(\"what's up\"); student.test(); } static class Student{ private Student(String str){} public void test(){ System.out.println(\"萨日朗\"); } } 我们发现，当访问权限不足时，会无法找到此构造方法，那么如何找到非public的构造方法呢？ Class\u003cStudent\u003e clazz = Student.class; Constructor\u003cStudent\u003e constructor = clazz.getDeclaredConstructor(String.class); constructor.setAccessible(true); //修改访问权限 Student student = constructor.newInstance(\"what's up\"); student.test(); 使用getDeclaredConstructor()方法可以找到类中的非public构造方法，但是在使用之前，我们需要先修改访问权限，在修改访问权限之后，就可以使用非public方法了（这意味着，反射可以无视权限修饰符访问类的内容） ","date":"2022-01-23","objectID":"/posts/java%E5%8F%8D%E5%B0%84%E4%B8%8E%E6%B3%A8%E5%B0%84/:3:0","tags":["Java反射与注解"],"title":"Java反射与注解","uri":"/posts/java%E5%8F%8D%E5%B0%84%E4%B8%8E%E6%B3%A8%E5%B0%84/"},{"categories":["JavaSE笔记"],"content":"调用类的方法 我们可以通过反射来调用类的方法（本质上还是类的实例进行调用）只是利用反射机制实现了方法的调用，我们在包下创建一个新的类： package com.test; public class Student { public void test(String str){ System.out.println(\"萨日朗\"+str); } } 这次我们通过forName(String)来找到这个类并创建一个新的对象： public static void main(String[] args) throws ReflectiveOperationException { Class\u003c?\u003e clazz = Class.forName(\"com.test.Student\"); Object instance = clazz.newInstance(); //创建出学生对象 Method method = clazz.getMethod(\"test\", String.class); //通过方法名和形参类型获取类中的方法 method.invoke(instance, \"what's up\"); //通过Method对象的invoke方法来调用方法 } 通过调用getMethod()方法，我们可以获取到类中所有声明为public的方法，得到一个Method对象，我们可以通过Method对象的invoke()方法（返回值就是方法的返回值，因为这里是void，返回值为null）来调用已经获取到的方法，注意传参。 我们发现，利用反射之后，在一个对象从构造到方法调用，没有任何一处需要引用到对象的实际类型，我们也没有导入Student类，整个过程都是反射在代替进行操作，使得整个过程被模糊了，过多的使用反射，会极大地降低后期维护性。 同构造方法一样，当出现非public方法时，我们可以通过反射来无视权限修饰符，获取非public方法并调用，现在我们将test()方法的权限修饰符改为private： public static void main(String[] args) throws ReflectiveOperationException { Class\u003c?\u003e clazz = Class.forName(\"com.test.Student\"); Object instance = clazz.newInstance(); //创建出学生对象 Method method = clazz.getDeclaredMethod(\"test\", String.class); //通过方法名和形参类型获取类中的方法 method.setAccessible(true); method.invoke(instance, \"what's up\"); //通过Method对象的invoke方法来调用方法 } Method和Constructor都和Class一样，他们存储了方法的信息，包括方法的形式参数列表，返回值，方法的名称等内容，我们可以直接通过Method对象来获取这些信息： public static void main(String[] args) throws ReflectiveOperationException { Class\u003c?\u003e clazz = Class.forName(\"com.test.Student\"); Method method = clazz.getDeclaredMethod(\"test\", String.class); //通过方法名和形参类型获取类中的方法 System.out.println(method.getName()); //获取方法名称 System.out.println(method.getReturnType()); //获取返回值类型 } 当方法的参数为可变参数时，我们该如何获取方法呢？实际上，我们在之前就已经提到过，可变参数实际上就是一个数组，因此我们可以直接使用数组的class对象表示： Method method = clazz.getDeclaredMethod(\"test\", String[].class); 反射非常强大，尤其是我们提到的越权访问，但是请一定谨慎使用，别人将某个方法设置为private一定有他的理由，如果实在是需要使用别人定义为private的方法，就必须确保这样做是安全的，在没有了解别人代码的整个过程就强行越权访问，可能会出现无法预知的错误。 ","date":"2022-01-23","objectID":"/posts/java%E5%8F%8D%E5%B0%84%E4%B8%8E%E6%B3%A8%E5%B0%84/:4:0","tags":["Java反射与注解"],"title":"Java反射与注解","uri":"/posts/java%E5%8F%8D%E5%B0%84%E4%B8%8E%E6%B3%A8%E5%B0%84/"},{"categories":["JavaSE笔记"],"content":"修改类的属性 我们还可以通过反射访问一个类中定义的成员字段也可以修改一个类的对象中的成员字段值，通过getField()方法来获取一个类定义的指定字段： public static void main(String[] args) throws ReflectiveOperationException { Class\u003c?\u003e clazz = Class.forName(\"com.test.Student\"); Object instance = clazz.newInstance(); Field field = clazz.getField(\"i\"); //获取类的成员字段i field.set(instance, 100); //将类实例instance的成员字段i设置为100 Method method = clazz.getMethod(\"test\"); method.invoke(instance); } 在得到Field之后，我们就可以直接通过set()方法为某个对象，设定此属性的值，比如上面，我们就为instance对象设定值为100，当访问private字段时，同样可以按照上面的操作进行越权访问： public static void main(String[] args) throws ReflectiveOperationException { Class\u003c?\u003e clazz = Class.forName(\"com.test.Student\"); Object instance = clazz.newInstance(); Field field = clazz.getDeclaredField(\"i\"); //获取类的成员字段i field.setAccessible(true); field.set(instance, 100); //将类实例instance的成员字段i设置为100 Method method = clazz.getMethod(\"test\"); method.invoke(instance); } 现在我们已经知道，反射几乎可以把一个类的老底都给扒出来，任何属性，任何内容，都可以被反射修改，无论权限修饰符是什么，那么，如果我的字段被标记为final呢？现在在字段i前面添加final关键字，我们再来看看效果： private final int i = 10; 这时，当字段为final时，就修改失败了！当然，通过反射可以直接将final修饰符直接去除，去除后，就可以随意修改内容了，我们来尝试修改Integer的value值： public static void main(String[] args) throws ReflectiveOperationException { Integer i = 10; Field field = Integer.class.getDeclaredField(\"value\"); Field modifiersField = Field.class.getDeclaredField(\"modifiers\"); //这里要获取Field类的modifiers字段进行修改 modifiersField.setAccessible(true); modifiersField.setInt(field,field.getModifiers()\u0026~Modifier.FINAL); //去除final标记 field.setAccessible(true); field.set(i, 100); //强行设置值 System.out.println(i); } 我们可以发现，反射非常暴力，就连被定义为final字段的值都能强行修改，几乎能够无视一切阻拦。我们来试试看修改一些其他的类型： public static void main(String[] args) throws ReflectiveOperationException { List\u003cString\u003e i = new ArrayList\u003c\u003e(); Field field = ArrayList.class.getDeclaredField(\"size\"); field.setAccessible(true); field.set(i, 10); i.add(\"测试\"); //只添加一个元素 System.out.println(i.size()); //大小直接变成11 i.remove(10); //瞎移除都不带报错的，淦 } 实际上，整个ArrayList体系由于我们的反射操作，导致被破坏，因此它已经无法正常工作了！ 再次强调，在进行反射操作时，必须注意是否安全，虽然拥有了创世主的能力，但是我们不能滥用，我们只能把它当做一个不得已才去使用的工具！ ","date":"2022-01-23","objectID":"/posts/java%E5%8F%8D%E5%B0%84%E4%B8%8E%E6%B3%A8%E5%B0%84/:5:0","tags":["Java反射与注解"],"title":"Java反射与注解","uri":"/posts/java%E5%8F%8D%E5%B0%84%E4%B8%8E%E6%B3%A8%E5%B0%84/"},{"categories":["JavaSE笔记"],"content":"自定义ClassLoader加载类 我们可以自己手动将class文件加载到JVM中吗？先写好我们定义的类： package com.test; public class Test { public String text; public void test(String str){ System.out.println(text+\" \u003e 我是测试方法！\"+str); } } 通过javac命令，手动编译一个.class文件： nagocoler@NagodeMacBook-Pro HelloWorld % javac src/main/java/com/test/Test.java 编译后，得到一个class文件，我们把它放到根目录下，然后编写一个我们自己的ClassLoader，因为普通的ClassLoader无法加载二进制文件，因此我们编写一个自己的来让它支持： //定义一个自己的ClassLoader static class MyClassLoader extends ClassLoader{ public Class\u003c?\u003e defineClass(String name, byte[] b){ return defineClass(name, b, 0, b.length); //调用protected方法，支持载入外部class文件 } } public static void main(String[] args) throws IOException { MyClassLoader classLoader = new MyClassLoader(); FileInputStream stream = new FileInputStream(\"Test.class\"); byte[] bytes = new byte[stream.available()]; stream.read(bytes); Class\u003c?\u003e clazz = classLoader.defineClass(\"com.test.Test\", bytes); //类名必须和我们定义的保持一致 System.out.println(clazz.getName()); //成功加载外部class文件 } 现在，我们就将此class文件读取并解析为Class了，现在我们就可以对此类进行操作了（注意，我们无法在代码中直接使用此类型，因为它是我们直接加载的），我们来试试看创建一个此类的对象并调用其方法： try { Object obj = clazz.newInstance(); Method method = clazz.getMethod(\"test\", String.class); //获取我们定义的test(String str)方法 method.invoke(obj, \"哥们这瓜多少钱一斤？\"); }catch (Exception e){ e.printStackTrace(); } 我们来试试看修改成员字段之后，再来调用此方法： try { Object obj = clazz.newInstance(); Field field = clazz.getField(\"text\"); //获取成员变量 String text; field.set(obj, \"华强\"); Method method = clazz.getMethod(\"test\", String.class); //获取我们定义的test(String str)方法 method.invoke(obj, \"哥们这瓜多少钱一斤？\"); }catch (Exception e){ e.printStackTrace(); } 通过这种方式，我们就可以实现外部加载甚至是网络加载一个类，只需要把类文件传递即可，这样就无需再将代码写在本地，而是动态进行传递，不仅可以一定程度上防止源代码被反编译（只是一定程度上，想破解你代码有的是方法），而且在更多情况下，我们还可以对byte[]进行加密，保证在传输过程中的安全性。 ","date":"2022-01-23","objectID":"/posts/java%E5%8F%8D%E5%B0%84%E4%B8%8E%E6%B3%A8%E5%B0%84/:6:0","tags":["Java反射与注解"],"title":"Java反射与注解","uri":"/posts/java%E5%8F%8D%E5%B0%84%E4%B8%8E%E6%B3%A8%E5%B0%84/"},{"categories":["JavaSE笔记"],"content":"注解 其实我们在之前就接触到注解了，比如@Override表示重写父类方法（当然不加效果也是一样的，此注解在编译时会被自动丢弃）注解本质上也是一个类，只不过它的用法比较特殊。 注解可以被标注在任意地方，包括方法上、类名上、参数上、成员属性上、注解定义上等，就像注释一样，它相当于我们对某样东西的一个标记。而与注释不同的是，注解可以通过反射在运行时获取，注解也可以选择是否保留到运行时。 ","date":"2022-01-23","objectID":"/posts/java%E5%8F%8D%E5%B0%84%E4%B8%8E%E6%B3%A8%E5%B0%84/:7:0","tags":["Java反射与注解"],"title":"Java反射与注解","uri":"/posts/java%E5%8F%8D%E5%B0%84%E4%B8%8E%E6%B3%A8%E5%B0%84/"},{"categories":["JavaSE笔记"],"content":"预设注解 JDK预设了以下注解，作用于代码： @Override - 检查（仅仅是检查，不保留到运行时）该方法是否是重写方法。如果发现其父类，或者是引用的接口中并没有该方法时，会报编译错误。 @Deprecated - 标记过时方法。如果使用该方法，会报编译警告。 @SuppressWarnings - 指示编译器去忽略注解中声明的警告（仅仅编译器阶段，不保留到运行时） @FunctionalInterface - Java 8 开始支持，标识一个匿名函数或函数式接口。 @SafeVarargs - Java 7 开始支持，忽略任何使用参数为泛型变量的方法或构造函数调用产生的警告。 ","date":"2022-01-23","objectID":"/posts/java%E5%8F%8D%E5%B0%84%E4%B8%8E%E6%B3%A8%E5%B0%84/:7:1","tags":["Java反射与注解"],"title":"Java反射与注解","uri":"/posts/java%E5%8F%8D%E5%B0%84%E4%B8%8E%E6%B3%A8%E5%B0%84/"},{"categories":["JavaSE笔记"],"content":"元注解 元注解是作用于注解上的注解，用于我们编写自定义的注解： @Retention - 标识这个注解怎么保存，是只在代码中，还是编入class文件中，或者是在运行时可以通过反射访问。 @Documented - 标记这些注解是否包含在用户文档中。 @Target - 标记这个注解应该是哪种 Java 成员。 @Inherited - 标记这个注解是继承于哪个注解类(默认 注解并没有继承于任何子类) @Repeatable - Java 8 开始支持，标识某注解可以在同一个声明上使用多次。 看了这么多预设的注解，你们肯定眼花缭乱了，那我们来看看@Override是如何定义的： @Target(ElementType.METHOD) @Retention(RetentionPolicy.SOURCE) public @interface Override { } 该注解由@Target限定为只能作用于方法上，ElementType是一个枚举类型，用于表示此枚举的作用域，一个注解可以有很多个作用域。@Retention表示此注解的保留策略，包括三种策略，在上述中有写到，而这里定义为只在代码中。一般情况下，自定义的注解需要定义1个@Retention和1-n个@Target。 既然了解了元注解的使用和注解的定义方式，我们就来尝试定义一个自己的注解： @Target(ElementType.METHOD) @Retention(RetentionPolicy.RUNTIME) public @interface Test { } 这里我们定义一个Test注解，并将其保留到运行时，同时此注解可以作用于方法或是类上： @Test public class Main { @Test public static void main(String[] args) { } } 这样，一个最简单的注解就被我们创建了。 ","date":"2022-01-23","objectID":"/posts/java%E5%8F%8D%E5%B0%84%E4%B8%8E%E6%B3%A8%E5%B0%84/:7:2","tags":["Java反射与注解"],"title":"Java反射与注解","uri":"/posts/java%E5%8F%8D%E5%B0%84%E4%B8%8E%E6%B3%A8%E5%B0%84/"},{"categories":["JavaSE笔记"],"content":"注解的使用 我们还可以在注解中定义一些属性，注解的属性也叫做成员变量，注解只有成员变量，没有方法。注解的成员变量在注解的定义中以“无形参的方法”形式来声明，其方法名定义了该成员变量的名字，其返回值定义了该成员变量的类型： @Target({ElementType.METHOD, ElementType.TYPE}) @Retention(RetentionPolicy.RUNTIME) public @interface Test { String value(); } 默认只有一个属性时，我们可以将其名字设定为value，否则，我们需要在使用时手动指定注解的属性名称，使用value则无需填入： @Target({ElementType.METHOD, ElementType.TYPE}) @Retention(RetentionPolicy.RUNTIME) public @interface Test { String test(); } public class Main { @Test(test = \"\") public static void main(String[] args) { } } 我们也可以使用default关键字来为这些属性指定默认值： @Target({ElementType.METHOD, ElementType.TYPE}) @Retention(RetentionPolicy.RUNTIME) public @interface Test { String value() default \"都看到这里了，给个三连吧！\"; } 当属性存在默认值时，使用注解的时候可以不用传入属性值。当属性为数组时呢？ @Target({ElementType.METHOD, ElementType.TYPE}) @Retention(RetentionPolicy.RUNTIME) public @interface Test { String[] value(); } 当属性为数组，我们在使用注解传参时，如果数组里面只有一个内容，我们可以直接传入一个值，而不是创建一个数组： @Test(\"关注点了吗\") public static void main(String[] args) { } public class Main { @Test({\"value1\", \"value2\"}) //多个值时就使用花括号括起来 public static void main(String[] args) { } } ","date":"2022-01-23","objectID":"/posts/java%E5%8F%8D%E5%B0%84%E4%B8%8E%E6%B3%A8%E5%B0%84/:7:3","tags":["Java反射与注解"],"title":"Java反射与注解","uri":"/posts/java%E5%8F%8D%E5%B0%84%E4%B8%8E%E6%B3%A8%E5%B0%84/"},{"categories":["JavaSE笔记"],"content":"反射获取注解 既然我们的注解可以保留到运行时，那么我们来看看，如何获取我们编写的注解，我们需要用到反射机制： public static void main(String[] args) { Class\u003cStudent\u003e clazz = Student.class; for (Annotation annotation : clazz.getAnnotations()) { System.out.println(annotation.annotationType()); //获取类型 System.out.println(annotation instanceof Test); //直接判断是否为Test Test test = (Test) annotation; System.out.println(test.value()); //获取我们在注解中写入的内容 } } 通过反射机制，我们可以快速获取到我们标记的注解，同时还能获取到注解中填入的值，那么我们来看看，方法上的标记是不是也可以通过这种方式获取注解： public static void main(String[] args) throws NoSuchMethodException { Class\u003cStudent\u003e clazz = Student.class; for (Annotation annotation : clazz.getMethod(\"test\").getAnnotations()) { System.out.println(annotation.annotationType()); //获取类型 System.out.println(annotation instanceof Test); //直接判断是否为Test Test test = (Test) annotation; System.out.println(test.value()); //获取我们在注解中写入的内容 } } 无论是方法、类、还是字段，都可以使用getAnnotations()方法（还有几个同名的）来快速获取我们标记的注解。 所以说呢，这玩意学来有啥用？丝毫get不到这玩意的用处。其实不是，现阶段你们还体会不到注解带来的快乐，在接触到Spring和SpringBoot等大型框架后，就能感受到注解带来的魅力了。 ","date":"2022-01-23","objectID":"/posts/java%E5%8F%8D%E5%B0%84%E4%B8%8E%E6%B3%A8%E5%B0%84/:7:4","tags":["Java反射与注解"],"title":"Java反射与注解","uri":"/posts/java%E5%8F%8D%E5%B0%84%E4%B8%8E%E6%B3%A8%E5%B0%84/"},{"categories":["JavaSE笔记"],"content":"Java多线程","date":"2022-01-23","objectID":"/posts/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/","tags":["Java多线程"],"title":"Java多线程","uri":"/posts/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"categories":["JavaSE笔记"],"content":"Java多线程 配套视频 **注意：**本章节会涉及到 操作系统 相关知识。 在了解多线程之前，让我们回顾一下操作系统中提到的进程概念： 进程是程序执行的实体，每一个进程都是一个应用程序（比如我们运行QQ、浏览器、LOL、网易云音乐等软件），都有自己的内存空间，CPU一个核心同时只能处理一件事情，当出现多个进程需要同时运行时，CPU一般通过时间片轮转调度算法，来实现多个进程的同时运行。 在早期的计算机中，进程是拥有资源和独立运行的最小单位，也是程序执行的最小单位。但是，如果我希望两个任务同时进行，就必须运行两个进程，由于每个进程都有一个自己的内存空间，进程之间的通信就变得非常麻烦（比如要共享某些数据）而且执行不同进程会产生上下文切换，非常耗时，那么能否实现在一个进程中就能够执行多个任务呢？ 后来，线程横空出世，一个进程可以有多个线程，线程是程序执行中一个单一的顺序控制流程，现在线程才是程序执行流的最小单元，各个线程之间共享程序的内存空间（也就是所在进程的内存空间），上下文切换速度也高于进程。 在Java中，我们从开始，一直以来编写的都是单线程应用程序（运行main()方法的内容），也就是说只能同时执行一个任务（无论你是调用方法、还是进行计算，始终都是依次进行的，也就是同步的），而如果我们希望同时执行多个任务（两个方法同时在运行或者是两个计算同时在进行，也就是异步的），就需要用到Java多线程框架。实际上一个Java程序启动后，会创建很多线程，不仅仅只运行一个主线程： public static void main(String[] args) { ThreadMXBean bean = ManagementFactory.getThreadMXBean(); long[] ids = bean.getAllThreadIds(); ThreadInfo[] infos = bean.getThreadInfo(ids); for (ThreadInfo info : infos) { System.out.println(info.getThreadName()); } } 关于除了main线程默认以外的线程，涉及到JVM相关底层原理，在这里不做讲解，了解就行。 ","date":"2022-01-23","objectID":"/posts/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/:0:0","tags":["Java多线程"],"title":"Java多线程","uri":"/posts/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"categories":["JavaSE笔记"],"content":"线程的创建和启动 通过创建Thread对象来创建一个新的线程，Thread构造方法中需要传入一个Runnable接口的实现（其实就是编写要在另一个线程执行的内容逻辑）同时Runnable只有一个未实现方法，因此可以直接使用lambda表达式： @FunctionalInterface public interface Runnable { /** * When an object implementing interface \u003ccode\u003eRunnable\u003c/code\u003e is used * to create a thread, starting the thread causes the object's * \u003ccode\u003erun\u003c/code\u003e method to be called in that separately executing * thread. * \u003cp\u003e * The general contract of the method \u003ccode\u003erun\u003c/code\u003e is that it may * take any action whatsoever. * * @see java.lang.Thread#run() */ public abstract void run(); } 创建好后，通过调用start()方法来运行此线程： public static void main(String[] args) { Thread t = new Thread(() -\u003e { //直接编写逻辑 System.out.println(\"我是另一个线程！\"); }); t.start(); //调用此方法来开始执行此线程 } 可能上面的例子看起来和普通的单线程没两样，那我们先来看看下面这段代码的运行结果： public static void main(String[] args) { Thread t = new Thread(() -\u003e { System.out.println(\"我是线程：\"+Thread.currentThread().getName()); System.out.println(\"我正在计算 0-10000 之间所有数的和...\"); int sum = 0; for (int i = 0; i \u003c= 10000; i++) { sum += i; } System.out.println(\"结果：\"+sum); }); t.start(); System.out.println(\"我是主线程！\"); } 我们发现，这段代码执行输出结果并不是按照从上往下的顺序了，因为他们分别位于两个线程，他们是同时进行的！如果你还是觉得很疑惑，我们接着来看下面的代码运行结果： public static void main(String[] args) { Thread t1 = new Thread(() -\u003e { for (int i = 0; i \u003c 50; i++) { System.out.println(\"我是一号线程：\"+i); } }); Thread t2 = new Thread(() -\u003e { for (int i = 0; i \u003c 50; i++) { System.out.println(\"我是二号线程：\"+i); } }); t1.start(); t2.start(); } 我们可以看到打印实际上是在交替进行的，也证明了他们是在同时运行！ 注意：我们发现还有一个run方法，也能执行线程里面定义的内容，但是run是直接在当前线程执行，并不是创建一个线程执行！ 实际上，线程和进程差不多，也会等待获取CPU资源，一旦获取到，就开始按顺序执行我们给定的程序，当需要等待外部IO操作（比如Scanner获取输入的文本），就会暂时处于休眠状态，等待通知，或是调用sleep()方法来让当前线程休眠一段时间： public static void main(String[] args) throws InterruptedException { System.out.println(\"l\"); Thread.sleep(1000); //休眠时间，以毫秒为单位，1000ms = 1s System.out.println(\"b\"); Thread.sleep(1000); System.out.println(\"w\"); Thread.sleep(1000); System.out.println(\"nb!\"); } 我们也可以使用stop()方法来强行终止此线程： public static void main(String[] args) throws InterruptedException { Thread t = new Thread(() -\u003e { Thread me = Thread.currentThread(); //获取当前线程对象 for (int i = 0; i \u003c 50; i++) { System.out.println(\"打印:\"+i); if(i == 20) me.stop(); //此方法会直接终止此线程 } }); t.start(); } 虽然stop()方法能够终止此线程，但是并不是所推荐的做法，有关线程中断相关问题，我们会在后面继续了解。 思考：猜猜以下程序输出结果： private static int value = 0; public static void main(String[] args) throws InterruptedException { Thread t1 = new Thread(() -\u003e { for (int i = 0; i \u003c 10000; i++) value++; System.out.println(\"线程1完成\"); }); Thread t2 = new Thread(() -\u003e { for (int i = 0; i \u003c 10000; i++) value++; System.out.println(\"线程2完成\"); }); t1.start(); t2.start(); Thread.sleep(1000); //主线程停止1秒，保证两个线程执行完成 System.out.println(value); } 我们发现，value最后的值并不是我们理想的结果，有关为什么会出现这种问题，在我们学习到线程锁的时候，再来探讨。 ","date":"2022-01-23","objectID":"/posts/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/:1:0","tags":["Java多线程"],"title":"Java多线程","uri":"/posts/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"categories":["JavaSE笔记"],"content":"线程的休眠和中断 我们前面提到，一个线程处于运行状态下，线程的下一个状态会出现以下情况： 当CPU给予的运行时间结束时，会从运行状态回到就绪（可运行）状态，等待下一次获得CPU资源。 当线程进入休眠 / 阻塞(如等待IO请求) / 手动调用wait()方法时，会使得线程处于等待状态，当等待状态结束后会回到就绪状态。 当线程出现异常或错误 / 被stop() 方法强行停止 / 所有代码执行结束时，会使得线程的运行终止。 而这个部分我们着重了解一下线程的休眠和中断，首先我们来了解一下如何使得线程进如休眠状态： public static void main(String[] args) { Thread t = new Thread(() -\u003e { try { System.out.println(\"l\"); Thread.sleep(1000); //sleep方法是Thread的静态方法，它只作用于当前线程（它知道当前线程是哪个） System.out.println(\"b\"); //调用sleep后，线程会直接进入到等待状态，直到时间结束 } catch (InterruptedException e) { e.printStackTrace(); } }); t.start(); } 通过调用sleep()方法来将当前线程进入休眠，使得线程处于等待状态一段时间。我们发现，此方法显示声明了会抛出一个InterruptedException异常，那么这个异常在什么时候会发生呢？ public static void main(String[] args) { Thread t = new Thread(() -\u003e { try { Thread.sleep(10000); //休眠10秒 } catch (InterruptedException e) { e.printStackTrace(); } }); t.start(); try { Thread.sleep(3000); //休眠3秒，一定比线程t先醒来 t.interrupt(); //调用t的interrupt方法 } catch (InterruptedException e) { e.printStackTrace(); } } 我们发现，每一个Thread对象中，都有一个interrupt()方法，调用此方法后，会给指定线程添加一个中断标记以告知线程需要立即停止运行或是进行其他操作，由线程来响应此中断并进行相应的处理，我们前面提到的stop()方法是强制终止线程，这样的做法虽然简单粗暴，但是很有可能导致资源不能完全释放，而类似这样的发送通知来告知线程需要中断，让线程自行处理后续，会更加合理一些，也是更加推荐的做法。我们来看看interrupt的用法： public static void main(String[] args) { Thread t = new Thread(() -\u003e { System.out.println(\"线程开始运行！\"); while (true){ //无限循环 if(Thread.currentThread().isInterrupted()){ //判断是否存在中断标志 break; //响应中断 } } System.out.println(\"线程被中断了！\"); }); t.start(); try { Thread.sleep(3000); //休眠3秒，一定比线程t先醒来 t.interrupt(); //调用t的interrupt方法 } catch (InterruptedException e) { e.printStackTrace(); } } 通过isInterrupted()可以判断线程是否存在中断标志，如果存在，说明外部希望当前线程立即停止，也有可能是给当前线程发送一个其他的信号，如果我们并不是希望收到中断信号就是结束程序，而是通知程序做其他事情，我们可以在收到中断信号后，复位中断标记，然后继续做我们的事情： public static void main(String[] args) { Thread t = new Thread(() -\u003e { System.out.println(\"线程开始运行！\"); while (true){ if(Thread.currentThread().isInterrupted()){ //判断是否存在中断标志 System.out.println(\"发现中断信号，复位，继续运行...\"); Thread.interrupted(); //复位中断标记（返回值是当前是否有中断标记，这里不用管） } } }); t.start(); try { Thread.sleep(3000); //休眠3秒，一定比线程t先醒来 t.interrupt(); //调用t的interrupt方法 } catch (InterruptedException e) { e.printStackTrace(); } } 复位中断标记后，会立即清除中断标记。那么，如果现在我们想暂停线程呢？我们希望线程暂时停下，比如等待其他线程执行完成后，再继续运行，那这样的操作怎么实现呢？ public static void main(String[] args) { Thread t = new Thread(() -\u003e { System.out.println(\"线程开始运行！\"); Thread.currentThread().suspend(); //暂停此线程 System.out.println(\"线程继续运行！\"); }); t.start(); try { Thread.sleep(3000); //休眠3秒，一定比线程t先醒来 t.resume(); //恢复此线程 } catch (InterruptedException e) { e.printStackTrace(); } } 虽然这样很方便地控制了线程的暂停状态，但是这两个方法我们发现实际上也是不推荐的做法，它很容易导致死锁！有关为什么被弃用的原因，我们会在线程锁继续探讨。 ","date":"2022-01-23","objectID":"/posts/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/:2:0","tags":["Java多线程"],"title":"Java多线程","uri":"/posts/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"categories":["JavaSE笔记"],"content":"线程的优先级 实际上，Java程序中的每个线程并不是平均分配CPU时间的，为了使得线程资源分配更加合理，Java采用的是抢占式调度方式，优先级越高的线程，优先使用CPU资源！我们希望CPU花费更多的时间去处理更重要的任务，而不太重要的任务，则可以先让出一部分资源。线程的优先级一般分为以下三种： MIN_PRIORITY 最低优先级 MAX_PRIORITY 最高优先级 NOM_PRIORITY 常规优先级 public static void main(String[] args) { Thread t = new Thread(() -\u003e { System.out.println(\"线程开始运行！\"); }); t.start(); t.setPriority(Thread.MIN_PRIORITY); //通过使用setPriority方法来设定优先级 } 优先级越高的线程，获得CPU资源的概率会越大，并不是说一定优先级越高的线程越先执行！ ","date":"2022-01-23","objectID":"/posts/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/:3:0","tags":["Java多线程"],"title":"Java多线程","uri":"/posts/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"categories":["JavaSE笔记"],"content":"线程的礼让和加入 我们还可以在当前线程的工作不重要时，将CPU资源让位给其他线程，通过使用yield()方法来将当前资源让位给其他同优先级线程： public static void main(String[] args) { Thread t1 = new Thread(() -\u003e { System.out.println(\"线程1开始运行！\"); for (int i = 0; i \u003c 50; i++) { if(i % 5 == 0) { System.out.println(\"让位！\"); Thread.yield(); } System.out.println(\"1打印：\"+i); } System.out.println(\"线程1结束！\"); }); Thread t2 = new Thread(() -\u003e { System.out.println(\"线程2开始运行！\"); for (int i = 0; i \u003c 50; i++) { System.out.println(\"2打印：\"+i); } }); t1.start(); t2.start(); } 观察结果，我们发现，在让位之后，尽可能多的在执行线程2的内容。 当我们希望一个线程等待另一个线程执行完成后再继续进行，我们可以使用join()方法来实现线程的加入： public static void main(String[] args) { Thread t1 = new Thread(() -\u003e { System.out.println(\"线程1开始运行！\"); for (int i = 0; i \u003c 50; i++) { System.out.println(\"1打印：\"+i); } System.out.println(\"线程1结束！\"); }); Thread t2 = new Thread(() -\u003e { System.out.println(\"线程2开始运行！\"); for (int i = 0; i \u003c 50; i++) { System.out.println(\"2打印：\"+i); if(i == 10){ try { System.out.println(\"线程1加入到此线程！\"); t1.join(); //在i==10时，让线程1加入，先完成线程1的内容，在继续当前内容 } catch (InterruptedException e) { e.printStackTrace(); } } } }); t1.start(); t2.start(); } 我们发现，线程1加入后，线程2等待线程1待执行的内容全部执行完成之后，再继续执行的线程2内容。注意，线程的加入只是等待另一个线程的完成，并不是将另一个线程和当前线程合并！我们来看看： public static void main(String[] args) { Thread t1 = new Thread(() -\u003e { System.out.println(Thread.currentThread().getName()+\"开始运行！\"); for (int i = 0; i \u003c 50; i++) { System.out.println(Thread.currentThread().getName()+\"打印：\"+i); } System.out.println(\"线程1结束！\"); }); Thread t2 = new Thread(() -\u003e { System.out.println(\"线程2开始运行！\"); for (int i = 0; i \u003c 50; i++) { System.out.println(\"2打印：\"+i); if(i == 10){ try { System.out.println(\"线程1加入到此线程！\"); t1.join(); //在i==10时，让线程1加入，先完成线程1的内容，在继续当前内容 } catch (InterruptedException e) { e.printStackTrace(); } } } }); t1.start(); t2.start(); } 实际上，t2线程只是暂时处于等待状态，当t1执行结束时，t2才开始继续执行，只是在效果上看起来好像是两个线程合并为一个线程在执行而已。 ","date":"2022-01-23","objectID":"/posts/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/:4:0","tags":["Java多线程"],"title":"Java多线程","uri":"/posts/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"categories":["JavaSE笔记"],"content":"线程锁和线程同步 在开始讲解线程同步之前，我们需要先了解一下多线程情况下Java的内存管理： 线程之间的共享变量（比如之前悬念中的value变量）存储在主内存（main memory）中，每个线程都有一个私有的工作内存（本地内存），工作内存中存储了该线程以读/写共享变量的副本。它类似于我们在计算机组成原理中学习的多处理器高速缓存机制： 高速缓存通过保存内存中数据的副本来提供更加快速的数据访问，但是如果多个处理器的运算任务都涉及同一块内存区域，就可能导致各自的高速缓存数据不一致，在写回主内存时就会发生冲突，这就是引入高速缓存引发的新问题，称之为：缓存一致性。 实际上，Java的内存模型也是这样类似设计的，当我们同时去操作一个共享变量时，如果仅仅是读取还好，但是如果同时写入内容，就会出现问题！好比说一个银行，如果我和我的朋友同时在银行取我账户里面的钱，难道取1000还可能吐2000出来吗？我们需要一种更加安全的机制来维持秩序，保证数据的安全性！ ","date":"2022-01-23","objectID":"/posts/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/:5:0","tags":["Java多线程"],"title":"Java多线程","uri":"/posts/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"categories":["JavaSE笔记"],"content":"悬念破案 我们再来回顾一下之前留给大家的悬念： private static int value = 0; public static void main(String[] args) throws InterruptedException { Thread t1 = new Thread(() -\u003e { for (int i = 0; i \u003c 10000; i++) value++; System.out.println(\"线程1完成\"); }); Thread t2 = new Thread(() -\u003e { for (int i = 0; i \u003c 10000; i++) value++; System.out.println(\"线程2完成\"); }); t1.start(); t2.start(); Thread.sleep(1000); //主线程停止1秒，保证两个线程执行完成 System.out.println(value); } 实际上，当两个线程同时读取value的时候，可能会同时拿到同样的值，而进行自增操作之后，也是同样的值，再写回主内存后，本来应该进行2次自增操作，实际上只执行了一次！ 那么要去解决这样的问题，我们就必须采取某种同步机制，来限制不同线程对于共享变量的访问！我们希望的是保证共享变量value自增操作的原子性（原子性是指一个操作或多个操作要么全部执行，且执行的过程不会被任何因素打断，包括其他线程，要么就都不执行） ","date":"2022-01-23","objectID":"/posts/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/:5:1","tags":["Java多线程"],"title":"Java多线程","uri":"/posts/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"categories":["JavaSE笔记"],"content":"线程锁 通过synchronized关键字来创造一个线程锁，首先我们来认识一下synchronized代码块，它需要在括号中填入一个内容，必须是一个对象或是一个类，我们在value自增操作外套上同步代码块： private static int value = 0; public static void main(String[] args) throws InterruptedException { Thread t1 = new Thread(() -\u003e { for (int i = 0; i \u003c 10000; i++) { synchronized (Main.class){ value++; } } System.out.println(\"线程1完成\"); }); Thread t2 = new Thread(() -\u003e { for (int i = 0; i \u003c 10000; i++) { synchronized (Main.class){ value++; } } System.out.println(\"线程2完成\"); }); t1.start(); t2.start(); Thread.sleep(1000); //主线程停止1秒，保证两个线程执行完成 System.out.println(value); } 我们发现，现在得到的结果就是我们想要的内容了，因为在同步代码块执行过程中，拿到了我们传入对象或类的锁（传入的如果是对象，就是对象锁，不同的对象代表不同的对象锁，如果是类，就是类锁，类锁只有一个，实际上类锁也是对象锁，是Class类实例，但是Class类实例同样的类无论怎么获取都是同一个），但是注意两个线程必须使用同一把锁！ 当一个线程进入到同步代码块时，会获取到当前的锁，而这时如果其他使用同样的锁的同步代码块也想执行内容，就必须等待当前同步代码块的内容执行完毕，在执行完毕后会自动释放这把锁，而其他的线程才能拿到这把锁并开始执行同步代码块里面的内容。（实际上synchronized是一种悲观锁，随时都认为有其他线程在对数据进行修改，后面有机会我们还会讲到乐观锁，如CAS算法） 那么我们来看看，如果使用的是不同对象的锁，那么还能顺利进行吗？ private static int value = 0; public static void main(String[] args) throws InterruptedException { Main main1 = new Main(); Main main2 = new Main(); Thread t1 = new Thread(() -\u003e { for (int i = 0; i \u003c 10000; i++) { synchronized (main1){ value++; } } System.out.println(\"线程1完成\"); }); Thread t2 = new Thread(() -\u003e { for (int i = 0; i \u003c 10000; i++) { synchronized (main2){ value++; } } System.out.println(\"线程2完成\"); }); t1.start(); t2.start(); Thread.sleep(1000); //主线程停止1秒，保证两个线程执行完成 System.out.println(value); } 当对象不同时，获取到的是不同的锁，因此并不能保证自增操作的原子性，最后也得不到我们想要的结果。 synchronized关键字也可以作用于方法上，调用此方法时也会获取锁： private static int value = 0; private static synchronized void add(){ value++; } public static void main(String[] args) throws InterruptedException { Thread t1 = new Thread(() -\u003e { for (int i = 0; i \u003c 10000; i++) add(); System.out.println(\"线程1完成\"); }); Thread t2 = new Thread(() -\u003e { for (int i = 0; i \u003c 10000; i++) add(); System.out.println(\"线程2完成\"); }); t1.start(); t2.start(); Thread.sleep(1000); //主线程停止1秒，保证两个线程执行完成 System.out.println(value); } 我们发现实际上效果是相同的，只不过这个锁不用你去给，如果是静态方法，就是使用的类锁，而如果是普通成员方法，就是使用的对象锁。通过灵活的使用synchronized就能很好地解决我们之前提到的问题了！ ","date":"2022-01-23","objectID":"/posts/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/:5:2","tags":["Java多线程"],"title":"Java多线程","uri":"/posts/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"categories":["JavaSE笔记"],"content":"死锁 其实死锁的概念在操作系统中也有提及，它是指两个线程相互持有对方需要的锁，但是又迟迟不释放，导致程序卡住： 我们发现，线程A和线程B都需要对方的锁，但是又被对方牢牢把握，由于线程被无限期地阻塞，因此程序不可能正常终止。我们来看看以下这段代码会得到什么结果： public static void main(String[] args) throws InterruptedException { Object o1 = new Object(); Object o2 = new Object(); Thread t1 = new Thread(() -\u003e { synchronized (o1){ try { Thread.sleep(1000); synchronized (o2){ System.out.println(\"线程1\"); } } catch (InterruptedException e) { e.printStackTrace(); } } }); Thread t2 = new Thread(() -\u003e { synchronized (o2){ try { Thread.sleep(1000); synchronized (o1){ System.out.println(\"线程2\"); } } catch (InterruptedException e) { e.printStackTrace(); } } }); t1.start(); t2.start(); } 那么我们如何去检测死锁呢？我们可以利用jstack命令来检测死锁，首先利用jps找到我们的java进程： nagocoler@NagodeMacBook-Pro ~ % jps 51592 Launcher 51690 Jps 14955 51693 Main nagocoler@NagodeMacBook-Pro ~ % jstack 51693 ... Java stack information for the threads listed above: =================================================== \"Thread-1\": at com.test.Main.lambda$main$1(Main.java:46) - waiting to lock \u003c0x000000076ad27fc0\u003e (a java.lang.Object) - locked \u003c0x000000076ad27fd0\u003e (a java.lang.Object) at com.test.Main$$Lambda$2/1867750575.run(Unknown Source) at java.lang.Thread.run(Thread.java:748) \"Thread-0\": at com.test.Main.lambda$main$0(Main.java:34) - waiting to lock \u003c0x000000076ad27fd0\u003e (a java.lang.Object) - locked \u003c0x000000076ad27fc0\u003e (a java.lang.Object) at com.test.Main$$Lambda$1/396873410.run(Unknown Source) at java.lang.Thread.run(Thread.java:748) Found 1 deadlock. jstack自动帮助我们找到了一个死锁，并打印出了相关线程的栈追踪信息。 不推荐使用 suspend() 去挂起线程的原因，是因为suspend()在使线程暂停的同时，并不会去释放任何锁资源。其他线程都无法访问被它占用的锁。直到对应的线程执行resume()方法后，被挂起的线程才能继续，从而其它被阻塞在这个锁的线程才可以继续执行。但是，如果resume()操作出现在suspend()之前执行，那么线程将一直处于挂起状态，同时一直占用锁，这就产生了死锁。 ","date":"2022-01-23","objectID":"/posts/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/:5:3","tags":["Java多线程"],"title":"Java多线程","uri":"/posts/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"categories":["JavaSE笔记"],"content":"wait和notify方法 其实我们之前可能就发现了，Object类还有三个方法我们从来没有使用过，分别是wait()、notify()以及notifyAll()，他们其实是需要配合synchronized来使用的，只有在同步代码块中才能使用这些方法，我们来看看他们的作用是什么： public static void main(String[] args) throws InterruptedException { Object o1 = new Object(); Thread t1 = new Thread(() -\u003e { synchronized (o1){ try { System.out.println(\"开始等待\"); o1.wait(); //进入等待状态并释放锁 System.out.println(\"等待结束！\"); } catch (InterruptedException e) { e.printStackTrace(); } } }); Thread t2 = new Thread(() -\u003e { synchronized (o1){ System.out.println(\"开始唤醒！\"); o1.notify(); //唤醒处于等待状态的线程 for (int i = 0; i \u003c 50; i++) { System.out.println(i); } //唤醒后依然需要等待这里的锁释放之前等待的线程才能继续 } }); t1.start(); Thread.sleep(1000); t2.start(); } 我们可以发现，对象的wait()方法会暂时使得此线程进入等待状态，同时会释放当前代码块持有的锁，这时其他线程可以获取到此对象的锁，当其他线程调用对象的notify()方法后，会唤醒刚才变成等待状态的线程（这时并没有立即释放锁）。注意，必须是在持有锁（同步代码块内部）的情况下使用，否则会抛出异常！ notifyAll其实和notify一样，也是用于唤醒，但是前者是唤醒所有调用wait()后处于等待的线程，而后者是看运气随机选择一个。 ","date":"2022-01-23","objectID":"/posts/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/:5:4","tags":["Java多线程"],"title":"Java多线程","uri":"/posts/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"categories":["JavaSE笔记"],"content":"ThreadLocal的使用 既然每个线程都有一个自己的工作内存，那么能否只在自己的工作内存中创建变量仅供线程自己使用呢？ 我们可以是ThreadLocal类，来创建工作内存中的变量，它将我们的变量值存储在内部（只能存储一个变量），不同的变量访问到ThreadLocal对象时，都只能获取到自己线程所属的变量。 public static void main(String[] args) throws InterruptedException { ThreadLocal\u003cString\u003e local = new ThreadLocal\u003c\u003e(); //注意这是一个泛型类，存储类型为我们要存放的变量类型 Thread t1 = new Thread(() -\u003e { local.set(\"lbwnb\"); //将变量的值给予ThreadLocal System.out.println(\"变量值已设定！\"); System.out.println(local.get()); //尝试获取ThreadLocal中存放的变量 }); Thread t2 = new Thread(() -\u003e { System.out.println(local.get()); //尝试获取ThreadLocal中存放的变量 }); t1.start(); Thread.sleep(3000); //间隔三秒 t2.start(); } 上面的例子中，我们开启两个线程分别去访问ThreadLocal对象，我们发现，第一个线程存放的内容，第一个线程可以获取，但是第二个线程无法获取，我们再来看看第一个线程存入后，第二个线程也存放，是否会覆盖第一个线程存放的内容： public static void main(String[] args) throws InterruptedException { ThreadLocal\u003cString\u003e local = new ThreadLocal\u003c\u003e(); //注意这是一个泛型类，存储类型为我们要存放的变量类型 Thread t1 = new Thread(() -\u003e { local.set(\"lbwnb\"); //将变量的值给予ThreadLocal System.out.println(\"线程1变量值已设定！\"); try { Thread.sleep(2000); //间隔2秒 } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(\"线程1读取变量值：\"); System.out.println(local.get()); //尝试获取ThreadLocal中存放的变量 }); Thread t2 = new Thread(() -\u003e { local.set(\"yyds\"); //将变量的值给予ThreadLocal System.out.println(\"线程2变量值已设定！\"); }); t1.start(); Thread.sleep(1000); //间隔1秒 t2.start(); } 我们发现，即使线程2重新设定了值，也没有影响到线程1存放的值，所以说，不同线程向ThreadLocal存放数据，只会存放在线程自己的工作空间中，而不会直接存放到主内存中，因此各个线程直接存放的内容互不干扰。 我们发现在线程中创建的子线程，无法获得父线程工作内存中的变量： public static void main(String[] args) { ThreadLocal\u003cString\u003e local = new ThreadLocal\u003c\u003e(); Thread t = new Thread(() -\u003e { local.set(\"lbwnb\"); new Thread(() -\u003e { System.out.println(local.get()); }).start(); }); t.start(); } 我们可以使用InheritableThreadLocal来解决： public static void main(String[] args) { ThreadLocal\u003cString\u003e local = new InheritableThreadLocal\u003c\u003e(); Thread t = new Thread(() -\u003e { local.set(\"lbwnb\"); new Thread(() -\u003e { System.out.println(local.get()); }).start(); }); t.start(); } 在InheritableThreadLocal存放的内容，会自动向子线程传递。 ","date":"2022-01-23","objectID":"/posts/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/:5:5","tags":["Java多线程"],"title":"Java多线程","uri":"/posts/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"categories":["JavaSE笔记"],"content":"定时器 我们有时候会有这样的需求，我希望定时执行任务，比如3秒后执行，其实我们可以通过使用Thread.sleep()来实现： public static void main(String[] args) { new TimerTask(() -\u003e System.out.println(\"我是定时任务！\"), 3000).start(); //创建并启动此定时任务 } static class TimerTask{ Runnable task; long time; public TimerTask(Runnable runnable, long time){ this.task = runnable; this.time = time; } public void start(){ new Thread(() -\u003e { try { Thread.sleep(time); task.run(); //休眠后再运行 } catch (InterruptedException e) { e.printStackTrace(); } }).start(); } } 我们通过自行封装一个TimerTask类，并在启动时，先休眠3秒钟，再执行我们传入的内容。那么现在我们希望，能否循环执行一个任务呢？比如我希望每隔1秒钟执行一次代码，这样该怎么做呢？ public static void main(String[] args) { new TimerLoopTask(() -\u003e System.out.println(\"我是定时任务！\"), 3000).start(); //创建并启动此定时任务 } static class TimerLoopTask{ Runnable task; long loopTime; public TimerLoopTask(Runnable runnable, long loopTime){ this.task = runnable; this.loopTime = loopTime; } public void start(){ new Thread(() -\u003e { try { while (true){ //无限循环执行 Thread.sleep(loopTime); task.run(); //休眠后再运行 } } catch (InterruptedException e) { e.printStackTrace(); } }).start(); } } 现在我们将单次执行放入到一个无限循环中，这样就能一直执行了，并且按照我们的间隔时间进行。 但是终究是我们自己实现，可能很多方面还没考虑到，Java也为我们提供了一套自己的框架用于处理定时任务： public static void main(String[] args) { Timer timer = new Timer(); //创建定时器对象 timer.schedule(new TimerTask() { //注意这个是一个抽象类，不是接口，无法使用lambda表达式简化，只能使用匿名内部类 @Override public void run() { System.out.println(Thread.currentThread().getName()); //打印当前线程名称 } }, 1000); //执行一个延时任务 } 我们可以通过创建一个Timer类来让它进行定时任务调度，我们可以通过此对象来创建任意类型的定时任务，包延时任务、循环定时任务等。我们发现，虽然任务执行完成了，但是我们的程序并没有停止，这是因为Timer内存维护了一个任务队列和一个工作线程： public class Timer { /** * The timer task queue. This data structure is shared with the timer * thread. The timer produces tasks, via its various schedule calls, * and the timer thread consumes, executing timer tasks as appropriate, * and removing them from the queue when they're obsolete. */ private final TaskQueue queue = new TaskQueue(); /** * The timer thread. */ private final TimerThread thread = new TimerThread(queue); ... } TimerThread继承自Thread，是一个新创建的线程，在构造时自动启动： public Timer(String name) { thread.setName(name); thread.start(); } 而它的run方法会循环地读取队列中是否还有任务，如果有任务依次执行，没有的话就暂时处于休眠状态： public void run() { try { mainLoop(); } finally { // Someone killed this Thread, behave as if Timer cancelled synchronized(queue) { newTasksMayBeScheduled = false; queue.clear(); // Eliminate obsolete references } } } /** * The main timer loop. (See class comment.) */ private void mainLoop() { try { TimerTask task; boolean taskFired; synchronized(queue) { // Wait for queue to become non-empty while (queue.isEmpty() \u0026\u0026 newTasksMayBeScheduled) //当队列为空同时没有被关闭时，会调用wait()方法暂时处于等待状态，当有新的任务时，会被唤醒。 queue.wait(); if (queue.isEmpty()) break; //当被唤醒后都没有任务时，就会结束循环，也就是结束工作线程 ... } newTasksMayBeScheduled实际上就是标记当前定时器是否关闭，当它为false时，表示已经不会再有新的任务到来，也就是关闭，我们可以通过调用cancel()方法来关闭它的工作线程： public void cancel() { synchronized(queue) { thread.newTasksMayBeScheduled = false; queue.clear(); queue.notify(); //唤醒wait使得工作线程结束 } } 因此，我们可以在使用完成后，调用Timer的cancel()方法以正常退出我们的程序： public static void main(String[] args) { Timer timer = new Timer(); timer.schedule(new TimerTask() { @Override public void run() { System.out.println(Thread.currentThread().getName()); timer.cancel(); //结束 } }, 1000); } ","date":"2022-01-23","objectID":"/posts/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/:6:0","tags":["Java多线程"],"title":"Java多线程","uri":"/posts/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"categories":["JavaSE笔记"],"content":"守护线程 不要把守护进程和守护线程相提并论！守护进程在后台运行运行，不需要和用户交互，本质和普通进程类似。而守护线程就不一样了，当其他所有的非守护线程结束之后，守护线程是自动结束，也就是说，Java中所有的线程都执行完毕后，守护线程自动结束，因此守护线程不适合进行IO操作，只适合打打杂： public static void main(String[] args) throws InterruptedException{ Thread t = new Thread(() -\u003e { while (true){ try { System.out.println(\"程序正常运行中...\"); Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } } }); t.setDaemon(true); //设置为守护线程（必须在开始之前，中途是不允许转换的） t.start(); for (int i = 0; i \u003c 5; i++) { Thread.sleep(1000); } } 在守护线程中产生的新线程也是守护的： public static void main(String[] args) throws InterruptedException{ Thread t = new Thread(() -\u003e { Thread it = new Thread(() -\u003e { while (true){ try { System.out.println(\"程序正常运行中...\"); Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } } }); it.start(); }); t.setDaemon(true); //设置为守护线程（必须在开始之前，中途是不允许转换的） t.start(); for (int i = 0; i \u003c 5; i++) { Thread.sleep(1000); } } ","date":"2022-01-23","objectID":"/posts/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/:7:0","tags":["Java多线程"],"title":"Java多线程","uri":"/posts/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"categories":["JavaSE笔记"],"content":"再谈集合类并行方法 其实我们之前在讲解集合类的根接口时，就发现有这样一个方法： default Stream\u003cE\u003e parallelStream() { return StreamSupport.stream(spliterator(), true); } 并行流，其实就是一个多线程执行的流，它通过默认的ForkJoinPool实现（这里不讲解原理），它可以提高你的多线程任务的速度。 public static void main(String[] args) { List\u003cInteger\u003e list = new ArrayList\u003c\u003e(Arrays.asList(1, 4, 5, 2, 9, 3, 6, 0)); list .parallelStream() //获得并行流 .forEach(i -\u003e System.out.println(Thread.currentThread().getName()+\" -\u003e \"+i)); } 我们发现，forEach操作的顺序，并不是我们实际List中的顺序，同时每次打印也是不同的线程在执行！我们可以通过调用forEachOrdered()方法来使用单线程维持原本的顺序： public static void main(String[] args) { List\u003cInteger\u003e list = new ArrayList\u003c\u003e(Arrays.asList(1, 4, 5, 2, 9, 3, 6, 0)); list .parallelStream() //获得并行流 .forEachOrdered(System.out::println); } 我们之前还发现，在Arrays数组工具类中，也包含大量的并行方法： public static void main(String[] args) { int[] arr = new int[]{1, 4, 5, 2, 9, 3, 6, 0}; Arrays.parallelSort(arr); //使用多线程进行并行排序，效率更高 System.out.println(Arrays.toString(arr)); } 更多地使用并行方法，可以更加充分地发挥现代计算机多核心的优势，但是同时需要注意多线程产生的异步问题！ public static void main(String[] args) { int[] arr = new int[]{1, 4, 5, 2, 9, 3, 6, 0}; Arrays.parallelSetAll(arr, i -\u003e { System.out.println(Thread.currentThread().getName()); return arr[i]; }); System.out.println(Arrays.toString(arr)); } 通过对Java多线程的了解，我们就具备了利用多线程解决问题的思维！ ","date":"2022-01-23","objectID":"/posts/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/:8:0","tags":["Java多线程"],"title":"Java多线程","uri":"/posts/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"categories":["JavaSE笔记"],"content":"Java多线程编程实战 这是整个教程最后一个编程实战内容了，下一章节为反射一般开发者使用比较少，属于选学内容，不编排编程实战课程。 ","date":"2022-01-23","objectID":"/posts/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/:9:0","tags":["Java多线程"],"title":"Java多线程","uri":"/posts/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"categories":["JavaSE笔记"],"content":"生产者与消费者 所谓的生产者消费者模型，是通过一个容器来解决生产者和消费者的强耦合问题。通俗的讲，就是生产者在不断的生产，消费者也在不断的消费，可是消费者消费的产品是生产者生产的，这就必然存在一个中间容器，我们可以把这个容器想象成是一个货架，当货架空的时候，生产者要生产产品，此时消费者在等待生产者往货架上生产产品，而当货架有货物的时候，消费者可以从货架上拿走商品，生产者此时等待货架出现空位，进而补货，这样不断的循环。 通过多线程编程，来模拟一个餐厅的2个厨师和3个顾客，假设厨师炒出一个菜的时间为3秒，顾客吃掉菜品的时间为4秒。 ","date":"2022-01-23","objectID":"/posts/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/:9:1","tags":["Java多线程"],"title":"Java多线程","uri":"/posts/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"categories":["JavaSE笔记"],"content":"java面向对象","date":"2022-01-23","objectID":"/posts/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/","tags":["Java对象和多态"],"title":"Java对象和多态","uri":"/posts/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"categories":["JavaSE笔记"],"content":"Java对象和多态 （面向对象） 配套视频 ","date":"2022-01-23","objectID":"/posts/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/:0:0","tags":["Java对象和多态"],"title":"Java对象和多态","uri":"/posts/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"categories":["JavaSE笔记"],"content":"面向对象基础 面向对象程序设计(Object Oriented Programming) 对象基于类创建，类相当于一个模板，对象就是根据模板创建出来的实体（就像做月饼，我们要做一个月饼首先需要一个模具，模具就是我们的类，而做出来的月饼，就是类的实现，也叫做对象），类是抽象的数据类型，并不能代表某一个具体的事物，类是对象的一个模板。类具有自己的属性，包括成员变量、成员方法等，我们可以调用类的成员方法来让类进行一些操作。 Scanner sc = new Scanner(System.in); String str = sc.nextLine(); System.out.println(\"你输入了：\"+str); sc.close(); 所有的对象，都需要通过new关键字创建，基本数据类型不是对象！Java不是纯面对对象语言！ 不是基本类型的变量，都是引用类型，引用类型变量代表一个对象，而基本数据类型变量，保存的是基本数据类型的值，我们可以通过引用来对对象进行操作。（最好不要理解为引用指向对象的地址，初学者不要谈内存，学到JVM时再来讨论） 对象占用的内存由JVM统一管理，不需要手动释放内存，当一个对象不再使用时（比如失去引用或是离开了作用域）会被JVM自动清理，内存管理更方便！ ","date":"2022-01-23","objectID":"/posts/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/:1:0","tags":["Java对象和多态"],"title":"Java对象和多态","uri":"/posts/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"categories":["JavaSE笔记"],"content":"类的基本结构 为了快速掌握，我们自己创建一个自己的类，创建的类文件名称应该和类名一致。 ","date":"2022-01-23","objectID":"/posts/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/:2:0","tags":["Java对象和多态"],"title":"Java对象和多态","uri":"/posts/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"categories":["JavaSE笔记"],"content":"成员变量 在类中，可以包含许多的成员变量，也叫成员属性，成员字段(field)通过.来访问我们类中的成员变量，我们可以通过类创建的对象来访问和修改这些变量。成员变量是属于对象的！ public class Test { int age; String name; } public static void main(String[] args) { Test test = new Test(); test.name = \"奥利给\"; System.out.println(test.name); } 成员变量默认带有初始值，也可以自己定义初始值。 ","date":"2022-01-23","objectID":"/posts/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/:2:1","tags":["Java对象和多态"],"title":"Java对象和多态","uri":"/posts/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"categories":["JavaSE笔记"],"content":"成员方法 我们之前的学习中接触过方法(Method)吗？主方法！ public static void main(String[] args) { //Body } 方法是语句的集合，是为了完成某件事情而存在的。完成某件事情，可以有结果，也可以做了就做了，不返回结果。比如计算两个数字的和，我们需要得到计算后的结果，所以说方法需要有返回值；又比如，我们只想吧数字打印在控制台，只需要打印就行，不用给我结果，所以说方法不需要有返回值。 方法的定义和使用 在类中，我们可以定义自己的方法，格式如下： [返回值类型] 方法名称([参数]){ //方法体 return 结果; } 返回值类型：可以是引用类型和基本类型，还可以是void，表示没有返回值 方法名称：和标识符的规则一致，和变量一样，规范小写字母开头！ 参数：例如方法需要计算两个数的和，那么我们就要把两个数到底是什么告诉方法，那么它们就可以作为参数传入方法 方法体：方法具体要干的事情 结果：方法执行的结果通过return返回（如果返回类型为void，可以省略return） 非void方法中，return关键字不一定需要放在最后，但是一定要保证方法在任何情况下都具有返回值！ int test(int a){ if(a \u003e 0){ //缺少retrun语句！ }else{ return 0; } } return也能用来提前结束整个方法，无论此时程序执行到何处，无论return位于哪里，都会立即结束个方法！ void main(String[] args) { for (int i = 0; i \u003c 10; i++) { if(i == 1) return; //在循环内返回了！和break区别？ } System.out.println(\"淦\"); //还会到这里吗？ } 传入方法的参数，如果是基本类型，会在调用方法的时候，对参数的值进行复制，方法中的参数变量，不是我们传入的变量本身！ public static void main(String[] args) { int a = 10, b = 20; new Test().swap(a, b); System.out.println(\"a=\"+a+\", b=\"+b); } public class Test{ void swap(int a, int b){ //传递的仅仅是值而已！ int temp = a; a = b; b = temp; } } 传入方法的参数，如果是引用类型，那么传入的依然是该对象的引用！（类似于C语言的指针） public class B{ String name; } public class A{ void test(B b){ //传递的是对象的引用，而不是值 System.out.println(b.name); } } public static void main(String[] args) { int a = 10, b = 20; B b = new B(); b.name = \"lbw\"; new A().test(b); System.out.println(\"a=\"+a+\", b=\"+b); } 方法之间可以相互调用 void a(){ //xxxx } void b(){ a(); } 当方法在自己内部调用自己时，称为递归调用（递归很危险，慎重！） int a(){ return a(); } 成员方法和成员变量一样，是属于对象的，只能通过对象去调用！ ","date":"2022-01-23","objectID":"/posts/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/:2:2","tags":["Java对象和多态"],"title":"Java对象和多态","uri":"/posts/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"categories":["JavaSE笔记"],"content":"对象设计练习 学生应该具有以下属性：名字、年龄 学生应该具有以下行为：学习、运动、说话 ","date":"2022-01-23","objectID":"/posts/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/:2:3","tags":["Java对象和多态"],"title":"Java对象和多态","uri":"/posts/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"categories":["JavaSE笔记"],"content":"方法的重载 一个类中可以包含多个同名的方法，但是需要的形式参数不一样。（补充：形式参数就是定义方法需要的参数，实际参数就传入的参数）方法的返回类型，可以相同，也可以不同，但是仅返回类型不同，是不允许的！ public class Test { int a(){ //原本的方法 return 1; } int a(int i){ //ok，形参不同 return i; } void a(byte i){ //ok，返回类型和形参都不同 } void a(){ //错误，仅返回值类型名称不同不能重载 } } 现在我们就可以使用不同的参数，但是支持调用同样的方法，执行一样的逻辑： public class Test { int sum(int a, int b){ //只有int支持，不灵活！ return a+b; } double sum(double a, double b){ //重写一个double类型的，就支持小数计算了 return a+b; } } 现在我们有很多种重写的方法，那么传入实参后，到底进了哪个方法呢？ public class Test { void a(int i){ System.out.println(\"调用了int\"); } void a(short i){ System.out.println(\"调用了short\"); } void a(long i){ System.out.println(\"调用了long\"); } void a(char i){ System.out.println(\"调用了char\"); } void a(double i){ System.out.println(\"调用了double\"); } void a(float i){ System.out.println(\"调用了float\"); } public static void main(String[] args) { Test test = new Test(); test.a(1); //直接输入整数 test.a(1.0); //直接输入小数 short s = 2; test.a(s); //会对号入座吗？ test.a(1.0F); } } ","date":"2022-01-23","objectID":"/posts/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/:2:4","tags":["Java对象和多态"],"title":"Java对象和多态","uri":"/posts/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"categories":["JavaSE笔记"],"content":"构造方法 构造方法（构造器）没有返回值，也可以理解为，返回的是当前对象的引用！每一个类都默认自带一个无参构造方法。 //反编译结果 package com.test; public class Test { public Test() { //即使你什么都不编写，也自带一个无参构造方法，只是默认是隐藏的 } } 反编译其实就是把我们编译好的class文件变回Java源代码。 Test test = new Test(); //实际上存在Test()这个的方法，new关键字就是用来创建并得到引用的 // new + 你想要使用的构造方法 这种方法没有写明返回值，但是每个类都必须具有这个方法！只有调用类的构造方法，才能创建类的对象！ 类要在一开始准备的所有东西，都会在构造方法里面执行，完成构造方法的内容后，才能创建出对象！ 一般最常用的就是给成员属性赋初始值： public class Student { String name; Student(){ name = \"伞兵一号\"; } } 我们可以手动指定有参构造，当遇到名称冲突时，需要用到this关键字 public class Student { String name; Student(String name){ //形参和类成员变量冲突了，Java会优先使用形式参数定义的变量！ this.name = name; //通过this指代当前的对象属性，this就代表当前对象 } } //idea 右键快速生成！ 注意，this只能用于指代当前对象的内容，因此，只有属于对象拥有的部分才可以使用this，也就是说，只能在类的成员方法中使用this，不能在静态方法中使用this关键字。 在我们定义了新的有参构造之后，默认的无参构造会被覆盖！ //反编译后依然只有我们定义的有参构造！ 如果同时需要有参和无参构造，那么就需要用到方法的重载！手动再去定义一个无参构造。 public class Student { String name; Student(){ } Student(String name){ this.name = name; } } 成员变量的初始化始终在构造方法执行之前 public class Student { String a = \"sadasa\"; Student(){ System.out.println(a); } public static void main(String[] args) { Student s = new Student(); } } ","date":"2022-01-23","objectID":"/posts/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/:2:5","tags":["Java对象和多态"],"title":"Java对象和多态","uri":"/posts/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"categories":["JavaSE笔记"],"content":"静态变量和静态方法 静态变量和静态方法是类具有的属性（后面还会提到静态类、静态代码块），也可以理解为是所有对象共享的内容。我们通过使用static关键字来声明一个变量或一个方法为静态的，一旦被声明为静态，那么通过这个类创建的所有对象，操作的都是同一个目标，也就是说，对象再多，也只有这一个静态的变量或方法。那么，一个对象改变了静态变量的值，那么其他的对象读取的就是被改变的值。 public class Student { static int a; } public static void main(String[] args) { Student s1 = new Student(); s1.a = 10; Student s2 = new Student(); System.out.println(s2.a); } 不推荐使用对象来调用，被标记为静态的内容，可以直接通过类名.xxx的形式访问 public static void main(String[] args) { Student.a = 10; System.out.println(Student.a); } 简述类加载机制 类并不是在一开始就全部加载好，而是在需要时才会去加载（提升速度）以下情况会加载类： 访问类的静态变量，或者为静态变量赋值 new 创建类的实例（隐式加载） 调用类的静态方法 子类初始化时 其他的情况会在讲到反射时介绍 所有被标记为静态的内容，会在类刚加载的时候就分配，而不是在对象创建的时候分配，所以说静态内容一定会在第一个对象初始化之前完成加载。 public class Student { static int a = test(); //直接调用静态方法，只能调用静态方法 Student(){ System.out.println(\"构造类对象\"); } static int test(){ //静态方法刚加载时就有了 System.out.println(\"初始化变量a\"); return 1; } } 思考：下面这种情况下，程序能正常运行吗？如果能，会输出什么内容？ public class Student { static int a = test(); static int test(){ return a; } public static void main(String[] args) { System.out.println(Student.a); } } 定义和赋值是两个阶段，在定义时会使用默认值（上面讲的，类的成员变量会有默认值）定义出来之后，如果发现有赋值语句，再进行赋值，而这时，调用了静态方法，所以说会先去加载静态方法，静态方法调用时拿到a，而a这时仅仅是刚定义，所以说还是初始值，最后得到0 ","date":"2022-01-23","objectID":"/posts/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/:2:6","tags":["Java对象和多态"],"title":"Java对象和多态","uri":"/posts/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"categories":["JavaSE笔记"],"content":"代码块和静态代码块 代码块在对象创建时执行，也是属于类的内容，但是它在构造方法执行之前执行（和成员变量初始值一样），且每创建一个对象时，只执行一次！（相当于构造之前的准备工作） public class Student { { System.out.println(\"我是代码块\"); } Student(){ System.out.println(\"我是构造方法\"); } } 静态代码块和上面的静态方法和静态变量一样，在类刚加载时就会调用； public class Student { static int a; static { a = 10; } public static void main(String[] args) { System.out.println(Student.a); } } ","date":"2022-01-23","objectID":"/posts/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/:2:7","tags":["Java对象和多态"],"title":"Java对象和多态","uri":"/posts/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"categories":["JavaSE笔记"],"content":"String和StringBuilder类 字符串类是一个比较特殊的类，他是Java中唯一重载运算符的类！(Java不支持运算符重载，String是特例) String的对象直接支持使用+或+=运算符来进行拼接，并形成新的String对象！（String的字符串是不可变的！） String a = \"dasdsa\", b = \"dasdasdsa\"; String l = a+b; System.out.println(l); 大量进行字符串的拼接似乎不太好，编译器是很聪明的，String的拼接有可能会被编译器优化为StringBuilder来减少对象创建（对象频繁创建时很费时间同时占内存的！） String result=\"String\"+\"and\"; //会被优化成一句！ String str1=\"String\"; String str2=\"and\"; String result=str1+str2; //变量随时可变，在编译时无法确定result的值，那么只能在运行时再去确定 String str1=\"String\"; String str2=\"and\"; String result=(new StringBuilder(String.valueOf(str1))).append(str2).toString(); //使用StringBuilder，会采用类似于第一种实现，显然会更快！ StringBuilder也是一个类，但是它能够存储可变长度的字符串！ StringBuilder builder = new StringBuilder(); builder .append(\"a\") .append(\"bc\") .append(\"d\"); //链式调用 String str = builder.toString(); System.out.println(str); ","date":"2022-01-23","objectID":"/posts/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/:2:8","tags":["Java对象和多态"],"title":"Java对象和多态","uri":"/posts/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"categories":["JavaSE笔记"],"content":"包和访问控制 ","date":"2022-01-23","objectID":"/posts/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/:3:0","tags":["Java对象和多态"],"title":"Java对象和多态","uri":"/posts/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"categories":["JavaSE笔记"],"content":"包声明和导入 包其实就是用来区分类位置的东西，也可以用来将我们的类进行分类，类似于C++中的namespace！ package com.test; public class Test{ } 包其实是文件夹，比如com.test就是一个com文件夹中包含一个test文件夹，再包含我们Test类。 一般包按照个人或是公司域名的规则倒过来写 顶级域名.一级域名.二级域名 com.java.xxxx 如果需要使用其他包里面的类，那么我们需要import（类似于C/C++中的include） import com.test.Student; 也可以导入包下的全部（一般导入会由编译器自带帮我们补全，但是一定要记得我们需要导包！） import com.test.* Java默认为我们导入了以下的包，不需要去声明 import java.lang.* ","date":"2022-01-23","objectID":"/posts/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/:3:1","tags":["Java对象和多态"],"title":"Java对象和多态","uri":"/posts/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"categories":["JavaSE笔记"],"content":"静态导入 静态导入可以直接导入某个类的静态方法或者是静态变量，导入后，相当于这个方法或是类在定义在当前类中，可以直接调用该方法。 import static com.test.ui.Student.test; public class Main { public static void main(String[] args) { test(); } } 静态导入不会进行类的初始化！ ","date":"2022-01-23","objectID":"/posts/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/:3:2","tags":["Java对象和多态"],"title":"Java对象和多态","uri":"/posts/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"categories":["JavaSE笔记"],"content":"访问控制 Java支持对类属性访问的保护，也就是说，不希望外部类访问类中的属性或是方法，只允许内部调用，这种情况下我们就需要用到权限控制符。 ![image-20210819160939950](C:/Users/Alone/Users/nagocoler/Library/Application Support/typora-user-images/image-20210819160939950.png) 权限控制符可以声明在方法、成员变量、类前面，一旦声明private，只能类内部访问！ public class Student { private int a = 10; //具有私有访问权限，只能类内部访问 } public static void main(String[] args) { Student s = new Student(); System.out.println(s.a); //还可以访问吗？ } 和文件名称相同的类，只能是public，并且一个java文件中只能有一个public class！ // Student.java public class Student { } class Test{ //不能添加权限修饰符！只能是default } ","date":"2022-01-23","objectID":"/posts/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/:3:3","tags":["Java对象和多态"],"title":"Java对象和多态","uri":"/posts/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"categories":["JavaSE笔记"],"content":"数组类型 假设出现一种情况，我想记录100个数字，定义100个变量还可行吗？ 我们可以使用到数组，数组是相同类型数据的有序集合。数组可以代表任何相同类型的一组内容（包括引用类型和基本类型）其中存放的每一个数据称为数组的一个元素，数组的下标是从0开始，也就是第一个元素的索引是0！ int[] arr = new int[10]; //需要new关键字来创建！ String[] arr2 = new String[10]; 数组本身也是类（编程不可见，C++写的），不是基本数据类型！ int[] arr = new int[10]; System.out.println(arr.length); //数组有成员变量！ System.out.println(arr.toString()); //数组有成员方法！ ","date":"2022-01-23","objectID":"/posts/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/:4:0","tags":["Java对象和多态"],"title":"Java对象和多态","uri":"/posts/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"categories":["JavaSE笔记"],"content":"一维数组 一维数组中，元素是依次排列的（线性），每个数组元素可以通过下标来访问！声明格式如下： 类型[] 变量名称 = new 类型[数组大小]; 类型 变量名称n = new 类型[数组大小]; //支持C语言样式，但不推荐！ 类型[] 变量名称 = new 类型[]{...}; //静态初始化（直接指定值和大小） 类型[] 变量名称 = {...}; //同上，但是只能在定义时赋值 创建出来的数组每个元素都有默认值（规则和类的成员变量一样，C语言创建的数组需要手动设置默认值），我们可以通过下标去访问： int[] arr = new int[10]; arr[0] = 626; System.out.println(arr[0]); System.out.println(arr[1]); 我们可以通过数组变量名称.length来获取当前数组长度： int[] arr = new int[]{1, 2, 3}; System.out.println(arr.length); //打印length成员变量的值 数组在创建时，就固定长度，不可更改！访问超出数组长度的内容，会出现错误！ String[] arr = new String[10]; System.out.println(arr[10]); //出现异常！ //Exception in thread \"main\" java.lang.ArrayIndexOutOfBoundsException: 11 // at com.test.Application.main(Application.java:7) 思考：能不能直接修改length的值来实现动态扩容呢？ int[] arr = new int[]{1, 2, 3}; arr.length = 10; 数组做实参，因为数组也是类，所以形参得到的是数组的引用而不是复制的数组，操作的依然是数组对象本身 public static void main(String[] args) { int[] arr = new int[]{1, 2, 3}; test(arr); System.out.println(arr[0]); } private static void test(int[] arr){ arr[0] = 2934; } ","date":"2022-01-23","objectID":"/posts/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/:4:1","tags":["Java对象和多态"],"title":"Java对象和多态","uri":"/posts/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"categories":["JavaSE笔记"],"content":"数组的遍历 如果我们想要快速打印数组中的每一个元素，又怎么办呢？ 传统for循环 我们很容易就联想到for循环 int[] arr = new int[]{1, 2, 3}; for (int i = 0; i \u003c arr.length; i++) { System.out.println(arr[i]); } foreach 传统for循环虽然可控性高，但是不够省事，要写一大堆东西，有没有一种省事的写法呢？ int[] arr = new int[]{1, 2, 3}; for (int i : arr) { System.out.println(i); } foreach属于增强型的for循环，它使得代码更简洁，同时我们能直接拿到数组中的每一个数字。 ","date":"2022-01-23","objectID":"/posts/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/:4:2","tags":["Java对象和多态"],"title":"Java对象和多态","uri":"/posts/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"categories":["JavaSE笔记"],"content":"二维数组 二维数组其实就是存放数组的数组，每一个元素都存放一个数组的引用，也就相当于变成了一个平面。 //三行两列 int[][] arr = { {1, 2}, {3, 4}, {5, 6}}; System.out.println(arr[2][1]); 二维数组的遍历同一维数组一样，只不过需要嵌套循环！ int[][] arr = new int[][]{ {1, 2}, {3, 4}, {5, 6}}; for (int i = 0; i \u003c 3; i++) { for (int j = 0; j \u003c 2; j++) { System.out.println(arr[i][j]); } } ","date":"2022-01-23","objectID":"/posts/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/:4:3","tags":["Java对象和多态"],"title":"Java对象和多态","uri":"/posts/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"categories":["JavaSE笔记"],"content":"多维数组 不止二维数组，还存在三维数组，也就是存放数组的数组的数组，原理同二维数组一样，逐级访问即可。 ","date":"2022-01-23","objectID":"/posts/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/:4:4","tags":["Java对象和多态"],"title":"Java对象和多态","uri":"/posts/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"categories":["JavaSE笔记"],"content":"可变长参数 可变长参数其实就是数组的一种应用，我们可以指定方法的形参为一个可变长参数，要求实参可以根据情况动态填入0个或多个，而不是固定的数量 public static void main(String[] args) { test(\"AAA\", \"BBB\", \"CCC\"); //可变长，最后都会被自动封装成一个数组 } private static void test(String... test){ System.out.println(test[0]); //其实参数就是一个数组 } 由于是数组，所以说只能使用一种类型的可变长参数，并且可变长参数只能放在最后一位！ ","date":"2022-01-23","objectID":"/posts/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/:4:5","tags":["Java对象和多态"],"title":"Java对象和多态","uri":"/posts/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"categories":["JavaSE笔记"],"content":"实战：三大基本排序算法 现在我们有一个数组，但是数组里面的数据是乱序排列的，如何使它变得有序？ int[] arr = {8, 5, 0, 1, 4, 9, 2, 3, 6, 7}; 排序是编程的一个重要技能，掌握排序算法，你的技术才能更上一层楼，很多的项目都需要用到排序！三大排序算法： 冒泡排序 冒泡排序就是冒泡，其实就是不断使得我们无序数组中的最大数向前移动，经历n轮循环逐渐将每一个数推向最前。 插入排序 插入排序其实就跟我们打牌是一样的，我们在摸牌的时候，牌堆是乱序的，但是我们一张一张摸到手中进行排序，使得它变成了有序的！ 选择排序 选择排序其实就是每次都选择当前数组中最大的数排到最前面！ ","date":"2022-01-23","objectID":"/posts/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/:4:6","tags":["Java对象和多态"],"title":"Java对象和多态","uri":"/posts/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"categories":["JavaSE笔记"],"content":"封装、继承和多态 封装、继承和多态是面向对象编程的三大特性。 ","date":"2022-01-23","objectID":"/posts/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/:5:0","tags":["Java对象和多态"],"title":"Java对象和多态","uri":"/posts/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"categories":["JavaSE笔记"],"content":"封装 封装的目的是为了保证变量的安全性，使用者不必在意具体实现细节，而只是通过外部接口即可访问类的成员，如果不进行封装，类中的实例变量可以直接查看和修改，可能给整个代码带来不好的影响，因此在编写类时一般将成员变量私有化，外部类需要同getter和setter方法来查看和设置变量。 设想：学生小明已经创建成功，正常情况下能随便改他的名字和年龄吗？ public class Student { private String name; private int age; public Student(String name, int age) { this.name = name; this.age = age; } public int getAge() { return age; } public String getName() { return name; } } 也就是说，外部现在只能通过调用我定义的方法来获取成员属性，而我们可以在这个方法中进行一些额外的操作，比如小明可以修改名字，但是名字中不能包含\"小\"这个字。 public void setName(String name) { if(name.contains(\"小\")) return; this.name = name; } 单独给外部开放设置名称的方法，因为我还需要做一些额外的处理，所以说不能给外部直接操作成员变量的权限！ 封装思想其实就是把实现细节给隐藏了，外部只需知道这个方法是什么作用，而无需关心实现。 封装就是通过访问权限控制来实现的。 ","date":"2022-01-23","objectID":"/posts/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/:5:1","tags":["Java对象和多态"],"title":"Java对象和多态","uri":"/posts/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"categories":["JavaSE笔记"],"content":"继承 继承属于非常重要的内容，在定义不同类的时候存在一些相同属性，为了方便使用可以将这些共同属性抽象成一个父类，在定义其他子类时可以继承自该父类，减少代码的重复定义，子类可以使用父类中非私有的成员。 现在学生分为两种，艺术生和体育生，他们都是学生的分支，但是他们都有自己的方法： public class SportsStudent extends Student{ //通过extends关键字来继承父类 public SportsStudent(String name, int age) { super(name, age); //必须先通过super关键字（指代父类），实现父类的构造方法！ } public void exercise(){ System.out.println(\"我超勇的！\"); } } public class ArtStudent extends Student{ public ArtStudent(String name, int age) { super(name, age); } public void art(){ System.out.println(\"随手画个毕加索！\"); } } 子类具有父类的全部属性，protected可见但外部无法使用（包括private属性，不可见，无法使用），同时子类还能有自己的方法。继承只能继承一个父类，不支持多继承！ 每一个子类必须定义一个实现父类构造方法的构造方法，也就是需要在构造方法开始使用super()，如果父类使用的是默认构造方法，那么子类不用手动指明。 所有类都默认继承自Object类，除非手动指定类型，但是依然改变不了最顶层的父类是Object类。所有类都包含Object类中的方法，比如： public static void main(String[] args) { Object obj = new Object; System.out.println(obj.hashCode()); //求对象的hashcode，默认是对象的内存地址 System.out.println(obj.equals(obj)); //比较对象是否相同，默认比较的是对象的内存地址，也就是等同于 == System.out.println(obj.toString()); //将对象转换为字符串，默认生成对象的类名称+hashcode } 关于Object类的其他方法，我们会在Java多线程中再来提及。 ","date":"2022-01-23","objectID":"/posts/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/:5:2","tags":["Java对象和多态"],"title":"Java对象和多态","uri":"/posts/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"categories":["JavaSE笔记"],"content":"多态 多态是同一个行为具有多个不同表现形式或形态的能力。也就是同样的方法，由于实现类不同，执行的结果也不同！ 方法的重写 我们之前学习了方法的重载，方法的重写和重载是不一样的，重载是原有的方法逻辑不变的情况下，支持更多参数的实现，而重写是直接覆盖原有方法！ //父类中的study public void study(){ System.out.println(\"学习\"); } //子类中的study @Override //声明这个方法是重写的，但是可以不要，我们现阶段不接触 public void study(){ System.out.println(\"给你看点好康的\"); } 再次定义同样的方法后，父类的方法就被覆盖！子类还可以给父类方法提升访问权限！ public static void main(String[] args) { SportsStudent student = new SportsStudent(\"lbw\", 20); student.study(); //输出子类定义的内容 } 思考：静态方法能被重写吗？ 当我们在重写方法时，不仅想使用我们自己的逻辑，同时还希望执行父类的逻辑（也就是调用父类的方法）怎么办呢？ public void study(){ super.study(); System.out.println(\"给你看点好康的\"); } 同理，如果想访问父类的成员变量，也可以使用super关键字来访问，注意，子类可以具有和父类相同的成员变量！而在方法中访问的默认是 形参列表中 \u003e 当前类的成员变量 \u003e 父类成员变量 public void setTest(int test){ test = 1; this.test = 1; super.test = 1; } 再谈类型转换 我们曾经学习过基本数据类型的类型转换，支持一种数据类型转换为另一种数据类型，而我们的类也是支持类型转换的（仅限于存在亲缘关系的类之间进行转换）比如子类可以直接向上转型： Student student = new SportsStudent(\"lbw\", 20); //父类变量引用子类实例 student.study(); //得到依然是具体实现的结果，而不是当前类型的结果 我们也可以把已经明确是由哪个类实现的父类引用，强制转换为对应的类型： Student student = new SportsStudent(\"lbw\", 20); //是由SportsStudent进行实现的 //... do something... SportsStudent ps = (SportsStudent)student; //让它变成一个具体的子类 ps.sport(); //调用具体实现类的方法 这样的类型转换称为向下转型。 instanceof关键字 那么我们如果只是得到一个父类引用，但是不知道它到底是哪一个子类的实现怎么办？我们可以使用instanceof关键字来实现，它能够进行类型判断！ private static void test(Student student){ if (student instanceof SportsStudent){ SportsStudent sportsStudent = (SportsStudent) student; sportsStudent.sport(); }else if (student instanceof ArtStudent){ ArtStudent artStudent = (ArtStudent) student; artStudent.art(); } } 通过进行类型判断，我们就可以明确类的具体实现到底是哪个类！ 思考：student instanceof Student的结果是什么？ 再谈final关键字 我们目前只知道final关键字能够使得一个变量的值不可更改，那么如果在类前面声明final，会发生什么？ public final class Student { //类被声明为终态，那么它还能被继承吗 } 类一旦被声明为终态，将无法再被继承，不允许子类的存在！而方法被声明为final呢？ public final void study(){ //还能重写吗 System.out.println(\"学习\"); } 如果类的成员属性被声明为final，那么必须在构造方法中或是在定义时赋初始值！ private final String name; //引用类型不允许再指向其他对象 private final int age; //基本类型值不允许发生改变 public Student(String name, int age) { this.name = name; this.age = age; } 学习完封装继承和多态之后，我们推荐在不会再发生改变的成员属性上添加final关键字，JVM会对添加了final关键字的属性进行优化！ 抽象类 类本身就是一种抽象，而抽象类，把类还要抽象，也就是说，抽象类可以只保留特征，而不保留具体呈现形态，比如方法可以定义好，但是我可以不去实现它，而是交由子类来进行实现！ public abstract class Student { //抽象类 public abstract void test(); //抽象方法 } 通过使用abstract关键字来表明一个类是一个抽象类，抽象类可以使用abstract关键字来表明一个方法为抽象方法，也可以定义普通方法，抽象方法不需要编写具体实现（无方法体）但是必须由子类实现（除非子类也是一个抽象类）！ 抽象类由于不是具体的类定义，因此无法直接通过new关键字来创建对象！ Student s = new Student(){ //只能直接创建带实现的匿名内部类！ public void test(){ } } 因此，抽象类一般只用作继承使用！抽象类使得继承关系之间更加明确： public void study(){ //现在只能由子类编写，父类没有定义，更加明确了多态的定义！同一个方法多种实现！ System.out.println(\"给你看点好康的\"); } 接口 接口甚至比抽象类还抽象，他只代表某个确切的功能！也就是只包含方法的定义，甚至都不是一个类！接口包含了一些列方法的具体定义，类可以实现这个接口，表示类支持接口代表的功能（类似于一个插件，只能作为一个附属功能加在主体上，同时具体实现还需要由主体来实现） public interface Eat { void eat(); } 通过使用interface关键字来表明是一个接口（注意，这里class关键字被替换为了interface）接口只能包含public权限的抽象方法！（Java8以后可以有默认实现）我们可以通过声明default关键字来给抽象方法一个默认实现： public interface Eat { default void eat(){ //do something... } } 接口中定义的变量，默认为public static final public interface Eat { int a = 1; void eat(); } 一个类可以实现很多个接口，但是不能理解为多继承！（实际上实现接口是附加功能，和继承的概念有一定出入，顶多说是多继承的一种替代方案）一个类可以附加很多个功能！ public class SportsStudent extends Student implements Eat, ...{ @Override public void eat() { } } 类通过implements关键字来声明实现的接口！每个接口之间用逗号隔开！ 实现接口的类也能通过instanceof关键字判断，也支持向上和向下转型！ ","date":"2022-01-23","objectID":"/posts/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/:5:3","tags":["Java对象和多态"],"title":"Java对象和多态","uri":"/posts/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"categories":["JavaSE笔记"],"content":"内部类 类中可以存在一个类！各种各样的长相怪异的代码就是从这里开始出现的！ ","date":"2022-01-23","objectID":"/posts/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/:6:0","tags":["Java对象和多态"],"title":"Java对象和多态","uri":"/posts/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"categories":["JavaSE笔记"],"content":"成员内部类 我们的类中可以在嵌套一个类： public class Test { class Inner{ //类中定义的一个内部类 } } 成员内部类和成员变量和成员方法一样，都是属于对象的，也就是说，必须存在外部对象，才能创建内部类的对象！ public static void main(String[] args) { Test test = new Test(); Test.Inner inner = test.new Inner(); //写法有那么一丝怪异，但是没毛病！ } ","date":"2022-01-23","objectID":"/posts/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/:6:1","tags":["Java对象和多态"],"title":"Java对象和多态","uri":"/posts/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"categories":["JavaSE笔记"],"content":"静态内部类 静态内部类其实就和类中的静态变量和静态方法一样，是属于类拥有的，我们可以直接通过类名.去访问: public class Test { static class Inner{ } } public static void main(String[] args) { Test.Inner inner = new Test.Inner(); //不用再创建外部类对象了！ } ","date":"2022-01-23","objectID":"/posts/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/:6:2","tags":["Java对象和多态"],"title":"Java对象和多态","uri":"/posts/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"categories":["JavaSE笔记"],"content":"局部内部类 对，你没猜错，就是和局部变量一样哒~ public class Test { public void test(){ class Inner{ } Inner inner = new Inner(); } } 反正我是没用过！内部类 -\u003e 累不累 -\u003e 反正我累了！ ","date":"2022-01-23","objectID":"/posts/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/:6:3","tags":["Java对象和多态"],"title":"Java对象和多态","uri":"/posts/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"categories":["JavaSE笔记"],"content":"匿名内部类 匿名内部类才是我们的重点，也是实现lambda表达式的原理！匿名内部类其实就是在new的时候，直接对接口或是抽象类的实现： public static void main(String[] args) { Eat eat = new Eat() { @Override public void eat() { //DO something... } }; } 我们不用单独去创建一个类来实现，而是可以直接在new的时候写对应的实现！但是，这样写，无法实现复用，只能在这里使用！ lambda表达式 读作λ表达式，它其实就是我们接口匿名实现的简化，比如说： public static void main(String[] args) { Eat eat = new Eat() { @Override public void eat() { //DO something... } }; } public static void main(String[] args) { Eat eat = () -\u003e {}; //等价于上述内容 } lambda表达式（匿名内部类）只能访问外部的final类型或是隐式final类型的局部变量！ 为了方便，JDK默认就为我们提供了专门写函数式的接口，这里只介绍Consumer ","date":"2022-01-23","objectID":"/posts/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/:6:4","tags":["Java对象和多态"],"title":"Java对象和多态","uri":"/posts/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"categories":["JavaSE笔记"],"content":"枚举类 假设现在我们想给小明添加一个状态（跑步、学习、睡觉），外部可以实时获取小明的状态： public class Student { private final String name; private final int age; private String status; //... public void setStatus(String status) { this.status = status; } public String getStatus() { return status; } } 但是这样会出现一个问题，如果我们仅仅是存储字符串，似乎外部可以不按照我们规则，传入一些其他的字符串。这显然是不够严谨的！ 有没有一种办法，能够更好地去实现这样的状态标记呢？我们希望开发者拿到使用的就是我们定义好的状态，我们可以使用枚举类！ public enum Status { RUNNING, STUDY, SLEEP //直接写每个状态的名字即可，分号可以不打，但是推荐打上 } 使用枚举类也非常方便，我们只需要直接访问即可 public class Student { private final String name; private final int age; private Status status; //... public void setStatus(Status status) { //不再是String，而是我们指定的枚举类型 this.status = status; } public Status getStatus() { return status; } } public static void main(String[] args) { Student student = new Student(\"小明\", 18); student.setStatus(Status.RUNNING); System.out.println(student.getStatus()); } 枚举类型使用起来就非常方便了，其实枚举类型的本质就是一个普通的类，但是它继承自Enum类，我们定义的每一个状态其实就是一个public static final的Status类型成员变量！ // Compiled from \"Status.java\" public final class com.test.Status extends java.lang.Enum\u003ccom.test.Status\u003e { public static final com.test.Status RUNNING; public static final com.test.Status STUDY; public static final com.test.Status SLEEP; public static com.test.Status[] values(); public static com.test.Status valueOf(java.lang.String); static {}; } 既然枚举类型是普通的类，那么我们也可以给枚举类型添加独有的成员方法 public enum Status { RUNNING(\"睡觉\"), STUDY(\"学习\"), SLEEP(\"睡觉\"); //无参构造方法被覆盖，创建枚举需要添加参数（本质就是调用的构造方法！） private final String name; //枚举的成员变量 Status(String name){ //覆盖原有构造方法（默认private，只能内部使用！） this.name = name; } public String getName() { //获取封装的成员变量 return name; } } public static void main(String[] args) { Student student = new Student(\"小明\", 18); student.setStatus(Status.RUNNING); System.out.println(student.getStatus().getName()); } 枚举类还自带一些继承下来的实用方法 Status.valueOf(\"\") //将名称相同的字符串转换为枚举 Status.values() //快速获取所有的枚举 ","date":"2022-01-23","objectID":"/posts/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/:7:0","tags":["Java对象和多态"],"title":"Java对象和多态","uri":"/posts/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"categories":["JavaSE笔记"],"content":"基本类型包装类 Java并不是纯面向对象的语言，虽然Java语言是一个面向对象的语言，但是Java中的基本数据类型却不是面向对象的。在学习泛型和集合之前，基本类型的包装类是一定要讲解的内容！ 我们的基本类型，如果想通过对象的形式去使用他们，Java提供的基本类型包装类，使得Java能够更好的体现面向对象的思想，同时也使得基本类型能够支持对象操作！ byte -\u003e Byte boolean -\u003e Boolean short -\u003e Short char -\u003e Character int -\u003e Integer long -\u003e Long float -\u003e Float double -\u003e Double 包装类实际上就行将我们的基本数据类型，封装成一个类（运用了封装的思想） private final int value; //Integer内部其实本质还是存了一个基本类型的数据，但是我们不能直接操作 public Integer(int value) { this.value = value; } 现在我们操作的就是Integer对象而不是一个int基本类型了！ public static void main(String[] args) { Integer i = 1; //包装类型可以直接接收对应类型的数据，并变为一个对象！ System.out.println(i + i); //包装类型可以直接被当做一个基本类型进行操作！ } 自动装箱和拆箱 那么为什么包装类型能直接使用一个具体值来赋值呢？其实依靠的是自动装箱和拆箱机制 Integer i = 1; //其实这里只是简写了而已 Integer i = Integer.valueOf(1); //编译后真正的样子 调用valueOf来生成一个Integer对象！ public static Integer valueOf(int i) { if (i \u003e= IntegerCache.low \u0026\u0026 i \u003c= IntegerCache.high) //注意，Java为了优化，有一个缓存机制，如果是在-128~127之间的数，会直接使用已经缓存好的对象，而不是再去创建新的！（面试常考） return IntegerCache.cache[i + (-IntegerCache.low)]; return new Integer(i); //返回一个新创建好的对象 } 而如果使用包装类来进行运算，或是赋值给一个基本类型变量，会进行自动拆箱： public static void main(String[] args) { Integer i = Integer.valueOf(1); int a = i; //简写 int a = i.intValue(); //编译后实际的代码 long c = i.longValue(); //其他类型也有！ } 既然现在是包装类型了，那么我们还能使用==来判断两个数是否相等吗？ public static void main(String[] args) { Integer i1 = 28914; Integer i2 = 28914; System.out.println(i1 == i2); //实际上判断是两个对象是否为同一个对象（内存地址是否相同） System.out.println(i1.equals(i2)); //这个才是真正的值判断！ } 注意IntegerCache带来的影响！ 思考：下面这种情况结果会是什么？ public static void main(String[] args) { Integer i1 = 28914; Integer i2 = 28914; System.out.println(i1+1 == i2+1); } 在集合类的学习中，我们还会继续用到我们的包装类型！ ","date":"2022-01-23","objectID":"/posts/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/:8:0","tags":["Java对象和多态"],"title":"Java对象和多态","uri":"/posts/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"categories":["JavaSE笔记"],"content":"面向对象编程实战 虽然我们学习了编程，但是我们不能一股脑的所有问题都照着编程的思维去解决，编程只是解决问题的一种手段，灵活的运用我们所学的知识，才是解决问题的最好办法！比如，求1到100所有数的和： public static void main(String[] args) { int sum = 0; for (int i = 1; i \u003c= 100; i++) { //for循环暴力求解，简单，但是效率似乎低了一些 sum += i; } System.out.println(sum); } public static void main(String[] args) { System.out.println((1 + 100) * 50); //高斯求和公式，利用数学，瞬间计算结果！ } 说到最后，其实数学和逻辑思维才是解决问题的最终办法！ ","date":"2022-01-23","objectID":"/posts/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/:9:0","tags":["Java对象和多态"],"title":"Java对象和多态","uri":"/posts/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"categories":["JavaSE笔记"],"content":"对象设计（面向对象、多态运用） 设计一个Person抽象类，包含吃饭运动学习三种行为，分为工人、学生、老师三种职业。 设计设计一个接口考试，只有老师和学生会考试。 设计一个方法，模拟让人类进入考场，要求只有会考试的人才能进入，并且考试。 ","date":"2022-01-23","objectID":"/posts/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/:9:1","tags":["Java对象和多态"],"title":"Java对象和多态","uri":"/posts/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"categories":["JavaSE笔记"],"content":"二分搜索（搜索算法） 现在有一个有序数组（从小到大，数组长度 0 \u003c n \u003c 1000000）如何快速寻找我们想要的数在哪个位置，如果存在请返回下标，不存在返回-1即可。 int[] arr = new int[]{1, 4, 5, 6, 7, 10, 12, 14, 20, 22, 26}; //测试用例 private static int test(int[] arr, int target){ //请在这里实现搜索算法 } ","date":"2022-01-23","objectID":"/posts/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/:9:2","tags":["Java对象和多态"],"title":"Java对象和多态","uri":"/posts/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"categories":["JavaSE笔记"],"content":"快速排序（排序算法、递归分治） （开始之前先介绍一下递归！）快速排序其实是一种排序执行效率很高的排序算法，它利用分治法来对待排序序列进行分治排序，它的思想主要是通过一趟排序将待排记录分隔成独立的两部分，其中的一部分比关键字小，后面一部分比关键字大，然后再对这前后的两部分分别采用这种方式进行排序，通过递归的运算最终达到整个序列有序。 快速排序就像它的名字一样，快速！在极端情况下，会退化成冒泡排序！ ","date":"2022-01-23","objectID":"/posts/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/:9:3","tags":["Java对象和多态"],"title":"Java对象和多态","uri":"/posts/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"categories":["JavaSE笔记"],"content":"0/1背包问题（回溯法、剪枝/动态规划优化） 给定 n 件物品，每一个物品的重量为 w[n]，每个物品的价值为 v[n]。现挑选物品放入背包中，假定背包能承受的最大重量为 capacity，求装入物品的最大价值是多少? int[] w = {2, 3, 4, 5}; int[] v = {3, 4, 5, 6}; int capacity = 8; ","date":"2022-01-23","objectID":"/posts/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/:9:4","tags":["Java对象和多态"],"title":"Java对象和多态","uri":"/posts/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"categories":["JavaSE笔记"],"content":"Java异常处理机制","date":"2022-01-23","objectID":"/posts/java%E5%BC%82%E5%B8%B8/","tags":["Java异常处理"],"title":"Java异常处理机制","uri":"/posts/java%E5%BC%82%E5%B8%B8/"},{"categories":["JavaSE笔记"],"content":"Java异常机制 配套视频 在理想的情况下，我们的程序会按照我们的思路去运行，按理说是不会出现问题的，但是，代码实际编写后并不一定是完美的，可能会有我们没有考虑到的情况，如果这些情况能够正常得到一个错误的结果还好，但是如果直接导致程序运行出现问题了呢？ public static void main(String[] args) { test(1, 0); //当b为0的时候，还能正常运行吗？ } private static int test(int a, int b){ return a/b; //没有任何的判断而是直接做计算 } Exception in thread \"main\" java.lang.ArithmeticException: / by zero at com.test.Application.test(Application.java:9) at com.test.Application.main(Application.java:5) 当程序运行出现我们没有考虑到的情况时，就有可能出现异常或是错误！ ","date":"2022-01-23","objectID":"/posts/java%E5%BC%82%E5%B8%B8/:0:0","tags":["Java异常处理"],"title":"Java异常处理机制","uri":"/posts/java%E5%BC%82%E5%B8%B8/"},{"categories":["JavaSE笔记"],"content":"异常 我们在之前其实已经接触过一些异常了，比如数组越界异常，空指针异常，算术异常等，他们其实都是异常类型，我们的每一个异常也是一个类，他们都继承自Exception类！异常类型本质依然类的对象，但是异常类型支持在程序运行出现问题时抛出（也就是上面出现的红色报错）也可以提前声明，告知使用者需要处理可能会出现的异常！ ","date":"2022-01-23","objectID":"/posts/java%E5%BC%82%E5%B8%B8/:1:0","tags":["Java异常处理"],"title":"Java异常处理机制","uri":"/posts/java%E5%BC%82%E5%B8%B8/"},{"categories":["JavaSE笔记"],"content":"运行时异常 异常的第一种类型是运行时异常，如上述的列子，在编译阶段无法感知代码是否会出现问题，只有在运行的时候才知道会不会出错（正常情况下是不会出错的），这样的异常称为运行时异常。所有的运行时异常都继承自RuntimeException。 ","date":"2022-01-23","objectID":"/posts/java%E5%BC%82%E5%B8%B8/:1:1","tags":["Java异常处理"],"title":"Java异常处理机制","uri":"/posts/java%E5%BC%82%E5%B8%B8/"},{"categories":["JavaSE笔记"],"content":"编译时异常 异常的另一种类型是编译时异常，编译时异常是明确会出现的异常，在编译阶段就需要进行处理的异常（捕获异常）如果不进行处理，将无法通过编译！默认继承自Exception类的异常都是编译时异常。 File file = new File(\"my.txt\"); file.createNewFile(); //要调用此方法，首先需要处理异常 ","date":"2022-01-23","objectID":"/posts/java%E5%BC%82%E5%B8%B8/:1:2","tags":["Java异常处理"],"title":"Java异常处理机制","uri":"/posts/java%E5%BC%82%E5%B8%B8/"},{"categories":["JavaSE笔记"],"content":"错误 错误比异常更严重，异常就是不同寻常，但不一定会导致致命的问题，而错误是致命问题，一般出现错误可能JVM就无法继续正常运行了，比如OutOfMemoryError就是内存溢出错误（内存占用已经超出限制，无法继续申请内存了） int[] arr = new int[Integer.MAX_VALUE]; //能创建如此之大的数组吗？ 运行后得到以下内容： Exception in thread \"main\" java.lang.OutOfMemoryError: Requested array size exceeds VM limit at com.test.Main.main(Main.java:14) 错误都继承自Error类，一般情况下，程序中只能处理异常，错误是很难进行处理的，Error和Execption都继承自Throwable类。当程序中出现错误或异常时又没有进行处理时，程序（当前线程）将终止运行： int[] arr = new int[Integer.MAX_VALUE]; System.out.println(\"lbwnb\"); //还能正常打印吗？ ","date":"2022-01-23","objectID":"/posts/java%E5%BC%82%E5%B8%B8/:2:0","tags":["Java异常处理"],"title":"Java异常处理机制","uri":"/posts/java%E5%BC%82%E5%B8%B8/"},{"categories":["JavaSE笔记"],"content":"异常的处理 当程序没有按照我们想要的样子运行而出现异常时（默认会交给JVM来处理，JVM发现任何异常都会立即终止程序运行，并在控制台打印栈追踪信息），我们希望能够自己处理出现的问题，让程序继续运行下去，就需要对异常进行捕获，比如： int[] arr = new int[5]; arr[5] = 1; //我们需要处理这种情况，保证后面的代码正常运行！ System.out.println(\"lbwnb\"); 我们可以使用try和catch语句块来处理： int[] arr = new int[5]; try{ //在try块中运行代码 arr[5] = 1; //当代码出现异常时，异常会被捕获，并在catch块中得到异常类型的对象 }catch (ArrayIndexOutOfBoundsException e){ //捕获的异常类型 System.out.println(\"程序运行出现异常！\"); //出现异常时执行 } //后面的代码会正常运行 System.out.println(\"lbwnb\"); 当异常被捕获后，就由我们自己进行处理（不再交给JVM处理），因此就不会导致程序终止运行。 我们可以通过使用e.printStackTrace()来打印栈追踪信息，定位我们的异常出现位置： java.lang.ArrayIndexOutOfBoundsException: 5 at com.test.Main.main(Main.java:7) //Main类的第7行出现问题 程序运行出现异常！ lbwnb 运行时异常在编译时可以不用捕获，但是编译时异常必须进行处理： File file = new File(\"my.txt\"); try { file.createNewFile(); } catch (IOException e) { //捕获声明的异常类型 e.printStackTrace(); } 可以捕获到类型不止是Exception的子类，只要是继承自Throwalbe的类，都能被捕获，也就是说，Error也能被捕获，但是不建议这样做，因为错误一般是虚拟机相关的问题，出现Error应该从问题的根源去解决。 ","date":"2022-01-23","objectID":"/posts/java%E5%BC%82%E5%B8%B8/:3:0","tags":["Java异常处理"],"title":"Java异常处理机制","uri":"/posts/java%E5%BC%82%E5%B8%B8/"},{"categories":["JavaSE笔记"],"content":"异常的抛出 当别人调用我们的方法时，如果传入了错误的参数导致程序无法正常运行，这时我们就需要手动抛出一个异常来终止程序继续运行下去，同时告知上一级方法执行出现了问题： public static void main(String[] args) { try { test(1, 0); } catch (Exception e) { //捕获方法中会出现的异常 e.printStackTrace(); } } private static int test(int a, int b) throws Exception { //声明抛出的异常类型 if(b == 0) throw new Exception(\"0不能做除数！\"); //创建异常对象并抛出异常 return a/b; //抛出异常会终止代码运行 } 通过throw关键字抛出异常（抛出异常后，后面的代码不再执行）当程序运行到这一行时，就会终止执行，并出现一个异常。 如果方法中抛出了非运行时异常，但是不希望在此方法内处理，而是交给调用者来处理异常，就需要在方法定义后面显式声明抛出的异常类型！如果抛出的是运行时异常，则不需要在方法后面声明异常类型，调用时也无需捕获，但是出现异常时同样会导致程序终止（出现运行时异常同时未被捕获会默认交给JVM处理，也就是直接中止程序并在控制台打印栈追踪信息） 如果想要调用声明编译时异常的方法，但是依然不想去处理，可以同样的在方法上声明throws来继续交给上一级处理。 public static void main(String[] args) throws Exception { //出现异常就再往上抛，而不是在此方法内处理 test(1, 0); } private static int test(int a, int b) throws Exception { //声明抛出的异常类型 if(b == 0) throw new Exception(\"0不能做除数！\"); //创建异常对象并抛出异常 return a/b; } 当main方法都声明抛出异常时，出现异常就由JVM进行处理，也就是默认的处理方式（直接中止程序并在控制台打印栈追踪信息） 异常只能被捕获一次，当异常捕获出现嵌套时，只会在最内层被捕获： public static void main(String[] args) throws Exception { try{ test(1, 0); }catch (Exception e){ System.out.println(\"外层\"); } } private static int test(int a, int b){ try{ if(b == 0) throw new Exception(\"0不能做除数！\"); }catch (Exception e){ System.out.println(\"内层\"); return 0; } return a/b; } ","date":"2022-01-23","objectID":"/posts/java%E5%BC%82%E5%B8%B8/:4:0","tags":["Java异常处理"],"title":"Java异常处理机制","uri":"/posts/java%E5%BC%82%E5%B8%B8/"},{"categories":["JavaSE笔记"],"content":"自定义异常 JDK为我们已经提前定义了一些异常了，但是可能对我们来说不够，那么就需要自定义异常： public class MyException extends Exception { //直接继承即可 } public static void main(String[] args) throws MyException { throw new MyException(); //直接使用 } 也可以使用父类的带描述的构造方法： public class MyException extends Exception { public MyException(String message){ super(message); } } public static void main(String[] args) throws MyException { throw new MyException(\"出现了自定义的错误\"); } 捕获异常指定的类型，会捕获其所有子异常类型： try { throw new MyException(\"出现了自定义的错误\"); } catch (Exception e) { //捕获父异常类型 System.out.println(\"捕获到异常\"); } ","date":"2022-01-23","objectID":"/posts/java%E5%BC%82%E5%B8%B8/:5:0","tags":["Java异常处理"],"title":"Java异常处理机制","uri":"/posts/java%E5%BC%82%E5%B8%B8/"},{"categories":["JavaSE笔记"],"content":"多重异常捕获和finally关键字 当代码可能出现多种类型的异常时，我们希望能够分不同情况处理不同类型的异常，就可以使用多重异常捕获： try { //.... } catch (NullPointerException e) { } catch (IndexOutOfBoundsException e){ } catch (RuntimeException e){ } 注意，类似于if-else if的结构，父异常类型只能放在最后！ try { //.... } catch (RuntimeException e){ //父类型在前，会将子类的也捕获 } catch (NullPointerException e) { //永远都不会被捕获 } catch (IndexOutOfBoundsException e){ //永远都不会被捕获 } 如果希望把这些异常放在一起进行处理： try { //.... } catch (NullPointerException | IndexOutOfBoundsException e) { //用|隔开每种类型即可 } 当我们希望，程序运行时，无论是否出现异常，都会在最后执行的任务，可以交给finally语句块来处理： try { //.... }catch (Exception e){ }finally { System.out.println(\"lbwnb\"); //无论是否出现异常，都会在最后执行 } try语句块至少要配合catch或finally中的一个： try { int a = 10; a /= 0; }finally { //不捕获异常，程序会终止，但在最后依然会执行下面的内容 System.out.println(\"lbwnb\"); } 思考：try、catch和finally执行顺序： private static int test(int a){ try{ return a; }catch (Exception e){ return 0; }finally { a = a + 1; } } ","date":"2022-01-23","objectID":"/posts/java%E5%BC%82%E5%B8%B8/:6:0","tags":["Java异常处理"],"title":"Java异常处理机制","uri":"/posts/java%E5%BC%82%E5%B8%B8/"},{"categories":["JavaSE笔记"],"content":"Java泛型与集合类","date":"2022-01-23","objectID":"/posts/java%E6%B3%9B%E5%9E%8B%E4%B8%8E%E9%9B%86%E5%90%88%E7%B1%BB/","tags":["Java泛型与集合类"],"title":"Java泛型与集合类","uri":"/posts/java%E6%B3%9B%E5%9E%8B%E4%B8%8E%E9%9B%86%E5%90%88%E7%B1%BB/"},{"categories":["JavaSE笔记"],"content":"Java泛型与集合类 配套视频 在前面我们学习了最重要的类和对象，了解了面向对象编程的思想，注意，非常重要，面向对象是必须要深入理解和掌握的内容，不能草草结束。在本章节，我们会继续深入了解，从我们的泛型开始，再到我们的数据结构，最后再开始我们的集合类学习。 ","date":"2022-01-23","objectID":"/posts/java%E6%B3%9B%E5%9E%8B%E4%B8%8E%E9%9B%86%E5%90%88%E7%B1%BB/:0:0","tags":["Java泛型与集合类"],"title":"Java泛型与集合类","uri":"/posts/java%E6%B3%9B%E5%9E%8B%E4%B8%8E%E9%9B%86%E5%90%88%E7%B1%BB/"},{"categories":["JavaSE笔记"],"content":"走进泛型 为了统计学生成绩，要求设计一个Score对象，包括课程名称、课程号、课程成绩，但是成绩分为两种，一种是以优秀、良好、合格 来作为结果，还有一种就是 60.0、75.5、92.5 这样的数字分数，那么现在该如何去设计这样的一个Score类呢？现在的问题就是，成绩可能是String类型，也可能是Integer类型，如何才能很好的去存可能出现的两种类型呢？ public class Score { String name; String id; Object score; //因为Object是所有类型的父类，因此既可以存放Integer也能存放String public Score(String name, String id, Object score) { this.name = name; this.id = id; this.score = score; } } 以上的方法虽然很好地解决了多种类型存储问题，但是Object类型在编译阶段并不具有良好的类型判断能力，很容易出现以下的情况： public static void main(String[] args) { Score score = new Score(\"数据结构与算法基础\", \"EP074512\", \"优秀\"); //是String类型的 //.... Integer number = (Integer) score.score; //获取成绩需要进行强制类型转换，虽然并不是一开始的类型，但是编译不会报错 } //运行时出现异常！ Exception in thread \"main\" java.lang.ClassCastException: java.lang.String cannot be cast to java.lang.Integer at com.test.Main.main(Main.java:14) 使用Object类型作为引用，取值只能进行强制类型转换，显然无法在编译期确定类型是否安全，项目中代码量非常之大，进行类型比较又会导致额外的开销和增加代码量，如果不经比较就很容易出现类型转换异常，代码的健壮性有所欠缺！（此方法虽然可行，但并不是最好的方法） 为了解决以上问题，JDK1.5新增了泛型，它能够在编译阶段就检查类型安全，大大提升开发效率。 public class Score\u003cT\u003e { //将Score转变为泛型类\u003cT\u003e String name; String id; T score; //T为泛型，根据用户提供的类型自动变成对应类型 public Score(String name, String id, T score) { //提供的score类型即为T代表的类型 this.name = name; this.id = id; this.score = score; } } public static void main(String[] args) { //直接确定Score的类型是字符串类型的成绩 Score\u003cString\u003e score = new Score\u003cString\u003e(\"数据结构与算法基础\", \"EP074512\", \"优秀\"); Integer i = score.score; //编译不通过，因为成员变量score类型被定为String！ } 泛型将数据类型的确定控制在了编译阶段，在编写代码的时候就能明确泛型的类型！如果类型不符合，将无法通过编译！ 泛型本质上也是一个语法糖（并不是JVM所支持的语法，编译后会转成编译器支持的语法，比如之前的foreach就是），在编译后会被擦除，变回上面的Object类型调用，但是类型转换由编译器帮我们完成，而不是我们自己进行转换（安全） //反编译后的代码 public static void main(String[] args) { Score score = new Score(\"数据结构与算法基础\", \"EP074512\", \"优秀\"); String i = (String)score.score; //其实依然会变为强制类型转换，但是这是由编译器帮我们完成的 } 像这样在编译后泛型的内容消失转变为Object的情况称为类型擦除（重要，需要完全理解），所以泛型只是为了方便我们在编译阶段确定类型的一种语法而已，并不是JVM所支持的。 综上，泛型其实就是一种类型参数，用于指定类型。 ","date":"2022-01-23","objectID":"/posts/java%E6%B3%9B%E5%9E%8B%E4%B8%8E%E9%9B%86%E5%90%88%E7%B1%BB/:1:0","tags":["Java泛型与集合类"],"title":"Java泛型与集合类","uri":"/posts/java%E6%B3%9B%E5%9E%8B%E4%B8%8E%E9%9B%86%E5%90%88%E7%B1%BB/"},{"categories":["JavaSE笔记"],"content":"泛型的使用 ","date":"2022-01-23","objectID":"/posts/java%E6%B3%9B%E5%9E%8B%E4%B8%8E%E9%9B%86%E5%90%88%E7%B1%BB/:2:0","tags":["Java泛型与集合类"],"title":"Java泛型与集合类","uri":"/posts/java%E6%B3%9B%E5%9E%8B%E4%B8%8E%E9%9B%86%E5%90%88%E7%B1%BB/"},{"categories":["JavaSE笔记"],"content":"泛型类 上一节我们已经提到泛型类的定义，实际上就是普通的类多了一个类型参数，也就是在使用时需要指定具体的泛型类型。泛型的名称一般取单个大写字母，比如T代表Type，也就是类型的英文单词首字母，当然也可以添加数字和其他的字符。 public class Score\u003cT\u003e { //将Score转变为泛型类\u003cT\u003e String name; String id; T score; //T为泛型，根据用户提供的类型自动变成对应类型 public Score(String name, String id, T score) { //提供的score类型即为T代表的类型 this.name = name; this.id = id; this.score = score; } } 在一个普通类型中定义泛型，泛型T称为参数化类型，在定义泛型类的引用时，需要明确指出类型： Score\u003cString\u003e score = new Score\u003cString\u003e(\"数据结构与算法基础\", \"EP074512\", \"优秀\"); 此时类中的泛型T已经被替换为String了，在我们获取此对象的泛型属性时，编译器会直接告诉我们类型： Integer i = score.score; //编译不通过，因为成员变量score明确为String类型 注意，泛型只能用于对象属性，也就是非静态的成员变量才能使用： static T score; //错误，不能在静态成员上定义 由此可见，泛型是只有在创建对象后编译器才能明确泛型类型，而静态类型是类所具有的属性，不足以使得编译器完成类型推断。 泛型无法使用基本类型，如果需要基本类型，只能使用基本类型的包装类进行替换！ Score\u003cdouble\u003e score = new Score\u003cdouble\u003e(\"数据结构与算法基础\", \"EP074512\", 90.5); //编译不通过 那么为什么泛型无法使用基本类型呢？回想上一节提到的类型擦除，其实就很好理解了。由于JVM没有泛型概念，因此泛型最后还是会被编译器编译为Object，并采用强制类型转换的形式进行类型匹配，而我们的基本数据类型和引用类型之间无法进行类型转换，所以只能使用基本类型的包装类来处理。 ","date":"2022-01-23","objectID":"/posts/java%E6%B3%9B%E5%9E%8B%E4%B8%8E%E9%9B%86%E5%90%88%E7%B1%BB/:2:1","tags":["Java泛型与集合类"],"title":"Java泛型与集合类","uri":"/posts/java%E6%B3%9B%E5%9E%8B%E4%B8%8E%E9%9B%86%E5%90%88%E7%B1%BB/"},{"categories":["JavaSE笔记"],"content":"类的泛型方法 泛型方法的使用也很简单，我们只需要把它当做一个未知的类型来使用即可： public T getScore() { //若方法的返回值类型为泛型，那么编译器会自动进行推断 return score; } public void setScore(T score) { //若方法的形式参数为泛型，那么实参只能是定义时的类型 this.score = score; } Score\u003cString\u003e score = new Score\u003cString\u003e(\"数据结构与算法基础\", \"EP074512\", \"优秀\"); score.setScore(10); //编译不通过，因为只接受String类型 同样地，静态方法无法直接使用类定义的泛型（注意是无法直接使用，静态方法可以使用泛型） ","date":"2022-01-23","objectID":"/posts/java%E6%B3%9B%E5%9E%8B%E4%B8%8E%E9%9B%86%E5%90%88%E7%B1%BB/:2:2","tags":["Java泛型与集合类"],"title":"Java泛型与集合类","uri":"/posts/java%E6%B3%9B%E5%9E%8B%E4%B8%8E%E9%9B%86%E5%90%88%E7%B1%BB/"},{"categories":["JavaSE笔记"],"content":"自定义泛型方法 那么如果我想在静态方法中使用泛型呢？首先我们要明确之前为什么无法使用泛型，因为之前我们的泛型定义是在类上的，只有明确具体的类型才能开始使用，也就是创建对象时完成类型确定，但是静态方法不需要依附于对象，那么只能在使用时再来确定了，所以静态方法可以使用泛型，但是需要单独定义： public static \u003cE\u003e void test(E e){ //在方法定义前声明泛型 System.out.println(e); } 同理，成员方法也能自行定义泛型，在实际使用时再进行类型确定： public \u003cE\u003e void test(E e){ System.out.println(e); } 其实，无论是泛型类还是泛型方法，再使用时一定要能够进行类型推断，明确类型才行。 注意一定要区分类定义的泛型和方法前定义的泛型！ ","date":"2022-01-23","objectID":"/posts/java%E6%B3%9B%E5%9E%8B%E4%B8%8E%E9%9B%86%E5%90%88%E7%B1%BB/:2:3","tags":["Java泛型与集合类"],"title":"Java泛型与集合类","uri":"/posts/java%E6%B3%9B%E5%9E%8B%E4%B8%8E%E9%9B%86%E5%90%88%E7%B1%BB/"},{"categories":["JavaSE笔记"],"content":"泛型引用 可以看到我们在定义一个泛型类的引用时，需要在后面指出此类型： Score\u003cInteger\u003e score; //声明泛型为Integer类型 如果不希望指定类型，或是希望此引用类型可以引用任意泛型的Score类对象，可以使用?通配符，来表示自动匹配任意的可用类型： Score\u003c?\u003e score; //score可以引用任意的Score类型对象了！ 那么使用通配符之后，得到的泛型成员变量会是什么类型呢？ Object o = score.getScore(); //只能变为Object 因为使用了通配符，编译器就无法进行类型推断，所以只能使用原始类型。 在学习了泛型的界限后，我们还会继续了解通配符的使用。 ","date":"2022-01-23","objectID":"/posts/java%E6%B3%9B%E5%9E%8B%E4%B8%8E%E9%9B%86%E5%90%88%E7%B1%BB/:2:4","tags":["Java泛型与集合类"],"title":"Java泛型与集合类","uri":"/posts/java%E6%B3%9B%E5%9E%8B%E4%B8%8E%E9%9B%86%E5%90%88%E7%B1%BB/"},{"categories":["JavaSE笔记"],"content":"泛型的界限 现在有一个新的需求，现在没有String类型的成绩了，但是成绩依然可能是整数，也可能是小数，这时我们不希望用户将泛型指定为除数字类型外的其他类型，我们就需要使用到泛型的上界定义： public class Score\u003cT extends Number\u003e { //设定泛型上界，必须是Number的子类 private final String name; private final String id; private T score; public Score(String name, String id, T score) { this.name = name; this.id = id; this.score = score; } public T getScore() { return score; } } 通过extends关键字进行上界限定，只有指定类型或指定类型的子类才能作为类型参数。 同样的，泛型通配符也支持泛型的界限： Score\u003c? extends Number\u003e score; //限定为匹配Number及其子类的类型 同理，既然泛型有上限，那么也有下限： Score\u003c? super Integer\u003e score; //限定为匹配Integer及其父类 通过super关键字进行下界限定，只有指定类型或指定类型的父类才能作为类型参数。 图解如下： 那么限定了上界后，我们再来使用这个对象的泛型成员，会变成什么类型呢？ Score\u003c? extends Number\u003e score = new Score\u003c\u003e(\"数据结构与算法基础\", \"EP074512\", 10); Number o = score.getScore(); //得到的结果为上界类型 也就是说，一旦我们指定了上界后，编译器就将范围从原始类型Object提升到我们指定的上界Number，但是依然无法明确具体类型。思考：那如果定义下限呢？ 那么既然我们可以给泛型类限定上界，现在我们来看编译后结果呢： //使用javap -l 进行反编译 public class com.test.Score\u003cT extends java.lang.Number\u003e { public com.test.Score(java.lang.String, java.lang.String, T); LineNumberTable: line 8: 0 line 9: 4 line 10: 9 line 11: 14 line 12: 19 LocalVariableTable: Start Length Slot Name Signature 0 20 0 this Lcom/test/Score; 0 20 1 name Ljava/lang/String; 0 20 2 id Ljava/lang/String; 0 20 3 score Ljava/lang/Number; //可以看到score的类型直接被编译为Number类 public T getScore(); LineNumberTable: line 15: 0 LocalVariableTable: Start Length Slot Name Signature 0 5 0 this Lcom/test/Score; } 因此，一旦确立上限后，编译器会自动将类型提升到上限类型。 ","date":"2022-01-23","objectID":"/posts/java%E6%B3%9B%E5%9E%8B%E4%B8%8E%E9%9B%86%E5%90%88%E7%B1%BB/:2:5","tags":["Java泛型与集合类"],"title":"Java泛型与集合类","uri":"/posts/java%E6%B3%9B%E5%9E%8B%E4%B8%8E%E9%9B%86%E5%90%88%E7%B1%BB/"},{"categories":["JavaSE笔记"],"content":"钻石运算符 我们发现，每次创建泛型对象都需要在前后都标明类型，但是实际上后面的类型声明是可以去掉的，因为我们在传入参数时或定义泛型类的引用时，就已经明确了类型，因此JDK1.7提供了钻石运算符来简化代码： Score\u003cInteger\u003e score = new Score\u003cInteger\u003e(\"数据结构与算法基础\", \"EP074512\", 10); //1.7之前 Score\u003cInteger\u003e score = new Score\u003c\u003e(\"数据结构与算法基础\", \"EP074512\", 10); //1.7之后 ","date":"2022-01-23","objectID":"/posts/java%E6%B3%9B%E5%9E%8B%E4%B8%8E%E9%9B%86%E5%90%88%E7%B1%BB/:2:6","tags":["Java泛型与集合类"],"title":"Java泛型与集合类","uri":"/posts/java%E6%B3%9B%E5%9E%8B%E4%B8%8E%E9%9B%86%E5%90%88%E7%B1%BB/"},{"categories":["JavaSE笔记"],"content":"泛型与多态 泛型不仅仅可以可以定义在类上，同时也能定义在接口上： public interface ScoreInterface\u003cT\u003e { T getScore(); void setScore(T t); } 当实现此接口时，我们可以选择在实现类明确泛型类型或是继续使用此泛型，让具体创建的对象来确定类型。 public class Score\u003cT\u003e implements ScoreInterface\u003cT\u003e{ //将Score转变为泛型类\u003cT\u003e private final String name; private final String id; private T score; public Score(String name, String id, T score) { this.name = name; this.id = id; this.score = score; } public T getScore() { return score; } @Override public void setScore(T score) { this.score = score; } } public class StringScore implements ScoreInterface\u003cString\u003e{ //在实现时明确类型 @Override public String getScore() { return null; } @Override public void setScore(String s) { } } 抽象类同理，这里就不多做演示了。 ","date":"2022-01-23","objectID":"/posts/java%E6%B3%9B%E5%9E%8B%E4%B8%8E%E9%9B%86%E5%90%88%E7%B1%BB/:2:7","tags":["Java泛型与集合类"],"title":"Java泛型与集合类","uri":"/posts/java%E6%B3%9B%E5%9E%8B%E4%B8%8E%E9%9B%86%E5%90%88%E7%B1%BB/"},{"categories":["JavaSE笔记"],"content":"多态类型擦除 思考一个问题，既然继承后明确了泛型类型，那么为什么@Override不会出现错误呢，重写的条件是需要和父类的返回值类型、形式参数一致，而泛型默认的原始类型是Object类型，子类明确后变为Number类型，这显然不满足重写的条件，但是为什么依然能编译通过呢？ class A\u003cT\u003e{ private T t; public T get(){ return t; } public void set(T t){ this.t=t; } } class B extends A\u003cNumber\u003e{ private Number n; @Override public Number get(){ //这并不满足重写的要求，因为只能重写父类同样返回值和参数的方法，但是这样却能够通过编译！ return t; } @Override public void set(Number t){ this.t=t; } } 通过反编译进行观察，实际上是编译器帮助我们生成了两个桥接方法用于支持重写： @Override public Object get(){ return this.get();//调用返回Number的那个方法 } @Override public void set(Object t ){ this.set((Number)t ); //调用参数是Number的那个方法 } ","date":"2022-01-23","objectID":"/posts/java%E6%B3%9B%E5%9E%8B%E4%B8%8E%E9%9B%86%E5%90%88%E7%B1%BB/:2:8","tags":["Java泛型与集合类"],"title":"Java泛型与集合类","uri":"/posts/java%E6%B3%9B%E5%9E%8B%E4%B8%8E%E9%9B%86%E5%90%88%E7%B1%BB/"},{"categories":["JavaSE笔记"],"content":"数据结构基础 警告！本章最难的部分！ 学习集合类之前，我们还有最关键的内容需要学习，同第一章一样，自底向上才是最佳的学习方向，比起直接带大家认识集合类，不如先了解一下数据结构，只有了解了数据结构基础，才能更好地学习集合类，同时，数据结构也是你以后深入学习JDK源码的必备条件！（学习不要快餐式！）当然，我们主要是讲解Java，数据结构作为铺垫作用，所以我们只会讲解关键的部分，其他部分可以下去自行了解。 在计算机科学中，数据结构是一种数据组织、管理和存储的格式,它可以帮助我们实现对数据高效的访问和修改。更准确地说,数据结构是数据值的集合，可以体现数据值之间的关系，以及可以对数据进行应用的函数或操作。 通俗地说，我们需要去学习在计算机中如何去更好地管理我们的数据，才能让我们对我们的数据控制更加灵活！ ","date":"2022-01-23","objectID":"/posts/java%E6%B3%9B%E5%9E%8B%E4%B8%8E%E9%9B%86%E5%90%88%E7%B1%BB/:3:0","tags":["Java泛型与集合类"],"title":"Java泛型与集合类","uri":"/posts/java%E6%B3%9B%E5%9E%8B%E4%B8%8E%E9%9B%86%E5%90%88%E7%B1%BB/"},{"categories":["JavaSE笔记"],"content":"线性表 线性表是最基本的一种数据结构，它是表示一组相同类型数据的有限序列，你可以把它与数组进行参考，但是它并不是数组，线性表是一种表结构，它能够支持数据的插入、删除、更新、查询等，同时数组可以随意存放在数组中任意位置，而线性表只能依次有序排列，不能出现空隙，因此，我们需要进一步的设计。 顺序表 将数据依次存储在连续的整块物理空间中，这种存储结构称为顺序存储结构，而以这种方式实现的线性表，我们称为顺序表。 同样的，表中的每一个个体都被称为元素，元素左边的元素（上一个元素），称为前驱，同理，右边的元素（后一个元素）称为后驱。 我们设计线性表的目标就是为了去更好地管理我们的数据，也就是说，我们可以基于数组，来进行封装，实现增删改查！既然要存储一组数据，那么很容易联想到我们之前学过的数组，数组就能够容纳一组同类型的数据。 目标：以数组为底层，编写以下抽象类的具体实现 /** * 线性表抽象类 * @param \u003cE\u003e 存储的元素(Element)类型 */ public abstract class AbstractList\u003cE\u003e { /** * 获取表的长度 * @return 顺序表的长度 */ public abstract int size(); /** * 添加一个元素 * @param e 元素 * @param index 要添加的位置(索引) */ public abstract void add(E e, int index); /** * 移除指定位置的元素 * @param index 位置 * @return 移除的元素 */ public abstract E remove(int index); /** * 获取指定位置的元素 * @param index 位置 * @return 元素 */ public abstract E get(int index); } 链表 数据分散的存储在物理空间中，通过一根线保存着它们之间的逻辑关系，这种存储结构称为链式存储结构 实际上，就是每一个结点存放一个元素和一个指向下一个结点的引用（C语言里面是指针，Java中就是对象的引用，代表下一个结点对象） 利用这种思想，我们再来尝试实现上面的抽象类，从实际的代码中感受！ 比较：顺序表和链表的优异？ 顺序表优缺点： 访问速度快，随机访问性能高 插入和删除的效率低下，极端情况下需要变更整个表 不易扩充，需要复制并重新创建数组 链表优缺点： 插入和删除效率高，只需要改变连接点的指向即可 动态扩充容量，无需担心容量问题 访问元素需要依次寻找，随机访问元素效率低下 链表只能指向后面，能不能指向前面呢？双向链表！ 栈和队列实际上就是对线性表加以约束的一种数据结构，如果前面的线性表的掌握已经ok，那么栈和队列就非常轻松了！ 栈 栈遵循先入后出原则，只能在线性表的一端添加和删除元素。我们可以把栈看做一个杯子，杯子只有一个口进出，最低处的元素只能等到上面的元素离开杯子后，才能离开。 向栈中插入一个元素时，称为入栈（压栈），移除栈顶元素称为出栈，我们需要尝试实现以下抽象类型： /** * 抽象类型栈，待实现 * @param \u003cE\u003e 元素类型 */ public abstract class AbstractStack\u003cE\u003e { /** * 出栈操作 * @return 栈顶元素 */ public abstract E pop(); /** * 入栈操作 * @param e 元素 */ public abstract void push(E e); } 其实，我们的JVM在处理方法调用时，也是一个栈操作： 所以说，如果玩不好递归，就会像这样： public class Main { public static void main(String[] args) { go(); } private static void go(){ go(); } } Exception in thread \"main\" java.lang.StackOverflowError at com.test.Main.go(Main.java:13) at com.test.Main.go(Main.java:13) at com.test.Main.go(Main.java:13) at com.test.Main.go(Main.java:13) at com.test.Main.go(Main.java:13) at com.test.Main.go(Main.java:13) at com.test.Main.go(Main.java:13) at com.test.Main.go(Main.java:13) ... 栈的深度是有限制的，如果达到限制，将会出现StackOverflowError错误（注意是错误！说明是JVM出现了问题） 队列 队列同样也是受限制的线性表，不过队列就像我们排队一样，只能从队尾开始排，从队首出。 所以我们要实现以下内容： /** * * @param \u003cE\u003e */ public abstract class AbstractQueue\u003cE\u003e { /** * 进队操作 * @param e 元素 */ public abstract void offer(E e); /** * 出队操作 * @return 元素 */ public abstract E poll(); } ","date":"2022-01-23","objectID":"/posts/java%E6%B3%9B%E5%9E%8B%E4%B8%8E%E9%9B%86%E5%90%88%E7%B1%BB/:3:1","tags":["Java泛型与集合类"],"title":"Java泛型与集合类","uri":"/posts/java%E6%B3%9B%E5%9E%8B%E4%B8%8E%E9%9B%86%E5%90%88%E7%B1%BB/"},{"categories":["JavaSE笔记"],"content":"二叉树 本版块主要学习的是二叉树，树也是一种数据结构，但是它使用起来更加的复杂。 树 我们前面已经学习过链表了，我们知道链表是单个结点之间相连，也就是一种一对一的关系，而树则是一个结点连接多个结点，也就是一对多的关系。 一个结点可以有N个子结点，就像上图一样，看起来就像是一棵树。而位于最顶端的结点（没有父结点）我们称为根结点，而结点拥有的子节点数量称为度，每向下一级称为一个层次，树中出现的最大层次称为树的深度(高度)。 二叉树 二叉树是一种特殊的树，每个结点最多有两颗子树，所以二叉树中不存在度大于2的结点，位于两边的子结点称为左右子树（注意，左右子树是明确区分的，是左就是左，是右就是右） 数学性质： 在二叉树的第i层上最多有2^(i-1) 个节点。 二叉树中如果深度为k，那么最多有2^k-1个节点。 设计一个二叉树结点类： public class TreeNode\u003cE\u003e { public E e; //当前结点数据 public TreeNode\u003cE\u003e left; //左子树 public TreeNode\u003cE\u003e right; //右子树 } 二叉树的遍历 顺序表的遍历其实就是依次有序去访问表中每一个元素，而像二叉树这样的复杂结构，我们有四种遍历方式，他们是：前序遍历、中序遍历、后序遍历以及层序遍历，本版块我们主要讨论前三种遍历方式： 前序遍历：从二叉树的根结点出发，到达结点时就直接输出结点数据，按照先向左在向右的方向访问。ABCDEF 中序遍历：从二叉树的根结点出发，优先输出左子树的节点的数据，再输出当前节点本身，最后才是右子树。CBDAEF 后序遍历：从二叉树的根结点出发，优先遍历其左子树，再遍历右子树，最后在输出当前节点本身。CDBFEA 满二叉树和完全二叉树 满二叉树和完全二叉树其实就是特殊情况下的二叉树，满二叉树左右的所有叶子节点都在同一层，也就是说，完全把每一个层级都给加满了结点。完全二叉树与满二叉树不同的地方在于，它的最下层叶子节点可以不满，但是最下层的叶子节点必须靠左排布。 其实满二叉树和完全二叉树就是有一定规律的二叉树，很容易理解。 ","date":"2022-01-23","objectID":"/posts/java%E6%B3%9B%E5%9E%8B%E4%B8%8E%E9%9B%86%E5%90%88%E7%B1%BB/:3:2","tags":["Java泛型与集合类"],"title":"Java泛型与集合类","uri":"/posts/java%E6%B3%9B%E5%9E%8B%E4%B8%8E%E9%9B%86%E5%90%88%E7%B1%BB/"},{"categories":["JavaSE笔记"],"content":"快速查找 我们之前提到的这些数据结构，很好地帮我们管理了数据，但是，如果需要查找某一个元素是否存在于数据结构中，如何才能更加高效的去完成呢？ 哈希表 通过前面的学习，我们发现，顺序表虽然查询效率高，但是插入删除有严重表更新的问题，而链表虽然弥补了更新问题，但是查询效率实在是太低了，能否有一种折中方案？哈希表！ 不知大家在之前的学习中是否发现，我们的Object类中，定义了一个叫做hashcode()的方法？而这个方法呢，就是为了更好地支持哈希表的实现。hashcode()默认得到的是对象的内存地址，也就是说，每个对象的hashCode都不一样。 哈希表，其实本质上就是一个存放链表的数组，那么它是如何去存储数据的呢？我们先来看看长啥样： 数组中每一个元素都是一个头结点，用于保存数据，那我们怎么确定数据应该放在哪一个位置呢？通过hash算法，我们能够瞬间得到元素应该放置的位置。 //假设hash表长度为16，hash算法为： private int hash(int hashcode){ return hashcode % 16; } 设想这样一个问题，如果计算出来的hash值和之前已经存在的元素相同了呢？这种情况我们称为hash碰撞，这也是为什么要将每一个表元素设置为一个链表的头结点的原因，一旦发现重复，我们可以往后继续添加节点。 当然，以上的hash表结构只是一种设计方案，在面对大额数据时，是不够用的，在JDK1.8中，集合类使用的是数组+二叉树的形式解决的（这里的二叉树是经过加强的二叉树，不是前面讲得简单二叉树，我们下一节就会开始讲） 二叉排序树 我们前面学习的二叉树效率是不够的，我们需要的是一种效率更高的二叉树，因此，基于二叉树的改进，提出了二叉查找树，可以看到结构像下面这样： 不难发现，每个节点的左子树，一定小于当前节点的值，每个节点的右子树，一定大于当前节点的值，这样的二叉树称为二叉排序树。利用二分搜索的思想，我们就可以快速查找某个节点！ 平衡二叉树 在了解了二叉查找树之后，我们发现，如果根节点为10，现在加入到结点的值从9开始，依次减小到1，那么这个表就会很奇怪，就像下面这样： 显然，当所有的结点都排列到一边，这种情况下，查找效率会直接退化为最原始的二叉树！因此我们需要维持二叉树的平衡，才能维持原有的查找效率。 现在我们对二叉排序树加以约束，要求每个结点的左右两个子树的高度差的绝对值不超过1，这样的二叉树称为平衡二叉树，同时要求每个结点的左右子树都是平衡二叉树，这样，就不会因为一边的疯狂增加导致失衡。我们来看看以下几种情况： 左左失衡 右右失衡 左右失衡 右左失衡 通过以上四种情况的处理，最终得到维护平衡二叉树的算法。 红黑树 红黑树也是二叉排序树的一种改进，同平衡二叉树一样，红黑树也是一种维护平衡的二叉排序树，但是没有平衡二叉树那样严格（平衡二叉树每次插入新结点时，可能会出现大量的旋转，而红黑树保证不超过三次），红黑树降低了对于旋转的要求，因此效率有一定的提升同时实现起来也更加简单。但是红黑树的效率却高于平衡二叉树，红黑树也是JDK1.8中使用的数据结构！ 红黑树的特性: （1）每个节点或者是黑色，或者是红色。 （2）根节点是黑色。 （3）每个叶子节点的两边也需要表示（虽然没有，但是null也需要表示出来）是黑色。 （4）如果一个节点是红色的，则它的子节点必须是黑色的。 （5）从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点。 我们来看看一个节点，是如何插入到红黑树中的： 基本的 插入规则和平衡二叉树一样，但是在插入后： 将新插入的节点标记为红色 如果 X 是根结点(root)，则标记为黑色 如果 X 的 parent 不是黑色，同时 X 也不是 root: 3.1 如果 X 的 uncle (叔叔) 是红色 3.1.1 将 parent 和 uncle 标记为黑色 3.1.2 将 grand parent (祖父) 标记为红色 3.1.3 让 X 节点的颜色与 X 祖父的颜色相同，然后重复步骤 2、3 3.2 如果 X 的 uncle (叔叔) 是黑色，我们要分四种情况处理 3.2.1 左左 (P 是 G 的左孩子，并且 X 是 P 的左孩子) 3.2.2 左右 (P 是 G 的左孩子，并且 X 是 P 的右孩子) 3.2.3 右右 (P 是 G 的右孩子，并且 X 是 P 的右孩子) 3.2.4 右左 (P 是 G 的右孩子，并且 X 是 P 的左孩子) 其实这种情况下处理就和我们的平衡二叉树一样了 ","date":"2022-01-23","objectID":"/posts/java%E6%B3%9B%E5%9E%8B%E4%B8%8E%E9%9B%86%E5%90%88%E7%B1%BB/:3:3","tags":["Java泛型与集合类"],"title":"Java泛型与集合类","uri":"/posts/java%E6%B3%9B%E5%9E%8B%E4%B8%8E%E9%9B%86%E5%90%88%E7%B1%BB/"},{"categories":["JavaSE笔记"],"content":"认识集合类 集合表示一组对象，称为其元素。一些集合允许重复的元素，而另一些则不允许。一些集合是有序的，而其他则是无序的。 集合类其实就是为了更好地组织、管理和操作我们的数据而存在的，包括列表、集合、队列、映射等数据结构。从这一块开始，我们会从源码角度给大家讲解（数据结构很重要！），不仅仅是教会大家如何去使用。 集合类最顶层不是抽象类而是接口，因为接口代表的是某个功能，而抽象类是已经快要成形的类型，不同的集合类的底层实现是不相同的，同时一个集合类可能会同时具有两种及以上功能（既能做队列也能做列表），所以采用接口会更加合适，接口只需定义支持的功能即可。 ","date":"2022-01-23","objectID":"/posts/java%E6%B3%9B%E5%9E%8B%E4%B8%8E%E9%9B%86%E5%90%88%E7%B1%BB/:4:0","tags":["Java泛型与集合类"],"title":"Java泛型与集合类","uri":"/posts/java%E6%B3%9B%E5%9E%8B%E4%B8%8E%E9%9B%86%E5%90%88%E7%B1%BB/"},{"categories":["JavaSE笔记"],"content":"数组与集合 相同之处： 它们都是容器，都能够容纳一组元素。 不同之处： 数组的大小是固定的，集合的大小是可变的。 数组可以存放基本数据类型，但集合只能存放对象。 数组存放的类型只能是一种，但集合可以有不同种类的元素。 ","date":"2022-01-23","objectID":"/posts/java%E6%B3%9B%E5%9E%8B%E4%B8%8E%E9%9B%86%E5%90%88%E7%B1%BB/:4:1","tags":["Java泛型与集合类"],"title":"Java泛型与集合类","uri":"/posts/java%E6%B3%9B%E5%9E%8B%E4%B8%8E%E9%9B%86%E5%90%88%E7%B1%BB/"},{"categories":["JavaSE笔记"],"content":"集合根接口Collection 本接口中定义了全部的集合基本操作，我们可以在源码中看看。 我们再来看看List和Set以及Queue接口。 ","date":"2022-01-23","objectID":"/posts/java%E6%B3%9B%E5%9E%8B%E4%B8%8E%E9%9B%86%E5%90%88%E7%B1%BB/:4:2","tags":["Java泛型与集合类"],"title":"Java泛型与集合类","uri":"/posts/java%E6%B3%9B%E5%9E%8B%E4%B8%8E%E9%9B%86%E5%90%88%E7%B1%BB/"},{"categories":["JavaSE笔记"],"content":"集合类的使用 ","date":"2022-01-23","objectID":"/posts/java%E6%B3%9B%E5%9E%8B%E4%B8%8E%E9%9B%86%E5%90%88%E7%B1%BB/:5:0","tags":["Java泛型与集合类"],"title":"Java泛型与集合类","uri":"/posts/java%E6%B3%9B%E5%9E%8B%E4%B8%8E%E9%9B%86%E5%90%88%E7%B1%BB/"},{"categories":["JavaSE笔记"],"content":"List列表 首先介绍ArrayList，它的底层是用数组实现的，内部维护的是一个可改变大小的数组，也就是我们之前所说的线性表！跟我们之前自己写的ArrayList相比，它更加的规范，同时继承自List接口。 先看看ArrayList的源码！ 基本操作 List\u003cString\u003e list = new ArrayList\u003c\u003e(); //默认长度的列表 List\u003cString\u003e listInit = new ArrayList\u003c\u003e(100); //初始长度为100的列表 向列表中添加元素： List\u003cString\u003e list = new ArrayList\u003c\u003e(); list.add(\"lbwnb\"); list.add(\"yyds\"); list.contains(\"yyds\"); //是否包含某个元素 System.out.println(list); 移除元素： public static void main(String[] args) { List\u003cString\u003e list = new ArrayList\u003c\u003e(); list.add(\"lbwnb\"); list.add(\"yyds\"); list.remove(0); //按下标移除元素 list.remove(\"yyds\"); //移除指定元素 System.out.println(list); } 也支持批量操作： public static void main(String[] args) { ArrayList\u003cString\u003e list = new ArrayList\u003c\u003e(); list.addAll(new ArrayList\u003c\u003e()); //在尾部批量添加元素 list.removeAll(new ArrayList\u003c\u003e()); //批量移除元素（只有给定集合中存在的元素才会被移除） list.retainAll(new ArrayList\u003c\u003e()); //只保留某些元素 System.out.println(list); } 我们再来看LinkedList，其实本质就是一个链表！我们来看看源码。 其实与我们之前编写的LinkedList不同之处在于，它内部使用的是一个双向链表： private static class Node\u003cE\u003e { E item; Node\u003cE\u003e next; Node\u003cE\u003e prev; Node(Node\u003cE\u003e prev, E element, Node\u003cE\u003e next) { this.item = element; this.next = next; this.prev = prev; } } 当然，我们发现它还实现了Queue接口，所以LinkedList也能被当做一个队列或是栈来使用。 public static void main(String[] args) { LinkedList\u003cString\u003e list = new LinkedList\u003c\u003e(); list.offer(\"A\"); //入队 System.out.println(list.poll()); //出队 list.push(\"A\"); list.push(\"B\"); //进栈 list.push(\"C\"); System.out.println(list.pop()); System.out.println(list.pop()); //出栈 System.out.println(list.pop()); } 利用代码块来快速添加内容 前面我们学习了匿名内部类，我们就可以利用代码块，来快速生成一个自带元素的List List\u003cString\u003e list = new LinkedList\u003cString\u003e(){{ //初始化时添加 this.add(\"A\"); this.add(\"B\"); }}; 如果是需要快速生成一个只读的List，后面我们会讲解Arrays工具类。 集合的排序 List\u003cInteger\u003e list = new LinkedList\u003cInteger\u003e(){ //Java9才支持匿名内部类使用钻石运算符 { this.add(10); this.add(2); this.add(5); this.add(8); } }; list.sort((a, b) -\u003e { //排序已经由JDK实现，现在只需要填入自定义规则，完成Comparator接口实现 return a - b; //返回值小于0，表示a应该在b前面，返回值大于0，表示b应该在a后面，等于0则不进行交换 }); System.out.println(list); ","date":"2022-01-23","objectID":"/posts/java%E6%B3%9B%E5%9E%8B%E4%B8%8E%E9%9B%86%E5%90%88%E7%B1%BB/:5:1","tags":["Java泛型与集合类"],"title":"Java泛型与集合类","uri":"/posts/java%E6%B3%9B%E5%9E%8B%E4%B8%8E%E9%9B%86%E5%90%88%E7%B1%BB/"},{"categories":["JavaSE笔记"],"content":"迭代器 集合的遍历 所有的集合类，都支持foreach循环！ public static void main(String[] args) { List\u003cInteger\u003e list = new LinkedList\u003cInteger\u003e(){ //Java9才支持匿名内部类使用钻石运算符 { this.add(10); this.add(2); this.add(5); this.add(8); } }; for (Integer integer : list) { System.out.println(integer); } } 当然，也可以使用JDK1.8新增的forEach方法，它接受一个Consumer接口实现： list.forEach(i -\u003e { System.out.println(i); }); 从JDK1.8开始，lambda表达式开始逐渐成为主流，我们需要去适应函数式编程的这种语法，包括批量替换，也是用到了函数式接口来完成的。 list.replaceAll((i) -\u003e { if(i == 2) return 3; //将所有的2替换为3 else return i; //不是2就不变 }); System.out.println(list); Iterable和Iterator接口 我们之前学习数据结构时，已经得知，不同的线性表实现，在获取元素时的效率也不同，因此我们需要一种更好地方式来统一不同数据结构的遍历。 由于ArrayList对于随机访问的速度更快，而LinkedList对于顺序访问的速度更快，因此在上述的传统for循环遍历操作中，ArrayList的效率更胜一筹，因此我们要使得LinkedList遍历效率提升，就需要采用顺序访问的方式进行遍历，如果没有迭代器帮助我们统一标准，那么我们在应对多种集合类型的时候，就需要对应编写不同的遍历算法，很显然这样会降低我们的开发效率，而迭代器的出现就帮助我们解决了这个问题。 我们先来看看迭代器里面方法： public interface Iterator\u003cE\u003e { //... } 每个集合类都有自己的迭代器，通过iterator()方法来获取： Iterator\u003cInteger\u003e iterator = list.iterator(); //生成一个新的迭代器 while (iterator.hasNext()){ //判断是否还有下一个元素 Integer i = iterator.next(); //获取下一个元素（获取一个少一个） System.out.println(i); } 迭代器生成后，默认指向第一个元素，每次调用next()方法，都会将指针后移，当指针移动到最后一个元素之后，调用hasNext()将会返回false，迭代器是一次性的，用完即止，如果需要再次使用，需要调用iterator()方法。 ListIterator\u003cInteger\u003e iterator = list.listIterator(); //List还有一个更好地迭代器实现ListIterator ListIterator是List中独有的迭代器，在原有迭代器基础上新增了一些额外的操作。 ","date":"2022-01-23","objectID":"/posts/java%E6%B3%9B%E5%9E%8B%E4%B8%8E%E9%9B%86%E5%90%88%E7%B1%BB/:5:2","tags":["Java泛型与集合类"],"title":"Java泛型与集合类","uri":"/posts/java%E6%B3%9B%E5%9E%8B%E4%B8%8E%E9%9B%86%E5%90%88%E7%B1%BB/"},{"categories":["JavaSE笔记"],"content":"Set集合 我们之前已经看过Set接口的定义了，我们发现接口中定义的方法都是Collection中直接继承的，因此，Set支持的功能其实也就和Collection中定义的差不多，只不过使用方法上稍有不同。 Set集合特点： 不允许出现重复元素 不支持随机访问（不允许通过下标访问） 首先认识一下HashSet，它的底层就是采用哈希表实现的（我们在这里先不去探讨实现原理，因为底层实质上维护的是一个HashMap，我们学习了Map之后再来讨论） public static void main(String[] args) { HashSet\u003cInteger\u003e set = new HashSet\u003c\u003e(); set.add(120); //支持插入元素，但是不支持指定位置插入 set.add(13); set.add(11); for (Integer integer : set) { System.out.println(integer); } } 运行上面代码发现，最后Set集合中存在的元素顺序，并不是我们的插入顺序，这是因为HashSet底层是采用哈希表来实现的，实际的存放顺序是由Hash算法决定的。 那么我们希望数据按照我们插入的顺序进行保存该怎么办呢？我们可以使用LinkedHashSet： public static void main(String[] args) { LinkedHashSet\u003cInteger\u003e set = new LinkedHashSet\u003c\u003e(); //会自动保存我们的插入顺序 set.add(120); set.add(13); set.add(11); for (Integer integer : set) { System.out.println(integer); } } LinkedHashSet底层维护的不再是一个HashMap，而是LinkedHashMap，它能够在插入数据时利用链表自动维护顺序，因此这样就能够保证我们插入顺序和最后的迭代顺序一致了。 还有一种Set叫做TreeSet，它会在元素插入时进行排序： public static void main(String[] args) { TreeSet\u003cInteger\u003e set = new TreeSet\u003c\u003e(); set.add(1); set.add(3); set.add(2); System.out.println(set); } 可以看到最后得到的结果并不是我们插入顺序，而是按照数字的大小进行排列。当然，我们也可以自定义排序规则： public static void main(String[] args) { TreeSet\u003cInteger\u003e set = new TreeSet\u003c\u003e((a, b) -\u003e b - a); //在创建对象时指定规则即可 set.add(1); set.add(3); set.add(2); System.out.println(set); } 现在的结果就是我们自定义的排序规则了。 虽然Set集合只是粗略的进行了讲解，但是学习Map之后，我们还会回来看我们Set的底层实现，所以说最重要的还是Map。本节只需要记住Set的性质、使用即可。 ","date":"2022-01-23","objectID":"/posts/java%E6%B3%9B%E5%9E%8B%E4%B8%8E%E9%9B%86%E5%90%88%E7%B1%BB/:5:3","tags":["Java泛型与集合类"],"title":"Java泛型与集合类","uri":"/posts/java%E6%B3%9B%E5%9E%8B%E4%B8%8E%E9%9B%86%E5%90%88%E7%B1%BB/"},{"categories":["JavaSE笔记"],"content":"Map映射 什么是映射 我们在高中阶段其实已经学习过映射了，映射指两个元素的之间相互“对应”的关系，也就是说，我们的元素之间是两两对应的，是以键值对的形式存在。 Map接口 Map就是为了实现这种数据结构而存在的，我们通过保存键值对的形式来存储映射关系。 我们先来看看Map接口中定义了哪些操作。 HashMap和LinkedHashMap HashMap的实现过程，相比List，就非常地复杂了，它并不是简简单单的表结构，而是利用哈希表存放映射关系，我们来看看HashMap是如何实现的，首先回顾我们之前学习的哈希表，它长这样： 哈希表的本质其实就是一个用于存放后续节点的头结点的数组，数组里面的每一个元素都是一个头结点（也可以说就是一个链表），当要新插入一个数据时，会先计算该数据的哈希值，找到数组下标，然后创建一个新的节点，添加到对应的链表后面。 而HashMap就是采用的这种方式，我们可以看到源码中同样定义了这样的一个结构： /** * The table, initialized on first use, and resized as * necessary. When allocated, length is always a power of two. * (We also tolerate length zero in some operations to allow * bootstrapping mechanics that are currently not needed.) */ transient Node\u003cK,V\u003e[] table; 这个表会在第一次使用时初始化，同时在必要时进行扩容，并且它的大小永远是2的倍数！ /** * The default initial capacity - MUST be a power of two. */ static final int DEFAULT_INITIAL_CAPACITY = 1 \u003c\u003c 4; // aka 16 我们可以看到默认的大小为2的4次方，每次都需要是2的倍数，也就是说，下一次增长之后，大小会变成2的5次方。 我们现在需要思考一个问题，当我们表中的数据不断增加之后，链表会变得越来越长，这样会严重导致查询速度变慢，首先想到办法就是，我们可以对数组的长度进行扩容，来存放更多的链表，那么什么情况下会进行扩容呢？ /** * The load factor for the hash table. * * @serial */ final float loadFactor; 我们还发现HashMap源码中有这样一个变量，也就是负载因子，那么它是干嘛的呢？ 负载因子其实就是用来衡量当前情况是否需要进行扩容的标准。我们可以看到默认的负载因子是0.75 /** * The load factor used when none specified in constructor. */ static final float DEFAULT_LOAD_FACTOR = 0.75f; 那么负载因子是怎么控制扩容的呢？0.75的意思是，在插入新的结点后，如果当前数组的占用率达到75%则进行扩容。在扩容时，会将所有的数据，重新计算哈希值，得到一个新的下标，组成新的哈希表。 但是这样依然有一个问题，链表过长的情况还是有可能发生，所以，为了从根源上解决这个问题，在JDK1.8时，引入了红黑树这个数据结构。 当链表的长度达到8时，会自动将链表转换为红黑树，这样能使得原有的查询效率大幅度降低！当使用红黑树之后，我们就可以利用二分搜索的思想，快速地去寻找我们想要的结果，而不是像链表一样挨个去看。 /** * Entry for Tree bins. Extends LinkedHashMap.Entry (which in turn * extends Node) so can be used as extension of either regular or * linked node. */ static final class TreeNode\u003cK,V\u003e extends LinkedHashMap.Entry\u003cK,V\u003e { 除了Node以外，HashMap还有TreeNode，很明显这就是为了实现红黑树而设计的内部类。不过我们发现，TreeNode并不是直接继承Node，而是使用了LinkedHashMap中的Entry实现，它保存了前后节点的顺序（也就是我们的插入顺序）。 /** * HashMap.Node subclass for normal LinkedHashMap entries. */ static class Entry\u003cK,V\u003e extends HashMap.Node\u003cK,V\u003e { Entry\u003cK,V\u003e before, after; Entry(int hash, K key, V value, Node\u003cK,V\u003e next) { super(hash, key, value, next); } } LinkedHashMap是直接继承自HashMap，具有HashMap的全部性质，同时得益于每一个节点都是一个双向链表，保存了插入顺序，这样我们在遍历LinkedHashMap时，顺序就同我们的插入顺序一致。当然，也可以使用访问顺序，也就是说对于刚访问过的元素，会被排到最后一位。 public static void main(String[] args) { LinkedHashMap\u003cInteger, String\u003e map = new LinkedHashMap\u003c\u003e(16, 0.75f, true); //以访问顺序 map.put(1, \"A\"); map.put(2, \"B\"); map.put(3, \"C\"); map.get(2); System.out.println(map); } 观察结果，我们发现，刚访问的结果被排到了最后一位。 TreeMap TreeMap其实就是自动维护顺序的一种Map，就和我们前面提到的TreeSet一样： /** * The comparator used to maintain order in this tree map, or * null if it uses the natural ordering of its keys. * * @serial */ private final Comparator\u003c? super K\u003e comparator; private transient Entry\u003cK,V\u003e root; /** * Node in the Tree. Doubles as a means to pass key-value pairs back to * user (see Map.Entry). */ static final class Entry\u003cK,V\u003e implements Map.Entry\u003cK,V\u003e { 我们发现它的内部直接维护了一个红黑树，就像它的名字一样，就是一个Tree，因为它默认就是有序的，所以说直接采用红黑树会更好。我们在创建时，直接给予一个比较规则即可。 Map的使用 我们首先来看看Map的一些基本操作： public static void main(String[] args) { Map\u003cInteger, String\u003e map = new HashMap\u003c\u003e(); map.put(1, \"A\"); map.put(2, \"B\"); map.put(3, \"C\"); System.out.println(map.get(1)); //获取Key为1的值 System.out.println(map.getOrDefault(0, \"K\")); //不存在就返回K map.remove(1); //移除这个Key的键值对 } 由于Map并未实现迭代器接口，因此不支持foreach，但是JDK1.8为我们提供了forEach方法使用： public static void main(String[] args) { Map\u003cInteger, String\u003e map = new HashMap\u003c\u003e(); map.put(1, \"A\"); map.put(2, \"B\"); map.put(3, \"C\"); map.forEach((k, v) -\u003e System.out.println(k+\"-\u003e\"+v)); for (Map.Entry\u003cInteger, String\u003e entry : map.entrySet()) { //也可以获取所有的Entry来foreach int key = entry.getKey(); String value = entry.getValue(); System.out.println(key+\" -\u003e \"+value); } } 我们也可以单独获取所有的值或者是键： public static void main(String[] args) { Map\u003cInteger, String\u003e map = new HashMap\u003c\u003e(); map.put(1, \"A\"); map.put(2, \"B\"); map.put(3, \"C\"); System.out.println(map.keySet()); //直接获取所有的key System.out.println(map.values()); //直接获取所有的值 } 再谈Set原理 通过观察Hash","date":"2022-01-23","objectID":"/posts/java%E6%B3%9B%E5%9E%8B%E4%B8%8E%E9%9B%86%E5%90%88%E7%B1%BB/:5:4","tags":["Java泛型与集合类"],"title":"Java泛型与集合类","uri":"/posts/java%E6%B3%9B%E5%9E%8B%E4%B8%8E%E9%9B%86%E5%90%88%E7%B1%BB/"},{"categories":["JavaSE笔记"],"content":"集合的嵌套 既然集合类型中的元素类型是泛型，那么能否嵌套存储呢？ public static void main(String[] args) { Map\u003cString, List\u003cInteger\u003e\u003e map = new HashMap\u003c\u003e(); //每一个映射都是 字符串\u003c-\u003e列表 map.put(\"卡布奇诺今犹在\", new LinkedList\u003c\u003e()); map.put(\"不见当年倒茶人\", new LinkedList\u003c\u003e()); System.out.println(map.keySet()); System.out.println(map.values()); } 通过Key获取到对应的值后，就是一个列表： map.get(\"卡布奇诺今犹在\").add(10); System.out.println(map.get(\"卡布奇诺今犹在\").get(0)); 让套娃继续下去： public static void main(String[] args) { Map\u003cInteger, Map\u003cInteger, Map\u003cInteger, String\u003e\u003e\u003e map = new HashMap\u003c\u003e(); } 你也可以使用List来套娃别的： public static void main(String[] args) { List\u003cMap\u003cString, Set\u003cString\u003e\u003e\u003e list = new LinkedList\u003c\u003e(); } ","date":"2022-01-23","objectID":"/posts/java%E6%B3%9B%E5%9E%8B%E4%B8%8E%E9%9B%86%E5%90%88%E7%B1%BB/:5:5","tags":["Java泛型与集合类"],"title":"Java泛型与集合类","uri":"/posts/java%E6%B3%9B%E5%9E%8B%E4%B8%8E%E9%9B%86%E5%90%88%E7%B1%BB/"},{"categories":["JavaSE笔记"],"content":"流Stream和Optional的使用 Java 8 API添加了一个新的抽象称为流Stream，可以让你以一种声明的方式处理数据。Stream 使用一种类似用 SQL 语句从数据库查询数据的直观方式来提供一种对 Java 集合运算和表达的高阶抽象。Stream API可以极大提高Java程序员的生产力，让程序员写出高效率、干净、简洁的代码。这种风格将要处理的元素集合看作一种流， 流在管道中传输， 并且可以在管道的节点上进行处理， 比如筛选， 排序，聚合等。元素流在管道中经过中间操作（intermediate operation）的处理，最后由最终操作(terminal operation)得到前面处理的结果。 它看起来就像一个工厂的流水线一样！我们就可以把一个Stream当做流水线处理： public static void main(String[] args) { List\u003cString\u003e list = new ArrayList\u003c\u003e(); list.add(\"A\"); list.add(\"B\"); list.add(\"C\"); //移除为B的元素 Iterator\u003cString\u003e iterator = list.iterator(); while (iterator.hasNext()){ if(iterator.next().equals(\"B\")) iterator.remove(); } //Stream操作 list = list //链式调用 .stream() //获取流 .filter(e -\u003e !e.equals(\"B\")) //只允许所有不是B的元素通过流水线 .collect(Collectors.toList()); //将流水线中的元素重新收集起来，变回List System.out.println(list); } 可能从上述例子中还不能感受到流处理带来的便捷，我们通过下面这个例子来感受一下： public static void main(String[] args) { List\u003cInteger\u003e list = new ArrayList\u003c\u003e(); list.add(1); list.add(2); list.add(3); list.add(3); list = list .stream() .distinct() //去重（使用equals判断） .sorted((a, b) -\u003e b - a) //进行倒序排列 .map(e -\u003e e+1) //每个元素都要执行+1操作 .limit(2) //只放行前两个元素 .collect(Collectors.toList()); System.out.println(list); } 当遇到大量的复杂操作时，我们就可以使用Stream来快速编写代码，这样不仅代码量大幅度减少，而且逻辑也更加清晰明了（如果你学习过SQL的话，你会发现它更像一个Sql语句） 注意：不能认为每一步是直接依次执行的！ List\u003cInteger\u003e list = new ArrayList\u003c\u003e(); list.add(1); list.add(2); list.add(3); list.add(3); list = list .stream() .distinct() //断点 .sorted((a, b) -\u003e b - a) .map(e -\u003e { System.out.println(\"\u003e\u003e\u003e \"+e); //断点 return e+1; }) .limit(2) //断点 .collect(Collectors.toList()); //实际上，stream会先记录每一步操作，而不是直接开始执行内容，当整个链式调用完成后，才会依次进行！ 接下来，我们用一堆随机数来进行更多流操作的演示： public static void main(String[] args) { Random random = new Random(); //Random是一个随机数工具类 random .ints(-100, 100) //生成-100~100之间的，随机int型数字（本质上是一个IntStream） .limit(10) //只获取前10个数字（这是一个无限制的流，如果不加以限制，将会无限进行下去！） .filter(i -\u003e i \u003c 0) //只保留小于0的数字 .sorted() //默认从小到大排序 .forEach(System.out::println); //依次打印 } 我们可以生成一个统计实例来帮助我们快速进行统计： public static void main(String[] args) { Random random = new Random(); //Random是一个随机数工具类 IntSummaryStatistics statistics = random .ints(0, 100) .limit(100) .summaryStatistics(); //获取语法统计实例 System.out.println(statistics.getMax()); //快速获取最大值 System.out.println(statistics.getCount()); //获取数量 System.out.println(statistics.getAverage()); //获取平均值 } 普通的List只需要一个方法就可以直接转换到方便好用的IntStream了： public static void main(String[] args) { List\u003cInteger\u003e list = new ArrayList\u003c\u003e(); list.add(1); list.add(1); list.add(2); list.add(3); list.add(4); list.stream() .mapToInt(i -\u003e i) //将每一个元素映射为Integer类型（这里因为本来就是Integer） .summaryStatistics(); } 我们还可以通过flat来对整个流进行进一步细分： public static void main(String[] args) { List\u003cString\u003e list = new ArrayList\u003c\u003e(); list.add(\"A,B\"); list.add(\"C,D\"); list.add(\"E,F\"); //我们想让每一个元素通过,进行分割，变成独立的6个元素 list = list .stream() //生成流 .flatMap(e -\u003e Arrays.stream(e.split(\",\"))) //分割字符串并生成新的流 .collect(Collectors.toList()); //汇成新的List System.out.println(list); //得到结果 } 我们也可以只通过Stream来完成所有数字的和，使用reduce方法： public static void main(String[] args) { List\u003cInteger\u003e list = new ArrayList\u003c\u003e(); list.add(1); list.add(2); list.add(3); int sum = list .stream() .reduce((a, b) -\u003e a + b) //计算规则为：a是上一次计算的值，b是当前要计算的参数，这里是求和 .get(); //我们发现得到的是一个Optional类实例，不是我们返回的类型，通过get方法返回得到的值 System.out.println(sum); } 通过上面的例子，我们发现，Stream不喜欢直接给我们返回一个结果，而是通过Optinal的方式，那么什么是Optional呢？ Optional类是Java8为了解决null值判断问题，使用Optional类可以避免显式的null值判断（null的防御性检查），避免null导致的NPE（NullPointerException）。总而言之，就是对控制的一个判断，为了避免空指针异常。 public static void main(String[] args) { String str = null; if(str != null){ //当str不为空时添加元素到List中 list.add(str); } } 有了Optional之后，我们就可以这样写： public static void main(String[] args) { String str = null; Optional\u003cString\u003e optional = Optional.ofNullable(str); //转换为Optional optional.ifPresent(System.out::println); //当存在时再执行方法 } 就类似于Kotlin中的： var str : String? = null str?.upperCase() 我们可以选择直接get或是当值为null时，获取备选值： public static void main(String[] args) { String str = null; Optional optional = Optional.ofNullable(str); //转换为Optional（可空） System.out.println(optional.orElse(\"lbwnb\")); // S","date":"2022-01-23","objectID":"/posts/java%E6%B3%9B%E5%9E%8B%E4%B8%8E%E9%9B%86%E5%90%88%E7%B1%BB/:5:6","tags":["Java泛型与集合类"],"title":"Java泛型与集合类","uri":"/posts/java%E6%B3%9B%E5%9E%8B%E4%B8%8E%E9%9B%86%E5%90%88%E7%B1%BB/"},{"categories":["JavaSE笔记"],"content":"Arrays和Collections的使用 Arrays是一个用于操作数组的工具类，它给我们提供了大量的工具方法： /** * This class contains various methods for manipulating arrays (such as * sorting and searching). This class also contains a static factory * that allows arrays to be viewed as lists. \u003c- 注意，这句话很关键 * * @author Josh Bloch * @author Neal Gafter * @author John Rose * @since 1.2 */ public class Arrays { 由于操作数组并不像集合那样方便，因此JDK提供了Arrays类来增强对数组操作，比如： public static void main(String[] args) { int[] array = {1, 5, 2, 4, 7, 3, 6}; Arrays.sort(array); //直接进行排序（底层原理：进行判断，元素少使用插入排序，大量元素使用双轴快速/归并排序） System.out.println(array); //由于int[]是一个对象类型，而数组默认是没有重写toString()方法，因此无法打印到想要的结果 System.out.println(Arrays.toString(array)); //我们可以使用Arrays.toString()来像集合一样直接打印每一个元素出来 } public static void main(String[] args) { int[] array = {1, 5, 2, 4, 7, 3, 6}; Arrays.sort(array); System.out.println(\"排序后的结果：\"+Arrays.toString(array)); System.out.println(\"目标元素3位置为：\"+Arrays.binarySearch(array, 3)); //二分搜素，必须是已经排序好的数组！ } public static void main(String[] args) { int[] array = {1, 5, 2, 4, 7, 3, 6}; Arrays .stream(array) //将数组转换为流进行操作 .sorted() .forEach(System.out::println); } public static void main(String[] args) { int[] array = {1, 5, 2, 4, 7, 3, 6}; int[] array2 = Arrays.copyOf(array, array.length); //复制一个一模一样的数组 System.out.println(Arrays.toString(array2)); System.out.println(Arrays.equals(array, array2)); //比较两个数组是否值相同 Arrays.fill(array, 0); //将数组的所有值全部填充为指定值 System.out.println(Arrays.toString(array)); Arrays.setAll(array2, i -\u003e array2[i] + 2); //依次计算每一个元素（注意i是下标位置） System.out.println(Arrays.toString(array2)); //这里计算让每个元素值+2 } 思考：当二维数组使用Arrays.equals()进行比较以及Arrays.toString()进行打印时，还会得到我们想要的结果吗？ public static void main(String[] args) { Integer[][] array = {{1, 5}, {2, 4}, {7, 3}, {6}}; Integer[][] array2 = {{1, 5}, {2, 4}, {7, 3}, {6}}; System.out.println(Arrays.toString(array)); //这样还会得到我们想要的结果吗？ System.out.println(Arrays.equals(array2, array)); //这样还会得到true吗？ System.out.println(Arrays.deepToString(array)); //使用deepToString就能到打印多维数组 System.out.println(Arrays.deepEquals(array2, array)); //使用deepEquals就能比较多维数组 } 那么，一开始提到的当做List进行操作呢？我们可以使用Arrays.asList()来将数组转换为一个 固定长度的List public static void main(String[] args) { Integer[] array = {1, 5, 2, 4, 7, 3, 6}; List\u003cInteger\u003e list = Arrays.asList(array); //不支持基本类型数组，必须是对象类型数组 Arrays.asList(\"A\", \"B\", \"C\"); //也可以逐个添加，因为是可变参数 list.add(1); //此List实现是长度固定的，是Arrays内部单独实现的一个类型，因此不支持添加操作 list.remove(0); //同理，也不支持移除 list.set(0, 8); //直接设置指定下标的值就可以 list.sort(Comparator.reverseOrder()); //也可以执行排序操作 System.out.println(list); //也可以像List那样直接打印 } 文字游戏：allows arrays to be viewed as lists，实际上只是当做List使用，本质还是数组，因此数组的属性依然存在！因此如果要将数组快速转换为实际的List，可以像这样： public static void main(String[] args) { Integer[] array = {1, 5, 2, 4, 7, 3, 6}; List\u003cInteger\u003e list = new ArrayList\u003c\u003e(Arrays.asList(array)); } 通过自行创建一个真正的ArrayList并在构造时将Arrays的List值传递。 既然数组操作都这么方便了，集合操作能不能也安排点高级的玩法呢？那必须的，JDK为我们准备的Collocations类就是专用于集合的工具类： public static void main(String[] args) { List\u003cInteger\u003e list = new ArrayList\u003c\u003e(); Collections.max(list); Collections.min(list); } 当然，Collections提供的内容相比Arrays会更多，希望大家下去自行了解，这里就不多做介绍了。 ","date":"2022-01-23","objectID":"/posts/java%E6%B3%9B%E5%9E%8B%E4%B8%8E%E9%9B%86%E5%90%88%E7%B1%BB/:5:7","tags":["Java泛型与集合类"],"title":"Java泛型与集合类","uri":"/posts/java%E6%B3%9B%E5%9E%8B%E4%B8%8E%E9%9B%86%E5%90%88%E7%B1%BB/"},{"categories":["JavaSE笔记"],"content":"集合类编程实战 ","date":"2022-01-23","objectID":"/posts/java%E6%B3%9B%E5%9E%8B%E4%B8%8E%E9%9B%86%E5%90%88%E7%B1%BB/:6:0","tags":["Java泛型与集合类"],"title":"Java泛型与集合类","uri":"/posts/java%E6%B3%9B%E5%9E%8B%E4%B8%8E%E9%9B%86%E5%90%88%E7%B1%BB/"},{"categories":["JavaSE笔记"],"content":"反转链表 1 \u003c- 3 \u003c- 5 \u003c- 7 \u003c- 9 转换为 1 \u003c- 3 \u003c- 5 \u003c- 7 \u003c- 9 现在有一个单链表，尝试将其所有节点倒序排列 public class Main { public static void main(String[] args) { Node head = new Node(1); head.next = new Node(3); head.next.next = new Node(5); head.next.next.next = new Node(7); head.next.next.next.next = new Node(9); head = reverse(head); while (head != null){ System.out.println(head.value+\" \"); head = head.next; } } public static class Node { public int value; public Node next; public Node(int data) { this.value = data; } } public static Node reverse(Node head) { //在这里实现 } } ","date":"2022-01-23","objectID":"/posts/java%E6%B3%9B%E5%9E%8B%E4%B8%8E%E9%9B%86%E5%90%88%E7%B1%BB/:6:1","tags":["Java泛型与集合类"],"title":"Java泛型与集合类","uri":"/posts/java%E6%B3%9B%E5%9E%8B%E4%B8%8E%E9%9B%86%E5%90%88%E7%B1%BB/"},{"categories":["JavaSE笔记"],"content":"重建二叉树 现在知道二叉树的前序: GDAFEMHZ，以及中序: ADEFGHMZ，请根据已知信息还原这颗二叉树。 ","date":"2022-01-23","objectID":"/posts/java%E6%B3%9B%E5%9E%8B%E4%B8%8E%E9%9B%86%E5%90%88%E7%B1%BB/:6:2","tags":["Java泛型与集合类"],"title":"Java泛型与集合类","uri":"/posts/java%E6%B3%9B%E5%9E%8B%E4%B8%8E%E9%9B%86%E5%90%88%E7%B1%BB/"},{"categories":["JavaSE笔记"],"content":"实现计算器 实现一个计算器，要求输入一个计算公式（含加减乘除运算符，没有负数但是有小数），得到结果，比如输入：1+4*3/1.321，得到结果为：2.2 ","date":"2022-01-23","objectID":"/posts/java%E6%B3%9B%E5%9E%8B%E4%B8%8E%E9%9B%86%E5%90%88%E7%B1%BB/:6:3","tags":["Java泛型与集合类"],"title":"Java泛型与集合类","uri":"/posts/java%E6%B3%9B%E5%9E%8B%E4%B8%8E%E9%9B%86%E5%90%88%E7%B1%BB/"},{"categories":["JavaSE笔记"],"content":"字符串匹配（KMP算法） 现在给定一个主字符串和一个子字符串，请判断主字符串是否包含子字符串，例如主字符串：ABCABCDHI，子字符串：ABCD，因此主字符串包含此子字符串；主字符串：ABCABCUISA，子字符串：ABCD，则不包含。 ","date":"2022-01-23","objectID":"/posts/java%E6%B3%9B%E5%9E%8B%E4%B8%8E%E9%9B%86%E5%90%88%E7%B1%BB/:6:4","tags":["Java泛型与集合类"],"title":"Java泛型与集合类","uri":"/posts/java%E6%B3%9B%E5%9E%8B%E4%B8%8E%E9%9B%86%E5%90%88%E7%B1%BB/"},{"categories":["C++实战"],"content":"”一起来领略C++模板的奥义“","date":"2022-01-20","objectID":"/posts/c++%E7%9A%84%E6%A8%A1%E6%9D%BF%E5%86%99println/","tags":["C++模板"],"title":"C++变参模板运用实战——实现PrintLn","uri":"/posts/c++%E7%9A%84%E6%A8%A1%E6%9D%BF%E5%86%99println/"},{"categories":["C++实战"],"content":"想要实现PrintLn，关键在于支持无限个参数的打印函数，所以我大致总结下C++能够如何去实现它！ ","date":"2022-01-20","objectID":"/posts/c++%E7%9A%84%E6%A8%A1%E6%9D%BF%E5%86%99println/:0:0","tags":["C++模板"],"title":"C++变参模板运用实战——实现PrintLn","uri":"/posts/c++%E7%9A%84%E6%A8%A1%E6%9D%BF%E5%86%99println/"},{"categories":["C++实战"],"content":"方式一：用初始化列表实现PrintLn() 【C++11】 ","date":"2022-01-20","objectID":"/posts/c++%E7%9A%84%E6%A8%A1%E6%9D%BF%E5%86%99println/:1:0","tags":["C++模板"],"title":"C++变参模板运用实战——实现PrintLn","uri":"/posts/c++%E7%9A%84%E6%A8%A1%E6%9D%BF%E5%86%99println/"},{"categories":["C++实战"],"content":"版本一：朴素初始化列表版本版本 函数版本： #include\u003ciostream\u003eusing namespace std; void PrintLn(std::initializer_list\u003cint\u003e args){ for(auto arg:args){ cout\u003c\u003carg\u003c\u003c\", \"; } cout\u003c\u003cstd::endl; } int main() { PrintLn({3,23,2,12}); return 0; } 类的构造器版本(可去掉小括号)： #include\u003ciostream\u003eusing namespace std; class PrintLn { public: PrintLn(std::initializer_list\u003cint\u003e args) { for (auto arg:args) { cout \u003c\u003c arg \u003c\u003c \", \"; } cout \u003c\u003c std::endl; } }; int main() { auto t = PrintLn{3, 23, 2, 12}; return 0; } ","date":"2022-01-20","objectID":"/posts/c++%E7%9A%84%E6%A8%A1%E6%9D%BF%E5%86%99println/:1:1","tags":["C++模板"],"title":"C++变参模板运用实战——实现PrintLn","uri":"/posts/c++%E7%9A%84%E6%A8%A1%E6%9D%BF%E5%86%99println/"},{"categories":["C++实战"],"content":"版本二：加模板参数版本 实际上和上面的基本没太大区别，除了上面确定为了int类型，二加了模板后，可以为任意类型，但是实际上传入的还是只能是同一个类型。所以初始化列表实现是非常的不好用的。 #incldue\u003ciostream\u003e using namespace std; template\u003ctypename T\u003e class PrintLn { public: PrintLn(std::initializer_list\u003cT\u003e args) { for (auto arg:args) { cout \u003c\u003c arg \u003c\u003c \", \"; }# PrintLn函数实现 想要实现PrintLn，关键在于支持无限个参数的打印函数，所以我大致总结下C++能够如何去实现它！ ## 方式一：用初始化列表实现PrintLn() 【C++11】 ### 版本一：朴素初始化列表版本版本 \u003e 函数版本： ```cpp #include\u003ciostream\u003eusing namespace std; void PrintLn(std::initializer_list\u003cint\u003e args){ for(auto arg:args){ cout\u003c\u003carg\u003c\u003c\", \"; } cout\u003c\u003cstd::endl; } int main() { PrintLn({3,23,2,12}); return 0; } 类的构造器版本(可去掉小括号)： #include\u003ciostream\u003eusing namespace std; class PrintLn { public: PrintLn(std::initializer_list\u003cint\u003e args) { for (auto arg:args) { cout \u003c\u003c arg \u003c\u003c \", \"; } cout \u003c\u003c std::endl; } }; int main() { auto t = PrintLn{3, 23, 2, 12}; return 0; } ","date":"2022-01-20","objectID":"/posts/c++%E7%9A%84%E6%A8%A1%E6%9D%BF%E5%86%99println/:1:2","tags":["C++模板"],"title":"C++变参模板运用实战——实现PrintLn","uri":"/posts/c++%E7%9A%84%E6%A8%A1%E6%9D%BF%E5%86%99println/"},{"categories":["C++实战"],"content":"版本二：加模板参数版本 实际上和上面的基本没太大区别，除了上面确定为了int类型，而加了模板后，可以为任意类型，但是实际上传入的还是只能是同一个类型。所以初始化列表的方式实现Println只能说形似而神不似。 #incldue\u003ciostream\u003e using namespace std; template\u003ctypename T\u003e class PrintLn { public: PrintLn(std::initializer_list\u003cT\u003e args) { for (auto arg:args) { cout \u003c\u003c arg \u003c\u003c \", \"; } cout \u003c\u003c std::endl; } }; int main() { auto t = PrintLn\u003cint\u003e{3, 23, 2, 12}; return 0; } ","date":"2022-01-20","objectID":"/posts/c++%E7%9A%84%E6%A8%A1%E6%9D%BF%E5%86%99println/:1:3","tags":["C++模板"],"title":"C++变参模板运用实战——实现PrintLn","uri":"/posts/c++%E7%9A%84%E6%A8%A1%E6%9D%BF%E5%86%99println/"},{"categories":["C++实战"],"content":"方式二：用可变参模板实现 【C++11/17】 如果有了解过C的可变参函数和可变参的宏，那么这个可变参模板与它有些类型，只不过C里面的va_start,va_list,va_arg,va_end这一系列实现可变参数的宏用起来非常麻烦，而且无法确定每个参数的类型，而可变参的模板则带有模板的泛型性质，所以是能确定类型的，甚至由于模板可以传值，后面还可直接传值使用。 以下简单描述可变参模板的使用方式： typenam... 算C++的一个新的关键字，它可以用来定义一个可变参的模板类型，而这个类型在其他地方定义使用的时候也要在后面带上 ... 表示拆包，否则会报错。 例如： template\u003ctypename... T\u003e void f(T... t){//TODO 这种类型或变量在任何地方作为参数定义或者传递的时候都需要加上...表示拆包 f(t...) } 在C++17出现fold expression之前，这个拆包过程只能借助另一个模板参数来得到模板参数包里面的内容。 注意以上两点，那么可以开始编写泛型模板，实现可变参数的完全打印过程了。 ","date":"2022-01-20","objectID":"/posts/c++%E7%9A%84%E6%A8%A1%E6%9D%BF%E5%86%99println/:2:0","tags":["C++模板"],"title":"C++变参模板运用实战——实现PrintLn","uri":"/posts/c++%E7%9A%84%E6%A8%A1%E6%9D%BF%E5%86%99println/"},{"categories":["C++实战"],"content":"C++11版本实现 错误实现版本：如果你直接像下面这样进行拆包，那么编译是会报错的，因为拆包过程相当于一个递归的过程，而你这个递归的过程没有一个跳出的条件，比如args如果为0个参数时，继续在往下就无法展开了，所以需要实现一个没有参数的版本让拆包过程停止。 template\u003ctypename T,typename... Args\u003e void PrintLn(T firstArg,Args... args){ cout\u003c\u003cfirstArg\u003c\u003c\", \"; PrintLn(args...); } //拆包过程：PrintLn(3,1,3,4)-\u003e // PrintLn(firstArg:3,args(1,3,4)); // PrintLn(firstArg:1,args(3,4)); // PrintLn(firstArg:3,args(4)); // PrintLn(firstArg:4,args(null)) // 由于到了上面的第四行还要继续往下拆包 // 而此时只有0个参数，没有对应的PrintLn版本可以调用，故报错！ 以下为正确修改版本： #include\u003ciostream\u003eusing namespace std; void PrintLn(){ } template\u003ctypename T,typename... Args\u003e void PrintLn(T firstArg,Args... args){ cout\u003c\u003cfirstArg\u003c\u003c\", \"; PrintLn(args...); } int main() { PrintLn(3, 23, 2, 12); return 0; 当然也可以控制只剩一个参数时就停止拆包。 #include\u003ciostream\u003eusing namespace std; template\u003ctypename T\u003e void PrintLn(T arg){ cout\u003c\u003carg\u003c\u003cendl; } template\u003ctypename T,typename... Args\u003e void PrintLn(T firstArg,Args... args){ cout\u003c\u003cfirstArg\u003c\u003c\", \"; PrintLn(args...); } int main() { PrintLn(3, 23, 2, 12); return 0; } ","date":"2022-01-20","objectID":"/posts/c++%E7%9A%84%E6%A8%A1%E6%9D%BF%E5%86%99println/:2:1","tags":["C++模板"],"title":"C++变参模板运用实战——实现PrintLn","uri":"/posts/c++%E7%9A%84%E6%A8%A1%E6%9D%BF%E5%86%99println/"},{"categories":["C++实战"],"content":"C++17版本实现 上面的实现流程实际上在C++17中可以用 if constexpr()+sizeof… 在编译期间来进行流程控制。 首先来讲一讲为什么普通的 if + sizeof… 来实现可变参数的长度控制流程会报错呢？ 因为整个模板推断和拆包解包过程是在编译期完成的，而if的控制流程在编译期是完全不清楚的，所以会报错，但是有了if constexpr之后，就能控制编译期的模板拆包过程了！ 如上面实现PrintLn，可以直接简化成下面这样： #include\u003ciostream\u003eusing namespace std; template\u003ctypename T,typename... Args\u003e void PrintLn(T firstArg,Args... args){ if constexpr(sizeof...(args)==0){//当参数个数为0个的时候就不继续拆包了 cout\u003c\u003cfirstArg\u003c\u003cendl; }else{ cout\u003c\u003cfirstArg\u003c\u003c\", \"; PrintLn(args...);//往下继续拆包 } } int main() { PrintLn(3, 23, 2, 12); return 0; } ","date":"2022-01-20","objectID":"/posts/c++%E7%9A%84%E6%A8%A1%E6%9D%BF%E5%86%99println/:2:2","tags":["C++模板"],"title":"C++变参模板运用实战——实现PrintLn","uri":"/posts/c++%E7%9A%84%E6%A8%A1%E6%9D%BF%E5%86%99println/"},{"categories":["C++实战"],"content":"方式三：可变参模板的fold expression展开 【C++17】 在C++17中，加入了一个fold expression的语法，让可变参数模板可以不通过递归的方式来解包，直接把每个包解开放入一个表达式，然后剩余的包都以该表达式解开，基本的语法如下： ((expression)op...); expression : 表示希望每个解开的参数所执行的表达式。 op : 你指定的操作符。 ... : 一直不断的解包，由于此处放的位置是右边，所以往右边解包，如果放左边则往左边解包。 示例代码： #include \u003cbits/stdc++.h\u003eusing namespace std; template\u003ctypename... Args\u003e double sum(Args... args){ return (args+...);//等价于3+23+1+3.32 } template\u003cauto... val\u003e//可变的传值的模板参数 constexpr int sum(){ return (val+...); } int main() { cout\u003c\u003csum\u003c3,23,1,32\u003e()\u003c\u003cendl;//传值模板参数不支持浮点类型，所以全用的int类型 cout\u003c\u003csum(3,23,1,3.32); return 0; } ","date":"2022-01-20","objectID":"/posts/c++%E7%9A%84%E6%A8%A1%E6%9D%BF%E5%86%99println/:3:0","tags":["C++模板"],"title":"C++变参模板运用实战——实现PrintLn","uri":"/posts/c++%E7%9A%84%E6%A8%A1%E6%9D%BF%E5%86%99println/"},{"categories":["C++实战"],"content":"简单的利用fold expr实现 基于以上对fold expr的使用，我们来正式实现PrintLn，值得一提的是，这个fold expr的性能肯定是比之前递归解包的性能要好的，因为只是迭代的拓宽而已。 我们可以将拆开的包用 ',' 展开 #include\u003ciostream\u003eusing namespace std; template\u003ctypename... Args\u003e void PrintLn(Args... args){ ((cout\u003c\u003cargs\u003c\u003c\", \"),...)\u003c\u003cendl; } int main() { PrintLn(1,2.3,\"LB\",\"hhh\"); return 0; } ","date":"2022-01-20","objectID":"/posts/c++%E7%9A%84%E6%A8%A1%E6%9D%BF%E5%86%99println/:3:1","tags":["C++模板"],"title":"C++变参模板运用实战——实现PrintLn","uri":"/posts/c++%E7%9A%84%E6%A8%A1%E6%9D%BF%E5%86%99println/"},{"categories":["C++实战"],"content":"加上流程控制实现 通过更复杂的流程控制把最后一个打印出来的逗号去掉。 通过延申三元运算符，使得运行时能够正确的打印最后一次。 反正我这里编译期只负责文本替换，所以被fold expr展开的表达式并不会有什么要是编译期常量的要求。 这一切都看作简单宏替换即可。 #include\u003ciostream\u003eusing namespace std; template\u003ctypename... Args\u003e void PrintLn(Args... args){ int lastIndex = sizeof...(args)-1;//得到传入的参数长度 int i = 0; ((i++==lastIndex?cout\u003c\u003cargs\u003c\u003cendl:cout\u003c\u003cargs\u003c\u003c\", \"),...); } int main() { PrintLn(1,2.3,\"LB\",\"hhh\"); return 0; } ","date":"2022-01-20","objectID":"/posts/c++%E7%9A%84%E6%A8%A1%E6%9D%BF%E5%86%99println/:3:2","tags":["C++模板"],"title":"C++变参模板运用实战——实现PrintLn","uri":"/posts/c++%E7%9A%84%E6%A8%A1%E6%9D%BF%E5%86%99println/"},{"categories":["C++实战"],"content":"更多fold expr运用… 利用与或表达式展开，然后利用它们的短路性质，实现得到拆包元素的精准打击（获得包里的第几个元素）。 #include\u003ciostream\u003eusing namespace std; template\u003ctypename... Args\u003e auto GetNth(int n, Args... args) { int i = 0; using CommonType = common_type_t\u003cArgs...\u003e; CommonType ret; ((i++ == n \u0026\u0026 (ret = args, true))||...); return ret; } int main() { cout \u003c\u003c GetNth(3, 2, 1, 2.3, 32.2); return 0; } 上面为了存储不确定的类型用了common_type_t，这个可以帮助你得到一个公共可用的类型，而这个类型必须是公共可用，比如int了float型可以进行相互转化所以有公共类型，而 char* 和int类型则没有，所以这个GetNth中的元素不能传递 char* 类型的同时传递int类型。 ","date":"2022-01-20","objectID":"/posts/c++%E7%9A%84%E6%A8%A1%E6%9D%BF%E5%86%99println/:3:3","tags":["C++模板"],"title":"C++变参模板运用实战——实现PrintLn","uri":"/posts/c++%E7%9A%84%E6%A8%A1%E6%9D%BF%E5%86%99println/"},{"categories":["C++实战"],"content":"”Socket基本操作的C++封装“","date":"2022-01-20","objectID":"/posts/socket%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9Cc++%E5%B0%81%E8%A3%85/","tags":["socket通信"],"title":"Socket基本操作的C++封装","uri":"/posts/socket%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9Cc++%E5%B0%81%E8%A3%85/"},{"categories":["C++实战"],"content":"封装过程 ","date":"2022-01-20","objectID":"/posts/socket%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9Cc++%E5%B0%81%E8%A3%85/:1:0","tags":["socket通信"],"title":"Socket基本操作的C++封装","uri":"/posts/socket%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9Cc++%E5%B0%81%E8%A3%85/"},{"categories":["C++实战"],"content":"接口类的实现(抽象类) _public_socket.h 该头文件用于包含所有该系统平台socket所需要依赖的库。 windows平台 #ifndef MY_TINY_STL__PUBLIC_SOCKET_H #define MY_TINY_STL__PUBLIC_SOCKET_H #include \u003cwinsock2.h\u003e#pragma comment (lib, \"ws2_32.lib\") //加载 ws2_32.dll #endif //MY_TINY_STL__PUBLIC_SOCKET_H Linux平台 #include \u003cunistd.h\u003e#include \u003carpa/inet.h\u003e#include \u003csys/socket.h\u003e#include \u003cnetinet/in.h\u003eTCP_INTERFACE.h(作用于win平台) 由于该接口由服务器端和客户端继承，而两者同样的函数成员也就是这些了，设计客户端和服务器端时就只需要考虑各自的套接字以及其余操作的成员函数，也不需要管理DLL的开关。 还有一个erro_die()成员函数用于阻断错误并打印对应情况。 // // Created by Alone on 2021/8/17. // #ifndef MY_TINY_STL_TCP_INTERFACE_H #define MY_TINY_STL_TCP_INTERFACE_H #include \u003ccstdio\u003e#include \"_public_socket.h\" class TCP_INTERFACE { public: TCP_INTERFACE() { //初始化 DLL WSADATA wsaData; WSAStartup(MAKEWORD(2, 2), \u0026wsaData); } //返回值小于等于0时发生错误 virtual int Send(SOCKET clnt, const void *buf, const int buflen) = 0; virtual int Recv(SOCKET clnt, void *buf, const int buflen) = 0; //closesocket返回值不为0则发生错误 virtual void Close(SOCKET clnt) = 0; virtual void error_die(const char *str) = 0; ~TCP_INTERFACE() { WSACleanup(); } }; #endif //MY_TINY_STL_TCP_INTERFACE_H ","date":"2022-01-20","objectID":"/posts/socket%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9Cc++%E5%B0%81%E8%A3%85/:1:1","tags":["socket通信"],"title":"Socket基本操作的C++封装","uri":"/posts/socket%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9Cc++%E5%B0%81%E8%A3%85/"},{"categories":["C++实战"],"content":"服务器端封装 这次修改了下逻辑，还是用accept返回一个套接字进行发送和接收操作比较好。类的底层没有再保留用于和某个客户端通信的套接字了，自己控制各个客户端套接字的关闭和使用。 TCP_SOCKET_SERVER.h // // Created by Alone on 2021/8/16. // #ifndef MY_TINY_STL_TCP_SOCKET_SERVER_H #define MY_TINY_STL_TCP_SOCKET_SERVER_H #include \"TCP_INTERFACE.h\" class TCP_SOCKET_SERVER : public TCP_INTERFACE { public: TCP_SOCKET_SERVER(); ~TCP_SOCKET_SERVER(); void Bind(int port); void Listen(); SOCKET Accept(); int Send(SOCKET clnt, const void *buf, const int buflen); int Recv(SOCKET clnt, void *buf, const int buflen); void Close(SOCKET clnt); void error_die(const char *str); private: SOCKET servSock; sockaddr_in sockAddr; }; #endif //MY_TINY_STL_TCP_SOCKET_SERVER_H TCP_SOCKET_SERVER.cpp // // Created by Alone on 2021/8/16. // #include \"TCP_SOCKET_SERVER.h\" //初始化操作 TCP_SOCKET_SERVER::TCP_SOCKET_SERVER() : servSock(0) { memset(\u0026sockAddr, 0, sizeof(sockAddr)); //每个字节都用0填充 } //绑定操作 void TCP_SOCKET_SERVER::Bind(int port) { servSock = socket(PF_INET, SOCK_STREAM, IPPROTO_TCP); sockAddr.sin_family = PF_INET; //使用IPv4地址 sockAddr.sin_addr.s_addr = htonl(INADDR_ANY); //具体的IP地址 sockAddr.sin_port = htons(port); //端口 if (bind(servSock, (SOCKADDR *) \u0026sockAddr, sizeof(SOCKADDR)) != 0) { error_die(\"bind\"); } } //置于监听状态 void TCP_SOCKET_SERVER::Listen() { if (servSock == 0) error_die(\"listen\"); if (listen(servSock, SOMAXCONN) != 0) { error_die(\"listen\"); } } //利用套接字的监听串口，接收客户端的请求，建立新的套接字进行存储信息 SOCKET TCP_SOCKET_SERVER::Accept() { SOCKADDR t; int nSize = sizeof(SOCKADDR); //后面两个参数为可选 SOCKET clnt = accept(servSock, \u0026t, \u0026nSize); if (clnt \u003c= 0)error_die(\"accept\"); return clnt; } //返回的是发送到缓冲区的字节长度 int TCP_SOCKET_SERVER::Send(SOCKET clnt, const void *buf, const int buflen) { return send(clnt, (const char *) buf, buflen, 0); } //返回已经接收的字节长度 int TCP_SOCKET_SERVER::Recv(SOCKET clnt, void *buf, const int buflen) { return recv(clnt, (char *) buf, buflen, 0); } //析构函数关闭socket TCP_SOCKET_SERVER::~TCP_SOCKET_SERVER() { if (servSock != 0)closesocket(servSock); } void TCP_SOCKET_SERVER::Close(SOCKET clnt) { if (closesocket(clnt) != 0) { error_die(\"closesocket\"); } } void TCP_SOCKET_SERVER::error_die(const char *str) { printf(\"[hint]%s failed:%d\", str, WSAGetLastError()); exit(-1); } ","date":"2022-01-20","objectID":"/posts/socket%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9Cc++%E5%B0%81%E8%A3%85/:1:2","tags":["socket通信"],"title":"Socket基本操作的C++封装","uri":"/posts/socket%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9Cc++%E5%B0%81%E8%A3%85/"},{"categories":["C++实战"],"content":"客户端的封装 TCP_SOCKET_CLIENT.h 增加了利用域名查询ip地址的成员函数gethostbyname(),挺好玩的！此次增加了erro_die函数，且发送和接收都操作套接字。在类的内部还是保留了套接字的备份，用于忘记关闭套接字时，析构函数进行关闭。 // // Created by Alone on 2021/8/18. // #ifndef MY_TINY_STL_TCP_SOCKET_CLIENT_H #define MY_TINY_STL_TCP_SOCKET_CLIENT_H #include \"TCP_INTERFACE.h\"#include \u003ciostream\u003e class TCP_SOCKET_CLIENT : public TCP_INTERFACE { public: TCP_SOCKET_CLIENT(); ~TCP_SOCKET_CLIENT(); SOCKET Connect(const char *IPAdrr, u_short port); //用于利用URL(域名)查询IP地址 void Gethostbyname(const char *URL); //接口必须实现的函数 int Send(SOCKET clnt,const void *buf, const int bufSize); int Recv(SOCKET clnt,void *buf, const int bufSize); void Close(SOCKET clnt); void error_die(const char *str); private: //由于一般客户端只需要一个套接字实现连接,然后还需要一个socketadrr_in用于连接内容的赋值 SOCKET clntSock; sockaddr_in sockAddr; }; #endif //MY_TINY_STL_TCP_SOCKET_CLIENT_H TCP_SOCKET_CLIENT.cpp // // Created by Alone on 2021/8/17. // #include \"TCP_SOCKET_CLIENT.h\" //初始化 TCP_SOCKET_CLIENT::TCP_SOCKET_CLIENT() : clntSock(0) {} //关闭套接字操作 void TCP_SOCKET_CLIENT::Close(SOCKET clnt) { if (closesocket(clnt) != 0) error_die(\"close\"); clntSock = 0; } //连接服务器操作 SOCKET TCP_SOCKET_CLIENT::Connect(const char *IPAdrr, u_short port) { memset(\u0026sockAddr, 0, sizeof sockAddr); clntSock = socket(PF_INET, SOCK_STREAM, IPPROTO_TCP); sockAddr.sin_family = PF_INET; sockAddr.sin_addr.s_addr = inet_addr(IPAdrr); sockAddr.sin_port = htons(port); if (connect(clntSock, (SOCKADDR *) \u0026sockAddr, sizeof(sockAddr)) != 0) { error_die(\"connect\"); } return clntSock; } //发送信息操作 int TCP_SOCKET_CLIENT::Send(SOCKET clnt,const void *buf, const int bufSize) { return send(clnt, (const char *) buf, bufSize, 0); } //接收信息操作 int TCP_SOCKET_CLIENT::Recv(SOCKET clnt,void *buf, const int bufSize) { return recv(clnt, (char *) buf, bufSize, 0); } //根据域名获取ip地址等信息 void TCP_SOCKET_CLIENT::Gethostbyname(const char *URL) { hostent *host = gethostbyname(URL); if (!host) { std::cout \u003c\u003c \"Get IP address error!\\n\"; return; } //打印本命 std::cout \u003c\u003c URL \u003c\u003c std::endl; //别名 for (int i = 0; host-\u003eh_aliases[i]; i++) { printf(\"Aliases %d: %s\\n\", i + 1, host-\u003eh_aliases[i]); } //地址类型 printf(\"Address type: %s\\n\", (host-\u003eh_addrtype == AF_INET) ? \"AF_INET\" : \"AF_INET6\"); //IP地址,其中inet_ntoa()函数是将网络字节序转为本地的字节序，方便打印看懂 for (int i = 0; host-\u003eh_addr_list[i]; i++) { printf(\"IP addr %d: %s\\n\", i + 1, inet_ntoa(*(struct in_addr *) host-\u003eh_addr_list[i])); } } //析构时需要确保所有东西已经关闭 TCP_SOCKET_CLIENT::~TCP_SOCKET_CLIENT() { if (clntSock != 0) closesocket(clntSock); } void TCP_SOCKET_CLIENT::error_die(const char *str) { printf(\"[hint]%s failed:%d\", str, WSAGetLastError()); exit(-1); } ","date":"2022-01-20","objectID":"/posts/socket%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9Cc++%E5%B0%81%E8%A3%85/:1:3","tags":["socket通信"],"title":"Socket基本操作的C++封装","uri":"/posts/socket%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9Cc++%E5%B0%81%E8%A3%85/"},{"categories":["C++实战"],"content":"实例讲解 ","date":"2022-01-20","objectID":"/posts/socket%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9Cc++%E5%B0%81%E8%A3%85/:2:0","tags":["socket通信"],"title":"Socket基本操作的C++封装","uri":"/posts/socket%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9Cc++%E5%B0%81%E8%A3%85/"},{"categories":["C++实战"],"content":"实例一：回声程序通信 服务器回声程序 绑定本地1234端口，进入监听状态等待请求，如果通信对象关闭了通信，也不慌，重新goto到等待请求得到新的通信套接字 #include \u003ciostream\u003e#include \"TCP_SOCKET_SERVER.h\" #define BUF_SIZE 1000 using namespace std; int main() { TCP_SOCKET_SERVER a; a.Bind(1234); a.Listen(); restart: SOCKET clnt = a.Accept(); while (1) { char *x = new char[BUF_SIZE]; memset(x, 0, BUF_SIZE); int size = a.Recv(clnt,x, BUF_SIZE); if (size \u003c= 0) break; if (a.Send(clnt,x, size) \u003c= 0) break; } a.Close(clnt); cout \u003c\u003c \"connect is over.Waiting for a new connection!\\n\"; goto restart; } 客户端通信程序 为保持持续通信，一旦客户端拒绝了请求，那么弹出循环重新连接，并设置连接超时操作。 #include \"TCP_SOCKET_CLIENT.h\"#define BUF_SIZE 100 int main(){ TCP_SOCKET_CLIENT t; const char* to = \"127.0.0.1\"; restart: SOCKET clnt = t.Connect(to,1234); while(1){ std::cout\u003c\u003c\"\\nInput your message:\\n\"; char buf[BUF_SIZE] = {0}; std::cin.getline(buf,99); int size = t.Send(clnt,buf,BUF_SIZE); if(size\u003c=0) break; memset(buf,0,sizeof buf); if(t.Recv(clnt,buf,size)\u003c=0) break; printf(\"received from %s is:\\n\",to); std::cout\u003c\u003cbuf; } t.Close(clnt); std::cout\u003c\u003c\"The Server is disconnected,and socket has been cleaned up,socket connection has been re-established\\n\"; goto restart; return 0; } 回声效果 客户端收到的结果 服务器端一直运行着，只要不关闭，但每次只能和一个客户端进行通信，通信完后重新等待连接。 ","date":"2022-01-20","objectID":"/posts/socket%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9Cc++%E5%B0%81%E8%A3%85/:2:1","tags":["socket通信"],"title":"Socket基本操作的C++封装","uri":"/posts/socket%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9Cc++%E5%B0%81%E8%A3%85/"},{"categories":["C++实战"],"content":"实例二：文件操作，传送图片(掌握重复传包) 分析待传图片 看看这百万大小的字节，一次肯定是传不完的，所以我们需要发送端不断的续传，直到传送完毕。 发送端程序 #include \"TCP_SOCKET_CLIENT.h\"#include \u003cfstream\u003eint main(){ TCP_SOCKET_CLIENT t; const char* to = \"127.0.0.1\"; restart: SOCKET clnt = t.Connect(to,1234); //图片写入buf(这几百万字节大小，得亏是new动态分配 std::ifstream img(\"D:/DesktopBackground/L-69.png\",std::ios::in|std::ios::binary); //设置文件指针用于求文件内容长度 img.seekg(0,std::ios::end); int len = img.tellg(); img.seekg(0,std::ios::beg); if(len\u003e0){printf(\"read OK\\n\");} else {printf(\"file is empty!\");return 0;} //填补buf char * buf = new char[len]; img.read(buf,len); //发送数据到服务器,一次肯定发送不完，所以多次 int sum = 0; while(sum\u003clen){ int sendlen = t.Send(clnt,buf,len); if(sendlen\u003c=0){ printf(\"Send Erro!\"); return 0; } sum += sendlen; } t.Close(clnt); printf(\"Send OK!\"); return 0; } 接收端程序 #include \u003ciostream\u003e#include \"TCP_SOCKET_SERVER.h\"#include \u003cfstream\u003e#define BUF_SIZE 100 using namespace std; int main() { TCP_SOCKET_SERVER a; a.Bind(1234); a.Listen(); //等待连接，连接成功便可建立通讯 SOCKET clnt = a.Accept(); //创建文件用于写入图片数据 ofstream t(\"test.png\",ios::binary|ios::out); //由于要接收的图片文件较大，需要分多次包进行传输数据，所以需要不断循环接收 while(1){ char buf[BUF_SIZE]; int sz = a.Recv(clnt,buf,BUF_SIZE); //直到发送端发送数据完毕断开连接后，便可判断为接收完毕 if(sz\u003c=0){ cout\u003c\u003c\"Finish !\"; return 0; } //每次调整文件指针位置到最后续写 t.seekp(0,ios::end); t.write(buf,sz); } a.Close(clnt); } 接收结果 一模一样毫无偏差 ","date":"2022-01-20","objectID":"/posts/socket%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9Cc++%E5%B0%81%E8%A3%85/:2:2","tags":["socket通信"],"title":"Socket基本操作的C++封装","uri":"/posts/socket%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9Cc++%E5%B0%81%E8%A3%85/"},{"categories":["C++实战"],"content":"实例三：Web通信(浏览器访问服务器) ","date":"2022-01-20","objectID":"/posts/socket%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9Cc++%E5%B0%81%E8%A3%85/:3:0","tags":["socket通信"],"title":"Socket基本操作的C++封装","uri":"/posts/socket%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9Cc++%E5%B0%81%E8%A3%85/"},{"categories":["C++实战"],"content":"Web服务器程序 我这个web服务器也算是及其简单了。。并没有对客户端的http请求进行解析然后发送对应的文件给客户端，而是单纯的我客户端想怎么发就怎么发。。另外这个程序虽然是对图片进行了判断，但并未写出对应的图片发送程序(二进制文件读写是不一样的)，所以实际只能发送文本文件，如html代码。所以后面看到的课程表都无法显示图片的原因是客户端程序压根就没在乎过客户端的请求🤣 #include \u003ciostream\u003e#include \u003cfstream\u003e#include \"TCP_SOCKET_SERVER.h\" void sendfileToWeb(SOCKET clnt, TCP_SOCKET_SERVER \u0026a, const char *filename); int main() { TCP_SOCKET_SERVER a; a.Bind(8086); a.Listen(); SOCKET clnt = a.Accept(); while (1) { sendfileToWeb(clnt, a, \"D:/Html/schedule/schedule.html\"); a.Close(clnt); clnt = a.Accept(); } } //反馈请求，发送文件代码或者图片等二进制信息。 void sendfileToWeb(SOCKET clnt, TCP_SOCKET_SERVER \u0026a, const char *filename) { //写入返回头信息：包括状态和内容类型 char *type = nullptr; if (strstr(filename, \".html\")) type = \"text/html\"; else if (strstr(filename, \".jpg\")) type = \"image/jpg\"; else if (strstr(filename, \".png\")) type = \"image/png\"; char x[100] = {0}; sprintf(x, \"HTTP/1.1 200 ok\\r\\nContent-Type: %s\\r\\n\\r\\n\", type); //发送返回头信息,每次发送间隔需要一定时间，否则浏览器可能接收没这么快 int sz1 = a.Send(clnt, x, strlen(x)); if (sz1 \u003c= 0)return; //发送文件内容到客户端 std::ifstream ss(filename, std::ios::in); char html[1024] = {0}; while (ss.getline(html, 1024)) { int szz = a.Send(clnt, html, strlen(html)); if (szz \u003c= 0) return; Sleep(1); } ss.close(); } ","date":"2022-01-20","objectID":"/posts/socket%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9Cc++%E5%B0%81%E8%A3%85/:3:1","tags":["socket通信"],"title":"Socket基本操作的C++封装","uri":"/posts/socket%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9Cc++%E5%B0%81%E8%A3%85/"},{"categories":["C++实战"],"content":"接收结果 ","date":"2022-01-20","objectID":"/posts/socket%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9Cc++%E5%B0%81%E8%A3%85/:3:2","tags":["socket通信"],"title":"Socket基本操作的C++封装","uri":"/posts/socket%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9Cc++%E5%B0%81%E8%A3%85/"},{"categories":["C++实战"],"content":"总结 收获： 了解到网络通讯过程到底是怎么样的。 了解到底层socket通信是如何进行的。 封装了socket操作，增强了代码的复用性。 对基本的http请求过程有所了解： 基本上就是浏览器(客户端)对相应的IP地址发起请求，其对应的服务器返回给你这个网页的主页，然后根据你鼠标的点击，又会触发http请求，其对应的服务器对你的请求进行解析，得出你想要的文件，然后发送给你，循环往复一直如此。。。 ","date":"2022-01-20","objectID":"/posts/socket%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9Cc++%E5%B0%81%E8%A3%85/:4:0","tags":["socket通信"],"title":"Socket基本操作的C++封装","uri":"/posts/socket%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9Cc++%E5%B0%81%E8%A3%85/"},{"categories":["C++实战"],"content":"”简单学习下基本的类封装“","date":"2022-01-20","objectID":"/posts/%E5%A4%A7%E6%95%B4%E6%95%B0%E5%8A%A0%E5%87%8F/","tags":["C++类的封装"],"title":"大数加减类的实现(C++实现)✨","uri":"/posts/%E5%A4%A7%E6%95%B4%E6%95%B0%E5%8A%A0%E5%87%8F/"},{"categories":["C++实战"],"content":"为什么需要大数加减类？ 对于计算机而言，基本的数据类型一般最多为64位数据表示范围，这个范围是有限的，没法无限的表示所有的数据，那么有没有一种方式能够表示所有的大数，并完成加减乘除呢？ 答案肯定是有的，由于数据都是由一位一位的数字所组成，我们只需要用数组中的每一位表示一位数字，便可完成对大数的模拟了。 那么我们说明时候需要用到大数模拟呢？对竞赛人而言，有很多题目实际上就是高精度大数模拟类型，而对于普通的程序员而言，大数模拟也仅是在做某个逻辑运算而保证不会溢出的最佳策略，那么大家难道不好奇如何实现一个大数模拟类吗？ 现在就从封装一个简单的加减类开始了解这样一个大数模拟是怎么实现的👀 ","date":"2022-01-20","objectID":"/posts/%E5%A4%A7%E6%95%B4%E6%95%B0%E5%8A%A0%E5%87%8F/:1:0","tags":["C++类的封装"],"title":"大数加减类的实现(C++实现)✨","uri":"/posts/%E5%A4%A7%E6%95%B4%E6%95%B0%E5%8A%A0%E5%87%8F/"},{"categories":["C++实战"],"content":"大数加减类实现详解 ","date":"2022-01-20","objectID":"/posts/%E5%A4%A7%E6%95%B4%E6%95%B0%E5%8A%A0%E5%87%8F/:2:0","tags":["C++类的封装"],"title":"大数加减类的实现(C++实现)✨","uri":"/posts/%E5%A4%A7%E6%95%B4%E6%95%B0%E5%8A%A0%E5%87%8F/"},{"categories":["C++实战"],"content":"一、流程图总览 如图总体来说分为五部分： 静态成员函数：属于类的公共接口(核心) 构造和析构函数：构造对象以及析构对象 成员数据：用于运算的数据以及表示对象的数据 运算符重载：用于自定义运算方式(核心) 内部成员函数：属于对象的公共接口 ","date":"2022-01-20","objectID":"/posts/%E5%A4%A7%E6%95%B4%E6%95%B0%E5%8A%A0%E5%87%8F/:2:1","tags":["C++类的封装"],"title":"大数加减类的实现(C++实现)✨","uri":"/posts/%E5%A4%A7%E6%95%B4%E6%95%B0%E5%8A%A0%E5%87%8F/"},{"categories":["C++实战"],"content":"二、成员数据和构造函数详解 成员数据 bool f; //是否是负数的标记 char *nums; //存储非符号的大数各个位 int length; //nums的数据长度 int capacity; //nums的可用容量 构造和析构 //缺省构造函数 BigInteger() : length(0), capacity(1), f(false) { nums = new char[capacity]; } //用于转化普通字符串的构造函数 BigInteger(const char *n) : length(strlen(n)), f(false) { int start = 0; if (n[0] == '-') { f = true; start++; } while (start\u003clength\u0026\u0026n[start] == '0')start++; capacity = length * 10; nums = new char[capacity]; std::copy(n + start, n + length, nums); length = length - start; } //拷贝构造函数 BigInteger(BigInteger \u0026a) { capacity = a.capacity; length = a.length; f = a.f; nums = new char[capacity]; std::copy(a.nums, a.nums + length, nums); } //移动构造函数：这里调用了等于号，根据a的类型来决定用哪个等于号 BigInteger(BigInteger \u0026\u0026a) :length(0){ *this = a; } //析构函数 ~BigInteger() { delete[] nums; } ","date":"2022-01-20","objectID":"/posts/%E5%A4%A7%E6%95%B4%E6%95%B0%E5%8A%A0%E5%87%8F/:2:2","tags":["C++类的封装"],"title":"大数加减类的实现(C++实现)✨","uri":"/posts/%E5%A4%A7%E6%95%B4%E6%95%B0%E5%8A%A0%E5%87%8F/"},{"categories":["C++实战"],"content":"三、(算法核心)静态成员函数和运算符重载详解 static Swap() //调用std的swap实现对基本数据的交换 static void Swap(BigInteger \u0026a, BigInteger \u0026b) { std::swap(a.length, b.length); std::swap(a.capacity, b.capacity); std::swap(a.f, b.f); std::swap(a.nums, b.nums); } static compare() //不看符号比较nums的大小：表示a是否比b大 static bool compare(const BigInteger \u0026a,const BigInteger \u0026b) { //比较纯nums大小(不看符号 int n1 = a.length; int n2 = b.length; if (n1 != n2)return n1 \u003e n2; //返回a和b哪个大，true则位a大 int i = 0; while (i \u003c n1 \u0026\u0026 a.nums[i] == b.nums[i])i++; //a b一样长的情况下，比较两个的值 if (i == n1) return false; return a.nums[i] \u003e b.nums[i]; } static isEqual() //表示a和b是否相等 bool isEqual(BigInteger \u0026a, BigInteger \u0026b) { if (a.f != b.f || (a.length != b.length))return false; int i = 0; while (i \u003c a.length \u0026\u0026 a.nums[i] == b.nums[i])i++; return i == a.length \u0026\u0026 a.f == b.f; } (*核心算法)static add() 不看符号的加法，符号这方面由重载加法运算符控制。 static BigInteger add(BigInteger \u0026a, BigInteger \u0026b) { //不看符号的加法 a.reverse();//尾端对齐 b.reverse(); BigInteger t; int up = 0; int len = a.length \u003e b.length ? a.length : b.length; for (int i = 0; i \u003c len; i++) { int ta = i \u003c a.length ? a[i] - '0' : 0; int tb = i \u003c b.length ? b[i] - '0' : 0; int base = ta + tb + up; t.push_back(base % 10 + '0'); up = base / 10; } if (up) t.push_back(up + '0'); t.reverse();//返回原位 a.reverse(); b.reverse(); return t; } (*核心算法)static minus() 不看符号的减法,默认了a的nums大小(不看符号)是比b大的。 static BigInteger minus(BigInteger \u0026a, BigInteger \u0026b) { a.reverse(); b.reverse(); BigInteger t; int len = a.length \u003e b.length ? a.length : b.length; for (int i = 0; i \u003c len; i++) { int ta = i \u003c a.length ? a[i] - '0' : 0; int tb = i \u003c b.length ? b[i] - '0' : 0; int base = ta - tb; if (base \u003c 0) { base += 10; a[i + 1]--; } t.push_back(base + '0'); } t.reverse(); a.reverse(); b.reverse(); return t; } char \u0026operator[] char \u0026operator[](int i) { return nums[i]; } BigInteger \u0026operator= 用了两个版本–右值引用和左值引用版本 右值引用延长寿命，用交换的方式实现(毕竟是将亡值 BigInteger \u0026operator=(BigInteger\u0026\u0026 a) { //Swap\u0026Copy方式实现右值赋值重载 Swap(*this, a); return *this; } 左值引用深拷贝 BigInteger \u0026operator=(const BigInteger \u0026a) {//深拷贝 if (length != 0)//如果不是初始化调用的 = ，则肯定需要先把原来的内存delete掉 delete[]nums; capacity = a.capacity; length = a.length; f = a.f; nums = new char[capacity]; std::copy(a.nums, a.nums + length, nums); return *this; } bool operator\u003c 重载了小于号，好处在于可以直接利用stl进行各种排序操作了。 注意：一定要写成const版本的成员函数，不然STL库无法调用，因为STL库中的所有比较都是基于const对象。 bool operator\u003c(const BigInteger \u0026a) const { if (f \u0026\u0026 !a.f) { //其中一个为负数，则那个是更小的 return true; } else if (!f \u0026\u0026 a.f) return false; if (f) { //两者都为负数的情况，左边的值要更大则为true return compare(*this, a); }//两者均为正数，则值更小的在左边为true return compare(a, *this); } (*核心算法)BigInteger operator+ 利用静态成员函数完成无符号的加减，然后在这里进行判断各种符号情况，根据不同的符号情况进行不同的加法处理。 注意在调用minus之前需要比较两个数的nums谁更大，更大的放在第一个参数上！ BigInteger operator+(BigInteger \u0026a) { BigInteger res; bool flag; if (a.f \u0026\u0026 f) { //同为负数情况，直接相加，再改符号 res = add(*this, a); flag = true; } else if (a.f \u0026\u0026 !f) {//左正右负 if (compare(a, *this)) { //看负数对应的nums是否比正数大 flag = true; res = minus(a, *this); } else { flag = false; res = minus(*this, a); } } else if (!a.f \u0026\u0026 f) { if (compare(*this, a)) { //与上一个相同 flag = true; res = minus(*this, a); } else { flag = false; res = minus(a, *this); } } else { //同时为正数就是最简单的加法 flag = false; res = add(*this, a); } res.f = flag; return res; } (*核心算法)BigInteger operator- 同样是分类讨论，同样是根据不同的类型调用minus和add函数。 与正数不同的处理在于对符号的处理，如果同为负数，则需要判断两者是否相等，防止两数相等相减后减为 0，而被处理为 -0 。 BigInteger operator-(BigInteger \u0026a) { BigInteger res; bool flag; if (a.f \u0026\u0026 f) { //同为负数情况--左边-右边==(不看符号)右边-(不看符号)左边 if (compare(a, *this)) { flag = false; res = minus(a, *this); } else { if (isEqual(*this, a)) flag = false; else flag = true; res = minus(*this, a); } } else if (a.f \u0026\u0026 !f) { //左边为正，右边为负--左边-右边==左边+右边 flag = false; res = add(a, *this); } else if (!a.f \u0026\u0026 f) { //右边为正，左边为负--左边-右边==两边为负的加法 flag = true; res = add(a, *this); } else { //同时为正数--左边-右边==左边-右边(分类讨论正负 if (compare(a, *this)) { //右边\u003e左边,符号为负 res = minus(a, *this); flag = true; } else { //右边\u003c左边，符号为正 res = minus(*this, a); flag = false; } } res.f = flag; return res; } ","date":"2022-01-20","objectID":"/posts/%E5%A4%A7%E6%95%B4%E6%95%B0%E5%8A%A0%E5%87%8F/:2:3","tags":["C++类的封装"],"title":"大数加减类的实现(C++实现)✨","uri":"/posts/%E5%A4%A7%E6%95%B4%E6%95%B0%E5%8A%A0%E5%87%8F/"},{"categories":["C++实战"],"content":"四、其他内部成员函数详解 向外提供的get接口 int getCap() { return capacity; } int getLength() { return length; } bool isNegative() { return f; } bool isEmpty() { return length == 0; } 进行赋值操作所必备的push_back和reverse函数 void push_back(char x) { if (length \u003e= capacity) {//扩容操作 capacity *= 2; char *t = nums; nums = new char[capacity]; std::copy(t, t + length, nums); delete[]t; } nums[length++] = x; } void reverse() {//反转操作 int l = 0, r = length - 1; while (l \u003c r) { std::swap(nums[l], nums[r]); l++; r--; } } 无关紧要的 read() 输入接口 和 print() 输出测试接口 void print() { if (f) printf(\"-\"); nums[length] = '\\0'; int i = 0; while (nums[i] == '0')i++; printf(\"%s\", nums + i); } void read() {//利用getchar()给对象赋上数据 char c = getchar(); if (c == '-') { f = true; c = getchar(); } while (c == '0') c = getchar();//将前导0消耗掉 while (c != '\\n') { push_back(c);//不断的调用push_back即可 c = getchar(); } } ","date":"2022-01-20","objectID":"/posts/%E5%A4%A7%E6%95%B4%E6%95%B0%E5%8A%A0%E5%87%8F/:2:4","tags":["C++类的封装"],"title":"大数加减类的实现(C++实现)✨","uri":"/posts/%E5%A4%A7%E6%95%B4%E6%95%B0%E5%8A%A0%E5%87%8F/"},{"categories":["C++实战"],"content":"整理代码 ","date":"2022-01-20","objectID":"/posts/%E5%A4%A7%E6%95%B4%E6%95%B0%E5%8A%A0%E5%87%8F/:3:0","tags":["C++类的封装"],"title":"大数加减类的实现(C++实现)✨","uri":"/posts/%E5%A4%A7%E6%95%B4%E6%95%B0%E5%8A%A0%E5%87%8F/"},{"categories":["C++实战"],"content":".h声明文件 如果在声明类的同时进行定义，则内部的成员函数默认就是内联的。所以我们一般把短小的代码进行内联，以下的实现均是以该规律进行。 // // Created by Alone on 2021/10/7. // #ifndef MY_TINY_STL_BIGINTEGER_H #define MY_TINY_STL_BIGINTEGER_H #include \u003calgorithm\u003e#include \u003ciostream\u003e#include \u003ccstring\u003e class BigInteger { bool f; char *nums; int length; int capacity; public: //构造函数 BigInteger() : length(0), capacity(1), f(false) { //缺省构造函数 nums = new char[capacity]; } BigInteger(const char *n); BigInteger(const BigInteger \u0026a); BigInteger(BigInteger \u0026\u0026a); ~BigInteger() { //析构函数 delete[] nums; } public: //静态函数 static void Swap(BigInteger \u0026a, BigInteger \u0026b); static bool compare(const BigInteger \u0026a, const BigInteger \u0026b); bool isEqual(BigInteger \u0026a, BigInteger \u0026b); static BigInteger add(BigInteger \u0026a, BigInteger \u0026b); static BigInteger minus(BigInteger \u0026a, BigInteger \u0026b); public: //运算符重载 char \u0026operator[](int i) { return nums[i]; } BigInteger \u0026operator=(BigInteger \u0026\u0026a) { //Swap\u0026Copy方式实现右值赋值重载 Swap(*this, a); return *this; } BigInteger \u0026operator=(const BigInteger \u0026a); bool operator\u003c(const BigInteger \u0026a) const; BigInteger operator+(BigInteger \u0026a); BigInteger operator-(BigInteger \u0026a); public: //对象的基本成员函数 int getCap() { return capacity; } int getLength() { return length; } bool isNegative() { return f; } bool isEmpty() { return length == 0; } void reverse(); void push_back(char x); void print(); void read(); }; #endif //MY_TINY_STL_BIGINTEGER_H ","date":"2022-01-20","objectID":"/posts/%E5%A4%A7%E6%95%B4%E6%95%B0%E5%8A%A0%E5%87%8F/:3:1","tags":["C++类的封装"],"title":"大数加减类的实现(C++实现)✨","uri":"/posts/%E5%A4%A7%E6%95%B4%E6%95%B0%E5%8A%A0%E5%87%8F/"},{"categories":["C++实战"],"content":".cpp定义并实现 // // Created by Alone on 2021/10/7. // #include \"BigInteger.h\" //@构造函数实现 BigInteger::BigInteger(const char *n) : length(strlen(n)), f(false) { //用于初始值的构造函数 int start = 0; if (n[0] == '-') { f = true; start++; } while (start \u003c length \u0026\u0026 n[start] == '0')start++; capacity = length * 10; nums = new char[capacity]; std::copy(n + start, n + length, nums); length = length - start; } BigInteger::BigInteger(const BigInteger \u0026a) { //拷贝构造函数 capacity = a.capacity; length = a.length; f = a.f; nums = new char[capacity]; std::copy(a.nums, a.nums + length, nums); } BigInteger::BigInteger(BigInteger \u0026\u0026a) : length(0) { //移动构造函数 *this = a; } //@静态函数实现 void BigInteger::Swap(BigInteger \u0026a, BigInteger \u0026b) { std::swap(a.length, b.length); std::swap(a.capacity, b.capacity); std::swap(a.f, b.f); std::swap(a.nums, b.nums); } bool BigInteger::compare(const BigInteger \u0026a, const BigInteger \u0026b) { int n1 = a.length; int n2 = b.length; if (n1 != n2)return n1 \u003e n2; //返回a和b哪个大，true则位a大 int i = 0; while (i \u003c n1 \u0026\u0026 a.nums[i] == b.nums[i])i++; //a b一样长的情况下，比较两个的值 if (i == n1) return false; return a.nums[i] \u003e b.nums[i]; } bool BigInteger::isEqual(BigInteger \u0026a, BigInteger \u0026b) { if (a.f != b.f || (a.length != b.length))return false; int i = 0; while (i \u003c a.length \u0026\u0026 a.nums[i] == b.nums[i])i++; return i == a.length \u0026\u0026 a.f == b.f; } BigInteger BigInteger::add(BigInteger \u0026a, BigInteger \u0026b) { a.reverse();//尾端对齐 b.reverse(); BigInteger t; int up = 0; int len = a.length \u003e b.length ? a.length : b.length; for (int i = 0; i \u003c len; i++) { int ta = i \u003c a.length ? a[i] - '0' : 0; int tb = i \u003c b.length ? b[i] - '0' : 0; int base = ta + tb + up; t.push_back(base % 10 + '0'); up = base / 10; } if (up) t.push_back(up + '0'); t.reverse();//返回原位 a.reverse(); b.reverse(); return t; } BigInteger BigInteger::minus(BigInteger \u0026a, BigInteger \u0026b) { a.reverse(); b.reverse(); BigInteger t; int len = a.length \u003e b.length ? a.length : b.length; for (int i = 0; i \u003c len; i++) { int ta = i \u003c a.length ? a[i] - '0' : 0; int tb = i \u003c b.length ? b[i] - '0' : 0; int base = ta - tb; if (base \u003c 0) { base += 10; a[i + 1]--; } t.push_back(base + '0'); } t.reverse(); a.reverse(); b.reverse(); return t; } //@运算符重载实现 BigInteger \u0026BigInteger::operator=(const BigInteger \u0026a) { if (length != 0)//如果不是初始化调用的 = ，则肯定需要先把原来的内存delete掉 delete[]nums; capacity = a.capacity; length = a.length; f = a.f; nums = new char[capacity]; std::copy(a.nums, a.nums + length, nums); return *this; } BigInteger BigInteger::operator+(BigInteger \u0026a) { BigInteger res; bool flag; if (a.f \u0026\u0026 f) { //同为负数情况，直接相加，再改符号 res = add(*this, a); flag = true; } else if (a.f \u0026\u0026 !f) {//左正右负 if (compare(a, *this)) { //看负数对应的nums是否比正数大 flag = true; res = minus(a, *this); } else { flag = false; res = minus(*this, a); } } else if (!a.f \u0026\u0026 f) { if (compare(*this, a)) { //与上一个相同 flag = true; res = minus(*this, a); } else { flag = false; res = minus(a, *this); } } else { //同时为正数就是最简单的加法 flag = false; res = add(*this, a); } res.f = flag; return res; } BigInteger BigInteger::operator-(BigInteger \u0026a) { BigInteger res; bool flag; if (a.f \u0026\u0026 f) { //同为负数情况--左边-右边==(不看符号)右边-(不看符号)左边 if (compare(a, *this)) { flag = false; res = minus(a, *this); } else { if (isEqual(*this, a)) flag = false; else flag = true; res = minus(*this, a); } } else if (a.f \u0026\u0026 !f) { //左边为正，右边为负--左边-右边==左边+右边 flag = false; res = add(a, *this); } else if (!a.f \u0026\u0026 f) { //右边为正，左边为负--左边-右边==两边为负的加法 flag = true; res = add(a, *this); } else { //同时为正数--左边-右边==左边-右边(分类讨论正负 if (compare(a, *this)) { //右边\u003e左边,符号为负 res = minus(a, *this); flag = true; } else { //右边\u003c左边，符号为正 res = minus(*this, a); flag = false; } } res.f = flag; return res; } bool BigInteger::operator\u003c(const BigInteger \u0026a) const { if (f \u0026\u0026 !a.f) { //其中一个为负数，则那个是更小的 return true; } else if (!f \u0026\u0026 a.f) return false; if (f) { //两者都为负数的情况，左边的值要更大则为true return compare(*this, a); }//两者均为正数，则值更小的在左边为true return compare(a, *this); } //@基本成员函数 void BigInteger::reverse() { int l = 0, r = length - 1; while (l \u003c r) { std::swap(nums[l], nums[r]); l++","date":"2022-01-20","objectID":"/posts/%E5%A4%A7%E6%95%B4%E6%95%B0%E5%8A%A0%E5%87%8F/:3:2","tags":["C++类的封装"],"title":"大数加减类的实现(C++实现)✨","uri":"/posts/%E5%A4%A7%E6%95%B4%E6%95%B0%E5%8A%A0%E5%87%8F/"},{"categories":["C++实战"],"content":"功能测试 ","date":"2022-01-20","objectID":"/posts/%E5%A4%A7%E6%95%B4%E6%95%B0%E5%8A%A0%E5%87%8F/:4:0","tags":["C++类的封装"],"title":"大数加减类的实现(C++实现)✨","uri":"/posts/%E5%A4%A7%E6%95%B4%E6%95%B0%E5%8A%A0%E5%87%8F/"},{"categories":["C++实战"],"content":"一、基本的加减测试 运行的测试代码： 打印输出 python输出 总结 与python输出无异，故通过测试。但碍于测试数据太过少，不是很有说服力，还有后面的解题测试。 ","date":"2022-01-20","objectID":"/posts/%E5%A4%A7%E6%95%B4%E6%95%B0%E5%8A%A0%E5%87%8F/:4:1","tags":["C++类的封装"],"title":"大数加减类的实现(C++实现)✨","uri":"/posts/%E5%A4%A7%E6%95%B4%E6%95%B0%E5%8A%A0%E5%87%8F/"},{"categories":["C++实战"],"content":"二、存储个人输入的数据+排序测试 测试代码(方便测试只输入了10个数据)： 排序输出： ","date":"2022-01-20","objectID":"/posts/%E5%A4%A7%E6%95%B4%E6%95%B0%E5%8A%A0%E5%87%8F/:4:2","tags":["C++类的封装"],"title":"大数加减类的实现(C++实现)✨","uri":"/posts/%E5%A4%A7%E6%95%B4%E6%95%B0%E5%8A%A0%E5%87%8F/"},{"categories":["C++实战"],"content":"三、解题测试 正好最近刷的PAT甲级就涉及到大数的加减hhh！ 题目描述 OJ平台 解题代码 #include \"bits/stdc++.h\" class BigInteger { bool f; char *nums; int length; int capacity; public://构造函数 BigInteger() : length(0), capacity(1), f(false) { //缺省构造函数 nums = new char[capacity]; } BigInteger(const char *n) : length(strlen(n)), f(false) { //用于初始值的构造函数 int start = 0; if (n[0] == '-') { f = true; start++; } while (start \u003c length \u0026\u0026 n[start] == '0')start++; capacity = length * 10; nums = new char[capacity]; std::copy(n + start, n + length, nums); length = length - start; } BigInteger(const BigInteger \u0026a) { //拷贝构造函数 capacity = a.capacity; length = a.length; f = a.f; nums = new char[capacity]; std::copy(a.nums, a.nums + length, nums); } BigInteger(BigInteger \u0026\u0026a) : length(0) { //移动构造函数 *this = a; } ~BigInteger() { //析构函数 delete[] nums; } public://静态成员函数 static void Swap(BigInteger \u0026a, BigInteger \u0026b) { std::swap(a.length, b.length); std::swap(a.capacity, b.capacity); std::swap(a.f, b.f); std::swap(a.nums, b.nums); } static bool compare(const BigInteger \u0026a, const BigInteger \u0026b) { //比较纯nums大小(不看符号 int n1 = a.length; int n2 = b.length; if (n1 != n2)return n1 \u003e n2; //返回a和b哪个大，true则位a大 int i = 0; while (i \u003c n1 \u0026\u0026 a.nums[i] == b.nums[i])i++; //a b一样长的情况下，比较两个的值 if (i == n1) return false; return a.nums[i] \u003e b.nums[i]; } bool isEqual(BigInteger \u0026a, BigInteger \u0026b) { if (a.f != b.f || (a.length != b.length))return false; int i = 0; while (i \u003c a.length \u0026\u0026 a.nums[i] == b.nums[i])i++; return i == a.length \u0026\u0026 a.f == b.f; } static BigInteger add(BigInteger \u0026a, BigInteger \u0026b) { //不看符号的加法 a.reverse();//尾端对齐 b.reverse(); BigInteger t; int up = 0; int len = a.length \u003e b.length ? a.length : b.length; for (int i = 0; i \u003c len; i++) { int ta = i \u003c a.length ? a[i] - '0' : 0; int tb = i \u003c b.length ? b[i] - '0' : 0; int base = ta + tb + up; t.push_back(base % 10 + '0'); up = base / 10; } if (up) t.push_back(up + '0'); t.reverse();//返回原位 a.reverse(); b.reverse(); return t; } static BigInteger minus(BigInteger \u0026a, BigInteger \u0026b) { //不看符号的减法,默认了a的长度或者大小是比b要大的(所以外界不要乱调用 a.reverse(); b.reverse(); BigInteger t; int len = a.length \u003e b.length ? a.length : b.length; for (int i = 0; i \u003c len; i++) { int ta = i \u003c a.length ? a[i] - '0' : 0; int tb = i \u003c b.length ? b[i] - '0' : 0; int base = ta - tb; if (base \u003c 0) { base += 10; a[i + 1]--; } t.push_back(base + '0'); } t.reverse(); a.reverse(); b.reverse(); return t; } public://成员函数和重载运算符 char \u0026operator[](int i) { return nums[i]; } BigInteger \u0026operator=(BigInteger \u0026\u0026a) { //Swap\u0026Copy方式实现右值赋值重载 Swap(*this, a); return *this; } BigInteger \u0026operator=(const BigInteger \u0026a) {//深拷贝 if (length != 0)//如果不是初始化调用的 = ，则肯定需要先把原来的内存delete掉 delete[]nums; capacity = a.capacity; length = a.length; f = a.f; nums = new char[capacity]; std::copy(a.nums, a.nums + length, nums); return *this; } int getCap() { return capacity; } int getLength() { return length; } bool isNegative() { return f; } bool isEmpty() { return length == 0; } void reverse() { int l = 0, r = length - 1; while (l \u003c r) { std::swap(nums[l], nums[r]); l++; r--; } } void push_back(char x) { if (length \u003e= capacity) { capacity *= 2; char *t = nums; nums = new char[capacity]; std::copy(t, t + length, nums); delete[]t; } nums[length++] = x; } bool operator\u003c(const BigInteger \u0026a) const { if (f \u0026\u0026 !a.f) { //其中一个为负数，则那个是更小的 return true; } else if (!f \u0026\u0026 a.f) return false; if (f) { //两者都为负数的情况，左边的值要更大则为true return compare(*this, a); }//两者均为正数，则值更小的在左边为true return compare(a, *this); } BigInteger operator+(BigInteger \u0026a) { BigInteger res; bool flag; if (a.f \u0026\u0026 f) { //同为负数情况，直接相加，再改符号 res = add(*this, a); flag = true; } else if (a.f \u0026\u0026 !f) {//左正右负 if (compare(a, *this)) { //看负数对应的nums是否比正数大 flag = true; res = minus(a, *this); } else { flag = false; res = minus(*this, a); } } else if (!a.f \u0026\u0026 f) { if (compare(*this, a)) { //与上一个相同 flag = true; res = minus(*this, a); } else { flag = false; res = minus(a, *this); } } else { //同时为正数就是最简单的加法 flag = false; res = add(*this, a); } res.f = flag; return res; } BigInteger operator-(BigInteger \u0026a","date":"2022-01-20","objectID":"/posts/%E5%A4%A7%E6%95%B4%E6%95%B0%E5%8A%A0%E5%87%8F/:4:3","tags":["C++类的封装"],"title":"大数加减类的实现(C++实现)✨","uri":"/posts/%E5%A4%A7%E6%95%B4%E6%95%B0%E5%8A%A0%E5%87%8F/"},{"categories":["C++实战"],"content":"总结 很多人，可能觉得做项目一定得是那种高大上，又或者是那种贪吃蛇小游戏、扫雷小游戏类型，实际上只要你有兴趣，任何一个东西都能成为你的练手项目，并且收获收获也许比你跟风去弄几个小游戏更大。 做这个小项目，我的收获是，对C++的语法更加的了解了，关于移动构造器、拷贝构造器、赋值重载这块弄得更清楚了，最大的收获在于强化了一个类的设计思路，这个是最重要的。 多写一些类的实现，不仅有利于对算法和语言语法的理解，更大的收获在于对各个功能的设计思路，作为程序员，我们最需要的就是这样的逻辑思维，从接到需求开始，我们应该能迅速的抽象出各种实现方案，然后进行不断的优化，得出属于自己的代码！ ","date":"2022-01-20","objectID":"/posts/%E5%A4%A7%E6%95%B4%E6%95%B0%E5%8A%A0%E5%87%8F/:5:0","tags":["C++类的封装"],"title":"大数加减类的实现(C++实现)✨","uri":"/posts/%E5%A4%A7%E6%95%B4%E6%95%B0%E5%8A%A0%E5%87%8F/"},{"categories":["C++实战"],"content":"矩阵快速幂的C++封装","date":"2022-01-20","objectID":"/posts/%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82%E7%9A%84c++%E5%B0%81%E8%A3%85/","tags":["矩阵快速幂"],"title":"矩阵快速幂的C++封装","uri":"/posts/%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82%E7%9A%84c++%E5%B0%81%E8%A3%85/"},{"categories":["C++实战"],"content":"实现源码在线查看 如果对于类的设计已经非常清楚，只是进来想看看我的这个泛型模板源代码，那么直接点到下面这个链接进行查看： 源码链接 ","date":"2022-01-20","objectID":"/posts/%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82%E7%9A%84c++%E5%B0%81%E8%A3%85/:0:0","tags":["矩阵快速幂"],"title":"矩阵快速幂的C++封装","uri":"/posts/%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82%E7%9A%84c++%E5%B0%81%E8%A3%85/"},{"categories":["C++实战"],"content":"什么是矩阵快速幂？ 关于快速幂，就是利用二进制进行求解某个数的幂的快速方法。 后面会对快速幂的原理进行简单讲解，如果还是不懂，请自行百度。 相信有很多小伙伴是初入大学的世界，可能还没学过线性代数（比如我），于是乎不知道矩阵是什么，我推荐一个网站去看看矩阵的乘法是怎么运算的，下面是网站链接：（话说how to这个网站还真是牛批，什么东西都有教程，而且质量还贼高！😂） 矩阵乘法的计算方式 那么如何用代码表示矩阵以及他的乘法呢？ 其实很简单，就是三层循环进行控制即可。 如：我这里是C++的重载运算符 Matrix 是我定义的一个类。 Matrix\u0026 operator*(Matrix\u0026 b){ assert(b.date!=NULL \u0026\u0026 date!=NULL \u0026\u0026 m==b.n); ll tmp[n][b.m]; for(int i=0;i\u003cn;i++){ for(int j=0;j\u003cb.m;j++){ ll sum = 0; for(int k=0;k\u003cm;k++){ sum = (sum + date[i][k]*b.date[k][j])%MOD; } tmp[i][j] = sum; } } this-\u003em = b.m; for(int i=0;i\u003cn;i++){ for (int j = 0; j \u003c m; ++j) { date[i][j] = tmp[i][j]; } } return *this; } ","date":"2022-01-20","objectID":"/posts/%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82%E7%9A%84c++%E5%B0%81%E8%A3%85/:1:0","tags":["矩阵快速幂"],"title":"矩阵快速幂的C++封装","uri":"/posts/%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82%E7%9A%84c++%E5%B0%81%E8%A3%85/"},{"categories":["C++实战"],"content":"怎么进行矩阵快速幂的运算？ 关于如何矩阵快速幂，我们先了解一下简单的快速幂。 说是快速幂就是通过位运算实现快速的同数累乘。 简述一下快速幂的原理： 原理就是，如果要求x的3次幂，那么可以转化为求 x*x 的 2 次幂，而求一个数的 2^n 幂是很简单的，比如进行一次 x *= x 便得到 x 的二次方。而再进行一次 x *= x 就得到了 4 次方，继续便可得到 8/16... 总之是 log2N 的时间。 代码如下： int QuickPow(int x,int n){ int c = n; int res = 1; while(c!=0){ if(c\u00261!=0){ res *= x; } c \u003e\u003e= 1; x *= x; } return res; } 那么矩阵的快速幂如何进行？ 把上述的 int 类型换成自己定义的矩阵就是矩阵的快速幂了。 我直接贴上C++实现的重载运算符后的类的快速幂写法： 这里的quickPow表示的是一个类的成员函数，所以可以直接用到这个矩阵里的数据进行运算。this表示指向这个对象的指针。init() 成员函数表示初始化为单位矩阵。 void quickPow(ll c){ if(c==1||c\u003c0)return; if(c==0){ init(); return; } Matrix tmp(*this); init(); while (c){ if(c\u00261){ *this = *this * tmp; } c \u003e\u003e= 1; tmp = tmp*tmp; } } ","date":"2022-01-20","objectID":"/posts/%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82%E7%9A%84c++%E5%B0%81%E8%A3%85/:1:1","tags":["矩阵快速幂"],"title":"矩阵快速幂的C++封装","uri":"/posts/%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82%E7%9A%84c++%E5%B0%81%E8%A3%85/"},{"categories":["C++实战"],"content":"为什么突然想写这个模板？ 主要是因为最近做了几道快速幂的题目，被坑的很惨，然后就突然想设计一个模板了，主要是 my_tiny_stl 这个仓库也好久没更新了😂 ","date":"2022-01-20","objectID":"/posts/%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82%E7%9A%84c++%E5%B0%81%E8%A3%85/:2:0","tags":["矩阵快速幂"],"title":"矩阵快速幂的C++封装","uri":"/posts/%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82%E7%9A%84c++%E5%B0%81%E8%A3%85/"},{"categories":["C++实战"],"content":"题目 OJ网站 ","date":"2022-01-20","objectID":"/posts/%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82%E7%9A%84c++%E5%B0%81%E8%A3%85/:2:1","tags":["矩阵快速幂"],"title":"矩阵快速幂的C++封装","uri":"/posts/%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82%E7%9A%84c++%E5%B0%81%E8%A3%85/"},{"categories":["C++实战"],"content":"我是如何被坑的 首先拿到这道题，我便马上开始简单的O(n)递推法实现，然后提交，然后。。超时。。 定眼一看，数据量原来这么大！ 后面一想，肯定是矩阵快速幂了，先想出以下矩阵的递推式子： 进而题目便可得到求解。 然后我就利用 C++ 的类简单的封装了一个矩阵类，里面重载了乘法和 quickpow 方法，然后比较悠闲的准备提交，还没提交前就遇到C++的语法陷阱、、 语法陷阱（建议非C++党绕道） 由于类用的都是堆内存，所以我写了析构函数，我遇到的问题出在重载乘法时我返回的是左值，而且我也没有对 ‘=’ 进行重载，所以 ‘=’ 就是直接的成员变量拷贝，这导致一个结果就是两个对象的 date 指向同一片内存空间，而之前的那片内存空间泄露了，且最后这两个对象肯定都会调用析构函数，这又导致了析构函数调用了两次！ 如何解决这个问题？如果是 C++98 ，那么这个问题很大，基本上就是两种方法解决： 逃避问题，乘法的左操作数必须是当前赋值对象，这样就避免了最后赋值语句将原本对象内的指针直接改变。 解决问题，解决这类问题无论是 C++11 还是 C++98 最直接的方式就是重载 ‘=’ 号，重载 '=' 号的实现根据具体的情况进行，而具体实现赋值的重载，我们需要考虑两件事：第一，需尽可能的减少内存的申请和使用（具体而言就是判断两个对象的指针所指向的是否为同一片空间，即便不是同一片空间，为了增加空间利用率还可以判断两个空间是否大小一致，然后进行拷贝即可）。第二，如果是临时对象则需要把它的指针置空（防止编译器未优化临时变量的析构函数，从而调用了析构函数多次析构同一内存）。 由于 C++11 开始有了右值引用和它配套的移动赋值构造器，所以可以把临时变量直接调用移动构造器变成具名对象，然后进行操作，一般就是把它的指针所有权进行转移，然后把它的指针置空防止析构错误，在我的理解下，右值引用的出现就是为了捕捉到匿名对象然后给程序员进行适当的性能优化操作，没有右值引用前，匿名对象的内存根本就没法去使用，只能用来简单的赋值拷贝操作后才能使用，这样就很消耗内存了，右值引用出现后，我们可以通过右值引用对匿名对象进行捕捉，然后操作它的底层内存。还有一个很大的内存相关的更新就是有了一个 nullptr 关键字，这个关键字使得空指针不再会有歧义，所以 delete nullptr 是安全的。所以防止多次 delete 同一片空间产生错误可以将它赋值为 nullptr 即可。 那么基于 C++11 这个问题该如何解决呢？解决方法和C++98没差，就是能够更加得心应手的进行内存的管理了，如果等号右边是一个右值，那么它肯定是一个临时对象，所以我们可以在 ‘=’ 号的重载中直接了当的用它的内存，并把它的指针置空。如果没有右值类型进行捕获，编译器默认也是会对临时对象进行优化的，也能防止产生多个对象的赋值拷贝，但只能在对象初始化的时候进行优化！而在其他时候则还是会调用析构函数，这个时候如果还是用编译器默认产生的 ‘=’ 重载，则会发生被析构的空间的指针被赋值的情况，而我们的右值引用版本的赋值重载便是针对此现象的。这样便于内存管理，将右值和左值进行分开处理。右值是临时变量只需要用一会儿，所以可以直接把它的内存拿过来继续用，也不会对程序逻辑造成影响，而左值则不一样，它还需要存活很长一段时间，所以我们需要另创空间进行拷贝。 特别提醒：如果是做算法题，则完全不用去考虑内存的管理，析构函数也不要去写，毕竟只需要单次调用使用，对象最多也就存在一会儿。 做题陷阱 在必要的时候千万不要舍不得开long long！！！！ 这道题的数据量无论是幂的次方还是整个记录过程的数据都要开long long！！！ 我被这个陷阱坑了无数回了，这一次也不另外😅 开始写完这种之后过了前5个，然后后面5个报错，我还以为我设计的这个类有问题，还特意去写了好几个普通C语言版本😂最后发现原来的没开long long。以下为更改long long后的代码通过版本，我用宏定义写了几个版本。。。 这个Matrix类的设计还是很多地方没有考虑到位，比如上一个陷阱的问题只是通过方法一得到解决，并未去重载赋值操作符。。。所以后面痛定思痛，设计一个较为可用的Matrix类！ 效率时快时慢的，这主要取决于编译器是否进行优化。 // // Created by Alone on 2021/11/19. // #include \u003cbits/stdc++.h\u003eusing namespace std; //#define ELSE_MAIN #define MY_MAIN #define MAT #ifdef MAT typedef long long ll; class Matrix{ ll** date; int m; int n; public: static const int MOD; public: Matrix(ll** rec,int n,int m):date(rec),n(n),m(m){}//C风格的初始化 Matrix():date(NULL),m(0),n(0){} //缺省 Matrix(Matrix\u0026 b):n(b.n),m(b.m){//拷贝构造 assert(b.date!=NULL \u0026\u0026 b.n\u003e0 \u0026\u0026 b.m\u003e0); date = new ll*[n]; copy(b.date,b.date+n,date); for(int i=0;i\u003cn;i++){ date[i] = new ll[m]; copy(b.date[i],b.date[i]+m,date[i]); } } ~Matrix(){//析构函数实现 assert(date!=NULL \u0026\u0026 n\u003e0 \u0026\u0026 m\u003e0); for (int i = n-1; i \u003e=0 ; --i) { delete [] date[i]; } delete[] date; } Matrix\u0026 operator*(Matrix\u0026 b){ assert(b.date!=NULL \u0026\u0026 date!=NULL \u0026\u0026 m==b.n); ll tmp[n][b.m]; for(int i=0;i\u003cn;i++){ for(int j=0;j\u003cb.m;j++){ ll sum = 0; for(int k=0;k\u003cm;k++){ sum = (sum + date[i][k]*b.date[k][j])%MOD; } tmp[i][j] = sum; } } this-\u003em = b.m; for(int i=0;i\u003cn;i++){ for (int j = 0; j \u003c m; ++j) { date[i][j] = tmp[i][j]; } } return *this; } void init(){//重新初始化为单位矩阵 assert(date!=NULL \u0026\u0026 n\u003e0 \u0026\u0026 m\u003e0); for (int i = 0; i \u003c n; ++i) { for (int j = 0; j \u003c m; ++j) { if(i==j)date[i][j] = 1; else date[i][j] = 0; } } } void quickPow(ll c){ if(c==1||c\u003c0)return; if(c==0){ init(); return; } Matrix tmp(*this); init(); while (c){ if(c\u00261){ *this = *this * tmp; } c \u003e\u003e= 1; tmp = tmp*tmp; } } void print(){ for(int i=0;i\u003cn;i++){ for(int j=0;j\u003cm;j++){ cout\u003c\u003cdate[i][j]\u003c\u003c' '; } cout\u003c\u003cendl; } } int get(int x,int y){ assert(date!=NULL \u0026\u0026 x\u003cn \u0026\u0026 y\u003cm); return date[x][y]; } }; const int Matrix::MOD = 1e9+7; #endif #ifdef MY_MAIN int main(){ ll c; cin\u003e\u003ec; ll** matrix = new ll*[2]; matrix[0] = new ll[2]{1,1}; matrix[1] = new ll[2]{1,0}; Matrix mat(matrix,2,2); mat.quickPow(c-1); //mat.print(); ll** res = new ll*[2]; res[0] = new ll[1]; res[1] = new ll[1]; res[0][0] = res[1][0] = 1; Matrix fib(res,2,1); //这里有个内存分配错误，mat*fib返回的是左值，而=没有重载默认直接赋值成员变量。 //直接导致了fib失去了之前的变量所有权，和mat共同有一个内存空间，这样导致同一片空间被free两次 //通过重载 = 号解决，防止直接的内存没有被释放就重新绑定同一片内存 Matrix ret(mat*fib); cout\u003c\u003cret.get(0,0); return 0; } #endif #ifdef TEST_MAIN typedef long long ll ; const int MOD = 1e9+7; ll a[2][2]{{1,1},{1,0}};ll b[2]{1,1}; void selfMut(){ ll tmp[2][2]; for(int i=0;i\u003c2;i","date":"2022-01-20","objectID":"/posts/%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82%E7%9A%84c++%E5%B0%81%E8%A3%85/:2:2","tags":["矩阵快速幂"],"title":"矩阵快速幂的C++封装","uri":"/posts/%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82%E7%9A%84c++%E5%B0%81%E8%A3%85/"},{"categories":["C++实战"],"content":"教你设计Matrix类 ","date":"2022-01-20","objectID":"/posts/%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82%E7%9A%84c++%E5%B0%81%E8%A3%85/:3:0","tags":["矩阵快速幂"],"title":"矩阵快速幂的C++封装","uri":"/posts/%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82%E7%9A%84c++%E5%B0%81%E8%A3%85/"},{"categories":["C++实战"],"content":"如何设计一个类？ 结构： 内部数据抽象：对象的运算数据存储 用二级指针 date 进行矩阵的二维空间的内存管理，以及n和m表示矩阵的行高和列宽。 行为抽象：对对象的行为描述 构造函数（缺省、自定义、拷贝、移动） 和 析构函数（调用destory成员函数）。 setter 和 getter。提供函数接口去设置和得到数据。 功能函数：比如重载的乘法运算符和快速幂函数这些都算功能函数。 对象的属性抽象： 数据和行为是否对外，对外封装数据的意义在于防止对对象行为描述的破坏，而对外开放的某个行为通常需要内部多个函数进行重复调用来实现。这个时候需要用到 public 和 private 关键字进行修饰。 数据和行为是否可继承，对于某些行为（函数），我们不想被外部调用，但是对子类又很有用，这个时候我们可以采取 protect 关键字进行修饰。 数据和行为是否能重复利用，为了节省不必要的内存开销，可以设计不需要产生具体对象的通用型函数，可以使用 static 关键字进行修饰，这样可以避免我想使用某个函数前还得去申请一片毫不相关的内存空间，而对于某个对象的数据也可以采用 static 进行修饰，这样一来，这个数据在对象的创建过程中就不需要再进行申请和赋值了。 那么接下来就来确定行为（函数）的属性了，数据肯定是不对外开放的（private），否则面向对象将毫无意义。 构造函数 和 析构函数，这两个是对象的创建和销毁的关键，所以如果不是希望对象不被创建或者是不被销毁，都应该使用 public 修饰。 setter 和 getter。很明显是对外开放的接口函数，所以肯定也是 public 修饰。 功能函数：矩阵快速幂的函数，很明显我们希望设置一个对外通用的情况，那么这个时候就应该不需要创建对象便可进行调用，所以最好用 static 进行修饰（这个一般为外部通用接口，内部还需实现一个方便类调用的版本，这也很简单，直接传参调用该函数即可），重载的乘法肯定也是对外的所以需要 public 修饰，destroy 函数用于处理内存的回收，很明显这是一个内部通用的函数，但是外界完全是不需要它的！所以把它设置为 private 属性即可。 以上便是对整个类的设计思路，当然真正动手设计的时候，还需要具体到函数的参数和返回值类型，因为这牵扯到 C++ 的具体语法了，比如我应该在重载乘法的时候返回一个什么样的类型？最好是返回一个右值！而重载赋值运算符则最好是返回一个左值。一般需要考虑返回值类型的取舍时，最难的就是如果返回一个对象，我该返回左值还是右值。 写了这么久C++，我感觉用C++写的Java屏蔽重载运算符的特性主要就是重载运算符时需要考虑的过程太多了，C++菜鸡（我就是这个菜鸟😂）写出及其低效且不安全的代码，而只有老鸟才能写出优雅高效的代码。 ","date":"2022-01-20","objectID":"/posts/%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82%E7%9A%84c++%E5%B0%81%E8%A3%85/:3:1","tags":["矩阵快速幂"],"title":"矩阵快速幂的C++封装","uri":"/posts/%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82%E7%9A%84c++%E5%B0%81%E8%A3%85/"},{"categories":["C++实战"],"content":"类的具体抽象结构（代码的具体规划图） 按照属性对类的各个部分进行分类的，毕竟属性也基本就代表了这个方法的使用场景了。 最后可以利用基本的断言或者异常，让代码变得更为健壮，使得更容易定位错误发生的位置和原因。 ","date":"2022-01-20","objectID":"/posts/%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82%E7%9A%84c++%E5%B0%81%E8%A3%85/:3:2","tags":["矩阵快速幂"],"title":"矩阵快速幂的C++封装","uri":"/posts/%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82%E7%9A%84c++%E5%B0%81%E8%A3%85/"},{"categories":["C++实战"],"content":"实现矩阵泛型模板类 源代码实现 我先是画出规划图进行实现，然后在实现的过程中，发现可以新增一些特性，比如重载下标运算符，比如用print函数打印出来方便验证。 具体实现过程，为了方便简单的定位可能发生的错误，使用了大量的assert进行断言检查。如果想代码的健壮性更强，可以使用抛出异常的方式。 源代码对应的GitHub仓库地址：仓库链接，还有更多模板的实现，包括少量STL 更好的源码阅读体验：源码在线阅读 直接阅读下面的代码有点不太好查看，推荐去上面的GitHub1s里面查看源码。 // // Created by L_B__ on 2021/11/20. // #ifndef LQTEST_MATRIX_H #define LQTEST_MATRIX_H #include \u003ccassert\u003e#include \u003calgorithm\u003e#include \u003ciostream\u003e #define _MOD template\u003ctypename T\u003e class Matrix { /*Type define*/ typedef T data_t; typedef int ssize_t; /*data source*/ data_t **data; ssize_t n; ssize_t m; public: static const data_t MOD; public: /*default construct*/ Matrix() : m(0), n(0), data(nullptr) {} /*custom construct*/ Matrix(data_t **mat, ssize_t n, ssize_t m) : data(mat), n(n), m(m) {}//外部申请内存传入内部 Matrix(ssize_t n, ssize_t m) : data(nullptr), n(n), m(m) {//外部指定矩阵的行和列即可，内存初始化在内部进行 assert(n \u003e 0 \u0026\u0026 m \u003e 0); data = new data_t *[n]; for (int i = 0; i \u003c n; i++) { data[i] = new data_t[m]; } init(data, n, m); } /*copy construct*/ Matrix(Matrix \u0026src) : data(nullptr), n(src.n), m(src.m)//也可用const \u0026引用类型，但这样很多右值的情况都不会调用移动构造了 { assert(n \u003e 0 \u0026\u0026 m \u003e 0); data = new data_t *[n]; for (int i = 0; i \u003c n; ++i) { data[i] = new data_t[m]; std::copy(src.data[i], src.data[i] + m, data[i]); } } /*move construct*/ Matrix(Matrix\u003cdata_t\u003e \u0026\u0026src) : n(src.n), m(src.m), data(nullptr) { assert(src.data != nullptr \u0026\u0026 n \u003e 0 \u0026\u0026 m \u003e 0); data = src.data; src.data = nullptr; src.n = src.m = 0; } /*destruct*/ ~Matrix() { destroy(); } /*overload*/ //加上MOD的特殊版本 #ifdef _MOD Matrix operator*(const Matrix\u003cdata_t\u003e \u0026src)//建议返回右值，返回左值的后续坑比较多，参数const \u0026既可以接受左值也可接受右值 { assert(data != nullptr \u0026\u0026 src.data != nullptr \u0026\u0026 m == src.n \u0026\u0026 m \u003e 0 \u0026\u0026 n \u003e 0 \u0026\u0026 src.m \u003e 0);//进行矩阵乘法的必要条件 data_t **tmp = new data_t *[n]; //为tmp申请动态内存，因为是传出参数 for (int i = 0; i \u003c n; ++i) { tmp[i] = new data_t[m]; } for (int i = 0; i \u003c n; ++i)//开始更新tmp { for (int j = 0; j \u003c src.m; ++j) { data_t sum = 0; for (int k = 0; k \u003c m; ++k) { sum = (sum + data[i][k] * src.data[k][j]) % MOD; } tmp[i][j] = sum; } } //直接构造匿名对象返回 return Matrix(tmp, n, src.m);; } Matrix \u0026operator*=(const Matrix\u003cdata_t\u003e \u0026src)//*= 想一想我们平时的使用，就是返回一个左值 { assert(data != nullptr \u0026\u0026 src.data != nullptr \u0026\u0026 m == src.n \u0026\u0026 m \u003e 0 \u0026\u0026 n \u003e 0 \u0026\u0026 src.m \u003e 0);//进行矩阵乘法的必要条件 data_t tmp[n][src.m];//静态内存就行，毕竟只是临时存数据的 for (int i = 0; i \u003c n; ++i)//开始更新tmp { for (int j = 0; j \u003c src.m; ++j) { data_t sum = 0; for (int k = 0; k \u003c m; ++k) { sum = (sum + data[i][k] * src.data[k][j]) % MOD; } tmp[i][j] = sum; } } //由于此时的date内存可能不够容下tmp数据，所以可能需要重新进行内存申请 //注意重新申请列内存的时候，需要把之前的内存释放 if (m != src.m) { for (int i = 0; i \u003c n; ++i) { delete[]data[i]; data[i] = nullptr; data[i] = new data_t[src.m]; } } for (int i = 0; i \u003c n; ++i) { assert(data[i] != nullptr); std::copy(tmp[i], tmp[i] + src.m, data[i]); } return *this; } #endif #ifndef _MOD Matrix operator*(const Matrix\u003cdata_t\u003e\u0026src)//建议返回右值，返回左值的后续坑比较多，参数const \u0026既可以接受左值也可接受右值 { assert(data!= nullptr\u0026\u0026src.data!= nullptr\u0026\u0026m==src.n\u0026\u0026m\u003e0\u0026\u0026n\u003e0\u0026\u0026src.m\u003e0);//进行矩阵乘法的必要条件 data_t** tmp = new data_t *[n]; //为tmp申请动态内存，因为是传出参数 for (int i = 0; i \u003c n; ++i) { tmp[i] = new data_t [m]; } for(int i=0;i\u003cn;++i)//开始更新tmp { for (int j = 0; j \u003c src.m; ++j) { data_t sum = 0; for (int k = 0; k \u003c m; ++k) { sum = sum + data[i][k]*src.data[k][j]; } tmp[i][j] = sum; } } //直接构造匿名对象返回 return Matrix (tmp,n,src.m); } /*与乘法的唯一区别在于乘法是构造一个新的对象，而*=返回的是this*/ Matrix \u0026operator*=(const Matrix\u003cdata_t\u003e \u0026src)//*= 想一想我们平时的使用，就是返回一个左值 { assert(data!= nullptr\u0026\u0026src.data!= nullptr\u0026\u0026m==src.n\u0026\u0026m\u003e0\u0026\u0026n\u003e0\u0026\u0026src.m\u003e0);//进行矩阵乘法的必要条件 data_t tmp[n][src.m];//静态内存就行，毕竟只是临时存数据的 for(int i=0;i\u003cn;++i)//开始更新tmp { for (int j = 0; j \u003c src.m; ++j) { data_t sum = 0; for (int k = 0; k \u003c m; ++k) { sum = sum + data[i][k]*src.data[k][j]; } tmp[i][j] = sum; } } //由于此时的date内存可能不够容下tmp数据，所以可能需要重新进行内存申请 //注意重新申请列内存的时候，需要把之前的内存释放 if(m!=src.m){ for (int i = 0; i \u003c n; ++i) { delete []data[i]; data[i] = nullptr; data[i] = new data_t [src.m]; } } for (int i = 0; i \u003c n; ++i) { assert(data[i] != nullptr); std::copy(tmp[i],tmp[i]+src.m,data[i]); } return *this; } #endif //赋值号的重载","date":"2022-01-20","objectID":"/posts/%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82%E7%9A%84c++%E5%B0%81%E8%A3%85/:3:3","tags":["矩阵快速幂"],"title":"矩阵快速幂的C++封装","uri":"/posts/%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82%E7%9A%84c++%E5%B0%81%E8%A3%85/"},{"categories":["C++实战"],"content":"总结 由于用的是 C++11 的语法进行实现的模板类，所以低于这个版本的编译器都无法正常使用。我查阅了相关资料，实际上蓝桥杯比赛的时候可以用 C++11，而acm更是不用说，早就能用C++11了。 简单复盘： 实现一个这样的类，主要能学到以下几点： 类的设计技巧。 对C++的左右值有了更深入的理解。 各种构造器的设计和实现已经达到炉火纯青的地步了。 ","date":"2022-01-20","objectID":"/posts/%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82%E7%9A%84c++%E5%B0%81%E8%A3%85/:4:0","tags":["矩阵快速幂"],"title":"矩阵快速幂的C++封装","uri":"/posts/%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82%E7%9A%84c++%E5%B0%81%E8%A3%85/"},{"categories":null,"content":"手写http协议解析库 ","date":"0001-01-01","objectID":"/posts/%E6%89%8B%E5%86%99http%E5%8D%8F%E8%AE%AE%E8%A7%A3%E6%9E%90%E5%99%A8/:0:0","tags":null,"title":"","uri":"/posts/%E6%89%8B%E5%86%99http%E5%8D%8F%E8%AE%AE%E8%A7%A3%E6%9E%90%E5%99%A8/"},{"categories":null,"content":"http协议的组成 http请求报文如下： http响应报文如下： ","date":"0001-01-01","objectID":"/posts/%E6%89%8B%E5%86%99http%E5%8D%8F%E8%AE%AE%E8%A7%A3%E6%9E%90%E5%99%A8/:1:0","tags":null,"title":"","uri":"/posts/%E6%89%8B%E5%86%99http%E5%8D%8F%E8%AE%AE%E8%A7%A3%E6%9E%90%E5%99%A8/"},{"categories":null,"content":"状态机设计 请求报文解析 响应报文解析 ","date":"0001-01-01","objectID":"/posts/%E6%89%8B%E5%86%99http%E5%8D%8F%E8%AE%AE%E8%A7%A3%E6%9E%90%E5%99%A8/:2:0","tags":null,"title":"","uri":"/posts/%E6%89%8B%E5%86%99http%E5%8D%8F%E8%AE%AE%E8%A7%A3%E6%9E%90%E5%99%A8/"},{"categories":null,"content":"代码结构设计 基础结构类：Response和Request，其中都包含一个Url类，用于解析得到路径和Query参数。 工具类：HttpParser，HttpParser用于解析纯http报文然后得到对应的Response或Request，组合成字符串信息只需要调用Request或者Response对应的to_string()方法。 ","date":"0001-01-01","objectID":"/posts/%E6%89%8B%E5%86%99http%E5%8D%8F%E8%AE%AE%E8%A7%A3%E6%9E%90%E5%99%A8/:3:0","tags":null,"title":"","uri":"/posts/%E6%89%8B%E5%86%99http%E5%8D%8F%E8%AE%AE%E8%A7%A3%E6%9E%90%E5%99%A8/"},{"categories":null,"content":"代码使用示例 对于head和body的设置均可通过直接调用head()和body()方法来设置，这个方法返回的是一个左值。 #include\"http-parser/Parser.h\" int main(){ http::Parser parser; auto req = parser.ToRequest(buffer); std::cout \u003c\u003c req.to_string(); //根据request内容获取对应的http报文 req.head()[\"dfasf\"] = \"fda\"; //随意设置request的header req.body() = \"fdsafsadf\"; //设置request的body部分 //request的特殊字段（GET的FORM和POST的form auto v = req.Query(\"test\"); //获取第一个值 auto v1 = req.PostQuery(\"test\"); //获取post表单里的第一个query值 req.PostMultiPart(\"test\"); //返回form-data的键值（可以传入文件 http::Response response; response.SetStatus(http::OK); response.SetContentType(http::ACCEPT_CONTENT_TYPE::T_JSON); response.SetConnection(false); response.body() = R\"({\"hello world!\":2323})\"; auto response_text = response.to_string(); } ","date":"0001-01-01","objectID":"/posts/%E6%89%8B%E5%86%99http%E5%8D%8F%E8%AE%AE%E8%A7%A3%E6%9E%90%E5%99%A8/:4:0","tags":null,"title":"","uri":"/posts/%E6%89%8B%E5%86%99http%E5%8D%8F%E8%AE%AE%E8%A7%A3%E6%9E%90%E5%99%A8/"}]