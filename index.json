[{"categories":["现代C++语法"],"content":"C++右值语义的基石——完美转发","date":"2022-02-04","objectID":"/posts/c++%E5%8F%B3%E5%80%BC%E8%AF%AD%E4%B9%89%E7%9A%84%E5%9F%BA%E7%9F%B3%E5%AE%8C%E7%BE%8E%E8%BD%AC%E5%8F%91/","tags":["C++右值语义的基石——完美转发"],"title":"C++右值语义的基石——完美转发","uri":"/posts/c++%E5%8F%B3%E5%80%BC%E8%AF%AD%E4%B9%89%E7%9A%84%E5%9F%BA%E7%9F%B3%E5%AE%8C%E7%BE%8E%E8%BD%AC%E5%8F%91/"},{"categories":["现代C++语法"],"content":"什么是完美转发？ 熟悉现代C++语法的都应该清楚，C++把变量分为左值和右值，为了实现对资源的转移而不是拷贝，右值和对应的移动构造函数应运而生，但我们发现，很多时候我们并不能把左值和右值精确的传递给对应版本的函数进行处理，比如下面一个简单的代码，你会发现即使我们把函数的参数类型设置为右值引用，但当拿它去调用对应的构造函数时，它给出的竟然是拷贝构造！故这个转发还不够完美！ #include\u003ciostream\u003eusing namespace std; class test{ public: test() = default; test(test\u0026\u0026 p){ cout\u003c\u003c\"move construct call\"\u003c\u003cendl; } test(const test\u0026 p){ cout\u003c\u003c\"copy construct call\"\u003c\u003cendl; } }; void test_fun(test\u0026\u0026 p){ test q(p); return; } int main() { test_fun(test()); return 0; } 为什么会出现这种情况呢？ 因为无论传入的形参是左值还是右值，对于函数内部来说，形参既有名称又能寻址，因此它都被认为是左值。 ","date":"2022-02-04","objectID":"/posts/c++%E5%8F%B3%E5%80%BC%E8%AF%AD%E4%B9%89%E7%9A%84%E5%9F%BA%E7%9F%B3%E5%AE%8C%E7%BE%8E%E8%BD%AC%E5%8F%91/:1:0","tags":["C++右值语义的基石——完美转发"],"title":"C++右值语义的基石——完美转发","uri":"/posts/c++%E5%8F%B3%E5%80%BC%E8%AF%AD%E4%B9%89%E7%9A%84%E5%9F%BA%E7%9F%B3%E5%AE%8C%E7%BE%8E%E8%BD%AC%E5%8F%91/"},{"categories":["现代C++语法"],"content":"如何实现完美转发？ 实现完美转发很简单，我们在现代C++中只需要 forward\u003cT\u003e 这个模板函数即可完成，其实际原理就是利用的 C++11 模板中提供的折叠引用的语法，最终达到的效果就是，把参数的类型强制转换为它该有的类型，是左值就转为左值，是右值就转为右值，从而实现该调用哪个版本的函数就调用哪个版本的函数，不再只被认定为右值了！ 先前的代码可以如此实现完美转发： #include\u003ciostream\u003eusing namespace std; class test{ public: test() = default; test(test\u0026\u0026 p){ cout\u003c\u003c\"move construct call\"\u003c\u003cendl; } test(const test\u0026 p){ cout\u003c\u003c\"copy construct call\"\u003c\u003cendl; } }; void test_fun(test\u0026\u0026 p){ test q(forward\u003ctest\u003e(p)); //修改的地方 return; } int main() { test_fun(test()); return 0; } ","date":"2022-02-04","objectID":"/posts/c++%E5%8F%B3%E5%80%BC%E8%AF%AD%E4%B9%89%E7%9A%84%E5%9F%BA%E7%9F%B3%E5%AE%8C%E7%BE%8E%E8%BD%AC%E5%8F%91/:2:0","tags":["C++右值语义的基石——完美转发"],"title":"C++右值语义的基石——完美转发","uri":"/posts/c++%E5%8F%B3%E5%80%BC%E8%AF%AD%E4%B9%89%E7%9A%84%E5%9F%BA%E7%9F%B3%E5%AE%8C%E7%BE%8E%E8%BD%AC%E5%8F%91/"},{"categories":["现代C++语法"],"content":"任何模板库都离不开完美转发 其实现在只要是C++的模板库，没有哪个是不用完美转发的，同时完美转发的问题也是产生自模板，而 forward 函数的实现其实也不是什么难事，实际就是利用 C++11 对模板提供的万能折叠语义： 当实参为左值或者左值引用（A\u0026）时，函数模板中 T\u0026\u0026 将转变为 A\u0026（A\u0026 \u0026\u0026 = A\u0026）； 当实参为右值或者右值引用（A\u0026\u0026）时，函数模板中 T\u0026\u0026 将转变为 A\u0026\u0026（A\u0026\u0026 \u0026\u0026 = A\u0026\u0026）。 以下为一个简单的利用完美转发设计的创建工厂： #include\u003ciostream\u003e#include \u003cmemory\u003e using namespace std; class test{ public: test() = default; test(int\u0026\u0026 arg):m_iData(arg){ cout\u003c\u003c\"move construct call\"\u003c\u003cendl; } test(const int\u0026 arg):m_iData(arg){ cout\u003c\u003c\"copy construct call\"\u003c\u003cendl; } private: int m_iData; }; template\u003ctypename T,typename Arg\u003e //不直接用T\u0026\u0026的原因在于，如果只使用一个模板参数会导致factory参数无法获得万能引用的效果 shared_ptr\u003cT\u003e factory(Arg\u0026\u0026 arg){ return shared_ptr\u003cT\u003e(new T(forward\u003cArg\u003e(arg)));//使用完美转发调用正确的构造函数 } int main() { int val = 5; auto p1 = factory\u003ctest\u003e(val); auto p2 = factory\u003ctest\u003e(5); return 0; } ","date":"2022-02-04","objectID":"/posts/c++%E5%8F%B3%E5%80%BC%E8%AF%AD%E4%B9%89%E7%9A%84%E5%9F%BA%E7%9F%B3%E5%AE%8C%E7%BE%8E%E8%BD%AC%E5%8F%91/:3:0","tags":["C++右值语义的基石——完美转发"],"title":"C++右值语义的基石——完美转发","uri":"/posts/c++%E5%8F%B3%E5%80%BC%E8%AF%AD%E4%B9%89%E7%9A%84%E5%9F%BA%E7%9F%B3%E5%AE%8C%E7%BE%8E%E8%BD%AC%E5%8F%91/"},{"categories":["现代C++语法"],"content":"std::forward的实现原理 gcc 的源代码实现如下： template\u003ctypename _Tp\u003e constexpr _Tp \u0026\u0026 forward(typename std::remove_reference\u003c_Tp\u003e::type \u0026__t) noexcept { return static_cast\u003c_Tp \u0026\u0026\u003e(__t); } template\u003ctypename _Tp\u003e constexpr _Tp \u0026\u0026 forward(typename std::remove_reference\u003c_Tp\u003e::type \u0026\u0026__t) noexcept { static_assert(!std::is_lvalue_reference\u003c_Tp\u003e::value, \"template argument\" \" substituting _Tp is an lvalue reference type\"); return static_cast\u003c_Tp \u0026\u0026\u003e(__t); } 我们发现，源代码中实现了两个模板特化，_Tp\u0026 和 _Tp\u0026\u0026 但最终都是通过 static_cast + 折叠引用的特性来实现强制转化的。也就是简单的强转而已！ ","date":"2022-02-04","objectID":"/posts/c++%E5%8F%B3%E5%80%BC%E8%AF%AD%E4%B9%89%E7%9A%84%E5%9F%BA%E7%9F%B3%E5%AE%8C%E7%BE%8E%E8%BD%AC%E5%8F%91/:4:0","tags":["C++右值语义的基石——完美转发"],"title":"C++右值语义的基石——完美转发","uri":"/posts/c++%E5%8F%B3%E5%80%BC%E8%AF%AD%E4%B9%89%E7%9A%84%E5%9F%BA%E7%9F%B3%E5%AE%8C%E7%BE%8E%E8%BD%AC%E5%8F%91/"},{"categories":["现代C++语法"],"content":"收获 在设计模板库的时候，如果需要根据左值右值语义比较清晰的实现转发，一定要用forward，否则参数只会被当作左值！ ","date":"2022-02-04","objectID":"/posts/c++%E5%8F%B3%E5%80%BC%E8%AF%AD%E4%B9%89%E7%9A%84%E5%9F%BA%E7%9F%B3%E5%AE%8C%E7%BE%8E%E8%BD%AC%E5%8F%91/:5:0","tags":["C++右值语义的基石——完美转发"],"title":"C++右值语义的基石——完美转发","uri":"/posts/c++%E5%8F%B3%E5%80%BC%E8%AF%AD%E4%B9%89%E7%9A%84%E5%9F%BA%E7%9F%B3%E5%AE%8C%E7%BE%8E%E8%BD%AC%E5%8F%91/"},{"categories":["算法——贪心"],"content":"leetcode每日一题——和为K的最少斐波那契数字数目","date":"2022-02-03","objectID":"/posts/leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E5%92%8C%E4%B8%BAk%E7%9A%84%E6%9C%80%E5%B0%91%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%AD%97%E6%95%B0%E7%9B%AE/","tags":["fib的贪心可行性"],"title":"leetcode每日一题——和为K的最少斐波那契数字数目","uri":"/posts/leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E5%92%8C%E4%B8%BAk%E7%9A%84%E6%9C%80%E5%B0%91%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%AD%97%E6%95%B0%E7%9B%AE/"},{"categories":["算法——贪心"],"content":"题目 题目链接 ","date":"2022-02-03","objectID":"/posts/leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E5%92%8C%E4%B8%BAk%E7%9A%84%E6%9C%80%E5%B0%91%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%AD%97%E6%95%B0%E7%9B%AE/:1:0","tags":["fib的贪心可行性"],"title":"leetcode每日一题——和为K的最少斐波那契数字数目","uri":"/posts/leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E5%92%8C%E4%B8%BAk%E7%9A%84%E6%9C%80%E5%B0%91%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%AD%97%E6%95%B0%E7%9B%AE/"},{"categories":["算法——贪心"],"content":"题目详解 我开始是想着构造好fib数组的值，然后用背包问题去解决它。可惜，直接超时了！ 后面直接用最简单的贪心方式没想到真的可行。。 然后看了题解才知道原来fib的「每次选择不超过当前 k 的最大数」这是一个特有的结论，然后大家都在证明他，虽然我看不懂，但我大受震撼😂 详解链接 ","date":"2022-02-03","objectID":"/posts/leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E5%92%8C%E4%B8%BAk%E7%9A%84%E6%9C%80%E5%B0%91%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%AD%97%E6%95%B0%E7%9B%AE/:2:0","tags":["fib的贪心可行性"],"title":"leetcode每日一题——和为K的最少斐波那契数字数目","uri":"/posts/leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E5%92%8C%E4%B8%BAk%E7%9A%84%E6%9C%80%E5%B0%91%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%AD%97%E6%95%B0%E7%9B%AE/"},{"categories":["算法——贪心"],"content":"解题代码 class Solution { public: int findMinFibonacciNumbers(int k) { vector\u003cint\u003eitems(2,1); int ret = 0; while(items.back()\u003ck){ items.push_back(items.back()+items[items.size()-2]); } for(int i=items.size()-1;i\u003e=0;i--){ ret += k/items[i]; k %= items[i]; } return ret; } }; ","date":"2022-02-03","objectID":"/posts/leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E5%92%8C%E4%B8%BAk%E7%9A%84%E6%9C%80%E5%B0%91%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%AD%97%E6%95%B0%E7%9B%AE/:3:0","tags":["fib的贪心可行性"],"title":"leetcode每日一题——和为K的最少斐波那契数字数目","uri":"/posts/leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E5%92%8C%E4%B8%BAk%E7%9A%84%E6%9C%80%E5%B0%91%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%AD%97%E6%95%B0%E7%9B%AE/"},{"categories":["算法——字符串"],"content":"字符串类型滑动窗口或递归分治解被ban字符求最长子串","date":"2022-02-01","objectID":"/posts/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B1%BB%E5%9E%8B%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%88%96%E9%80%92%E5%BD%92%E5%88%86%E6%B2%BB%E8%A7%A3%E8%A2%ABban%E5%AD%97%E7%AC%A6%E6%B1%82%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/","tags":["递归分治、滑动窗口、位运算"],"title":"字符串类型滑动窗口或递归分治解被ban字符求最长子串","uri":"/posts/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B1%BB%E5%9E%8B%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%88%96%E9%80%92%E5%BD%92%E5%88%86%E6%B2%BB%E8%A7%A3%E8%A2%ABban%E5%AD%97%E7%AC%A6%E6%B1%82%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/"},{"categories":["算法——字符串"],"content":"题目一：至少有 K 个重复字符的最长子串 395. 至少有 K 个重复字符的最长子串 ","date":"2022-02-01","objectID":"/posts/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B1%BB%E5%9E%8B%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%88%96%E9%80%92%E5%BD%92%E5%88%86%E6%B2%BB%E8%A7%A3%E8%A2%ABban%E5%AD%97%E7%AC%A6%E6%B1%82%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/:1:0","tags":["递归分治、滑动窗口、位运算"],"title":"字符串类型滑动窗口或递归分治解被ban字符求最长子串","uri":"/posts/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B1%BB%E5%9E%8B%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%88%96%E9%80%92%E5%BD%92%E5%88%86%E6%B2%BB%E8%A7%A3%E8%A2%ABban%E5%AD%97%E7%AC%A6%E6%B1%82%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/"},{"categories":["算法——字符串"],"content":"题目解析 有两种方法： 递归分治解决：该分治法的应用对象：解决那种不会去跨越任何一个段更新答案的题目。比如此题这种关于字符串子串的题。首先在整个字符串大范围内可以确定哪些字符没有达到k次，故只要存在这些字符的子串都被排除在外。具体到递归分治的代码上就是： 分治的每一段都不含上一个总字符串的被 ban (被禁)字符，故每个分治的对象都要进行以下几个步骤： 一、计算 [l,r] 之间所有字符的出现次数。 二、根据出现次数计算出被 ban 掉的字符类型。 三、根据是否有被 ban 的字符类型，来确定是否还需要再往下递归分治，如果没有被 ban 的字符类型，则该字符串就是一个符合条件的字符串。否则继续往下递归分治，分治的子对象都不能含有该被 ban 字符类型。 根据枚举类型的滑动窗口解决：按照字符类型的滑动窗口技巧，最外层用于枚举固定当前窗口内最多有多少类型。这个技巧就是，当我们无法直接找到滑动窗口的边界时，我们可以根据有限的类型来构造滑动窗口的边界，由于最多有26个类型的字符，而我们滑动窗口过程可以根据某个类型的字符数量是否符合条件来得到窗口内符合条件的类型数量，只要窗口内的类型数量等于符合条件的类型数量，那么该窗口内的字符串即为一个答案。但问题是，我们不清楚窗口内的类型数量是多大，这也就是我们没有明确的边界，此时我们根据枚举 1~26 个类型来进行窗口的滑动限制即可。 ","date":"2022-02-01","objectID":"/posts/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B1%BB%E5%9E%8B%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%88%96%E9%80%92%E5%BD%92%E5%88%86%E6%B2%BB%E8%A7%A3%E8%A2%ABban%E5%AD%97%E7%AC%A6%E6%B1%82%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/:1:1","tags":["递归分治、滑动窗口、位运算"],"title":"字符串类型滑动窗口或递归分治解被ban字符求最长子串","uri":"/posts/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B1%BB%E5%9E%8B%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%88%96%E9%80%92%E5%BD%92%E5%88%86%E6%B2%BB%E8%A7%A3%E8%A2%ABban%E5%AD%97%E7%AC%A6%E6%B1%82%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/"},{"categories":["算法——字符串"],"content":"解题代码 法一：递归分治 class Solution { public: int dfs(string\u0026 s,int l,int r,int k){ int cnt[26] = {0}; for(int i=l;i\u003c=r;i++){//计算字符的次数方便计算ban掉的字符类型 cnt[s[i]-'a']++; } char split = 0; for(int i=0;i\u003c26;i++){ if(cnt[i]!=0\u0026\u0026cnt[i]\u003ck){ //很明显在这个大范围内要是这个字符类型次数都小于k了，肯定就是要被ban的 split = i+'a'; break; } } if(split==0)//如果该段字符串没有被ban的字符类型则该字符串就是符合条件的字符串 return r-l+1; int ret = 0; //开始枚举分治到下面去 while(l\u003c=r){ while(l\u003c=r\u0026\u0026s[l]==split){//不让起始点从被ban的字符开始 l++; } if(l\u003er) break;//说明全是被ban的字符 int start = l; while(l\u003c=r\u0026\u0026s[l]!=split){//计算本次分段的长度（结束位置） l++; } int length = dfs(s,start,l-1,k); ret = max(ret,length); } return ret; } int longestSubstring(string s, int k) { return dfs(s,0,s.size()-1,k); } }; 法二：枚举类型的滑动窗口 class Solution { public: int longestSubstring(string s, int k) { int n = s.size(); int cnt[26]{0};//用于记录窗口内字符的出现次数 int maxLen = 0; for(int i=1;i\u003c=26;i++){ memset(cnt,0,sizeof(cnt)); for(int l=0,r=0,sum=0,tot=0;r\u003cn;r++){//sum、tot分别表示窗口内的有效字符种类数和总的种类数 cnt[s[r]-'a']++; if(cnt[s[r]-'a']==1) //增加种类数 tot++; if(cnt[s[r]-'a']==k) //为了防止多次更新千万别取大于号 sum++; //增加有效种类数 while(tot\u003ei){ //达到收缩窗口条件，因为窗口内的种类数限制为i个 int dup = (s[l++]-'a'); cnt[dup]--; if(cnt[dup]==0) //种类数此时需要-1 tot--; if(cnt[dup]==k-1)//有效种类数-1 sum--; } if(sum==tot) maxLen = max(maxLen,r-l+1); } } return maxLen; } }; ","date":"2022-02-01","objectID":"/posts/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B1%BB%E5%9E%8B%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%88%96%E9%80%92%E5%BD%92%E5%88%86%E6%B2%BB%E8%A7%A3%E8%A2%ABban%E5%AD%97%E7%AC%A6%E6%B1%82%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/:1:2","tags":["递归分治、滑动窗口、位运算"],"title":"字符串类型滑动窗口或递归分治解被ban字符求最长子串","uri":"/posts/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B1%BB%E5%9E%8B%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%88%96%E9%80%92%E5%BD%92%E5%88%86%E6%B2%BB%E8%A7%A3%E8%A2%ABban%E5%AD%97%E7%AC%A6%E6%B1%82%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/"},{"categories":["算法——字符串"],"content":"题目二：最长的美好子字符串 最长的美好子字符串 ","date":"2022-02-01","objectID":"/posts/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B1%BB%E5%9E%8B%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%88%96%E9%80%92%E5%BD%92%E5%88%86%E6%B2%BB%E8%A7%A3%E8%A2%ABban%E5%AD%97%E7%AC%A6%E6%B1%82%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/:2:0","tags":["递归分治、滑动窗口、位运算"],"title":"字符串类型滑动窗口或递归分治解被ban字符求最长子串","uri":"/posts/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B1%BB%E5%9E%8B%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%88%96%E9%80%92%E5%BD%92%E5%88%86%E6%B2%BB%E8%A7%A3%E8%A2%ABban%E5%AD%97%E7%AC%A6%E6%B1%82%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/"},{"categories":["算法——字符串"],"content":"题目解析 这题虽然由于数据量的关系，被划分为简单题，但实际上完全不亚于第一题。甚至还得用上一些位运算的思想。 这题我会的做法只有两种： 普通位运算枚举法：其实就是此题的暴力解法，只是用了位运算使得更为优雅，由于此题需要求最长的大小写都包含的字符串，我们用一个int位来表示所有小写字母的出现，用另一个int位来表示所有大写字母的出现，则对于每个字符串，都可以通过这两个int是否相等来判断是否正好是大小写都含有，然后就是暴力的遍历所有子串的过程了。 递归分治法：此题和上题差不多，也是不会跨越任何一个段去更新答案，所以也能使用递归分治的方式来进行解决。但前期处理被ban字符和上题是不一样的，其余都一样，这题要根据 [l,r] 之间字符的位运算结果 lower 和 upper 再与运算得到两者的交集来判断是否有被 ban 字符，或者是不被ban的字符。 ","date":"2022-02-01","objectID":"/posts/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B1%BB%E5%9E%8B%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%88%96%E9%80%92%E5%BD%92%E5%88%86%E6%B2%BB%E8%A7%A3%E8%A2%ABban%E5%AD%97%E7%AC%A6%E6%B1%82%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/:2:1","tags":["递归分治、滑动窗口、位运算"],"title":"字符串类型滑动窗口或递归分治解被ban字符求最长子串","uri":"/posts/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B1%BB%E5%9E%8B%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%88%96%E9%80%92%E5%BD%92%E5%88%86%E6%B2%BB%E8%A7%A3%E8%A2%ABban%E5%AD%97%E7%AC%A6%E6%B1%82%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/"},{"categories":["算法——字符串"],"content":"解题代码 方法一：位运算+暴力遍历 class Solution { public: string longestNiceSubstring(string s) { int sz = s.size(); int start,len=0; for(int i=0;i\u003csz;i++){ int lower = 0,upper = 0; for(int j=i;j\u003csz;j++){ if(islower(s[j])){ lower |= (1\u003c\u003c(s[j]-'a')); }else{ upper |= (1\u003c\u003c(s[j]-'A')); } if(lower==upper\u0026\u0026(j-i+1\u003elen)){ start = i; len = j-i+1; } } } return len==0?\"\":s.substr(start,len); } }; 方法二：递归分治 class Solution { public: void dfs(string \u0026s, int l, int r, pair\u003cint, int\u003e \u0026ret) { int lower = 0, upper = 0; for (int i = l; i \u003c= r; i++) { if (islower(s[i])) { lower |= (1 \u003c\u003c (s[i] - 'a')); } else { upper |= (1 \u003c\u003c (s[i] - 'A')); } } if (lower == upper) {//我之前这里的判断条件导致了无限循环，一旦满足第一个条件，但不满足第二个条件，就发生无限循环！！！所以注意放到下面去 if (r - l + 1 \u003e ret.second) { ret.first = l; ret.second = r - l + 1; } return; } int valid = lower \u0026 upper;//这两的交集代表大小写都出现的类型，为符合条件的类型，而被ban的就是不处于这里面的字符类型 int start; while (l \u003c= r) { while (l \u003c= r \u0026\u0026 !(valid \u0026 (1 \u003c\u003c (tolower(s[l]) - 'a')))) {//让start处于符合条件的类型 l++; } if (l \u003e r) break; start = l; while (l \u003c= r \u0026\u0026 (valid \u0026 (1 \u003c\u003c (tolower(s[l]) - 'a')))) {//得到符合条件的分段右端点 l++; } dfs(s, start, l - 1, ret); } } string longestNiceSubstring(string s) { pair\u003cint, int\u003e ret{0, 0}; dfs(s, 0, s.size() - 1, ret); return s.substr(ret.first, ret.second); } }; ","date":"2022-02-01","objectID":"/posts/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B1%BB%E5%9E%8B%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%88%96%E9%80%92%E5%BD%92%E5%88%86%E6%B2%BB%E8%A7%A3%E8%A2%ABban%E5%AD%97%E7%AC%A6%E6%B1%82%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/:2:2","tags":["递归分治、滑动窗口、位运算"],"title":"字符串类型滑动窗口或递归分治解被ban字符求最长子串","uri":"/posts/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B1%BB%E5%9E%8B%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%88%96%E9%80%92%E5%BD%92%E5%88%86%E6%B2%BB%E8%A7%A3%E8%A2%ABban%E5%AD%97%E7%AC%A6%E6%B1%82%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/"},{"categories":["算法——动态规划"],"content":"划分数问题","date":"2022-01-30","objectID":"/posts/%E5%88%92%E5%88%86%E6%95%B0%E9%97%AE%E9%A2%98/","tags":["划分数问题"],"title":"划分数问题","uri":"/posts/%E5%88%92%E5%88%86%E6%95%B0%E9%97%AE%E9%A2%98/"},{"categories":["算法——动态规划"],"content":"题目 题目链接 ","date":"2022-01-30","objectID":"/posts/%E5%88%92%E5%88%86%E6%95%B0%E9%97%AE%E9%A2%98/:1:0","tags":["划分数问题"],"title":"划分数问题","uri":"/posts/%E5%88%92%E5%88%86%E6%95%B0%E9%97%AE%E9%A2%98/"},{"categories":["算法——动态规划"],"content":"题目详解 划分数类型题目都是dp解决，而且都有固定的套路和公式，但我们还是需要在前人的公式上加以理解！ 划分数问题dp总结 我这里就提两个比较常见的划分数问题的dp原理： 如果对数字划分较为抽象，那么我们把这个数字可以比作苹果，即有n个苹果需要划分到m个盘子里面，而这几个盘子的顺序肯定是不考虑的，也就是5个苹果划分给3个盘子，则1 2 2和2 1 2是完全一样的情况，只看具体的数字组合不看内部排列！ 将n划分成不大于m的划分。 $dp[n][m] = dp[n-m][m]+dp[n][m-1]$ 对于以上的状态转移方程， dp[n-m][m] 表示n个苹果放入m个盘子中，无空盘的情况。 dp[n][m-1] 表示n个苹果放入m个盘子中，有空盘的情况(这就是划分成不大于m盘的关键所在)。这么写肯定是有些难以理解，但当你去举例子，将它递归往下写的时候，你就会发现这个dp[n][m-1] 包含了从 dp[n][1] 到 dp[n][m-1] 的所有情况！ 底层的基本case有： 当 n==1||m==1 ，即盘子或者苹果数量为1个的时候，那肯定就只有一种情况。即dp[n][m]=1。 当 n\u003em ，则还能继续划分即dp[n][m] = dp[n-m][m]+dp[n][m-1]。 当 n==m ，则有两种情况，当划分为m个时，结果为1，然后继续空盘子划分，即 dp[n][m]=dp[n][m-1]+1。 当 n\u003cm，由于可以空盘，所以是允许存在的，但此时不可能满盘，所以等于空盘的情况，即 dp[n][m] = dp[n][m-1]。 写成代码形式就是（我比较喜欢写记忆化dfs，毕竟不需要考虑初始化问题，只需考虑最后的跳出）： 以下的两个判断条件就把所有是以上四种情况包含在内了！ int memo[202][8];//记忆化的备忘录 //TODO 划分数记忆化方式 int dfs(int n,int m){ if(n\u003c0||m\u003c0) return 0; if(n==1||n==0||m==1) return 1; return memo[n][m] = dfs(n-m,m)+dfs(n,m-1); } 将n严格划分为m个数。(即n个苹果严格划分为m盘，不要有空位！) $dp[n][m] = dp[n-m][m]+dp[n-1][m-1]$ 下面给出我的一段手写推导： base case也在手写题解里面提到了，所以直接上代码： int memo[202][8]; //TODO 划分数n划成k份的记忆化方式 int dfs(int n,int k){ if(n\u003ck) return 0; if(n==k||k==1) return 1; if(memo[n][k])return memo[n][k]; return memo[n][k] = dfs(n-k, k) + dfs(n-1,k-1); } ","date":"2022-01-30","objectID":"/posts/%E5%88%92%E5%88%86%E6%95%B0%E9%97%AE%E9%A2%98/:2:0","tags":["划分数问题"],"title":"划分数问题","uri":"/posts/%E5%88%92%E5%88%86%E6%95%B0%E9%97%AE%E9%A2%98/"},{"categories":["算法——动态规划"],"content":"解题代码 前面已经介绍了两种划分数的dp，那么本题就属于第二种划分数的dp！ 直接把上面的代码拿下来直接秒！ #include\u003cbits/stdc++.h\u003eusing namespace std; using ll = long long; ll memo[202][8]; int n,k; //TODO 划分数记忆化方式 ll dfs(int a,int b){ if(a\u003cb) return 0; if(a==b||b==1) return 1; if(memo[a][b])return memo[a][b]; return memo[a][b] = dfs(a-b, b) + dfs(a-1,b-1); } int main(){ cin\u003e\u003en\u003e\u003ek; cout\u003c\u003cdfs(n, k); return 0; } ","date":"2022-01-30","objectID":"/posts/%E5%88%92%E5%88%86%E6%95%B0%E9%97%AE%E9%A2%98/:3:0","tags":["划分数问题"],"title":"划分数问题","uri":"/posts/%E5%88%92%E5%88%86%E6%95%B0%E9%97%AE%E9%A2%98/"},{"categories":["算法——路径更新问题"],"content":"leetcode每日一题——地图中的最高点","date":"2022-01-29","objectID":"/posts/leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E5%9C%B0%E5%9B%BE%E4%B8%AD%E7%9A%84%E6%9C%80%E9%AB%98%E7%82%B9/","tags":["leetcode每日一题——地图中的最高点"],"title":"leetcode每日一题——地图中的最高点","uri":"/posts/leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E5%9C%B0%E5%9B%BE%E4%B8%AD%E7%9A%84%E6%9C%80%E9%AB%98%E7%82%B9/"},{"categories":["算法——路径更新问题"],"content":"题目 题目链接 ","date":"2022-01-29","objectID":"/posts/leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E5%9C%B0%E5%9B%BE%E4%B8%AD%E7%9A%84%E6%9C%80%E9%AB%98%E7%82%B9/:1:0","tags":["leetcode每日一题——地图中的最高点"],"title":"leetcode每日一题——地图中的最高点","uri":"/posts/leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E5%9C%B0%E5%9B%BE%E4%B8%AD%E7%9A%84%E6%9C%80%E9%AB%98%E7%82%B9/"},{"categories":["算法——路径更新问题"],"content":"解题思路 两种解题思路，都是根据题目的意思更新路径信息即可： bfs思路：由于相邻的两个格子必须高度差为1，而水域必须高度为0，所以，直接以水域为bfs源点，进行bfs把整个区域的值给更新就行了。这是bfs思路。 dp思路：由于dp都依赖上一次更新的结果，而我们一般就是从左到右的遍历更新，而这题是和四个位置相关，所以，我们分为：从上到下从左到右更新，可以把依赖上和左的答案给更新，从下到上，从右到左更新，可以把依赖下和右的结果给更新完。 ","date":"2022-01-29","objectID":"/posts/leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E5%9C%B0%E5%9B%BE%E4%B8%AD%E7%9A%84%E6%9C%80%E9%AB%98%E7%82%B9/:2:0","tags":["leetcode每日一题——地图中的最高点"],"title":"leetcode每日一题——地图中的最高点","uri":"/posts/leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E5%9C%B0%E5%9B%BE%E4%B8%AD%E7%9A%84%E6%9C%80%E9%AB%98%E7%82%B9/"},{"categories":["算法——路径更新问题"],"content":"解题代码 BFS代码 class Solution { public: const int dx[4]={-1,1,0,0}; const int dy[4]={0,0,-1,1}; int n,m; bool isValid(int x,int y){ return x\u003cn\u0026\u0026x\u003e=0\u0026\u0026y\u003cm\u0026\u0026y\u003e=0; } const int maxn = 1e3+5; vector\u003cvector\u003cint\u003e\u003e highestPeak(vector\u003cvector\u003cint\u003e\u003e\u0026 isWater) { n = isWater.size(); m = isWater[0].size(); bool visit[maxn][maxn]; memset(visit,0,sizeof(visit)); queue\u003cpair\u003cint,int\u003e\u003eQ; for(int i=0;i\u003cn;i++){ for(int j=0;j\u003cm;j++){ if(isWater[i][j]){ visit[i][j] = 1; isWater[i][j] = 0; Q.push({i,j}); } } } int step = 1; while(!Q.empty()){ for(int i=Q.size();i\u003e0;i--){ auto[x,y] = Q.front();Q.pop(); for(int k=0;k\u003c4;k++){ int nx = x+dx[k]; int ny = y+dy[k]; if(isValid(nx,ny)\u0026\u0026!visit[nx][ny]){ visit[nx][ny] = 1; isWater[nx][ny] = step; Q.push({nx,ny}); } } } step++; } return isWater; } }; dp代码 class Solution { public: vector\u003cvector\u003cint\u003e\u003e highestPeak(vector\u003cvector\u003cint\u003e\u003e\u0026 isWater) { int n = isWater.size(); int m = isWater[0].size(); vector\u003cvector\u003cint\u003e\u003e dp(n, vector\u003cint\u003e(m, 1e9+7)); for(int i=0; i\u003cn; i++) { //从上到下从左到右 for(int j=0; j\u003cm; j++) { if(isWater[i][j]) dp[i][j] = 0; else { if(i \u003e 0) dp[i][j] = min(dp[i][j], dp[i-1][j]+1); if(j \u003e 0) dp[i][j] = min(dp[i][j], dp[i][j-1]+1); } } } for(int i=n-1; i\u003e=0; i--) { //从下到上从右到左 for(int j=m-1; j\u003e=0; j--) { if(isWater[i][j]) dp[i][j] = 0; else { if(i \u003c n-1) dp[i][j] = min(dp[i][j], dp[i+1][j]+1); if(j \u003c m-1) dp[i][j] = min(dp[i][j], dp[i][j+1]+1); } } } return dp; } }; ","date":"2022-01-29","objectID":"/posts/leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E5%9C%B0%E5%9B%BE%E4%B8%AD%E7%9A%84%E6%9C%80%E9%AB%98%E7%82%B9/:3:0","tags":["leetcode每日一题——地图中的最高点"],"title":"leetcode每日一题——地图中的最高点","uri":"/posts/leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E5%9C%B0%E5%9B%BE%E4%B8%AD%E7%9A%84%E6%9C%80%E9%AB%98%E7%82%B9/"},{"categories":["算法——贪心"],"content":"leetcode每日一题-游戏中弱角色的数量","date":"2022-01-28","objectID":"/posts/leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-%E6%B8%B8%E6%88%8F%E4%B8%AD%E5%BC%B1%E8%A7%92%E8%89%B2%E7%9A%84%E6%95%B0%E9%87%8F/","tags":["利用排序基于遍历过程处理的贪心-游戏中弱角色的数量"],"title":"leetcode每日一题-游戏中弱角色的数量","uri":"/posts/leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-%E6%B8%B8%E6%88%8F%E4%B8%AD%E5%BC%B1%E8%A7%92%E8%89%B2%E7%9A%84%E6%95%B0%E9%87%8F/"},{"categories":["算法——贪心"],"content":"题目 题目链接 ","date":"2022-01-28","objectID":"/posts/leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-%E6%B8%B8%E6%88%8F%E4%B8%AD%E5%BC%B1%E8%A7%92%E8%89%B2%E7%9A%84%E6%95%B0%E9%87%8F/:1:0","tags":["利用排序基于遍历过程处理的贪心-游戏中弱角色的数量"],"title":"leetcode每日一题-游戏中弱角色的数量","uri":"/posts/leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-%E6%B8%B8%E6%88%8F%E4%B8%AD%E5%BC%B1%E8%A7%92%E8%89%B2%E7%9A%84%E6%95%B0%E9%87%8F/"},{"categories":["算法——贪心"],"content":"解题思路 一句话解决：以第一个字段为标准从大到小排序，然后再遍历数组，对比第二字段的最大值即可。 关键细节： 为了避免第一个字段相同的情况下被更新，所以在排序时采取，攻击力降序防御力升序的方式(关键)来进行。 这样就让第一个字段相同时，按照从左到右的遍历顺序是不可能把第一个字段相同的情况拿来更新 cnt 。 ","date":"2022-01-28","objectID":"/posts/leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-%E6%B8%B8%E6%88%8F%E4%B8%AD%E5%BC%B1%E8%A7%92%E8%89%B2%E7%9A%84%E6%95%B0%E9%87%8F/:2:0","tags":["利用排序基于遍历过程处理的贪心-游戏中弱角色的数量"],"title":"leetcode每日一题-游戏中弱角色的数量","uri":"/posts/leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-%E6%B8%B8%E6%88%8F%E4%B8%AD%E5%BC%B1%E8%A7%92%E8%89%B2%E7%9A%84%E6%95%B0%E9%87%8F/"},{"categories":["算法——贪心"],"content":"解题代码 注意：golang 的代码中的断言型函数接口有点不一样。。它调用时用的是数组下标的形式来调用。 cpp version class Solution { public: //一句话解决：以第一个字段为标准从大到小排序，然后再遍历数组，对比第二字段的最大值即可。 //但为了避免第一个字段相同的情况下被更新，所以在排序时采取，攻击力降序防御力升序的方式(关键)来进行 //这样就让第一个字段相同时，按照从左到右的遍历顺序是不可能把第一个字段相同的情况拿来更新cnt。 int numberOfWeakCharacters(vector\u003cvector\u003cint\u003e\u003e\u0026 properties) { int n = properties.size(); auto cmp = [](vector\u003cint\u003e\u0026 t1,vector\u003cint\u003e\u0026t2){return t1[0]==t2[0]?t1[1]\u003ct2[1]:t1[0]\u003et2[0];}; sort(properties.begin(),properties.end(),cmp); int mx = INT_MIN; int cnt = 0; for(int i=0;i\u003cn;i++){ if(mx\u003eproperties[i][1]) cnt++; mx = max(mx,properties[i][1]); } return cnt; } }; java version class Solution { public int numberOfWeakCharacters(int[][] properties) { Arrays.sort(properties,(o1,o2)-\u003e o1[0]==o2[0]?o1[1]-o2[1]:o2[0]-o1[0]); int max = -1,cnt = 0; for(int[] p : properties){ if(p[1]\u003cmax) cnt++; max = Math.max(max,p[1]); } return cnt; } } golang version func numberOfWeakCharacters(properties [][]int) int { sort.Slice(properties,func (i int,j int) bool{//注意这个接口被写死只能用int型 p, q := properties[i], properties[j] return p[0] \u003e q[0] || p[0] == q[0] \u0026\u0026 p[1] \u003c q[1] }) var max = -1 cnt := 0 for _,v := range properties{ if max\u003ev[1] { cnt++ } max = int(math.Max(float64(max), float64(v[1]))) } return cnt } ","date":"2022-01-28","objectID":"/posts/leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-%E6%B8%B8%E6%88%8F%E4%B8%AD%E5%BC%B1%E8%A7%92%E8%89%B2%E7%9A%84%E6%95%B0%E9%87%8F/:3:0","tags":["利用排序基于遍历过程处理的贪心-游戏中弱角色的数量"],"title":"leetcode每日一题-游戏中弱角色的数量","uri":"/posts/leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-%E6%B8%B8%E6%88%8F%E4%B8%AD%E5%BC%B1%E8%A7%92%E8%89%B2%E7%9A%84%E6%95%B0%E9%87%8F/"},{"categories":["算法——贪心"],"content":"收获 被坑了，往二分+哈希表方向去写了。完全没想到之间排序+遍历就能解决。。。 排序的处理非常之精髓。 ","date":"2022-01-28","objectID":"/posts/leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-%E6%B8%B8%E6%88%8F%E4%B8%AD%E5%BC%B1%E8%A7%92%E8%89%B2%E7%9A%84%E6%95%B0%E9%87%8F/:4:0","tags":["利用排序基于遍历过程处理的贪心-游戏中弱角色的数量"],"title":"leetcode每日一题-游戏中弱角色的数量","uri":"/posts/leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-%E6%B8%B8%E6%88%8F%E4%B8%AD%E5%BC%B1%E8%A7%92%E8%89%B2%E7%9A%84%E6%95%B0%E9%87%8F/"},{"categories":["算法——计算几何"],"content":"leetcode每日一题-检测正方形","date":"2022-01-27","objectID":"/posts/leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-%E6%A3%80%E6%B5%8B%E6%AD%A3%E6%96%B9%E5%BD%A2/","tags":["leetcode每日一题-检测正方形"],"title":"leetcode每日一题-检测正方形","uri":"/posts/leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-%E6%A3%80%E6%B5%8B%E6%AD%A3%E6%96%B9%E5%BD%A2/"},{"categories":["算法——计算几何"],"content":"题目 题目链接 ","date":"2022-01-27","objectID":"/posts/leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-%E6%A3%80%E6%B5%8B%E6%AD%A3%E6%96%B9%E5%BD%A2/:1:0","tags":["leetcode每日一题-检测正方形"],"title":"leetcode每日一题-检测正方形","uri":"/posts/leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-%E6%A3%80%E6%B5%8B%E6%AD%A3%E6%96%B9%E5%BD%A2/"},{"categories":["算法——计算几何"],"content":"题目解析 注意此题为计算几何类型的题目，我认为这类问题最重要的就是把这个几何图形用好用的方法去表示出来。 三个重点： 点的表示：我们通过上下两点确定正方形的原则来表示，且点的存储方式一点不能用pair，这样效率及其低下，且难以有一定的自由度取操作 x，y 轴，我们采用哈希表套哈希表的方式取存储！ 点的记录：通过嵌套哈希表完成点的次数记录，比如： unordered_map\u003cint, unordered_map\u003cint, int\u003e\u003e cnt; cnt[y][x]++; 点的枚举：通过嵌套哈希表，可以很好的把 x，y 坐标的对应点数给限制住，所以我们要根据这点可以利用count方法直接把不是同一个纵轴的点给排除，比如： res += (colCnt.count(x) ? colCnt[x] : 0) * (yCnt.count(x + d) ? yCnt[x + d] : 0) * (colCnt.count(x + d)? colCnt[x + d] : 0); //一旦以上的count方法返回0，即表示该点不是同一个纵轴上的点，则得出结果0，整个res就相当于没有加任何数字。 再比如通过yCnt提前取出在同一个横轴的点： unordered_map\u003cint, int\u003e \u0026 yCnt = cnt[y]; //取和point在同一行的所有点 //这样后续的枚举过程直接可以套用yCnt[x+d]或者yCnt[x-d]来得到对应左右两种情况正方形的点个数。 最后一个优化：由于我们每次枚举同一纵轴上的点不确定是上面还是下面，实际上根本不重要，由于在计算时，我们都会把左右两种正方形的情况给计算完，而这个过程正好是两个相反的 +- 过程，所以无论枚举得到的正方形边长为正还是为负数，都不影响！ ","date":"2022-01-27","objectID":"/posts/leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-%E6%A3%80%E6%B5%8B%E6%AD%A3%E6%96%B9%E5%BD%A2/:2:0","tags":["leetcode每日一题-检测正方形"],"title":"leetcode每日一题-检测正方形","uri":"/posts/leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-%E6%A3%80%E6%B5%8B%E6%AD%A3%E6%96%B9%E5%BD%A2/"},{"categories":["算法——计算几何"],"content":"解题代码 非常详细的注释了 class DetectSquares { public: unordered_map\u003cint, unordered_map\u003cint, int\u003e\u003e cnt; DetectSquares() { } void add(vector\u003cint\u003e point) { int x = point[0], y = point[1]; cnt[y][x]++; } int count(vector\u003cint\u003e point) { int res = 0; int x = point[0], y = point[1]; if (!cnt.count(y)) { return 0; } unordered_map\u003cint, int\u003e \u0026 yCnt = cnt[y]; //取和point在同一行的所有点 for (auto \u0026 [col, colCnt] : cnt) { if (col != y) {//由于我们构造正方形是根据上下两条边，故此处枚举的另外一点不能在同一行 // 根据对称性，这里可以不用取绝对值，具体而言就是所有情况根据+-已经包括 int d = col - y;//得到正方形边长，根据这个值可以直接取到对应的另外几个点(如果存在的话) //这里的colCnt.count(x)用于判断是否和当前点在同一个纵轴，这样才可能构造上下两边，故下面只要有1个为0，则加的都是0 //由于我们指定了必须是同一个纵轴上的点，所以不可能构造出两个相同的正方形！ res += (colCnt.count(x) ? colCnt[x] : 0) * (yCnt.count(x + d) ? yCnt[x + d] : 0) * (colCnt.count(x + d)? colCnt[x + d] : 0); res += (colCnt.count(x) ? colCnt[x] : 0) * (yCnt.count(x - d) ? yCnt[x - d] : 0) * (colCnt.count(x - d) ? colCnt[x - d] : 0); } } return res; } }; ","date":"2022-01-27","objectID":"/posts/leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-%E6%A3%80%E6%B5%8B%E6%AD%A3%E6%96%B9%E5%BD%A2/:3:0","tags":["leetcode每日一题-检测正方形"],"title":"leetcode每日一题-检测正方形","uri":"/posts/leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-%E6%A3%80%E6%B5%8B%E6%AD%A3%E6%96%B9%E5%BD%A2/"},{"categories":["算法——计算几何"],"content":"总结 学到以下： 如何通过嵌套哈希表表示点，以及用它表示的而不用pair表示的好处。 重点好像也就上面那条。 ","date":"2022-01-27","objectID":"/posts/leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-%E6%A3%80%E6%B5%8B%E6%AD%A3%E6%96%B9%E5%BD%A2/:4:0","tags":["leetcode每日一题-检测正方形"],"title":"leetcode每日一题-检测正方形","uri":"/posts/leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-%E6%A3%80%E6%B5%8B%E6%AD%A3%E6%96%B9%E5%BD%A2/"},{"categories":["JavaWeb笔记"],"content":"Java网络编程","date":"2022-01-26","objectID":"/posts/java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/","tags":["JavaWeb第一节"],"title":"Java网络编程","uri":"/posts/java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"categories":["JavaWeb笔记"],"content":"Java网络编程 配套视频 在JavaSE阶段，我们学习了I/O流，既然I/O流如此强大，那么能否跨越不同的主机进行I/O操作呢？这就要提到Java的网络编程了。 注意：本章会涉及到计算机网络相关内容（只会讲解大致内容，不会完整的讲解计算机网络知识） 若没有计算机网络基础，实际上Java这里封装的Socket网络IO操作已经简单到完全不需要任何基础的，但是没有计算机网络相关的底层知识，以后的深入学习会非常不知所云。 ","date":"2022-01-26","objectID":"/posts/java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/:0:0","tags":["JavaWeb第一节"],"title":"Java网络编程","uri":"/posts/java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"categories":["JavaWeb笔记"],"content":"计算机网络基础 利用通信线路和通信设备，将地理位置不同的、功能独立的多台计算机互连起来，以功能完善的网络软件来实现资源共享和信息传递，就构成了计算机网络系统。 比如我们家里的路由器，通过将我们的设备（手机、平板、电脑、电视剧）连接到路由器，来实现对互联网的访问。实际上，我们的路由器连接在互联网上，而我们的设备又连接了路由器，这样我们的设备就可以通过路由器访问到互联网了。通过网络，我们可以直接访问互联网上的另一台主机，比如我们要把QQ的消息发送给我们的朋友，或是通过远程桌面管理来操作另一台电脑，也可以是连接本地网络上的打印机。 既然我们可以通过网络访问其他计算机，那么如何区别不同的计算机呢？通过IP地址，我们就可以区分不同的计算机了： 每一台电脑在同一个网络上都有一个自己的IP地址，用于区别于其他的电脑，我们可以通过对方主机的IP地址对其进行访问。那么我手机连接的移动流量，能访问到连接家里路由器的电脑吗？（不能，因为他们不属于同一个网络） 而我们的电脑上可能运行着大量的程序，每一个程序可能都需要通过网络来访问其他计算机，那这时该如何区分呢？我们可以通过端口号来区分： 因此，我们一般看到的是这样的：192.168.0.11:8080，通过IP:端口的形式来访问目标主机上的一个应用程序服务。注意端口号只能是0-65535之间的值！ IP地址分为IPv4和IPv6，IPv4类似于192.168.0.11，我们上面提到的例子都是使用的IPv4，它一共有四组数字，每组数字占8个bit位，IPv4地址0.0.0.0表示为2进制就是：00000000.00000000.00000000.00000000，共32个bit，最大为255.255.255.255，实际上，IPv4能够表示的所有地址，早就已经被用完了。IPv6能够保存128个bit位，因此它也可以表示更多的IP地址，一个IPv6地址看起来像这样：1030::C9B4:FF12:48AA:1A2B，目前也正在向IPv6的阶段过度。 TCP和UDP是两种不同的传输层协议： TCP：当一台计算机想要与另一台计算机通讯时，两台计算机之间的通信需要畅通且可靠（会进行三次握手，断开也会进行四次挥手），这样才能保证正确收发数据，因此TCP更适合一些可靠的数据传输场景。 UDP：它是一种无连接协议，数据想发就发，而且不会建立可靠传输，也就是说传输过程中有可能会导致部分数据丢失，但是它比TCP传输更加简单高效，适合视频直播之类的。 ","date":"2022-01-26","objectID":"/posts/java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/:1:0","tags":["JavaWeb第一节"],"title":"Java网络编程","uri":"/posts/java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"categories":["JavaWeb笔记"],"content":"了解Socket技术 通过Socket技术（它是计算机之间进行通信的一种约定或一种方式），我们就可以实现两台计算机之间的通信，Socket也被翻译为套接字，是操作系统底层提供的一项通信技术，它支持TCP和UDP。而Java就对socket底层支持进行了一套完整的封装，我们可以通过Java来实现Socket通信。 要实现Socket通信，我们必须创建一个数据发送者和一个数据接收者，也就是客户端和服务端，我们需要提前启动服务端，来等待客户端的连接，而客户端只需要随时启动去连接服务端即可！ //服务端 public static void main(String[] args) { try(ServerSocket server = new ServerSocket(8080)){ //将服务端创建在端口8080上 System.out.println(\"正在等待客户端连接...\"); Socket socket = server.accept(); //当没有客户端连接时，线程会阻塞，直到有客户端连接为止 System.out.println(\"客户端已连接，IP地址为：\"+socket.getInetAddress().getHostAddress()); }catch (IOException e){ e.printStackTrace(); } } //客户端 public static void main(String[] args) { try (Socket socket = new Socket(\"localhost\", 8080)){ System.out.println(\"已连接到服务端！\"); }catch (IOException e){ System.out.println(\"服务端连接失败！\"); e.printStackTrace(); } } 实际上它就是一个TCP连接的建立过程： 一旦TCP连接建立，服务端和客户端之间就可以相互发送数据，直到客户端主动关闭连接。当然，服务端不仅仅只可以让一个客户端进行连接，我们可以尝试让服务端一直运行来不断接受客户端的连接： public static void main(String[] args) { try(ServerSocket server = new ServerSocket(8080)){ //将服务端创建在端口8080上 System.out.println(\"正在等待客户端连接...\"); while (true){ //无限循环等待客户端连接 Socket socket = server.accept(); System.out.println(\"客户端已连接，IP地址为：\"+socket.getInetAddress().getHostAddress()); } }catch (IOException e){ e.printStackTrace(); } } 现在我们就可以多次去连接此服务端了。 ","date":"2022-01-26","objectID":"/posts/java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/:2:0","tags":["JavaWeb第一节"],"title":"Java网络编程","uri":"/posts/java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"categories":["JavaWeb笔记"],"content":"使用Socket进行数据传输 通过Socket对象，我们就可以获取到对应的I/O流进行网络数据传输： public static void main(String[] args) { try (Socket socket = new Socket(\"localhost\", 8080); Scanner scanner = new Scanner(System.in)){ System.out.println(\"已连接到服务端！\"); OutputStream stream = socket.getOutputStream(); OutputStreamWriter writer = new OutputStreamWriter(stream); //通过转换流来帮助我们快速写入内容 System.out.println(\"请输入要发送给服务端的内容：\"); String text = scanner.nextLine(); writer.write(text+'\\n'); //因为对方是readLine()这里加个换行符 writer.flush(); System.out.println(\"数据已发送：\"+text); }catch (IOException e){ System.out.println(\"服务端连接失败！\"); e.printStackTrace(); }finally { System.out.println(\"客户端断开连接！\"); } } } public static void main(String[] args) { try(ServerSocket server = new ServerSocket(8080)){ //将服务端创建在端口8080上 System.out.println(\"正在等待客户端连接...\"); Socket socket = server.accept(); System.out.println(\"客户端已连接，IP地址为：\"+socket.getInetAddress().getHostAddress()); BufferedReader reader = new BufferedReader(new InputStreamReader(socket.getInputStream())); //通过 System.out.print(\"接收到客户端数据：\"); System.out.println(reader.readLine()); socket.close(); //和服务端TCP连接完成之后，记得关闭socket }catch (IOException e){ e.printStackTrace(); } } 同理，既然服务端可以读取客户端的内容，客户端也可以在发送后等待服务端给予响应： public static void main(String[] args) { try (Socket socket = new Socket(\"localhost\", 8080); Scanner scanner = new Scanner(System.in)){ System.out.println(\"已连接到服务端！\"); OutputStream stream = socket.getOutputStream(); OutputStreamWriter writer = new OutputStreamWriter(stream); //通过转换流来帮助我们快速写入内容 System.out.println(\"请输入要发送给服务端的内容：\"); String text = scanner.nextLine(); writer.write(text+'\\n'); //因为对方是readLine()这里加个换行符 writer.flush(); System.out.println(\"数据已发送：\"+text); BufferedReader reader = new BufferedReader(new InputStreamReader(socket.getInputStream())); System.out.println(\"收到服务器返回：\"+reader.readLine()); }catch (IOException e){ System.out.println(\"服务端连接失败！\"); e.printStackTrace(); }finally { System.out.println(\"客户端断开连接！\"); } } public static void main(String[] args) { try(ServerSocket server = new ServerSocket(8080)){ //将服务端创建在端口8080上 System.out.println(\"正在等待客户端连接...\"); Socket socket = server.accept(); System.out.println(\"客户端已连接，IP地址为：\"+socket.getInetAddress().getHostAddress()); BufferedReader reader = new BufferedReader(new InputStreamReader(socket.getInputStream())); //通过 System.out.print(\"接收到客户端数据：\"); System.out.println(reader.readLine()); OutputStreamWriter writer = new OutputStreamWriter(socket.getOutputStream()); writer.write(\"已收到！\"); writer.flush(); }catch (IOException e){ e.printStackTrace(); } } 我们可以手动关闭单向的流： socket.shutdownOutput(); //关闭输出方向的流 socket.shutdownInput(); //关闭输入方向的流 如果我们不希望服务端等待太长的时间，我们可以通过调用setSoTimeout()方法来设定IO超时时间： socket.setSoTimeout(3000); 当超过设定时间都依然没有收到客户端或是服务端的数据时，会抛出异常： java.net.SocketTimeoutException: Read timed out at java.net.SocketInputStream.socketRead0(Native Method) at java.net.SocketInputStream.socketRead(SocketInputStream.java:116) at java.net.SocketInputStream.read(SocketInputStream.java:171) at java.net.SocketInputStream.read(SocketInputStream.java:141) at sun.nio.cs.StreamDecoder.readBytes(StreamDecoder.java:284) at sun.nio.cs.StreamDecoder.implRead(StreamDecoder.java:326) at sun.nio.cs.StreamDecoder.read(StreamDecoder.java:178) at java.io.InputStreamReader.read(InputStreamReader.java:184) at java.io.BufferedReader.fill(BufferedReader.java:161) at java.io.BufferedReader.readLine(BufferedReader.java:324) at java.io.BufferedReader.readLine(BufferedReader.java:389) at com.test.Main.main(Main.java:41) 我们之前使用的都是通过构造方法直接连接服务端，那么是否可以等到我们想要的时候再去连接呢？ try (Socket socket = new Socket(); //调用无参构造不会自动连接 Scanner scanner = new Scanner(System.in)){ socket.connect(new InetSocketAddress(\"localhost\", 8080), 1000); //手动调用connect方法进行连接 如果连接的双方发生意外而通知不到对方，导致一方还持有连接，这样就会占用资源，因此我们可以使用setKeepAlive()方法来防止此类情况发生： socket.setKeepAlive(true); 当客户端连接后，如果设置了keeplive为 true，当对方没有发送任何数据过来，超过一个时间(看系统内核参数配置)，那么我们这边会发送一个ack探测包发到对方，探测双方的TCP/IP连接是否有效。 TCP在传输过程中，实际上会有一个缓冲区用于数据的发送和接收： 此缓冲区大小为：8192，我们可以手动调整其大小来优化传输效率： socket.setReceiveBufferSize(25565); /","date":"2022-01-26","objectID":"/posts/java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/:3:0","tags":["JavaWeb第一节"],"title":"Java网络编程","uri":"/posts/java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"categories":["JavaWeb笔记"],"content":"使用Socket传输文件 既然Socket为我们提供了IO流便于数据传输，那么我们就可以轻松地实现文件传输了。 ","date":"2022-01-26","objectID":"/posts/java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/:4:0","tags":["JavaWeb第一节"],"title":"Java网络编程","uri":"/posts/java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"categories":["JavaWeb笔记"],"content":"使用浏览器访问Socket服务器 在了解了如何使用Socket传输文件后，我们来看看，浏览器是如何向服务器发起请求的： public static void main(String[] args) { try(ServerSocket server = new ServerSocket(8080)){ //将服务端创建在端口8080上 System.out.println(\"正在等待客户端连接...\"); Socket socket = server.accept(); System.out.println(\"客户端已连接，IP地址为：\"+socket.getInetAddress().getHostAddress()); InputStream in = socket.getInputStream(); //通过 System.out.println(\"接收到客户端数据：\"); while (true){ int i = in.read(); if(i == -1) break; System.out.print((char) i); } }catch (Exception e){ e.printStackTrace(); } } 我们现在打开浏览器，输入http://localhost:8080或是http://127.0.0.1:8080/，来连接我们本地开放的服务器。 我们发现浏览器是无法打开这个链接的，但是我们服务端却收到了不少的信息： GET / HTTP/1.1\rHost: 127.0.0.1:8080\rConnection: keep-alive\rCache-Control: max-age=0\rsec-ch-ua: \"Chromium\";v=\"94\", \"Google Chrome\";v=\"94\", \";Not A Brand\";v=\"99\"\rsec-ch-ua-mobile: ?0\rsec-ch-ua-platform: \"macOS\"\rUpgrade-Insecure-Requests: 1\rUser-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/94.0.4606.81 Safari/537.36\rAccept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9\rSec-Fetch-Site: none\rSec-Fetch-Mode: navigate\rSec-Fetch-User: ?1\rSec-Fetch-Dest: document\rAccept-Encoding: gzip, deflate, br\rAccept-Language: zh-CN,zh;q=0.9,und;q=0.8,en;q=0.7\r实际上这些内容都是Http协议规定的请求头内容。HTTP是一种应用层协议，全称为超文本传输协议，它本质也是基于TCP协议进行数据传输，因此我们的服务端能够读取HTTP请求。但是Http协议并不会保持长连接，在得到我们响应的数据后会立即关闭TCP连接。 既然使用的是Http连接，如果我们的服务器要支持响应HTTP请求，那么就需要按照HTTP协议的规则，返回一个规范的响应文本，首先是响应头，它至少要包含一个响应码： HTTP/1.1 200 Accpeted\r然后就是响应内容（注意一定要换行再写），我们尝试来编写一下支持HTTP协议的响应内容： public static void main(String[] args) { try(ServerSocket server = new ServerSocket(8080)){ //将服务端创建在端口8080上 System.out.println(\"正在等待客户端连接...\"); Socket socket = server.accept(); System.out.println(\"客户端已连接，IP地址为：\"+socket.getInetAddress().getHostAddress()); BufferedReader reader = new BufferedReader(new InputStreamReader(socket.getInputStream())); //通过 System.out.println(\"接收到客户端数据：\"); while (reader.ready()) System.out.println(reader.readLine()); //ready是判断当前流中是否还有可读内容 OutputStreamWriter writer = new OutputStreamWriter(socket.getOutputStream()); writer.write(\"HTTP/1.1 200 Accepted\\r\\n\"); //200是响应码，Http协议规定200为接受请求，400为错误的请求，404为找不到此资源（不止这些，还有很多） writer.write(\"\\r\\n\"); //在请求头写完之后还要进行一次换行，然后写入我们的响应实体（会在浏览器上展示的内容） writer.write(\"lbwnb!\"); writer.flush(); }catch (Exception e){ e.printStackTrace(); } } 我们可以打开浏览器的开发者模式（这里推荐使用Chrome/Edge浏览器，按下F12即可打开），我们来观察一下浏览器的实际请求过程。 ","date":"2022-01-26","objectID":"/posts/java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/:5:0","tags":["JavaWeb第一节"],"title":"Java网络编程","uri":"/posts/java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"categories":["Linux网络编程"],"content":"TCP网络编程中connect、listen、accept三者之间的关系","date":"2022-01-26","objectID":"/posts/tcp%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E4%B8%ADconnectlistenaccept%E4%B8%89%E8%80%85%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB/","tags":["TCP网络编程中connect、listen、accept三者之间的关系"],"title":"TCP网络编程中connect、listen、accept三者之间的关系","uri":"/posts/tcp%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E4%B8%ADconnectlistenaccept%E4%B8%89%E8%80%85%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB/"},{"categories":["Linux网络编程"],"content":" 基于 TCP 的网络编程开发分为服务器端和客户端两部分，常见的核心步骤和流程如下： 整个函数调用(image)\"\r整个函数调用(image)\r ","date":"2022-01-26","objectID":"/posts/tcp%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E4%B8%ADconnectlistenaccept%E4%B8%89%E8%80%85%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB/:0:0","tags":["TCP网络编程中connect、listen、accept三者之间的关系"],"title":"TCP网络编程中connect、listen、accept三者之间的关系","uri":"/posts/tcp%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E4%B8%ADconnectlistenaccept%E4%B8%89%E8%80%85%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB/"},{"categories":["Linux网络编程"],"content":"accept()函数 对于客户端的 connect() 函数，该函数的功能为客户端主动连接服务器，建立连接是通过三次握手，而这个连接的过程是由内核完成，不是这个函数完成的，这个函数的作用仅仅是通知 Linux 内核，让 Linux 内核自动完成 TCP 三次握手连接，最后把连接的结果返回给这个函数的返回值（成功连接为0， 失败为-1）。 通常的情况，客户端的 connect() 函数默认会一直阻塞，直到三次握手成功或超时失败才返回（正常的情况，这个过程很快完成）。 ","date":"2022-01-26","objectID":"/posts/tcp%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E4%B8%ADconnectlistenaccept%E4%B8%89%E8%80%85%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB/:1:0","tags":["TCP网络编程中connect、listen、accept三者之间的关系"],"title":"TCP网络编程中connect、listen、accept三者之间的关系","uri":"/posts/tcp%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E4%B8%ADconnectlistenaccept%E4%B8%89%E8%80%85%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB/"},{"categories":["Linux网络编程"],"content":"listen()函数 对于服务器，它是被动连接的。举一个生活中的例子，通常的情况下，移动的客服（相当于服务器）是等待着客户（相当于客户端）电话的到来。而这个过程，需要调用listen()函数。 #include\u003csys/socket.h\u003eint listen(int sockfd, int backlog); listen() 函数的主要作用就是将套接字( sockfd )变成被动的连接监听套接字（被动等待客户端的连接），至于参数 backlog 的作用是设置内核中连接队列的长度（这个长度有什么用，后面做详细的解释），TCP 三次握手也不是由这个函数完成，listen()的作用仅仅告诉内核一些信息。 这样的话，当有一个客户端主动连接 connect()，Linux 内核就自动完成TCP 三次握手，将建立好的链接自动存储到队列中，如此重复。 所以，只要 TCP 服务器调用了 listen()，客户端就可以通过 connect() 和服务器建立连接，而这个连接的过程是由内核完成。 三次握手\"\r三次握手\r 下面为测试的服务器和客户端代码，运行程序时，要先运行服务器，再运行客户端： 服务器： #include \u003cstdio.h\u003e#include \u003cstdlib.h\u003e#include \u003cstring.h\u003e #include \u003cunistd.h\u003e#include \u003csys/socket.h\u003e#include \u003cnetinet/in.h\u003e#include \u003carpa/inet.h\u003e int main(int argc, char *argv[]) { unsigned short port = 8000; int sockfd; sockfd = socket(AF_INET, SOCK_STREAM, 0);// 创建通信端点：套接字 if(sockfd \u003c 0) { perror(\"socket\"); exit(-1); } struct sockaddr_in my_addr; bzero(\u0026my_addr, sizeof(my_addr)); my_addr.sin_family = AF_INET; my_addr.sin_port = htons(port); my_addr.sin_addr.s_addr = htonl(INADDR_ANY); int err_log = bind(sockfd, (struct sockaddr*)\u0026my_addr, sizeof(my_addr)); if( err_log != 0) { perror(\"binding\"); close(sockfd); exit(-1); } err_log = listen(sockfd, 10); if(err_log != 0) { perror(\"listen\"); close(sockfd); exit(-1); } printf(\"listen client @port=%d...\\n\",port); sleep(10); // 延时10s system(\"netstat -an | grep 8000\"); // 查看连接状态 return 0; } 客户端 #include \u003cstdio.h\u003e#include \u003cunistd.h\u003e#include \u003cstring.h\u003e#include \u003cstdlib.h\u003e#include \u003carpa/inet.h\u003e#include \u003csys/socket.h\u003e#include \u003cnetinet/in.h\u003eint main(int argc, char *argv[]) { unsigned short port = 8000; // 服务器的端口号 char *server_ip = \"10.221.20.12\"; // 服务器ip地址 int sockfd; sockfd = socket(AF_INET, SOCK_STREAM, 0);// 创建通信端点：套接字 if(sockfd \u003c 0) { perror(\"socket\"); exit(-1); } struct sockaddr_in server_addr; bzero(\u0026server_addr,sizeof(server_addr)); // 初始化服务器地址 server_addr.sin_family = AF_INET; server_addr.sin_port = htons(port); inet_pton(AF_INET, server_ip, \u0026server_addr.sin_addr); int err_log = connect(sockfd, (struct sockaddr*)\u0026server_addr, sizeof(server_addr)); // 主动连接服务器 if(err_log != 0) { perror(\"connect\"); close(sockfd); exit(-1); } system(\"netstat -an | grep 8000\"); // 查看连接状态 while(1); return 0; } 运行结果： ","date":"2022-01-26","objectID":"/posts/tcp%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E4%B8%ADconnectlistenaccept%E4%B8%89%E8%80%85%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB/:2:0","tags":["TCP网络编程中connect、listen、accept三者之间的关系"],"title":"TCP网络编程中connect、listen、accept三者之间的关系","uri":"/posts/tcp%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E4%B8%ADconnectlistenaccept%E4%B8%89%E8%80%85%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB/"},{"categories":["Linux网络编程"],"content":"三次握手的连接队列 这里详细的介绍一下 listen() 函数的第二个参数（ backlog）的作用：告诉内核连接队列的长度。 为了更好的理解 backlog 参数，我们必须认识到内核为任何一个给定的监听套接口维护两个队列： 未完成连接队列（incomplete connection queue），以某个客户发出并到达服务器，而服务器正在等待完成相应的 TCP 三次握手过程。这些端口都处于处于 SYN_RCVD 状态。 已完成连接队列（completed connection queue），这些端口处于 ESTABLISHED 状态。 当来自客户的 SYN 到达时，TCP 在未完成连接队列中创建一个新项，然后响应以三次握手的第二个分节：服务器的 SYN 响应，其中稍带对客户 SYN 的 ACK（即SYN+ACK），这一项一直保留在未完成连接队列中，直到三次握手的第三个分节（客户对服务器 SYN 的 ACK ）到达或者该项超时为止（源自Berkeley的实现为这些未完成连接的项设置的超时值为75秒）。 如果三次握手正常完成，该项就从未完成连接队列移到已完成连接队列的队尾。 backlog 参数历史上被定义为上面两个队列的大小之和，大多数实现默认值为 5，当服务器把这个完成连接队列的某个连接取走后，这个队列的位置又空出一个，这样来回实现动态平衡，但在高并发 web 服务器中此值显然不够。 ","date":"2022-01-26","objectID":"/posts/tcp%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E4%B8%ADconnectlistenaccept%E4%B8%89%E8%80%85%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB/:3:0","tags":["TCP网络编程中connect、listen、accept三者之间的关系"],"title":"TCP网络编程中connect、listen、accept三者之间的关系","uri":"/posts/tcp%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E4%B8%ADconnectlistenaccept%E4%B8%89%E8%80%85%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB/"},{"categories":["Linux网络编程"],"content":"accept()函数 accept()函数功能是，从处于 established 状态的连接队列头部取出一个已经完成的连接，如果这个队列没有已经完成的连接，accept()函数就会阻塞，直到取出队列中已完成的用户连接为止。 如果，服务器不能及时调用 accept() 取走队列中已完成的连接，队列满掉后会怎样呢？UNP（《unix网络编程》）告诉我们，服务器的连接队列满掉后，服务器不会对再对建立新连接的syn进行应答，所以客户端的 connect 就会返回 ETIMEDOUT。但实际上Linux的并不是这样的！ ","date":"2022-01-26","objectID":"/posts/tcp%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E4%B8%ADconnectlistenaccept%E4%B8%89%E8%80%85%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB/:4:0","tags":["TCP网络编程中connect、listen、accept三者之间的关系"],"title":"TCP网络编程中connect、listen、accept三者之间的关系","uri":"/posts/tcp%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E4%B8%ADconnectlistenaccept%E4%B8%89%E8%80%85%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB/"},{"categories":["Linux网络编程"],"content":"实验 下面为测试代码，服务器 listen() 函数只指定队列长度为 2，客户端有 6 个不同的套接字主动连接服务器，同时，保证客户端的 6 个 connect()函数都先调用完毕，服务器的 accpet() 才开始调用。 服务端： #include \u003cstdio.h\u003e#include \u003cstdlib.h\u003e#include \u003cstring.h\u003e #include \u003cunistd.h\u003e#include \u003csys/socket.h\u003e#include \u003cnetinet/in.h\u003e#include \u003carpa/inet.h\u003e int main(int argc, char *argv[]) { unsigned short port = 8000; int sockfd = socket(AF_INET, SOCK_STREAM, 0); if(sockfd \u003c 0) { perror(\"socket\"); exit(-1); } struct sockaddr_in my_addr; bzero(\u0026my_addr, sizeof(my_addr)); my_addr.sin_family = AF_INET; my_addr.sin_port = htons(port); my_addr.sin_addr.s_addr = htonl(INADDR_ANY); int err_log = bind(sockfd, (struct sockaddr*)\u0026my_addr, sizeof(my_addr)); if( err_log != 0) { perror(\"binding\"); close(sockfd); exit(-1); } err_log = listen(sockfd, 2); // 等待队列为2 if(err_log != 0) { perror(\"listen\"); close(sockfd); exit(-1); } printf(\"after listen\\n\"); sleep(20); //延时 20秒 printf(\"listen client @port=%d...\\n\",port); int i = 0; while(1) { struct sockaddr_in client_addr; char cli_ip[INET_ADDRSTRLEN] = \"\"; socklen_t cliaddr_len = sizeof(client_addr); int connfd; connfd = accept(sockfd, (struct sockaddr*)\u0026client_addr, \u0026cliaddr_len); if(connfd \u003c 0) { perror(\"accept\"); continue; } inet_ntop(AF_INET, \u0026client_addr.sin_addr, cli_ip, INET_ADDRSTRLEN); printf(\"-----------%d------\\n\", ++i); printf(\"client ip=%s,port=%d\\n\", cli_ip,ntohs(client_addr.sin_port)); char recv_buf[512] = {0}; while( recv(connfd, recv_buf, sizeof(recv_buf), 0) \u003e 0 ) { printf(\"recv data ==%s\\n\",recv_buf); break; } close(connfd); //关闭已连接套接字 //printf(\"client closed!\\n\"); } close(sockfd); //关闭监听套接字 return 0; } 客户端： #include \u003cstdio.h\u003e#include \u003cunistd.h\u003e#include \u003cstring.h\u003e#include \u003cstdlib.h\u003e#include \u003carpa/inet.h\u003e#include \u003csys/socket.h\u003e#include \u003cnetinet/in.h\u003e void test_connect() { unsigned short port = 8000; // 服务器的端口号 char *server_ip = \"10.221.20.12\"; // 服务器ip地址 int sockfd; sockfd = socket(AF_INET, SOCK_STREAM, 0);// 创建通信端点：套接字 if(sockfd \u003c 0) { perror(\"socket\"); exit(-1); } struct sockaddr_in server_addr; bzero(\u0026server_addr,sizeof(server_addr)); // 初始化服务器地址 server_addr.sin_family = AF_INET; server_addr.sin_port = htons(port); inet_pton(AF_INET, server_ip, \u0026server_addr.sin_addr); int err_log = connect(sockfd, (struct sockaddr*)\u0026server_addr, sizeof(server_addr)); // 主动连接服务器 if(err_log != 0) { perror(\"connect\"); close(sockfd); exit(-1); } printf(\"err_log ========= %d\\n\", err_log); char send_buf[100]=\"this is for test\"; send(sockfd, send_buf, strlen(send_buf), 0); // 向服务器发送信息 system(\"netstat -an | grep 8000\"); // 查看连接状态 //close(sockfd); } int main(int argc, char *argv[]) { pid_t pid; pid = fork(); if(0 == pid){ test_connect(); // 1 pid_t pid = fork(); if(0 == pid){ test_connect(); // 2 }else if(pid \u003e 0){ test_connect(); // 3 } }else if(pid \u003e 0){ test_connect(); // 4 pid_t pid = fork(); if(0 == pid){ test_connect(); // 5 }else if(pid \u003e 0){ test_connect(); // 6 } } while(1); return 0; } 服务器调用 accept()函数前延时了 20 秒。保证了客户端的 connect() 全部调用完毕后再调用 accept(),运行结果如下： 客户端运行效果图： 按照 UNP 的说法，连接队列满后（这里设置长度为 2，发了 6 个连接），以后再调用 connect() 应该统统超时失败，但实际上测试结果是：有的 connect()立刻成功返回了，有的经过明显延迟后成功返回了。对于服务器 accpet() 函数也是这样的结果：有的立马成功返回，有的延迟后成功返回。 对于上面服务器的代码，我们把lisen()的第二个参数改为 0 ，重新运行程序，发现： 客户端 connect() 全部返回连接成功（有些会延时）： 服务器 accpet() 函数却不能把连接队列的所有连接都取出来： 对于上面服务器的代码，我们把lisen()的第二个参数改为大于 6 的数(如 10)，重新运行程序，发现，客户端 connect() 立马返回连接成功， 服务器 accpet() 函数也立马返回成功。 ","date":"2022-01-26","objectID":"/posts/tcp%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E4%B8%ADconnectlistenaccept%E4%B8%89%E8%80%85%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB/:4:1","tags":["TCP网络编程中connect、listen、accept三者之间的关系"],"title":"TCP网络编程中connect、listen、accept三者之间的关系","uri":"/posts/tcp%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E4%B8%ADconnectlistenaccept%E4%B8%89%E8%80%85%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB/"},{"categories":["Linux网络编程"],"content":"总结 TCP 的连接队列满后，Linux 不会如书中所说的拒绝连接，只是有些会延时连接，但千万注意此时accept()就不一定能把已经建立好的连接全部取出来（如：当队列的长度指定为 0 ），写程序时服务器的 listen() 的第二个参数最好还是根据需要填写，写太大不好（具体可以看cat /proc/sys/net/core/somaxconn，默认最大值限制是 128），浪费资源，写太小也不好，延时建立连接。 ","date":"2022-01-26","objectID":"/posts/tcp%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E4%B8%ADconnectlistenaccept%E4%B8%89%E8%80%85%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB/:4:2","tags":["TCP网络编程中connect、listen、accept三者之间的关系"],"title":"TCP网络编程中connect、listen、accept三者之间的关系","uri":"/posts/tcp%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E4%B8%ADconnectlistenaccept%E4%B8%89%E8%80%85%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB/"},{"categories":["现代C++语法"],"content":"C++与python文件系统对比","date":"2022-01-25","objectID":"/posts/c++%E4%B8%8Epython%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%AF%B9%E6%AF%94/","tags":["C++与python文件系统对比"],"title":"C++与python文件系统对比","uri":"/posts/c++%E4%B8%8Epython%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%AF%B9%E6%AF%94/"},{"categories":["现代C++语法"],"content":"C++17 和 python 中好用的文件操作 | filesystem | os | shutil C++ 17 python 功能 filesystem::path::is_absolute() os.path.isabs() 判断是否为绝对路径 filesystem::path::parent_path() os.path.dirname() 路径分割 filesystem::path::filename() os.path.basename() 路径分割 filesystem::operator/() os.path.join() 路径拼接 filesystem::current_path() os.getcwd() 获取当前路径 filesystem::directory_iterator os.listdir() 返回指定目录下的所有文件/文件夹 filesystem::recursive_directory_iterator os.walk() 递归返回指定目录下的所有文件/文件夹 filesystem::exists() os.path.exists() 判断路径是否存在 filesystem::is_regular_file() os.path.isfile() 判断路径是文件还是目录 filesystem::is_directory() os.path.isdir() 判断路径是文件还是目录 filesystem::absolute() os.path.abspath() 返回绝对路径 filesystem::copy_file() shutil.copyfile() 文件拷贝 filesystem::remove() os.remove() 文件删除 filesystem::copy() shutil.copytree 路径拷贝 filesystem::remove_all shutil.rmtree() 路径删除 ","date":"2022-01-25","objectID":"/posts/c++%E4%B8%8Epython%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%AF%B9%E6%AF%94/:0:0","tags":["C++与python文件系统对比"],"title":"C++与python文件系统对比","uri":"/posts/c++%E4%B8%8Epython%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%AF%B9%E6%AF%94/"},{"categories":["现代C++语法"],"content":"filesystem::path vs. os.path filesystem::path是一个类，里面封装了很多方法，我们通过实例化之后直接调用方法。 os.path是一个模块，里面有很多函数，可以直接调用。 ","date":"2022-01-25","objectID":"/posts/c++%E4%B8%8Epython%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%AF%B9%E6%AF%94/:1:0","tags":["C++与python文件系统对比"],"title":"C++与python文件系统对比","uri":"/posts/c++%E4%B8%8Epython%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%AF%B9%E6%AF%94/"},{"categories":["现代C++语法"],"content":"判断是否为绝对路径 什么是绝对路径？我个人的理解是从根目录开始的就是绝对路径，例如/usr/local和C:\\\\Users，其余都是相对路径。可以发现，在不同操作系统中路径的分割符是不同的。同时在相对路径中./和../有特殊含义，./表示当前目录，../表示上一层目录，相应地，../../就是上两层目录。 1.filesystem::path中提供了判断是否为绝对路径/相对路径方法。 _LIBCPP_INLINE_VISIBILITY bool is_absolute() const { return has_root_directory(); } _LIBCPP_INLINE_VISIBILITY bool is_relative() const { return !is_absolute(); } 可以发现，判断相对路径的结果就是绝对路径取反。 void eg1_1() { /*判断是否为绝对路径*/ // std::filesystem::path abs_path = \"C:\\\\Users\"; std::filesystem::path abs_path = \"/usr/local\"; // 注意，实例化path的时候可以直接用等号 std::cout \u003c\u003c \"abs_path.is_absolute() : \" \u003c\u003c abs_path.is_absolute() \u003c\u003c std::endl; std::cout \u003c\u003c \"abs_path.is_relative() : \" \u003c\u003c abs_path.is_relative() \u003c\u003c std::endl; std::filesystem::path rel_path = \"../\"; std::cout \u003c\u003c \"rel_path.is_absolute() : \" \u003c\u003c rel_path.is_absolute() \u003c\u003c std::endl; std::cout \u003c\u003c \"rel_path.is_relative() : \" \u003c\u003c rel_path.is_relative() \u003c\u003c std::endl; } abs_path.is_absolute() : 1 abs_path.is_relative() : 0 rel_path.is_absolute() : 0 rel_path.is_relative() : 1 os.path中提供了isabs()函数用于判断是否为绝对路径。 def eg1_1(): \"\"\"判断是否为绝对路径\"\"\" # abs_path = \"C:\\\\Users\" abs_path = \"/usr/local\" print(\"os.path.isabs({}) : {}\".format(abs_path, os.path.isabs(abs_path))) rel_path = \"../\" print(\"os.path.isabs({}) : {}\".format(rel_path, os.path.isabs(rel_path))) os.path.isabs(/usr/local) : True os.path.isabs(../) : False ","date":"2022-01-25","objectID":"/posts/c++%E4%B8%8Epython%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%AF%B9%E6%AF%94/:1:1","tags":["C++与python文件系统对比"],"title":"C++与python文件系统对比","uri":"/posts/c++%E4%B8%8Epython%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%AF%B9%E6%AF%94/"},{"categories":["现代C++语法"],"content":"路径分割 filesystem::path中提供了路径分割的方法。 // decomposition _LIBCPP_INLINE_VISIBILITY path root_name() const { return string_type(__root_name()); } _LIBCPP_INLINE_VISIBILITY path root_directory() const { return string_type(__root_directory()); } _LIBCPP_INLINE_VISIBILITY path root_path() const { return root_name().append(string_type(__root_directory())); } _LIBCPP_INLINE_VISIBILITY path relative_path() const { return string_type(__relative_path()); } _LIBCPP_INLINE_VISIBILITY path parent_path() const { return string_type(__parent_path()); } _LIBCPP_INLINE_VISIBILITY path filename() const { return string_type(__filename()); } _LIBCPP_INLINE_VISIBILITY path stem() const { return string_type(__stem()); } _LIBCPP_INLINE_VISIBILITY path extension() const { return string_type(__extension()); } void eg1_2() { /*路径分割*/ std::filesystem::path path = \"../test_dir/1.txt\"; std::cout \u003c\u003c \"path.relative_path() : \" \u003c\u003c path.relative_path() \u003c\u003c std::endl; std::cout \u003c\u003c \"path.parent_path() : \" \u003c\u003c path.parent_path() \u003c\u003c std::endl; std::cout \u003c\u003c \"path.filename() : \" \u003c\u003c path.filename() \u003c\u003c std::endl; std::cout \u003c\u003c \"path.stem() : \" \u003c\u003c path.stem() \u003c\u003c std::endl; std::cout \u003c\u003c \"path.extension() : \" \u003c\u003c path.extension() \u003c\u003c std::endl; } path.relative_path() : \"../test_dir/1.txt\" path.parent_path() : \"../test_dir\" path.filename() : \"1.txt\" path.stem() : \"1\" path.extension() : \".txt\" os.path中提供了分割函数split()以及dirname()，basename()。 def eg1_2(): \"\"\"路径分割\"\"\" path = \"../test_dir/1.txt\" print(\"os.path.split(path) : {}\".format(os.path.split(path))) print(\"os.path.dirname(path) : {}\".format(os.path.dirname(path))) print(\"os.path.basename(path) : {}\".format(os.path.basename(path))) os.path.split(path) : ('../test_dir', '1.txt') os.path.dirname(path) : ../test_dir os.path.basename(path) : 1.txt ","date":"2022-01-25","objectID":"/posts/c++%E4%B8%8Epython%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%AF%B9%E6%AF%94/:1:2","tags":["C++与python文件系统对比"],"title":"C++与python文件系统对比","uri":"/posts/c++%E4%B8%8Epython%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%AF%B9%E6%AF%94/"},{"categories":["现代C++语法"],"content":"路径拼接 filesystem::path中重载了符号/和/=。 friend _LIBCPP_INLINE_VISIBILITY path operator/(const path\u0026 __lhs, const path\u0026 __rhs) { path __result(__lhs); __result /= __rhs; return __result; } void eg1_3() { /*路径拼接*/ std::filesystem::path path = \"../test_dir\"; std::filesystem::path txt1_path = path / \"1.txt\"; std::filesystem::path txt2_path = path / \"1_dir\" / \"2.txt\"; std::cout \u003c\u003c \"txt1_path : \" \u003c\u003c txt1_path \u003c\u003c std::endl; std::cout \u003c\u003c \"txt2_path : \" \u003c\u003c txt2_path \u003c\u003c std::endl; path /= \"1.txt\"; std::cout \u003c\u003c \"path : \" \u003c\u003c path \u003c\u003c std::endl; } txt1_path : \"../test_dir/1.txt\" txt2_path : \"../test_dir/1_dir/2.txt\" path : \"../test_dir/1.txt\" os.path中提供了join()函数。 def eg1_3(): \"\"\"路径拼接\"\"\" path = \"../test_dir\" txt1_path = os.path.join(path, \"1.txt\") txt2_path = os.path.join(path, \"1_dir\", \"2.txt\") print(\"txt1_path : {}\".format(txt1_path)) print(\"txt2_path : {}\".format(txt2_path)) txt1_path : ../test_dir/1.txt txt2_path : ../test_dir/1_dir/2.txt 注意，不同操作系统的分隔符不同，所以在Windows中运行结果如下。 txt1_path : ../test_dir\\1.txt txt2_path : ../test_dir\\1_dir\\2.txt ","date":"2022-01-25","objectID":"/posts/c++%E4%B8%8Epython%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%AF%B9%E6%AF%94/:1:3","tags":["C++与python文件系统对比"],"title":"C++与python文件系统对比","uri":"/posts/c++%E4%B8%8Epython%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%AF%B9%E6%AF%94/"},{"categories":["现代C++语法"],"content":"filesystem vs. os ","date":"2022-01-25","objectID":"/posts/c++%E4%B8%8Epython%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%AF%B9%E6%AF%94/:2:0","tags":["C++与python文件系统对比"],"title":"C++与python文件系统对比","uri":"/posts/c++%E4%B8%8Epython%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%AF%B9%E6%AF%94/"},{"categories":["现代C++语法"],"content":"获取当前工作目录 filesystem提供了获取当前路径的函数current_path()，注意返回的是绝对路径。 void eg2_1() { /*获取当前路径*/ std::filesystem::path current_path = std::filesystem::current_path(); std::cout \u003c\u003c \"current_path : \" \u003c\u003c current_path \u003c\u003c std::endl; } current_path : \"/Users/xxx/Github/intro_to_C-python/xxx/cmake-build-debug\" os提供了函数getcwd()。 def eg2_1(): \"\"\"获取当前路径\"\"\" current_path = os.getcwd() print(\"current_path : {}\".format(current_path)) current_path : /Users/xxx/Github/intro_to_C-python/xxx 这里先展示一下目录树，方便理解后边的例子。 └── test_dir ├── 1.txt └── 1_dir ├── 2.txt └── empty_dir ","date":"2022-01-25","objectID":"/posts/c++%E4%B8%8Epython%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%AF%B9%E6%AF%94/:2:1","tags":["C++与python文件系统对比"],"title":"C++与python文件系统对比","uri":"/posts/c++%E4%B8%8Epython%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%AF%B9%E6%AF%94/"},{"categories":["现代C++语法"],"content":"返回指定目录下的所有文件/文件夹 filesystem的类directory_iterator可以实现该功能。 void eg2_2() { /*返回指定目录下的所有文件/文件夹*/ std::filesystem::directory_iterator iter(\"../test_dir\"); for(const auto \u0026i : iter) { std::cout \u003c\u003c i.path() \u003c\u003cstd::endl; } } \"../test_dir/1.txt\" \"../test_dir/1_dir\" os中提供了函数listdir()。 def eg2_2(): \"\"\"返回指定目录下的所有文件/文件夹\"\"\" for i in os.listdir(\"./test_dir\"): print(i) 1.txt 1_dir ","date":"2022-01-25","objectID":"/posts/c++%E4%B8%8Epython%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%AF%B9%E6%AF%94/:2:2","tags":["C++与python文件系统对比"],"title":"C++与python文件系统对比","uri":"/posts/c++%E4%B8%8Epython%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%AF%B9%E6%AF%94/"},{"categories":["现代C++语法"],"content":"递归返回指定目录下的所有文件/文件夹 filesystem的类recursive_directory_iterator可以实现该功能。 void eg2_3() { /*递归返回指定目录下的所有文件/文件夹*/ std::filesystem::recursive_directory_iterator iter(\"../test_dir\"); for(const auto \u0026i : iter) { std::cout \u003c\u003c i.path() \u003c\u003cstd::endl; } } \"../test_dir/1.txt\" \"../test_dir/1_dir\" \"../test_dir/1_dir/empty_dir\" \"../test_dir/1_dir/2.txt\" os中提供了函数walk()。 def eg2_3(): \"\"\"递归返回指定目录下的所有文件/文件夹\"\"\" for root, dirs, files in os.walk(\"./test_dir\"): print(\"root : {}, dirs : {}, files : {}\".format(root, dirs, files)) root : ./test_dir, dirs : ['1_dir'], files : ['1.txt'] root : ./test_dir/1_dir, dirs : ['empty_dir'], files : ['2.txt'] root : ./test_dir/1_dir/empty_dir, dirs : [], files : [] ","date":"2022-01-25","objectID":"/posts/c++%E4%B8%8Epython%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%AF%B9%E6%AF%94/:2:3","tags":["C++与python文件系统对比"],"title":"C++与python文件系统对比","uri":"/posts/c++%E4%B8%8Epython%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%AF%B9%E6%AF%94/"},{"categories":["现代C++语法"],"content":"判断路径是否存在 filesystem提供了判断路径是否存在的函数exists()。 void eg2_4() { /*判断路径是否存在*/ bool exist = std::filesystem::exists(\"C:\\\\Users\"); std::cout \u003c\u003c \"exist : \" \u003c\u003c exist \u003c\u003c std::endl; } exist : 0 os.path中提供了函数exists()。 def eg2_4(): \"\"\"判断路径是否存在\"\"\" path = \"C:\\\\Users\" print(\"os.path.exists({}) : {}\".format(path, os.path.exists(path))) os.path.exists(C:\\Users) : False ","date":"2022-01-25","objectID":"/posts/c++%E4%B8%8Epython%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%AF%B9%E6%AF%94/:2:4","tags":["C++与python文件系统对比"],"title":"C++与python文件系统对比","uri":"/posts/c++%E4%B8%8Epython%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%AF%B9%E6%AF%94/"},{"categories":["现代C++语法"],"content":"判断路径是文件还是目录 filesystem提供了判断路径是文件还是目录的函数。（比较多） inline _LIBCPP_INLINE_VISIBILITY bool is_block_file(file_status __s) noexcept { return __s.type() == file_type::block; } inline _LIBCPP_INLINE_VISIBILITY bool is_block_file(const path\u0026 __p) { return is_block_file(__status(__p)); } inline _LIBCPP_INLINE_VISIBILITY bool is_block_file(const path\u0026 __p, error_code\u0026 __ec) noexcept { return is_block_file(__status(__p, \u0026__ec)); } inline _LIBCPP_INLINE_VISIBILITY bool is_character_file(file_status __s) noexcept { return __s.type() == file_type::character; } inline _LIBCPP_INLINE_VISIBILITY bool is_character_file(const path\u0026 __p) { return is_character_file(__status(__p)); } inline _LIBCPP_INLINE_VISIBILITY bool is_character_file(const path\u0026 __p, error_code\u0026 __ec) noexcept { return is_character_file(__status(__p, \u0026__ec)); } inline _LIBCPP_INLINE_VISIBILITY bool is_directory(file_status __s) noexcept { return __s.type() == file_type::directory; } inline _LIBCPP_INLINE_VISIBILITY bool is_directory(const path\u0026 __p) { return is_directory(__status(__p)); } inline _LIBCPP_INLINE_VISIBILITY bool is_directory(const path\u0026 __p, error_code\u0026 __ec) noexcept { return is_directory(__status(__p, \u0026__ec)); } inline _LIBCPP_INLINE_VISIBILITY bool is_empty(const path\u0026 __p) { return __fs_is_empty(__p); } inline _LIBCPP_INLINE_VISIBILITY bool is_empty(const path\u0026 __p, error_code\u0026 __ec) { return __fs_is_empty(__p, \u0026__ec); } inline _LIBCPP_INLINE_VISIBILITY bool is_fifo(file_status __s) noexcept { return __s.type() == file_type::fifo; } inline _LIBCPP_INLINE_VISIBILITY bool is_fifo(const path\u0026 __p) { return is_fifo(__status(__p)); } inline _LIBCPP_INLINE_VISIBILITY bool is_fifo(const path\u0026 __p, error_code\u0026 __ec) noexcept { return is_fifo(__status(__p, \u0026__ec)); } inline _LIBCPP_INLINE_VISIBILITY bool is_regular_file(file_status __s) noexcept { return __s.type() == file_type::regular; } inline _LIBCPP_INLINE_VISIBILITY bool is_regular_file(const path\u0026 __p) { return is_regular_file(__status(__p)); } inline _LIBCPP_INLINE_VISIBILITY bool is_regular_file(const path\u0026 __p, error_code\u0026 __ec) noexcept { return is_regular_file(__status(__p, \u0026__ec)); } inline _LIBCPP_INLINE_VISIBILITY bool is_socket(file_status __s) noexcept { return __s.type() == file_type::socket; } inline _LIBCPP_INLINE_VISIBILITY bool is_socket(const path\u0026 __p) { return is_socket(__status(__p)); } inline _LIBCPP_INLINE_VISIBILITY bool is_socket(const path\u0026 __p, error_code\u0026 __ec) noexcept { return is_socket(__status(__p, \u0026__ec)); } inline _LIBCPP_INLINE_VISIBILITY bool is_symlink(file_status __s) noexcept { return __s.type() == file_type::symlink; } inline _LIBCPP_INLINE_VISIBILITY bool is_symlink(const path\u0026 __p) { return is_symlink(__symlink_status(__p)); } inline _LIBCPP_INLINE_VISIBILITY bool is_symlink(const path\u0026 __p, error_code\u0026 __ec) noexcept { return is_symlink(__symlink_status(__p, \u0026__ec)); } inline _LIBCPP_INLINE_VISIBILITY bool is_other(file_status __s) noexcept { return exists(__s) \u0026\u0026 !is_regular_file(__s) \u0026\u0026 !is_directory(__s) \u0026\u0026 !is_symlink(__s); } inline _LIBCPP_INLINE_VISIBILITY bool is_other(const path\u0026 __p) { return is_other(__status(__p)); } inline _LIBCPP_INLINE_VISIBILITY bool is_other(const path\u0026 __p, error_code\u0026 __ec) noexcept { return is_other(__status(__p, \u0026__ec)); } void eg2_5() { /*判断路径是文件还是目录*/ std::filesystem::path file_path = \"../test_dir/1.txt\"; std::filesystem::path dir_path = \"../test_dir/1_dir\"; std::cout \u003c\u003c \"is_regular_file(file_path) : \" \u003c\u003c std::filesystem::is_regular_file(file_path) \u003c\u003c std::endl; std::cout \u003c\u003c \"is_directory(dir_path) : \" \u003c\u003c std::filesystem::is_directory(dir_path) \u003c\u003c std::endl; } is_regular_file(file_path) : 1 is_directory(dir_path) : 1 os.path中提供了函数isfile()和isdir()。 def eg2_5(): \"\"\"判断路径是文件还是目录\"\"\" file_path = \"./test_dir/1.txt\" dir_path = \"./test_dir/1_dir\" print(\"os.path.isfile({}) : {}\".format(file_path, os.path.isfile(file_path))) print(\"os.path.isdir({}) : {}\".format(dir_path, os.path.isdir(dir_path))) os.path.isfile(./test_dir/1.txt) : True os.path.i","date":"2022-01-25","objectID":"/posts/c++%E4%B8%8Epython%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%AF%B9%E6%AF%94/:2:5","tags":["C++与python文件系统对比"],"title":"C++与python文件系统对比","uri":"/posts/c++%E4%B8%8Epython%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%AF%B9%E6%AF%94/"},{"categories":["现代C++语法"],"content":"返回绝对路径【神奇】 filesystem中提供了函数absolute()。 void eg2_6() { /*返回绝对路径*/ std::filesystem::path path = \"../test_dir\"; std::filesystem::path abs_path = std::filesystem::absolute(path); std::cout \u003c\u003c \"abs_path : \" \u003c\u003c abs_path \u003c\u003c std::endl; std::cout \u003c\u003c \"exists(abs_path) : \" \u003c\u003c std::filesystem::exists(abs_path) \u003c\u003c std::endl; } abs_path : \"/Users/xxx/Github/intro_to_C-python/xxx/cmake-build-debug/../test_dir\" exists(abs_path) : 1 在Windows系统中结果如下。 abs_path : \"D:\\\\GitHub\\\\intro_to_C-python\\\\xxx\\\\test_dir\" exists(abs_path) : 1 os.path中提供了函数abspath()。 def eg2_6(): \"\"\"返回绝对路径\"\"\" path = \"../../-PyTorch-\" abs_path = os.path.abspath(path) print(\"abs_path : {}\".format(abs_path)) print(\"os.path.exists({}) : {}\".format(abs_path, os.path.exists(abs_path))) abs_path : /Users/xxx/Github/-PyTorch- os.path.exists(/Users/xxx/Github/-PyTorch-) : True ","date":"2022-01-25","objectID":"/posts/c++%E4%B8%8Epython%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%AF%B9%E6%AF%94/:2:6","tags":["C++与python文件系统对比"],"title":"C++与python文件系统对比","uri":"/posts/c++%E4%B8%8Epython%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%AF%B9%E6%AF%94/"},{"categories":["现代C++语法"],"content":"filesystem vs. shutil shutil = shell + util，对os进行一些补充。 ","date":"2022-01-25","objectID":"/posts/c++%E4%B8%8Epython%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%AF%B9%E6%AF%94/:3:0","tags":["C++与python文件系统对比"],"title":"C++与python文件系统对比","uri":"/posts/c++%E4%B8%8Epython%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%AF%B9%E6%AF%94/"},{"categories":["现代C++语法"],"content":"文件拷贝 filesystem中提供了copy_file()函数，可以拷贝文件或空文件夹。 void eg3_1() { /*文件拷贝*/ std::cout \u003c\u003c \"~~~~~~before copy_file~~~~~~\" \u003c\u003c std::endl; for (const auto \u0026i :std::filesystem::directory_iterator(\"../test_dir\")) { std::cout \u003c\u003c i.path() \u003c\u003c std::endl; } std::filesystem::copy_file(\"../test_dir/1.txt\", \"../test_dir/eg3_1.txt\"); std::cout \u003c\u003c \"~~~~~~after copy_file~~~~~~\" \u003c\u003c std::endl; for (const auto \u0026i :std::filesystem::directory_iterator(\"../test_dir\")) { std::cout \u003c\u003c i.path() \u003c\u003c std::endl; } } ~~~~~~before copy_file~~~~~~ \"../test_dir/1.txt\" \"../test_dir/1_dir\" ~~~~~~after copy_file~~~~~~ \"../test_dir/eg3_1.txt\" \"../test_dir/1.txt\" \"../test_dir/1_dir\" shutil中提供函数copyfile()。 def eg3_1(): \"\"\"文件拷贝\"\"\" print(\"~~~~~~before copy_file~~~~~~\") for i in os.listdir(\"./test_dir\"): print(i) src_path = \"./test_dir/1.txt\" dst_path = \"./test_dir/eg3_1.txt\" shutil.copyfile(src_path, dst_path) print(\"~~~~~~after copy_file~~~~~~\") for i in os.listdir(\"./test_dir\"): print(i) ~~~~~~before copy_file~~~~~~ 1.txt 1_dir ~~~~~~after copy_file~~~~~~ eg3_1.txt 1.txt 1_dir ","date":"2022-01-25","objectID":"/posts/c++%E4%B8%8Epython%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%AF%B9%E6%AF%94/:3:1","tags":["C++与python文件系统对比"],"title":"C++与python文件系统对比","uri":"/posts/c++%E4%B8%8Epython%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%AF%B9%E6%AF%94/"},{"categories":["现代C++语法"],"content":"文件删除 filesystem中提供了remove()函数，可以删除文件或空文件夹。 void eg3_2() { /*文件删除*/ std::cout \u003c\u003c \"~~~~~~before remove~~~~~~\" \u003c\u003c std::endl; for (const auto \u0026i :std::filesystem::directory_iterator(\"../test_dir\")) { std::cout \u003c\u003c i.path() \u003c\u003c std::endl; } std::filesystem::remove(\"../test_dir/eg3_1.txt\"); std::cout \u003c\u003c \"~~~~~~after remove~~~~~~\" \u003c\u003c std::endl; for (const auto \u0026i :std::filesystem::directory_iterator(\"../test_dir\")) { std::cout \u003c\u003c i.path() \u003c\u003c std::endl; } } ~~~~~~before remove~~~~~~ \"../test_dir/eg3_1.txt\" \"../test_dir/1.txt\" \"../test_dir/1_dir\" ~~~~~~after remove~~~~~~ \"../test_dir/1.txt\" \"../test_dir/1_dir\" os中提供了函数remove()。 def eg3_2(): \"\"\"文件删除\"\"\" print(\"~~~~~~before remove~~~~~~\") for i in os.listdir(\"./test_dir\"): print(i) rm_path = \"./test_dir/eg3_1.txt\" os.remove(rm_path) print(\"~~~~~~after remove~~~~~~\") for i in os.listdir(\"./test_dir\"): print(i) ~~~~~~before remove~~~~~~ eg3_1.txt 1.txt 1_dir ~~~~~~after remove~~~~~~ 1.txt 1_dir ","date":"2022-01-25","objectID":"/posts/c++%E4%B8%8Epython%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%AF%B9%E6%AF%94/:3:2","tags":["C++与python文件系统对比"],"title":"C++与python文件系统对比","uri":"/posts/c++%E4%B8%8Epython%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%AF%B9%E6%AF%94/"},{"categories":["现代C++语法"],"content":"路径拷贝 filesystem中提供了copy()函数，可以按照选项（是否递归）拷贝文件或文件夹。 void eg3_3() { /*路径拷贝*/ std::cout \u003c\u003c \"~~~~~~before copy[1_dir]~~~~~~\" \u003c\u003c std::endl; for (const auto \u0026i :std::filesystem::directory_iterator(\"../test_dir/1_dir\")) { std::cout \u003c\u003c i.path() \u003c\u003c std::endl; } std::filesystem::copy(\"../test_dir/1_dir\", \"../test_dir/eg3_3_dir\", std::filesystem::copy_options::recursive); std::cout \u003c\u003c \"~~~~~~after copy[eg3_3_dir]~~~~~~\" \u003c\u003c std::endl; for (const auto \u0026i :std::filesystem::directory_iterator(\"../test_dir/eg3_3_dir\")) { std::cout \u003c\u003c i.path() \u003c\u003c std::endl; } } ~~~~~~before copy[1_dir]~~~~~~ \"../test_dir/1_dir/empty_dir\" \"../test_dir/1_dir/2.txt\" ~~~~~~after copy[eg3_3_dir]~~~~~~ \"../test_dir/eg3_3_dir/empty_dir\" \"../test_dir/eg3_3_dir/2.txt\" shutil提供了函数copytree()。 def eg3_3(): \"\"\"路径拷贝\"\"\" print(\"~~~~~~before copy[1_dir]~~~~~~\") for i in os.listdir(\"./test_dir/1_dir\"): print(i) src_path = \"./test_dir/1_dir\" dst_path = \"./test_dir/eg3_3_dir\" shutil.copytree(src_path, dst_path) print(\"~~~~~~after copy[eg3_3_dir]~~~~~~\") for i in os.listdir(\"./test_dir/eg3_3_dir\"): print(i) ~~~~~~before copy[1_dir]~~~~~~ empty_dir 2.txt ~~~~~~after copy[eg3_3_dir]~~~~~~ empty_dir 2.txt ","date":"2022-01-25","objectID":"/posts/c++%E4%B8%8Epython%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%AF%B9%E6%AF%94/:3:3","tags":["C++与python文件系统对比"],"title":"C++与python文件系统对比","uri":"/posts/c++%E4%B8%8Epython%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%AF%B9%E6%AF%94/"},{"categories":["现代C++语法"],"content":"递归删除 filesystem中提供了remove_all()函数，可以递归删除文件或文件夹。 void eg3_4() { /*递归删除*/ std::filesystem::path dir_path = \"../test_dir/eg3_3_dir\"; std::cout \u003c\u003c \"exists(dir_path) : \" \u003c\u003c std::filesystem::exists(dir_path) \u003c\u003c std::endl; std::filesystem::remove_all(dir_path); std::cout \u003c\u003c \"exists(dir_path) : \" \u003c\u003c std::filesystem::exists(dir_path) \u003c\u003c std::endl; } exists(dir_path) : 1 exists(dir_path) : 0 shutil提供了函数rmtree()。 def eg3_4(): \"\"\"递归删除\"\"\" dir_path = \"./test_dir/eg3_3_dir\" print(\"os.path.exists({}) : {}\".format(dir_path, os.path.exists(dir_path))) shutil.rmtree(dir_path) print(\"os.path.exists({}) : {}\".format(dir_path, os.path.exists(dir_path))) os.path.exists(./test_dir/eg3_3_dir) : True os.path.exists(./test_dir/eg3_3_dir) : False ","date":"2022-01-25","objectID":"/posts/c++%E4%B8%8Epython%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%AF%B9%E6%AF%94/:3:4","tags":["C++与python文件系统对比"],"title":"C++与python文件系统对比","uri":"/posts/c++%E4%B8%8Epython%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%AF%B9%E6%AF%94/"},{"categories":["JavaSE笔记"],"content":"Java I/O","date":"2022-01-23","objectID":"/posts/java-io/","tags":["Java I/O"],"title":"Java I/O","uri":"/posts/java-io/"},{"categories":["JavaSE笔记"],"content":"Java I/O 配套视频 注意：这块会涉及到操作系统和计算机组成原理相关内容。 I/O简而言之，就是输入输出，那么为什么会有I/O呢？其实I/O无时无刻都在我们的身边，比如读取硬盘上的文件，网络文件传输，鼠标键盘输入，也可以是接受单片机发回的数据，而能够支持这些操作的设备就是I/O设备。 我们可以大致看一下整个计算机的总线结构： 常见的I/O设备一般是鼠标、键盘这类通过USB进行传输的外设或者是通过Sata接口或是M.2连接的硬盘。一般情况下，这些设备是由CPU发出指令通过南桥芯片间接进行控制，而不是由CPU直接操作。 而我们在程序中，想要读取这些外部连接的I/O设备中的内容，就需要将数据传输到内存中。而需要实现这样的操作，单单凭借一个小的程序是无法做到的，而操作系统（如：Windows/Linux/MacOS）就是专门用于控制和管理计算机硬件和软件资源的软件，我们需要读取一个IO设备的内容时，可以向操作系统发出请求，由操作系统帮助我们来和底层的硬件交互以完成我们的读取/写入请求。从读取硬盘文件的角度来说，不同的操作系统有着不同的文件系统（也就是文件在硬盘中的存储排列方式，如Windows就是NTFS、MacOS就是APFS），硬盘只能存储一个个0和1这样的二进制数据，至于0和1如何排列，各自又代表什么意思，就是由操作系统的文件系统来决定的。从网络通信角度来说，网络信号通过网卡等设备翻译为二进制信号，再交给系统进行读取，最后再由操作系统来给到程序。 JDK提供了一套用于IO操作的框架，根据流的传输方向和读取单位，分为字节流InputStream和OutputStream以及字符流Reader和Writer，当然，这里的Stream并不是前面集合框架认识的Stream，这里的流指的是数据流，通过流，我们就可以一直从流中读取数据，直到读取到尽头，或是不断向其中写入数据，直到我们写入完成。而这类IO就是我们所说的BIO， 字节流一次读取一个字节，也就是一个byte的大小，而字符流顾名思义，就是一次读取一个字符，也就是一个char的大小（在读取纯文本文件的时候更加适合），有关这两种流，会在后面详细介绍，这个章节我们需要学习16个关键的流。 ","date":"2022-01-23","objectID":"/posts/java-io/:0:0","tags":["Java I/O"],"title":"Java I/O","uri":"/posts/java-io/"},{"categories":["JavaSE笔记"],"content":"文件流 要学习和使用IO，首先就要从最易于理解的读取文件开始说起。 ","date":"2022-01-23","objectID":"/posts/java-io/:1:0","tags":["Java I/O"],"title":"Java I/O","uri":"/posts/java-io/"},{"categories":["JavaSE笔记"],"content":"文件字节流 首先介绍一下FileInputStream，通过它来获取文件的输入流。 public static void main(String[] args) { try { FileInputStream inputStream = new FileInputStream(\"路径\"); //路径支持相对路径和绝对路径 } catch (FileNotFoundException e) { e.printStackTrace(); } } 相对路径是在当前运行的路径下寻找文件，而绝对路径，是从根目录开始寻找。路径分割符支持使用/或是\\\\，但是不能写为\\因为它是转义字符！ 在使用完成一个流之后，必须关闭这个流来完成对资源的释放，否则资源会被一直占用！ public static void main(String[] args) { FileInputStream inputStream = null; //定义可以先放在try外部 try { inputStream = new FileInputStream(\"路径\"); } catch (FileNotFoundException e) { e.printStackTrace(); } finally { try { //建议在finally中进行，因为这个是任何情况都必须要执行的！ if(inputStream != null) inputStream.close(); } catch (IOException e) { e.printStackTrace(); } } } 虽然这样的写法才是最保险的，但是显得过于繁琐了，尤其是finally中再次嵌套了一个try-catch块，因此在JDK1.7新增了try-with-resource语法，用于简化这样的写法（本质上还是和这样的操作一致，只是换了个写法） public static void main(String[] args) { //注意，这种语法只支持实现了AutoCloseable接口的类！ try(FileInputStream inputStream = new FileInputStream(\"路径\")) { //直接在try()中定义要在完成之后释放的资源 } catch (IOException e) { //这里变成IOException是因为调用close()可能会出现，而FileNotFoundException是继承自IOException的 e.printStackTrace(); } //无需再编写finally语句块，因为在最后自动帮我们调用了close() } 之后为了方便，我们都使用此语法进行教学。 public static void main(String[] args) { //test.txt：a try(FileInputStream inputStream = new FileInputStream(\"test.txt\")) { //使用read()方法进行字符读取 System.out.println((char) inputStream.read()); //读取一个字节的数据（英文字母只占1字节，中文占2字节） System.out.println(inputStream.read()); //唯一一个字节的内容已经读完了，再次读取返回-1表示没有内容了 }catch (IOException e){ e.printStackTrace(); } } 使用read可以直接读取一个字节的数据，注意，流的内容是有限的，读取一个少一个！我们如果想一次性全部读取的话，可以直接使用一个while循环来完成： public static void main(String[] args) { //test.txt：abcd try(FileInputStream inputStream = new FileInputStream(\"test.txt\")) { int tmp; while ((tmp = inputStream.read()) != -1){ //通过while循环来一次性读完内容 System.out.println((char)tmp); } }catch (IOException e){ e.printStackTrace(); } } 使用方法能查看当前可读的剩余字节数量（注意：并不一定真实的数据量就是这么多，尤其是在网络I/O操作时，这个方法只能进行一个预估也可以说是暂时能一次性读取的数量） try(FileInputStream inputStream = new FileInputStream(\"test.txt\")) { System.out.println(inputStream.available()); //查看剩余数量 }catch (IOException e){ e.printStackTrace(); } 当然，一个一个读取效率太低了，那能否一次性全部读取呢？我们可以预置一个合适容量的byte[]数组来存放。 public static void main(String[] args) { //test.txt：abcd try(FileInputStream inputStream = new FileInputStream(\"test.txt\")) { byte[] bytes = new byte[inputStream.available()]; //我们可以提前准备好合适容量的byte数组来存放 System.out.println(inputStream.read(bytes)); //一次性读取全部内容（返回值是读取的字节数） System.out.println(new String(bytes)); //通过String(byte[])构造方法得到字符串 }catch (IOException e){ e.printStackTrace(); } } 也可以控制要读取数量： System.out.println(inputStream.read(bytes, 1, 2)); //第二个参数是从给定数组的哪个位置开始放入内容，第三个参数是读取流中的字节数 注意：一次性读取同单个读取一样，当没有任何数据可读时，依然会返回-1 通过skip()方法可以跳过指定数量的字节： public static void main(String[] args) { //test.txt：abcd try(FileInputStream inputStream = new FileInputStream(\"test.txt\")) { System.out.println(inputStream.skip(1)); System.out.println((char) inputStream.read()); //跳过了一个字节 }catch (IOException e){ e.printStackTrace(); } } 注意：FileInputStream是不支持reset()的，虽然有这个方法，但是这里先不提及。 既然有输入流，那么文件输出流也是必不可少的： public static void main(String[] args) { //输出流也需要在最后调用close()方法，并且同样支持try-with-resource try(FileOutputStream outputStream = new FileOutputStream(\"output.txt\")) { //注意：若此文件不存在，会直接创建这个文件！ }catch (IOException e){ e.printStackTrace(); } } 输出流没有read()操作而是write()操作，使用方法同输入流一样，只不过现在的方向变为我们向文件里写入内容： public static void main(String[] args) { try(FileOutputStream outputStream = new FileOutputStream(\"output.txt\")) { outputStream.write('c'); //同read一样，可以直接写入内容 outputStream.write(\"lbwnb\".getBytes()); //也可以直接写入byte[] outputStream.write(\"lbwnb\".getBytes(), 0, 1); //同上输入流 outputStream.flush(); //建议在最后执行一次刷新操作（强制写入）来保证数据正确写入到硬盘文件中 }catch (IOException e){ e.printStackTrace(); } } 那么如果是我只想在文件尾部进行追加写入数据呢？我们可以调用另一个构造方法来实现： public static void main(String[] args) { try(FileOutputStream outputStream = new FileOutputStream(\"output.txt\", true)) { outputStream.write(\"lb\".getBytes()); //现在只会进行追加写入，而不是直接替换原文件内容 outputStream.flush(); }catch (IOException e){ e.printStackTrace(); } } ","date":"2022-01-23","objectID":"/posts/java-io/:1:1","tags":["Java I/O"],"title":"Java I/O","uri":"/posts/java-io/"},{"categories":["JavaSE笔记"],"content":"文件字符流 字符流不同于字节，字符流是以一个具体的字符进行读取，因此它只适合读纯文本的文件，如果是其他类型的文件不适用： public static void main(String[] args) { try(FileReader reader = new FileReader(\"test.txt\")){ reader.skip(1); //现在跳过的是一个字符 System.out.println((char) reader.read()); //现在是按字符进行读取，而不是字节，因此可以直接读取到中文字符 }catch (IOException e){ e.printStackTrace(); } } 同理，字符流只支持char[]类型作为存储： public static void main(String[] args) { try(FileReader reader = new FileReader(\"test.txt\")){ char[] str = new char[10]; reader.read(str); System.out.println(str); //直接读取到char[]中 }catch (IOException e){ e.printStackTrace(); } } 既然有了Reader肯定也有Writer： public static void main(String[] args) { try(FileWriter writer = new FileWriter(\"output.txt\")){ writer.getEncoding(); //支持获取编码（不同的文本文件可能会有不同的编码类型） writer.write('牛'); writer.append('牛'); //其实功能和write一样 writer.flush(); //刷新 }catch (IOException e){ e.printStackTrace(); } } 我们发现不仅有write()方法，还有一个append()方法，但是实际上他们效果是一样的，看源码： /** * Appends the specified character to this writer. * * \u003cp\u003e An invocation of this method of the form \u003ctt\u003eout.append(c)\u003c/tt\u003e * behaves in exactly the same way as the invocation * * \u003cpre\u003e * out.write(c) \u003c/pre\u003e * * @param c * The 16-bit character to append * * @return This writer * * @throws IOException * If an I/O error occurs * * @since 1.5 */ public Writer append(char c) throws IOException { write(c); return this; } append支持像StringBuilder那样的链式调用，返回的是Writer对象本身。 练习：尝试一下用Reader和Writer来拷贝纯文本文件 ","date":"2022-01-23","objectID":"/posts/java-io/:1:2","tags":["Java I/O"],"title":"Java I/O","uri":"/posts/java-io/"},{"categories":["JavaSE笔记"],"content":"File类 File类专门用于表示一个文件或文件夹，只不过它只是代表这个文件，但并不是这个文件本身。通过File对象，可以更好地管理和操作硬盘上的文件。 public static void main(String[] args) { File file = new File(\"test.txt\"); //直接创建文件对象，可以是相对路径，也可以是绝对路径 System.out.println(file.exists()); //此文件是否存在 System.out.println(file.length()); //获取文件的大小 System.out.println(file.isDirectory()); //是否为一个文件夹 System.out.println(file.canRead()); //是否可读 System.out.println(file.canWrite()); //是否可写 System.out.println(file.canExecute()); //是否可执行 } 通过File对象，我们就能快速得到文件的所有信息，如果是文件夹，还可以获取文件夹内部的文件列表等内容： File file = new File(\"/\"); System.out.println(Arrays.toString(file.list())); //快速获取文件夹下的文件名称列表 for (File f : file.listFiles()){ //所有子文件的File对象 System.out.println(f.getAbsolutePath()); //获取文件的绝对路径 } 如果我们希望读取某个文件的内容，可以直接将File作为参数传入字节流或是字符流： File file = new File(\"test.txt\"); try (FileInputStream inputStream = new FileInputStream(file)){ //直接做参数 System.out.println(inputStream.available()); }catch (IOException e){ e.printStackTrace(); } 练习：尝试拷贝文件夹下的所有文件到另一个文件夹 ","date":"2022-01-23","objectID":"/posts/java-io/:1:3","tags":["Java I/O"],"title":"Java I/O","uri":"/posts/java-io/"},{"categories":["JavaSE笔记"],"content":"缓冲流 虽然普通的文件流读取文件数据非常便捷，但是每次都需要从外部I/O设备去获取数据，由于外部I/O设备的速度一般都达不到内存的读取速度，很有可能造成程序反应迟钝，因此性能还不够高，而缓冲流正如其名称一样，它能够提供一个缓冲，提前将部分内容存入内存（缓冲区）在下次读取时，如果缓冲区中存在此数据，则无需再去请求外部设备。同理，当向外部设备写入数据时，也是由缓冲区处理，而不是直接向外部设备写入。 ","date":"2022-01-23","objectID":"/posts/java-io/:2:0","tags":["Java I/O"],"title":"Java I/O","uri":"/posts/java-io/"},{"categories":["JavaSE笔记"],"content":"缓冲字节流 要创建一个缓冲字节流，只需要将原本的流作为构造参数传入BufferedInputStream即可： public static void main(String[] args) { try (BufferedInputStream bufferedInputStream = new BufferedInputStream(new FileInputStream(\"test.txt\"))){ //传入FileInputStream System.out.println((char) bufferedInputStream.read()); //操作和原来的流是一样的 }catch (IOException e){ e.printStackTrace(); } } 实际上进行I/O操作的并不是BufferedInputStream，而是我们传入的FileInputStream，而BufferedInputStream虽然有着同样的方法，但是进行了一些额外的处理然后再调用FileInputStream的同名方法，这样的写法称为装饰者模式 public void close() throws IOException { byte[] buffer; while ( (buffer = buf) != null) { if (bufUpdater.compareAndSet(this, buffer, null)) { //CAS无锁算法，并发会用到，暂时不管 InputStream input = in; in = null; if (input != null) input.close(); return; } // Else retry in case a new buf was CASed in fill() } } 实际上这种模式是父类FilterInputStream提供的规范，后面我们还会讲到更多FilterInputStream的子类。 我们可以发现在BufferedInputStream中还存在一个专门用于缓存的数组： /** * The internal buffer array where the data is stored. When necessary, * it may be replaced by another array of * a different size. */ protected volatile byte buf[]; I/O操作一般不能重复读取内容（比如键盘发送的信号，主机接收了就没了），而缓冲流提供了缓冲机制，一部分内容可以被暂时保存，BufferedInputStream支持reset()和mark()操作，首先我们来看看mark()方法的介绍： /** * Marks the current position in this input stream. A subsequent * call to the \u003ccode\u003ereset\u003c/code\u003e method repositions this stream at * the last marked position so that subsequent reads re-read the same bytes. * \u003cp\u003e * The \u003ccode\u003ereadlimit\u003c/code\u003e argument tells this input stream to * allow that many bytes to be read before the mark position gets * invalidated. * \u003cp\u003e * This method simply performs \u003ccode\u003ein.mark(readlimit)\u003c/code\u003e. * * @param readlimit the maximum limit of bytes that can be read before * the mark position becomes invalid. * @see java.io.FilterInputStream#in * @see java.io.FilterInputStream#reset() */ public synchronized void mark(int readlimit) { in.mark(readlimit); } 当调用mark()之后，输入流会以某种方式保留之后读取的readlimit数量的内容，当读取的内容数量超过readlimit则之后的内容不会被保留，当调用reset()之后，会使得当前的读取位置回到mark()调用时的位置。 public static void main(String[] args) { try (BufferedInputStream bufferedInputStream = new BufferedInputStream(new FileInputStream(\"test.txt\"))){ bufferedInputStream.mark(1); //只保留之后的1个字符 System.out.println((char) bufferedInputStream.read()); System.out.println((char) bufferedInputStream.read()); bufferedInputStream.reset(); //回到mark时的位置 System.out.println((char) bufferedInputStream.read()); System.out.println((char) bufferedInputStream.read()); }catch (IOException e) { e.printStackTrace(); } } 我们发现虽然后面的部分没有保存，但是依然能够正常读取，其实mark()后保存的读取内容是取readlimit和BufferedInputStream类的缓冲区大小两者中的最大值，而并非完全由readlimit确定。因此我们限制一下缓冲区大小，再来观察一下结果： public static void main(String[] args) { try (BufferedInputStream bufferedInputStream = new BufferedInputStream(new FileInputStream(\"test.txt\"), 1)){ //将缓冲区大小设置为1 bufferedInputStream.mark(1); //只保留之后的1个字符 System.out.println((char) bufferedInputStream.read()); System.out.println((char) bufferedInputStream.read()); //已经超过了readlimit，继续读取会导致mark失效 bufferedInputStream.reset(); //mark已经失效，无法reset() System.out.println((char) bufferedInputStream.read()); System.out.println((char) bufferedInputStream.read()); }catch (IOException e) { e.printStackTrace(); } } 了解完了BufferedInputStream之后，我们再来看看BufferedOutputStream，其实和BufferedInputStream原理差不多，只是反向操作： public static void main(String[] args) { try (BufferedOutputStream outputStream = new BufferedOutputStream(new FileOutputStream(\"output.txt\"))){ outputStream.write(\"lbwnb\".getBytes()); outputStream.flush(); }catch (IOException e) { e.printStackTrace(); } } 操作和FileOutputStream一致，这里就不多做介绍了。 ","date":"2022-01-23","objectID":"/posts/java-io/:2:1","tags":["Java I/O"],"title":"Java I/O","uri":"/posts/java-io/"},{"categories":["JavaSE笔记"],"content":"缓冲字符流 缓存字符流和缓冲字节流一样，也有一个专门的缓冲区，BufferedReader构造时需要传入一个Reader对象： public static void main(String[] args) { try (BufferedReader reader = new BufferedReader(new FileReader(\"test.txt\"))){ System.out.println((char) reader.read()); }catch (IOException e) { e.printStackTrace(); } } 使用和reader也是一样的，内部也包含一个缓存数组： private char cb[]; 相比Reader更方便的是，它支持按行读取： public static void main(String[] args) { try (BufferedReader reader = new BufferedReader(new FileReader(\"test.txt\"))){ System.out.println(reader.readLine()); //按行读取 }catch (IOException e) { e.printStackTrace(); } } 读取后直接得到一个字符串，当然，它还能把每一行内容依次转换为集合类提到的Stream流： public static void main(String[] args) { try (BufferedReader reader = new BufferedReader(new FileReader(\"test.txt\"))){ reader .lines() .limit(2) .distinct() .sorted() .forEach(System.out::println); }catch (IOException e) { e.printStackTrace(); } } 它同样也支持mark()和reset()操作： public static void main(String[] args) { try (BufferedReader reader = new BufferedReader(new FileReader(\"test.txt\"))){ reader.mark(1); System.out.println((char) reader.read()); reader.reset(); System.out.println((char) reader.read()); }catch (IOException e) { e.printStackTrace(); } } BufferedReader处理纯文本文件时就更加方便了，BufferedWriter在处理时也同样方便： public static void main(String[] args) { try (BufferedWriter reader = new BufferedWriter(new FileWriter(\"output.txt\"))){ reader.newLine(); //使用newLine进行换行 reader.write(\"汉堡做滴彳亍不彳亍\"); //可以直接写入一个字符串 reader.flush(); //清空缓冲区 }catch (IOException e) { e.printStackTrace(); } } ","date":"2022-01-23","objectID":"/posts/java-io/:2:2","tags":["Java I/O"],"title":"Java I/O","uri":"/posts/java-io/"},{"categories":["JavaSE笔记"],"content":"转换流 有时会遇到这样一个很麻烦的问题：我这里读取的是一个字符串或是一个个字符，但是我只能往一个OutputStream里输出，但是OutputStream又只支持byte类型，如果要往里面写入内容，进行数据转换就会很麻烦，那么能否有更加简便的方式来做这样的事情呢？ public static void main(String[] args) { try(OutputStreamWriter writer = new OutputStreamWriter(new FileOutputStream(\"test.txt\"))){ //虽然给定的是FileOutputStream，但是现在支持以Writer的方式进行写入 writer.write(\"lbwnb\"); //以操作Writer的样子写入OutputStream }catch (IOException e){ e.printStackTrace(); } } 同样的，我们现在只拿到了一个InputStream，但是我们希望能够按字符的方式读取，我们就可以使用InputStreamReader来帮助我们实现： public static void main(String[] args) { try(InputStreamReader reader = new InputStreamReader(new FileInputStream(\"test.txt\"))){ //虽然给定的是FileInputStream，但是现在支持以Reader的方式进行读取 System.out.println((char) reader.read()); }catch (IOException e){ e.printStackTrace(); } } InputStreamReader和OutputStreamWriter本质也是Reader和Writer，因此可以直接放入BufferedReader来实现更加方便的操作。 ","date":"2022-01-23","objectID":"/posts/java-io/:3:0","tags":["Java I/O"],"title":"Java I/O","uri":"/posts/java-io/"},{"categories":["JavaSE笔记"],"content":"打印流 打印流其实我们从一开始就在使用了，比如System.out就是一个PrintStream，PrintStream也继承自FilterOutputStream类因此依然是装饰我们传入的输出流，但是它存在自动刷新机制，例如当向PrintStream流中写入一个字节数组后自动调用flush()方法。PrintStream也永远不会抛出异常，而是使用内部检查机制checkError()方法进行错误检查。最方便的是，它能够格式化任意的类型，将它们以字符串的形式写入到输出流。 public final static PrintStream out = null; 可以看到System.out也是PrintStream，不过默认是向控制台打印，我们也可以让它向文件中打印： public static void main(String[] args) { try(PrintStream stream = new PrintStream(new FileOutputStream(\"test.txt\"))){ stream.println(\"lbwnb\"); //其实System.out就是一个PrintStream }catch (IOException e){ e.printStackTrace(); } } 我们平时使用的println方法就是PrintStream中的方法，它会直接打印基本数据类型或是调用对象的toString()方法得到一个字符串，并将字符串转换为字符，放入缓冲区再经过转换流输出到给定的输出流上。 因此实际上内部还包含这两个内容： /** * Track both the text- and character-output streams, so that their buffers * can be flushed without flushing the entire stream. */ private BufferedWriter textOut; private OutputStreamWriter charOut; 与此相同的还有一个PrintWriter，不过他们的功能基本一致，PrintWriter的构造方法可以接受一个Writer作为参数，这里就不再做过多阐述了。 ","date":"2022-01-23","objectID":"/posts/java-io/:4:0","tags":["Java I/O"],"title":"Java I/O","uri":"/posts/java-io/"},{"categories":["JavaSE笔记"],"content":"数据流 数据流DataInputStream也是FilterInputStream的子类，同样采用装饰者模式，最大的不同是它支持基本数据类型的直接读取： public static void main(String[] args) { try (DataInputStream dataInputStream = new DataInputStream(new FileInputStream(\"test.txt\"))){ System.out.println(dataInputStream.readBoolean()); //直接将数据读取为任意基本数据类型 }catch (IOException e) { e.printStackTrace(); } } 用于写入基本数据类型： public static void main(String[] args) { try (DataOutputStream dataOutputStream = new DataOutputStream(new FileOutputStream(\"output.txt\"))){ dataOutputStream.writeBoolean(false); }catch (IOException e) { e.printStackTrace(); } } 注意，写入的是二进制数据，并不是写入的字符串，使用DataInputStream可以读取，一般他们是配合一起使用的。 ","date":"2022-01-23","objectID":"/posts/java-io/:5:0","tags":["Java I/O"],"title":"Java I/O","uri":"/posts/java-io/"},{"categories":["JavaSE笔记"],"content":"对象流 既然基本数据类型能够读取和写入基本数据类型，那么能否将对象也支持呢？ObjectOutputStream不仅支持基本数据类型，通过对对象的序列化操作，以某种格式保存对象，来支持对象类型的IO，注意：它不是继承自FilterInputStream的。 public static void main(String[] args) { try (ObjectOutputStream outputStream = new ObjectOutputStream(new FileOutputStream(\"output.txt\")); ObjectInputStream inputStream = new ObjectInputStream(new FileInputStream(\"output.txt\"))){ People people = new People(\"lbw\"); outputStream.writeObject(people); outputStream.flush(); people = (People) inputStream.readObject(); System.out.println(people.name); }catch (IOException | ClassNotFoundException e) { e.printStackTrace(); } } static class People implements Serializable{ //必须实现Serializable接口才能被序列化 String name; public People(String name){ this.name = name; } } 在我们后续的操作中，有可能会使得这个类的一些结构发生变化，而原来保存的数据只适用于之前版本的这个类，因此我们需要一种方法来区分类的不同版本： static class People implements Serializable{ private static final long serialVersionUID = 123456; //在序列化时，会被自动添加这个属性，它代表当前类的版本，我们也可以手动指定版本。 String name; public People(String name){ this.name = name; } } 当发生版本不匹配时，会无法反序列化为对象： java.io.InvalidClassException: com.test.Main$People; local class incompatible: stream classdesc serialVersionUID = 123456, local class serialVersionUID = 1234567 at java.io.ObjectStreamClass.initNonProxy(ObjectStreamClass.java:699) at java.io.ObjectInputStream.readNonProxyDesc(ObjectInputStream.java:2003) at java.io.ObjectInputStream.readClassDesc(ObjectInputStream.java:1850) at java.io.ObjectInputStream.readOrdinaryObject(ObjectInputStream.java:2160) at java.io.ObjectInputStream.readObject0(ObjectInputStream.java:1667) at java.io.ObjectInputStream.readObject(ObjectInputStream.java:503) at java.io.ObjectInputStream.readObject(ObjectInputStream.java:461) at com.test.Main.main(Main.java:27) 如果我们不希望某些属性参与到序列化中进行保存，我们可以添加transient关键字： public static void main(String[] args) { try (ObjectOutputStream outputStream = new ObjectOutputStream(new FileOutputStream(\"output.txt\")); ObjectInputStream inputStream = new ObjectInputStream(new FileInputStream(\"output.txt\"))){ People people = new People(\"lbw\"); outputStream.writeObject(people); outputStream.flush(); people = (People) inputStream.readObject(); System.out.println(people.name); //虽然能得到对象，但是name属性并没有保存，因此为null }catch (IOException | ClassNotFoundException e) { e.printStackTrace(); } } static class People implements Serializable{ private static final long serialVersionUID = 1234567; transient String name; public People(String name){ this.name = name; } } 其实我们可以看到，在一些JDK内部的源码中，也存在大量的transient关键字，使得某些属性不参与序列化，取消这些不必要保存的属性，可以节省数据空间占用以及减少序列化时间。 ","date":"2022-01-23","objectID":"/posts/java-io/:6:0","tags":["Java I/O"],"title":"Java I/O","uri":"/posts/java-io/"},{"categories":["JavaSE笔记"],"content":"Java I/O编程实战 ","date":"2022-01-23","objectID":"/posts/java-io/:7:0","tags":["Java I/O"],"title":"Java I/O","uri":"/posts/java-io/"},{"categories":["JavaSE笔记"],"content":"图书管理系统 要求实现一个图书管理系统（控制台），支持以下功能：保存书籍信息（要求持久化），查询、添加、删除、修改书籍信息。 参考代码： import java.io.*; import java.util.HashSet; import java.util.Objects; import java.util.Scanner; public class Library { static private HashSet\u003cBook\u003e MAP; public static void main(String[] args) { //TODO 注意先分配内存 Scanner scan = new Scanner(System.in); readData(); while (true) { System.out.println(\"============图书馆管理系统===========\"); System.out.println(\"1.插入数据\"); System.out.println(\"2.修改数据\"); System.out.println(\"3.查询图书列表\"); System.out.println(\"4.删除图书\"); System.out.println(\"(按下任意其他键退出程序)\"); String str = scan.nextLine(); switch (str) { case \"1\": insertBooks(scan); break; case \"2\": modifyBook(scan); break; case \"3\": showBooks(); break; case \"4\": deleteBooks(scan); break; default: saveData(); scan.close(); return; } } } //TODO 程序启动前，读取持久化数据 private static void readData(){ File file = new File(\"data\"); if(file.exists()){ try(ObjectInputStream inputStream = new ObjectInputStream(new FileInputStream(\"data\"))){ MAP = (HashSet\u003cBook\u003e) inputStream.readObject(); }catch (IOException|ClassNotFoundException e){ e.printStackTrace(); } }else { MAP = new HashSet\u003c\u003e(); } } //TODO 程序结束时，持久序列化保存数据 private static void saveData(){ try(ObjectOutputStream outputStream = new ObjectOutputStream(new FileOutputStream(\"data\"))){ outputStream.writeObject(MAP); outputStream.flush(); }catch (IOException e){ e.printStackTrace(); } } //TODO 修改图书数据 private static void modifyBook(Scanner scan) { showBooks(); System.out.println(\"输入您要修改书籍的索书号：\"); int index = scan.nextInt(); scan.nextLine(); Book t = new Book().setIndex(index); if (!MAP.contains(t)) { System.out.println(\"输入错误图书馆内无该书籍!\"); } else { System.out.println(\"请输入您要更改的信息：书名，作者，价格\"); String name = scan.nextLine(); String author = scan.nextLine(); double price = scan.nextDouble(); scan.nextLine(); for (Book tt : MAP) { if (tt.equals(t)) { tt.setAuthor(author); tt.setName(name); tt.setPrice(price); break; } } } } //TODO 删除书籍 private static void deleteBooks(Scanner scan) { showBooks(); System.out.println(\"请输入要删除书籍的索书号：\"); int index = scan.nextInt(); scan.nextLine(); Book t = new Book().setIndex(index); if (!MAP.contains(t)) { System.out.println(\"索书号出错没有这样的书籍\"); } else { System.out.printf(\"删除索书号为:%d 的书籍成功!\\n\", index); MAP.remove(t); } } //TODO 显示图书信息 private static void showBooks() { MAP.forEach(System.out::println); } //TODO 插入书籍 private static void insertBooks(Scanner scan) { System.out.println(\"请输入 索书号 书名 作者 价格。每输入一个信息按下回车键确认！\"); MAP.add(new Book().setIndex(scan.nextInt()) .setName(scan.nextLine() + scan.nextLine()) .setAuthor(scan.nextLine()) .setPrice(scan.nextDouble()) ); scan.nextLine(); } //TODO 书籍类 private static class Book implements Serializable{ int index;//索书号 String name;//书名 String author;//作者 double price;//价格 public Book setName(String name) { this.name = name; return this; } public Book setIndex(int index) { this.index = index; return this; } public Book setAuthor(String author) { this.author = author; return this; } public Book setPrice(double price) { this.price = price; return this; } @Override public String toString() { return \"书籍{\" + \"索书号=\" + index + \", 书名='\" + name + '\\'' + \", 作者='\" + author + '\\'' + \", 价格=\" + price + '}'; } @Override public boolean equals(Object o) { if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; Book book = (Book) o; return index == book.index; } @Override public int hashCode() { return Objects.hash(index); } } } ","date":"2022-01-23","objectID":"/posts/java-io/:7:1","tags":["Java I/O"],"title":"Java I/O","uri":"/posts/java-io/"},{"categories":["JavaSE笔记"],"content":"Java反射与注解","date":"2022-01-23","objectID":"/posts/java%E5%8F%8D%E5%B0%84%E4%B8%8E%E6%B3%A8%E5%B0%84/","tags":["Java反射与注解"],"title":"Java反射与注解","uri":"/posts/java%E5%8F%8D%E5%B0%84%E4%B8%8E%E6%B3%A8%E5%B0%84/"},{"categories":["JavaSE笔记"],"content":"Java反射和注解 配套视频 **注意：**本章节涉及到JVM相关底层原理，难度会有一些大。 反射就是把Java类中的各个成分映射成一个个的Java对象。即在运行状态中，对于任意一个类，都能够知道这个类所有的属性和方法，对于任意一个对象，都能调用它的任意一个方法和属性。这种动态获取信息及动态调用对象方法的功能叫Java的反射机制。 简而言之，我们可以通过反射机制，获取到类的一些属性，包括类里面有哪些字段，有哪些方法，继承自哪个类，甚至还能获取到泛型！它的权限非常高，慎重使用！ ","date":"2022-01-23","objectID":"/posts/java%E5%8F%8D%E5%B0%84%E4%B8%8E%E6%B3%A8%E5%B0%84/:0:0","tags":["Java反射与注解"],"title":"Java反射与注解","uri":"/posts/java%E5%8F%8D%E5%B0%84%E4%B8%8E%E6%B3%A8%E5%B0%84/"},{"categories":["JavaSE笔记"],"content":"Java类加载机制 在学习Java的反射机制之前，我们需要先了解一下类的加载机制，一个类是如何被加载和使用的： 在Java程序启动时，JVM会将一部分类（class文件）先加载（并不是所有的类都会在一开始加载），通过ClassLoader将类加载，在加载过程中，会将类的信息提取出来（存放在元空间中，JDK1.8之前存放在永久代），同时也会生成一个Class对象存放在内存（堆内存），注意此Class对象只会存在一个，与加载的类唯一对应！ **思考：**既然说和与加载的类唯一对应，那如果我们手动创建一个与JDK包名一样，同时类名也保持一致，那么JVM会加载这个类吗？ package java.lang; public class String { //JDK提供的String类也是 public static void main(String[] args) { System.out.println(\"我姓🐴，我叫🐴nb\"); } } 我们发现，会出现以下报错： 错误: 在类 java.lang.String 中找不到 main 方法, 请将 main 方法定义为: public static void main(String[] args) 但是我们明明在自己写的String类中定义了main方法啊，为什么会找不到此方法呢？实际上这是ClassLoader的双亲委派机制在保护Java程序的正常运行： 实际上我们的类最开始是由BootstarpClassLoader进行加载，BootstarpClassLoader用于加载JDK提供的类，而我们自己编写的类实际上是AppClassLoader，只有BootstarpClassLoader都没有加载的类，才会让AppClassLoader来加载，因此我们自己编写的同名包同名类不会被加载，而实际要去启动的是真正的String类，也就自然找不到main方法了！ public class Main { public static void main(String[] args) { System.out.println(Main.class.getClassLoader()); //查看当前类的类加载器 System.out.println(Main.class.getClassLoader().getParent()); //父加载器 System.out.println(Main.class.getClassLoader().getParent().getParent()); //爷爷加载器 System.out.println(String.class.getClassLoader()); //String类的加载器 } } 由于BootstarpClassLoader是C++编写的，我们在Java中是获取不到的。 ","date":"2022-01-23","objectID":"/posts/java%E5%8F%8D%E5%B0%84%E4%B8%8E%E6%B3%A8%E5%B0%84/:1:0","tags":["Java反射与注解"],"title":"Java反射与注解","uri":"/posts/java%E5%8F%8D%E5%B0%84%E4%B8%8E%E6%B3%A8%E5%B0%84/"},{"categories":["JavaSE笔记"],"content":"Class对象 通过前面，我们了解了类的加载，同时会提取一个类的信息生成Class对象存放在内存中，而反射机制其实就是利用这些存放的类信息，来获取类的信息和操作类。那么如何获取到每个类对应的Class对象呢，我们可以通过以下方式： public static void main(String[] args) throws ClassNotFoundException { Class\u003cString\u003e clazz = String.class; //使用class关键字，通过类名获取 Class\u003c?\u003e clazz2 = Class.forName(\"java.lang.String\"); //使用Class类静态方法forName()，通过包名.类名获取，注意返回值是Class\u003c?\u003e Class\u003c?\u003e clazz3 = new String(\"cpdd\").getClass(); //通过实例对象获取 } 注意Class类也是一个泛型类，只有第一种方法，能够直接获取到对应类型的Class对象，而以下两种方法使用了?通配符作为返回值，但是实际上都和第一个返回的是同一个对象： Class\u003cString\u003e clazz = String.class; //使用class关键字，通过类名获取 Class\u003c?\u003e clazz2 = Class.forName(\"java.lang.String\"); //使用Class类静态方法forName()，通过包名.类名获取，注意返回值是Class\u003c?\u003e Class\u003c?\u003e clazz3 = new String(\"cpdd\").getClass(); System.out.println(clazz == clazz2); System.out.println(clazz == clazz3); 通过比较，验证了我们一开始的结论，在JVM中每个类始终只存在一个Class对象，无论通过什么方法获取，都是一样的。现在我们再来看看这个问题： public static void main(String[] args) { Class\u003c?\u003e clazz = int.class; //基本数据类型有Class对象吗？ System.out.println(clazz); } 迷了，不是每个类才有Class对象吗，基本数据类型又不是类，这也行吗？实际上，基本数据类型也有对应的Class对象（反射操作可能需要用到），而且我们不仅可以通过class关键字获取，其实本质上是定义在对应的包装类中的： /** * The {@code Class} instance representing the primitive type * {@code int}. * * @since JDK1.1 */ @SuppressWarnings(\"unchecked\") public static final Class\u003cInteger\u003e TYPE = (Class\u003cInteger\u003e) Class.getPrimitiveClass(\"int\"); /* * Return the Virtual Machine's Class object for the named * primitive type */ static native Class\u003c?\u003e getPrimitiveClass(String name); //C++实现，并非Java定义 每个包装类中（包括Void），都有一个获取原始类型Class方法，注意，getPrimitiveClass获取的是原始类型，并不是包装类型，只是可以使用包装类来表示。 public static void main(String[] args) { Class\u003c?\u003e clazz = int.class; System.out.println(Integer.TYPE == int.class); } 通过对比，我们发现实际上包装类型都有一个TYPE，其实也就是基本类型的Class，那么包装类的Class和基本类的Class一样吗？ public static void main(String[] args) { System.out.println(Integer.TYPE == Integer.class); } 我们发现，包装类型的Class对象并不是基本类型Class对象。数组类型也是一种类型，只是编程不可见，因此我们可以直接获取数组的Class对象： public static void main(String[] args) { Class\u003cString[]\u003e clazz = String[].class; System.out.println(clazz.getName()); //获取类名称（得到的是包名+类名的完整名称） System.out.println(clazz.getSimpleName()); System.out.println(clazz.getTypeName()); System.out.println(clazz.getClassLoader()); //获取它的类加载器 System.out.println(clazz.cast(new Integer(\"10\"))); //强制类型转换 } ","date":"2022-01-23","objectID":"/posts/java%E5%8F%8D%E5%B0%84%E4%B8%8E%E6%B3%A8%E5%B0%84/:2:0","tags":["Java反射与注解"],"title":"Java反射与注解","uri":"/posts/java%E5%8F%8D%E5%B0%84%E4%B8%8E%E6%B3%A8%E5%B0%84/"},{"categories":["JavaSE笔记"],"content":"再谈instanceof 正常情况下，我们使用instanceof进行类型比较： public static void main(String[] args) { String str = \"\"; System.out.println(str instanceof String); } 它可以判断一个对象是否为此接口或是类的实现或是子类，而现在我们有了更多的方式去判断类型： public static void main(String[] args) { String str = \"\"; System.out.println(str.getClass() == String.class); //直接判断是否为这个类型 } 如果需要判断是否为子类或是接口/抽象类的实现，我们可以使用asSubClass()方法： public static void main(String[] args) { Integer i = 10; i.getClass().asSubclass(Number.class); //当Integer不是Number的子类时，会产生异常 } ","date":"2022-01-23","objectID":"/posts/java%E5%8F%8D%E5%B0%84%E4%B8%8E%E6%B3%A8%E5%B0%84/:2:1","tags":["Java反射与注解"],"title":"Java反射与注解","uri":"/posts/java%E5%8F%8D%E5%B0%84%E4%B8%8E%E6%B3%A8%E5%B0%84/"},{"categories":["JavaSE笔记"],"content":"获取父类信息 通过getSuperclass()方法，我们可以获取到父类的Class对象： public static void main(String[] args) { Integer i = 10; System.out.println(i.getClass().getSuperclass()); } 也可以通过getGenericSuperclass()获取父类的原始类型的Type： public static void main(String[] args) { Integer i = 10; Type type = i.getClass().getGenericSuperclass(); System.out.println(type); System.out.println(type instanceof Class); } 我们发现Type实际上是Class类的父接口，但是获取到的Type的实现并不一定是Class。 同理，我们也可以像上面这样获取父接口： public static void main(String[] args) { Integer i = 10; for (Class\u003c?\u003e anInterface : i.getClass().getInterfaces()) { System.out.println(anInterface.getName()); } for (Type genericInterface : i.getClass().getGenericInterfaces()) { System.out.println(genericInterface.getTypeName()); } } ","date":"2022-01-23","objectID":"/posts/java%E5%8F%8D%E5%B0%84%E4%B8%8E%E6%B3%A8%E5%B0%84/:2:2","tags":["Java反射与注解"],"title":"Java反射与注解","uri":"/posts/java%E5%8F%8D%E5%B0%84%E4%B8%8E%E6%B3%A8%E5%B0%84/"},{"categories":["JavaSE笔记"],"content":"创建类对象 既然我们拿到了类的定义，那么是否可以通过Class对象来创建对象、调用方法、修改变量呢？当然是可以的，那我们首先来探讨一下如何创建一个类的对象： public static void main(String[] args) throws InstantiationException, IllegalAccessException { Class\u003cStudent\u003e clazz = Student.class; Student student = clazz.newInstance(); student.test(); } static class Student{ public void test(){ System.out.println(\"萨日朗\"); } } 通过使用newInstance()方法来创建对应类型的实例，返回泛型T，注意它会抛出InstantiationException和IllegalAccessException异常，那么什么情况下会出现异常呢？ public static void main(String[] args) throws InstantiationException, IllegalAccessException { Class\u003cStudent\u003e clazz = Student.class; Student student = clazz.newInstance(); student.test(); } static class Student{ public Student(String text){ } public void test(){ System.out.println(\"萨日朗\"); } } 当类默认的构造方法被带参构造覆盖时，会出现InstantiationException异常，因为newInstance()只适用于默认无参构造。 public static void main(String[] args) throws InstantiationException, IllegalAccessException { Class\u003cStudent\u003e clazz = Student.class; Student student = clazz.newInstance(); student.test(); } static class Student{ private Student(){} public void test(){ System.out.println(\"萨日朗\"); } } 当默认无参构造的权限不是public时，会出现IllegalAccessException异常，表示我们无权去调用默认构造方法。在JDK9之后，不再推荐使用newInstance()方法了，而是使用我们接下来要介绍到的，通过获取构造器，来实例化对象： public static void main(String[] args) throws NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException { Class\u003cStudent\u003e clazz = Student.class; Student student = clazz.getConstructor(String.class).newInstance(\"what's up\"); student.test(); } static class Student{ public Student(String str){} public void test(){ System.out.println(\"萨日朗\"); } } 通过获取类的构造方法（构造器）来创建对象实例，会更加合理，我们可以使用getConstructor()方法来获取类的构造方法，同时我们需要向其中填入参数，也就是构造方法需要的类型，当然我们这里只演示了。那么，当访问权限不是public的时候呢？ public static void main(String[] args) throws NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException { Class\u003cStudent\u003e clazz = Student.class; Student student = clazz.getConstructor(String.class).newInstance(\"what's up\"); student.test(); } static class Student{ private Student(String str){} public void test(){ System.out.println(\"萨日朗\"); } } 我们发现，当访问权限不足时，会无法找到此构造方法，那么如何找到非public的构造方法呢？ Class\u003cStudent\u003e clazz = Student.class; Constructor\u003cStudent\u003e constructor = clazz.getDeclaredConstructor(String.class); constructor.setAccessible(true); //修改访问权限 Student student = constructor.newInstance(\"what's up\"); student.test(); 使用getDeclaredConstructor()方法可以找到类中的非public构造方法，但是在使用之前，我们需要先修改访问权限，在修改访问权限之后，就可以使用非public方法了（这意味着，反射可以无视权限修饰符访问类的内容） ","date":"2022-01-23","objectID":"/posts/java%E5%8F%8D%E5%B0%84%E4%B8%8E%E6%B3%A8%E5%B0%84/:3:0","tags":["Java反射与注解"],"title":"Java反射与注解","uri":"/posts/java%E5%8F%8D%E5%B0%84%E4%B8%8E%E6%B3%A8%E5%B0%84/"},{"categories":["JavaSE笔记"],"content":"调用类的方法 我们可以通过反射来调用类的方法（本质上还是类的实例进行调用）只是利用反射机制实现了方法的调用，我们在包下创建一个新的类： package com.test; public class Student { public void test(String str){ System.out.println(\"萨日朗\"+str); } } 这次我们通过forName(String)来找到这个类并创建一个新的对象： public static void main(String[] args) throws ReflectiveOperationException { Class\u003c?\u003e clazz = Class.forName(\"com.test.Student\"); Object instance = clazz.newInstance(); //创建出学生对象 Method method = clazz.getMethod(\"test\", String.class); //通过方法名和形参类型获取类中的方法 method.invoke(instance, \"what's up\"); //通过Method对象的invoke方法来调用方法 } 通过调用getMethod()方法，我们可以获取到类中所有声明为public的方法，得到一个Method对象，我们可以通过Method对象的invoke()方法（返回值就是方法的返回值，因为这里是void，返回值为null）来调用已经获取到的方法，注意传参。 我们发现，利用反射之后，在一个对象从构造到方法调用，没有任何一处需要引用到对象的实际类型，我们也没有导入Student类，整个过程都是反射在代替进行操作，使得整个过程被模糊了，过多的使用反射，会极大地降低后期维护性。 同构造方法一样，当出现非public方法时，我们可以通过反射来无视权限修饰符，获取非public方法并调用，现在我们将test()方法的权限修饰符改为private： public static void main(String[] args) throws ReflectiveOperationException { Class\u003c?\u003e clazz = Class.forName(\"com.test.Student\"); Object instance = clazz.newInstance(); //创建出学生对象 Method method = clazz.getDeclaredMethod(\"test\", String.class); //通过方法名和形参类型获取类中的方法 method.setAccessible(true); method.invoke(instance, \"what's up\"); //通过Method对象的invoke方法来调用方法 } Method和Constructor都和Class一样，他们存储了方法的信息，包括方法的形式参数列表，返回值，方法的名称等内容，我们可以直接通过Method对象来获取这些信息： public static void main(String[] args) throws ReflectiveOperationException { Class\u003c?\u003e clazz = Class.forName(\"com.test.Student\"); Method method = clazz.getDeclaredMethod(\"test\", String.class); //通过方法名和形参类型获取类中的方法 System.out.println(method.getName()); //获取方法名称 System.out.println(method.getReturnType()); //获取返回值类型 } 当方法的参数为可变参数时，我们该如何获取方法呢？实际上，我们在之前就已经提到过，可变参数实际上就是一个数组，因此我们可以直接使用数组的class对象表示： Method method = clazz.getDeclaredMethod(\"test\", String[].class); 反射非常强大，尤其是我们提到的越权访问，但是请一定谨慎使用，别人将某个方法设置为private一定有他的理由，如果实在是需要使用别人定义为private的方法，就必须确保这样做是安全的，在没有了解别人代码的整个过程就强行越权访问，可能会出现无法预知的错误。 ","date":"2022-01-23","objectID":"/posts/java%E5%8F%8D%E5%B0%84%E4%B8%8E%E6%B3%A8%E5%B0%84/:4:0","tags":["Java反射与注解"],"title":"Java反射与注解","uri":"/posts/java%E5%8F%8D%E5%B0%84%E4%B8%8E%E6%B3%A8%E5%B0%84/"},{"categories":["JavaSE笔记"],"content":"修改类的属性 我们还可以通过反射访问一个类中定义的成员字段也可以修改一个类的对象中的成员字段值，通过getField()方法来获取一个类定义的指定字段： public static void main(String[] args) throws ReflectiveOperationException { Class\u003c?\u003e clazz = Class.forName(\"com.test.Student\"); Object instance = clazz.newInstance(); Field field = clazz.getField(\"i\"); //获取类的成员字段i field.set(instance, 100); //将类实例instance的成员字段i设置为100 Method method = clazz.getMethod(\"test\"); method.invoke(instance); } 在得到Field之后，我们就可以直接通过set()方法为某个对象，设定此属性的值，比如上面，我们就为instance对象设定值为100，当访问private字段时，同样可以按照上面的操作进行越权访问： public static void main(String[] args) throws ReflectiveOperationException { Class\u003c?\u003e clazz = Class.forName(\"com.test.Student\"); Object instance = clazz.newInstance(); Field field = clazz.getDeclaredField(\"i\"); //获取类的成员字段i field.setAccessible(true); field.set(instance, 100); //将类实例instance的成员字段i设置为100 Method method = clazz.getMethod(\"test\"); method.invoke(instance); } 现在我们已经知道，反射几乎可以把一个类的老底都给扒出来，任何属性，任何内容，都可以被反射修改，无论权限修饰符是什么，那么，如果我的字段被标记为final呢？现在在字段i前面添加final关键字，我们再来看看效果： private final int i = 10; 这时，当字段为final时，就修改失败了！当然，通过反射可以直接将final修饰符直接去除，去除后，就可以随意修改内容了，我们来尝试修改Integer的value值： public static void main(String[] args) throws ReflectiveOperationException { Integer i = 10; Field field = Integer.class.getDeclaredField(\"value\"); Field modifiersField = Field.class.getDeclaredField(\"modifiers\"); //这里要获取Field类的modifiers字段进行修改 modifiersField.setAccessible(true); modifiersField.setInt(field,field.getModifiers()\u0026~Modifier.FINAL); //去除final标记 field.setAccessible(true); field.set(i, 100); //强行设置值 System.out.println(i); } 我们可以发现，反射非常暴力，就连被定义为final字段的值都能强行修改，几乎能够无视一切阻拦。我们来试试看修改一些其他的类型： public static void main(String[] args) throws ReflectiveOperationException { List\u003cString\u003e i = new ArrayList\u003c\u003e(); Field field = ArrayList.class.getDeclaredField(\"size\"); field.setAccessible(true); field.set(i, 10); i.add(\"测试\"); //只添加一个元素 System.out.println(i.size()); //大小直接变成11 i.remove(10); //瞎移除都不带报错的，淦 } 实际上，整个ArrayList体系由于我们的反射操作，导致被破坏，因此它已经无法正常工作了！ 再次强调，在进行反射操作时，必须注意是否安全，虽然拥有了创世主的能力，但是我们不能滥用，我们只能把它当做一个不得已才去使用的工具！ ","date":"2022-01-23","objectID":"/posts/java%E5%8F%8D%E5%B0%84%E4%B8%8E%E6%B3%A8%E5%B0%84/:5:0","tags":["Java反射与注解"],"title":"Java反射与注解","uri":"/posts/java%E5%8F%8D%E5%B0%84%E4%B8%8E%E6%B3%A8%E5%B0%84/"},{"categories":["JavaSE笔记"],"content":"自定义ClassLoader加载类 我们可以自己手动将class文件加载到JVM中吗？先写好我们定义的类： package com.test; public class Test { public String text; public void test(String str){ System.out.println(text+\" \u003e 我是测试方法！\"+str); } } 通过javac命令，手动编译一个.class文件： nagocoler@NagodeMacBook-Pro HelloWorld % javac src/main/java/com/test/Test.java 编译后，得到一个class文件，我们把它放到根目录下，然后编写一个我们自己的ClassLoader，因为普通的ClassLoader无法加载二进制文件，因此我们编写一个自己的来让它支持： //定义一个自己的ClassLoader static class MyClassLoader extends ClassLoader{ public Class\u003c?\u003e defineClass(String name, byte[] b){ return defineClass(name, b, 0, b.length); //调用protected方法，支持载入外部class文件 } } public static void main(String[] args) throws IOException { MyClassLoader classLoader = new MyClassLoader(); FileInputStream stream = new FileInputStream(\"Test.class\"); byte[] bytes = new byte[stream.available()]; stream.read(bytes); Class\u003c?\u003e clazz = classLoader.defineClass(\"com.test.Test\", bytes); //类名必须和我们定义的保持一致 System.out.println(clazz.getName()); //成功加载外部class文件 } 现在，我们就将此class文件读取并解析为Class了，现在我们就可以对此类进行操作了（注意，我们无法在代码中直接使用此类型，因为它是我们直接加载的），我们来试试看创建一个此类的对象并调用其方法： try { Object obj = clazz.newInstance(); Method method = clazz.getMethod(\"test\", String.class); //获取我们定义的test(String str)方法 method.invoke(obj, \"哥们这瓜多少钱一斤？\"); }catch (Exception e){ e.printStackTrace(); } 我们来试试看修改成员字段之后，再来调用此方法： try { Object obj = clazz.newInstance(); Field field = clazz.getField(\"text\"); //获取成员变量 String text; field.set(obj, \"华强\"); Method method = clazz.getMethod(\"test\", String.class); //获取我们定义的test(String str)方法 method.invoke(obj, \"哥们这瓜多少钱一斤？\"); }catch (Exception e){ e.printStackTrace(); } 通过这种方式，我们就可以实现外部加载甚至是网络加载一个类，只需要把类文件传递即可，这样就无需再将代码写在本地，而是动态进行传递，不仅可以一定程度上防止源代码被反编译（只是一定程度上，想破解你代码有的是方法），而且在更多情况下，我们还可以对byte[]进行加密，保证在传输过程中的安全性。 ","date":"2022-01-23","objectID":"/posts/java%E5%8F%8D%E5%B0%84%E4%B8%8E%E6%B3%A8%E5%B0%84/:6:0","tags":["Java反射与注解"],"title":"Java反射与注解","uri":"/posts/java%E5%8F%8D%E5%B0%84%E4%B8%8E%E6%B3%A8%E5%B0%84/"},{"categories":["JavaSE笔记"],"content":"注解 其实我们在之前就接触到注解了，比如@Override表示重写父类方法（当然不加效果也是一样的，此注解在编译时会被自动丢弃）注解本质上也是一个类，只不过它的用法比较特殊。 注解可以被标注在任意地方，包括方法上、类名上、参数上、成员属性上、注解定义上等，就像注释一样，它相当于我们对某样东西的一个标记。而与注释不同的是，注解可以通过反射在运行时获取，注解也可以选择是否保留到运行时。 ","date":"2022-01-23","objectID":"/posts/java%E5%8F%8D%E5%B0%84%E4%B8%8E%E6%B3%A8%E5%B0%84/:7:0","tags":["Java反射与注解"],"title":"Java反射与注解","uri":"/posts/java%E5%8F%8D%E5%B0%84%E4%B8%8E%E6%B3%A8%E5%B0%84/"},{"categories":["JavaSE笔记"],"content":"预设注解 JDK预设了以下注解，作用于代码： @Override - 检查（仅仅是检查，不保留到运行时）该方法是否是重写方法。如果发现其父类，或者是引用的接口中并没有该方法时，会报编译错误。 @Deprecated - 标记过时方法。如果使用该方法，会报编译警告。 @SuppressWarnings - 指示编译器去忽略注解中声明的警告（仅仅编译器阶段，不保留到运行时） @FunctionalInterface - Java 8 开始支持，标识一个匿名函数或函数式接口。 @SafeVarargs - Java 7 开始支持，忽略任何使用参数为泛型变量的方法或构造函数调用产生的警告。 ","date":"2022-01-23","objectID":"/posts/java%E5%8F%8D%E5%B0%84%E4%B8%8E%E6%B3%A8%E5%B0%84/:7:1","tags":["Java反射与注解"],"title":"Java反射与注解","uri":"/posts/java%E5%8F%8D%E5%B0%84%E4%B8%8E%E6%B3%A8%E5%B0%84/"},{"categories":["JavaSE笔记"],"content":"元注解 元注解是作用于注解上的注解，用于我们编写自定义的注解： @Retention - 标识这个注解怎么保存，是只在代码中，还是编入class文件中，或者是在运行时可以通过反射访问。 @Documented - 标记这些注解是否包含在用户文档中。 @Target - 标记这个注解应该是哪种 Java 成员。 @Inherited - 标记这个注解是继承于哪个注解类(默认 注解并没有继承于任何子类) @Repeatable - Java 8 开始支持，标识某注解可以在同一个声明上使用多次。 看了这么多预设的注解，你们肯定眼花缭乱了，那我们来看看@Override是如何定义的： @Target(ElementType.METHOD) @Retention(RetentionPolicy.SOURCE) public @interface Override { } 该注解由@Target限定为只能作用于方法上，ElementType是一个枚举类型，用于表示此枚举的作用域，一个注解可以有很多个作用域。@Retention表示此注解的保留策略，包括三种策略，在上述中有写到，而这里定义为只在代码中。一般情况下，自定义的注解需要定义1个@Retention和1-n个@Target。 既然了解了元注解的使用和注解的定义方式，我们就来尝试定义一个自己的注解： @Target(ElementType.METHOD) @Retention(RetentionPolicy.RUNTIME) public @interface Test { } 这里我们定义一个Test注解，并将其保留到运行时，同时此注解可以作用于方法或是类上： @Test public class Main { @Test public static void main(String[] args) { } } 这样，一个最简单的注解就被我们创建了。 ","date":"2022-01-23","objectID":"/posts/java%E5%8F%8D%E5%B0%84%E4%B8%8E%E6%B3%A8%E5%B0%84/:7:2","tags":["Java反射与注解"],"title":"Java反射与注解","uri":"/posts/java%E5%8F%8D%E5%B0%84%E4%B8%8E%E6%B3%A8%E5%B0%84/"},{"categories":["JavaSE笔记"],"content":"注解的使用 我们还可以在注解中定义一些属性，注解的属性也叫做成员变量，注解只有成员变量，没有方法。注解的成员变量在注解的定义中以“无形参的方法”形式来声明，其方法名定义了该成员变量的名字，其返回值定义了该成员变量的类型： @Target({ElementType.METHOD, ElementType.TYPE}) @Retention(RetentionPolicy.RUNTIME) public @interface Test { String value(); } 默认只有一个属性时，我们可以将其名字设定为value，否则，我们需要在使用时手动指定注解的属性名称，使用value则无需填入： @Target({ElementType.METHOD, ElementType.TYPE}) @Retention(RetentionPolicy.RUNTIME) public @interface Test { String test(); } public class Main { @Test(test = \"\") public static void main(String[] args) { } } 我们也可以使用default关键字来为这些属性指定默认值： @Target({ElementType.METHOD, ElementType.TYPE}) @Retention(RetentionPolicy.RUNTIME) public @interface Test { String value() default \"都看到这里了，给个三连吧！\"; } 当属性存在默认值时，使用注解的时候可以不用传入属性值。当属性为数组时呢？ @Target({ElementType.METHOD, ElementType.TYPE}) @Retention(RetentionPolicy.RUNTIME) public @interface Test { String[] value(); } 当属性为数组，我们在使用注解传参时，如果数组里面只有一个内容，我们可以直接传入一个值，而不是创建一个数组： @Test(\"关注点了吗\") public static void main(String[] args) { } public class Main { @Test({\"value1\", \"value2\"}) //多个值时就使用花括号括起来 public static void main(String[] args) { } } ","date":"2022-01-23","objectID":"/posts/java%E5%8F%8D%E5%B0%84%E4%B8%8E%E6%B3%A8%E5%B0%84/:7:3","tags":["Java反射与注解"],"title":"Java反射与注解","uri":"/posts/java%E5%8F%8D%E5%B0%84%E4%B8%8E%E6%B3%A8%E5%B0%84/"},{"categories":["JavaSE笔记"],"content":"反射获取注解 既然我们的注解可以保留到运行时，那么我们来看看，如何获取我们编写的注解，我们需要用到反射机制： public static void main(String[] args) { Class\u003cStudent\u003e clazz = Student.class; for (Annotation annotation : clazz.getAnnotations()) { System.out.println(annotation.annotationType()); //获取类型 System.out.println(annotation instanceof Test); //直接判断是否为Test Test test = (Test) annotation; System.out.println(test.value()); //获取我们在注解中写入的内容 } } 通过反射机制，我们可以快速获取到我们标记的注解，同时还能获取到注解中填入的值，那么我们来看看，方法上的标记是不是也可以通过这种方式获取注解： public static void main(String[] args) throws NoSuchMethodException { Class\u003cStudent\u003e clazz = Student.class; for (Annotation annotation : clazz.getMethod(\"test\").getAnnotations()) { System.out.println(annotation.annotationType()); //获取类型 System.out.println(annotation instanceof Test); //直接判断是否为Test Test test = (Test) annotation; System.out.println(test.value()); //获取我们在注解中写入的内容 } } 无论是方法、类、还是字段，都可以使用getAnnotations()方法（还有几个同名的）来快速获取我们标记的注解。 所以说呢，这玩意学来有啥用？丝毫get不到这玩意的用处。其实不是，现阶段你们还体会不到注解带来的快乐，在接触到Spring和SpringBoot等大型框架后，就能感受到注解带来的魅力了。 ","date":"2022-01-23","objectID":"/posts/java%E5%8F%8D%E5%B0%84%E4%B8%8E%E6%B3%A8%E5%B0%84/:7:4","tags":["Java反射与注解"],"title":"Java反射与注解","uri":"/posts/java%E5%8F%8D%E5%B0%84%E4%B8%8E%E6%B3%A8%E5%B0%84/"},{"categories":["JavaSE笔记"],"content":"Java多线程","date":"2022-01-23","objectID":"/posts/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/","tags":["Java多线程"],"title":"Java多线程","uri":"/posts/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"categories":["JavaSE笔记"],"content":"Java多线程 配套视频 **注意：**本章节会涉及到 操作系统 相关知识。 在了解多线程之前，让我们回顾一下操作系统中提到的进程概念： 进程是程序执行的实体，每一个进程都是一个应用程序（比如我们运行QQ、浏览器、LOL、网易云音乐等软件），都有自己的内存空间，CPU一个核心同时只能处理一件事情，当出现多个进程需要同时运行时，CPU一般通过时间片轮转调度算法，来实现多个进程的同时运行。 在早期的计算机中，进程是拥有资源和独立运行的最小单位，也是程序执行的最小单位。但是，如果我希望两个任务同时进行，就必须运行两个进程，由于每个进程都有一个自己的内存空间，进程之间的通信就变得非常麻烦（比如要共享某些数据）而且执行不同进程会产生上下文切换，非常耗时，那么能否实现在一个进程中就能够执行多个任务呢？ 后来，线程横空出世，一个进程可以有多个线程，线程是程序执行中一个单一的顺序控制流程，现在线程才是程序执行流的最小单元，各个线程之间共享程序的内存空间（也就是所在进程的内存空间），上下文切换速度也高于进程。 在Java中，我们从开始，一直以来编写的都是单线程应用程序（运行main()方法的内容），也就是说只能同时执行一个任务（无论你是调用方法、还是进行计算，始终都是依次进行的，也就是同步的），而如果我们希望同时执行多个任务（两个方法同时在运行或者是两个计算同时在进行，也就是异步的），就需要用到Java多线程框架。实际上一个Java程序启动后，会创建很多线程，不仅仅只运行一个主线程： public static void main(String[] args) { ThreadMXBean bean = ManagementFactory.getThreadMXBean(); long[] ids = bean.getAllThreadIds(); ThreadInfo[] infos = bean.getThreadInfo(ids); for (ThreadInfo info : infos) { System.out.println(info.getThreadName()); } } 关于除了main线程默认以外的线程，涉及到JVM相关底层原理，在这里不做讲解，了解就行。 ","date":"2022-01-23","objectID":"/posts/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/:0:0","tags":["Java多线程"],"title":"Java多线程","uri":"/posts/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"categories":["JavaSE笔记"],"content":"线程的创建和启动 通过创建Thread对象来创建一个新的线程，Thread构造方法中需要传入一个Runnable接口的实现（其实就是编写要在另一个线程执行的内容逻辑）同时Runnable只有一个未实现方法，因此可以直接使用lambda表达式： @FunctionalInterface public interface Runnable { /** * When an object implementing interface \u003ccode\u003eRunnable\u003c/code\u003e is used * to create a thread, starting the thread causes the object's * \u003ccode\u003erun\u003c/code\u003e method to be called in that separately executing * thread. * \u003cp\u003e * The general contract of the method \u003ccode\u003erun\u003c/code\u003e is that it may * take any action whatsoever. * * @see java.lang.Thread#run() */ public abstract void run(); } 创建好后，通过调用start()方法来运行此线程： public static void main(String[] args) { Thread t = new Thread(() -\u003e { //直接编写逻辑 System.out.println(\"我是另一个线程！\"); }); t.start(); //调用此方法来开始执行此线程 } 可能上面的例子看起来和普通的单线程没两样，那我们先来看看下面这段代码的运行结果： public static void main(String[] args) { Thread t = new Thread(() -\u003e { System.out.println(\"我是线程：\"+Thread.currentThread().getName()); System.out.println(\"我正在计算 0-10000 之间所有数的和...\"); int sum = 0; for (int i = 0; i \u003c= 10000; i++) { sum += i; } System.out.println(\"结果：\"+sum); }); t.start(); System.out.println(\"我是主线程！\"); } 我们发现，这段代码执行输出结果并不是按照从上往下的顺序了，因为他们分别位于两个线程，他们是同时进行的！如果你还是觉得很疑惑，我们接着来看下面的代码运行结果： public static void main(String[] args) { Thread t1 = new Thread(() -\u003e { for (int i = 0; i \u003c 50; i++) { System.out.println(\"我是一号线程：\"+i); } }); Thread t2 = new Thread(() -\u003e { for (int i = 0; i \u003c 50; i++) { System.out.println(\"我是二号线程：\"+i); } }); t1.start(); t2.start(); } 我们可以看到打印实际上是在交替进行的，也证明了他们是在同时运行！ 注意：我们发现还有一个run方法，也能执行线程里面定义的内容，但是run是直接在当前线程执行，并不是创建一个线程执行！ 实际上，线程和进程差不多，也会等待获取CPU资源，一旦获取到，就开始按顺序执行我们给定的程序，当需要等待外部IO操作（比如Scanner获取输入的文本），就会暂时处于休眠状态，等待通知，或是调用sleep()方法来让当前线程休眠一段时间： public static void main(String[] args) throws InterruptedException { System.out.println(\"l\"); Thread.sleep(1000); //休眠时间，以毫秒为单位，1000ms = 1s System.out.println(\"b\"); Thread.sleep(1000); System.out.println(\"w\"); Thread.sleep(1000); System.out.println(\"nb!\"); } 我们也可以使用stop()方法来强行终止此线程： public static void main(String[] args) throws InterruptedException { Thread t = new Thread(() -\u003e { Thread me = Thread.currentThread(); //获取当前线程对象 for (int i = 0; i \u003c 50; i++) { System.out.println(\"打印:\"+i); if(i == 20) me.stop(); //此方法会直接终止此线程 } }); t.start(); } 虽然stop()方法能够终止此线程，但是并不是所推荐的做法，有关线程中断相关问题，我们会在后面继续了解。 思考：猜猜以下程序输出结果： private static int value = 0; public static void main(String[] args) throws InterruptedException { Thread t1 = new Thread(() -\u003e { for (int i = 0; i \u003c 10000; i++) value++; System.out.println(\"线程1完成\"); }); Thread t2 = new Thread(() -\u003e { for (int i = 0; i \u003c 10000; i++) value++; System.out.println(\"线程2完成\"); }); t1.start(); t2.start(); Thread.sleep(1000); //主线程停止1秒，保证两个线程执行完成 System.out.println(value); } 我们发现，value最后的值并不是我们理想的结果，有关为什么会出现这种问题，在我们学习到线程锁的时候，再来探讨。 ","date":"2022-01-23","objectID":"/posts/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/:1:0","tags":["Java多线程"],"title":"Java多线程","uri":"/posts/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"categories":["JavaSE笔记"],"content":"线程的休眠和中断 我们前面提到，一个线程处于运行状态下，线程的下一个状态会出现以下情况： 当CPU给予的运行时间结束时，会从运行状态回到就绪（可运行）状态，等待下一次获得CPU资源。 当线程进入休眠 / 阻塞(如等待IO请求) / 手动调用wait()方法时，会使得线程处于等待状态，当等待状态结束后会回到就绪状态。 当线程出现异常或错误 / 被stop() 方法强行停止 / 所有代码执行结束时，会使得线程的运行终止。 而这个部分我们着重了解一下线程的休眠和中断，首先我们来了解一下如何使得线程进如休眠状态： public static void main(String[] args) { Thread t = new Thread(() -\u003e { try { System.out.println(\"l\"); Thread.sleep(1000); //sleep方法是Thread的静态方法，它只作用于当前线程（它知道当前线程是哪个） System.out.println(\"b\"); //调用sleep后，线程会直接进入到等待状态，直到时间结束 } catch (InterruptedException e) { e.printStackTrace(); } }); t.start(); } 通过调用sleep()方法来将当前线程进入休眠，使得线程处于等待状态一段时间。我们发现，此方法显示声明了会抛出一个InterruptedException异常，那么这个异常在什么时候会发生呢？ public static void main(String[] args) { Thread t = new Thread(() -\u003e { try { Thread.sleep(10000); //休眠10秒 } catch (InterruptedException e) { e.printStackTrace(); } }); t.start(); try { Thread.sleep(3000); //休眠3秒，一定比线程t先醒来 t.interrupt(); //调用t的interrupt方法 } catch (InterruptedException e) { e.printStackTrace(); } } 我们发现，每一个Thread对象中，都有一个interrupt()方法，调用此方法后，会给指定线程添加一个中断标记以告知线程需要立即停止运行或是进行其他操作，由线程来响应此中断并进行相应的处理，我们前面提到的stop()方法是强制终止线程，这样的做法虽然简单粗暴，但是很有可能导致资源不能完全释放，而类似这样的发送通知来告知线程需要中断，让线程自行处理后续，会更加合理一些，也是更加推荐的做法。我们来看看interrupt的用法： public static void main(String[] args) { Thread t = new Thread(() -\u003e { System.out.println(\"线程开始运行！\"); while (true){ //无限循环 if(Thread.currentThread().isInterrupted()){ //判断是否存在中断标志 break; //响应中断 } } System.out.println(\"线程被中断了！\"); }); t.start(); try { Thread.sleep(3000); //休眠3秒，一定比线程t先醒来 t.interrupt(); //调用t的interrupt方法 } catch (InterruptedException e) { e.printStackTrace(); } } 通过isInterrupted()可以判断线程是否存在中断标志，如果存在，说明外部希望当前线程立即停止，也有可能是给当前线程发送一个其他的信号，如果我们并不是希望收到中断信号就是结束程序，而是通知程序做其他事情，我们可以在收到中断信号后，复位中断标记，然后继续做我们的事情： public static void main(String[] args) { Thread t = new Thread(() -\u003e { System.out.println(\"线程开始运行！\"); while (true){ if(Thread.currentThread().isInterrupted()){ //判断是否存在中断标志 System.out.println(\"发现中断信号，复位，继续运行...\"); Thread.interrupted(); //复位中断标记（返回值是当前是否有中断标记，这里不用管） } } }); t.start(); try { Thread.sleep(3000); //休眠3秒，一定比线程t先醒来 t.interrupt(); //调用t的interrupt方法 } catch (InterruptedException e) { e.printStackTrace(); } } 复位中断标记后，会立即清除中断标记。那么，如果现在我们想暂停线程呢？我们希望线程暂时停下，比如等待其他线程执行完成后，再继续运行，那这样的操作怎么实现呢？ public static void main(String[] args) { Thread t = new Thread(() -\u003e { System.out.println(\"线程开始运行！\"); Thread.currentThread().suspend(); //暂停此线程 System.out.println(\"线程继续运行！\"); }); t.start(); try { Thread.sleep(3000); //休眠3秒，一定比线程t先醒来 t.resume(); //恢复此线程 } catch (InterruptedException e) { e.printStackTrace(); } } 虽然这样很方便地控制了线程的暂停状态，但是这两个方法我们发现实际上也是不推荐的做法，它很容易导致死锁！有关为什么被弃用的原因，我们会在线程锁继续探讨。 ","date":"2022-01-23","objectID":"/posts/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/:2:0","tags":["Java多线程"],"title":"Java多线程","uri":"/posts/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"categories":["JavaSE笔记"],"content":"线程的优先级 实际上，Java程序中的每个线程并不是平均分配CPU时间的，为了使得线程资源分配更加合理，Java采用的是抢占式调度方式，优先级越高的线程，优先使用CPU资源！我们希望CPU花费更多的时间去处理更重要的任务，而不太重要的任务，则可以先让出一部分资源。线程的优先级一般分为以下三种： MIN_PRIORITY 最低优先级 MAX_PRIORITY 最高优先级 NOM_PRIORITY 常规优先级 public static void main(String[] args) { Thread t = new Thread(() -\u003e { System.out.println(\"线程开始运行！\"); }); t.start(); t.setPriority(Thread.MIN_PRIORITY); //通过使用setPriority方法来设定优先级 } 优先级越高的线程，获得CPU资源的概率会越大，并不是说一定优先级越高的线程越先执行！ ","date":"2022-01-23","objectID":"/posts/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/:3:0","tags":["Java多线程"],"title":"Java多线程","uri":"/posts/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"categories":["JavaSE笔记"],"content":"线程的礼让和加入 我们还可以在当前线程的工作不重要时，将CPU资源让位给其他线程，通过使用yield()方法来将当前资源让位给其他同优先级线程： public static void main(String[] args) { Thread t1 = new Thread(() -\u003e { System.out.println(\"线程1开始运行！\"); for (int i = 0; i \u003c 50; i++) { if(i % 5 == 0) { System.out.println(\"让位！\"); Thread.yield(); } System.out.println(\"1打印：\"+i); } System.out.println(\"线程1结束！\"); }); Thread t2 = new Thread(() -\u003e { System.out.println(\"线程2开始运行！\"); for (int i = 0; i \u003c 50; i++) { System.out.println(\"2打印：\"+i); } }); t1.start(); t2.start(); } 观察结果，我们发现，在让位之后，尽可能多的在执行线程2的内容。 当我们希望一个线程等待另一个线程执行完成后再继续进行，我们可以使用join()方法来实现线程的加入： public static void main(String[] args) { Thread t1 = new Thread(() -\u003e { System.out.println(\"线程1开始运行！\"); for (int i = 0; i \u003c 50; i++) { System.out.println(\"1打印：\"+i); } System.out.println(\"线程1结束！\"); }); Thread t2 = new Thread(() -\u003e { System.out.println(\"线程2开始运行！\"); for (int i = 0; i \u003c 50; i++) { System.out.println(\"2打印：\"+i); if(i == 10){ try { System.out.println(\"线程1加入到此线程！\"); t1.join(); //在i==10时，让线程1加入，先完成线程1的内容，在继续当前内容 } catch (InterruptedException e) { e.printStackTrace(); } } } }); t1.start(); t2.start(); } 我们发现，线程1加入后，线程2等待线程1待执行的内容全部执行完成之后，再继续执行的线程2内容。注意，线程的加入只是等待另一个线程的完成，并不是将另一个线程和当前线程合并！我们来看看： public static void main(String[] args) { Thread t1 = new Thread(() -\u003e { System.out.println(Thread.currentThread().getName()+\"开始运行！\"); for (int i = 0; i \u003c 50; i++) { System.out.println(Thread.currentThread().getName()+\"打印：\"+i); } System.out.println(\"线程1结束！\"); }); Thread t2 = new Thread(() -\u003e { System.out.println(\"线程2开始运行！\"); for (int i = 0; i \u003c 50; i++) { System.out.println(\"2打印：\"+i); if(i == 10){ try { System.out.println(\"线程1加入到此线程！\"); t1.join(); //在i==10时，让线程1加入，先完成线程1的内容，在继续当前内容 } catch (InterruptedException e) { e.printStackTrace(); } } } }); t1.start(); t2.start(); } 实际上，t2线程只是暂时处于等待状态，当t1执行结束时，t2才开始继续执行，只是在效果上看起来好像是两个线程合并为一个线程在执行而已。 ","date":"2022-01-23","objectID":"/posts/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/:4:0","tags":["Java多线程"],"title":"Java多线程","uri":"/posts/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"categories":["JavaSE笔记"],"content":"线程锁和线程同步 在开始讲解线程同步之前，我们需要先了解一下多线程情况下Java的内存管理： 线程之间的共享变量（比如之前悬念中的value变量）存储在主内存（main memory）中，每个线程都有一个私有的工作内存（本地内存），工作内存中存储了该线程以读/写共享变量的副本。它类似于我们在计算机组成原理中学习的多处理器高速缓存机制： 高速缓存通过保存内存中数据的副本来提供更加快速的数据访问，但是如果多个处理器的运算任务都涉及同一块内存区域，就可能导致各自的高速缓存数据不一致，在写回主内存时就会发生冲突，这就是引入高速缓存引发的新问题，称之为：缓存一致性。 实际上，Java的内存模型也是这样类似设计的，当我们同时去操作一个共享变量时，如果仅仅是读取还好，但是如果同时写入内容，就会出现问题！好比说一个银行，如果我和我的朋友同时在银行取我账户里面的钱，难道取1000还可能吐2000出来吗？我们需要一种更加安全的机制来维持秩序，保证数据的安全性！ ","date":"2022-01-23","objectID":"/posts/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/:5:0","tags":["Java多线程"],"title":"Java多线程","uri":"/posts/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"categories":["JavaSE笔记"],"content":"悬念破案 我们再来回顾一下之前留给大家的悬念： private static int value = 0; public static void main(String[] args) throws InterruptedException { Thread t1 = new Thread(() -\u003e { for (int i = 0; i \u003c 10000; i++) value++; System.out.println(\"线程1完成\"); }); Thread t2 = new Thread(() -\u003e { for (int i = 0; i \u003c 10000; i++) value++; System.out.println(\"线程2完成\"); }); t1.start(); t2.start(); Thread.sleep(1000); //主线程停止1秒，保证两个线程执行完成 System.out.println(value); } 实际上，当两个线程同时读取value的时候，可能会同时拿到同样的值，而进行自增操作之后，也是同样的值，再写回主内存后，本来应该进行2次自增操作，实际上只执行了一次！ 那么要去解决这样的问题，我们就必须采取某种同步机制，来限制不同线程对于共享变量的访问！我们希望的是保证共享变量value自增操作的原子性（原子性是指一个操作或多个操作要么全部执行，且执行的过程不会被任何因素打断，包括其他线程，要么就都不执行） ","date":"2022-01-23","objectID":"/posts/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/:5:1","tags":["Java多线程"],"title":"Java多线程","uri":"/posts/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"categories":["JavaSE笔记"],"content":"线程锁 通过synchronized关键字来创造一个线程锁，首先我们来认识一下synchronized代码块，它需要在括号中填入一个内容，必须是一个对象或是一个类，我们在value自增操作外套上同步代码块： private static int value = 0; public static void main(String[] args) throws InterruptedException { Thread t1 = new Thread(() -\u003e { for (int i = 0; i \u003c 10000; i++) { synchronized (Main.class){ value++; } } System.out.println(\"线程1完成\"); }); Thread t2 = new Thread(() -\u003e { for (int i = 0; i \u003c 10000; i++) { synchronized (Main.class){ value++; } } System.out.println(\"线程2完成\"); }); t1.start(); t2.start(); Thread.sleep(1000); //主线程停止1秒，保证两个线程执行完成 System.out.println(value); } 我们发现，现在得到的结果就是我们想要的内容了，因为在同步代码块执行过程中，拿到了我们传入对象或类的锁（传入的如果是对象，就是对象锁，不同的对象代表不同的对象锁，如果是类，就是类锁，类锁只有一个，实际上类锁也是对象锁，是Class类实例，但是Class类实例同样的类无论怎么获取都是同一个），但是注意两个线程必须使用同一把锁！ 当一个线程进入到同步代码块时，会获取到当前的锁，而这时如果其他使用同样的锁的同步代码块也想执行内容，就必须等待当前同步代码块的内容执行完毕，在执行完毕后会自动释放这把锁，而其他的线程才能拿到这把锁并开始执行同步代码块里面的内容。（实际上synchronized是一种悲观锁，随时都认为有其他线程在对数据进行修改，后面有机会我们还会讲到乐观锁，如CAS算法） 那么我们来看看，如果使用的是不同对象的锁，那么还能顺利进行吗？ private static int value = 0; public static void main(String[] args) throws InterruptedException { Main main1 = new Main(); Main main2 = new Main(); Thread t1 = new Thread(() -\u003e { for (int i = 0; i \u003c 10000; i++) { synchronized (main1){ value++; } } System.out.println(\"线程1完成\"); }); Thread t2 = new Thread(() -\u003e { for (int i = 0; i \u003c 10000; i++) { synchronized (main2){ value++; } } System.out.println(\"线程2完成\"); }); t1.start(); t2.start(); Thread.sleep(1000); //主线程停止1秒，保证两个线程执行完成 System.out.println(value); } 当对象不同时，获取到的是不同的锁，因此并不能保证自增操作的原子性，最后也得不到我们想要的结果。 synchronized关键字也可以作用于方法上，调用此方法时也会获取锁： private static int value = 0; private static synchronized void add(){ value++; } public static void main(String[] args) throws InterruptedException { Thread t1 = new Thread(() -\u003e { for (int i = 0; i \u003c 10000; i++) add(); System.out.println(\"线程1完成\"); }); Thread t2 = new Thread(() -\u003e { for (int i = 0; i \u003c 10000; i++) add(); System.out.println(\"线程2完成\"); }); t1.start(); t2.start(); Thread.sleep(1000); //主线程停止1秒，保证两个线程执行完成 System.out.println(value); } 我们发现实际上效果是相同的，只不过这个锁不用你去给，如果是静态方法，就是使用的类锁，而如果是普通成员方法，就是使用的对象锁。通过灵活的使用synchronized就能很好地解决我们之前提到的问题了！ ","date":"2022-01-23","objectID":"/posts/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/:5:2","tags":["Java多线程"],"title":"Java多线程","uri":"/posts/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"categories":["JavaSE笔记"],"content":"死锁 其实死锁的概念在操作系统中也有提及，它是指两个线程相互持有对方需要的锁，但是又迟迟不释放，导致程序卡住： 我们发现，线程A和线程B都需要对方的锁，但是又被对方牢牢把握，由于线程被无限期地阻塞，因此程序不可能正常终止。我们来看看以下这段代码会得到什么结果： public static void main(String[] args) throws InterruptedException { Object o1 = new Object(); Object o2 = new Object(); Thread t1 = new Thread(() -\u003e { synchronized (o1){ try { Thread.sleep(1000); synchronized (o2){ System.out.println(\"线程1\"); } } catch (InterruptedException e) { e.printStackTrace(); } } }); Thread t2 = new Thread(() -\u003e { synchronized (o2){ try { Thread.sleep(1000); synchronized (o1){ System.out.println(\"线程2\"); } } catch (InterruptedException e) { e.printStackTrace(); } } }); t1.start(); t2.start(); } 那么我们如何去检测死锁呢？我们可以利用jstack命令来检测死锁，首先利用jps找到我们的java进程： nagocoler@NagodeMacBook-Pro ~ % jps 51592 Launcher 51690 Jps 14955 51693 Main nagocoler@NagodeMacBook-Pro ~ % jstack 51693 ... Java stack information for the threads listed above: =================================================== \"Thread-1\": at com.test.Main.lambda$main$1(Main.java:46) - waiting to lock \u003c0x000000076ad27fc0\u003e (a java.lang.Object) - locked \u003c0x000000076ad27fd0\u003e (a java.lang.Object) at com.test.Main$$Lambda$2/1867750575.run(Unknown Source) at java.lang.Thread.run(Thread.java:748) \"Thread-0\": at com.test.Main.lambda$main$0(Main.java:34) - waiting to lock \u003c0x000000076ad27fd0\u003e (a java.lang.Object) - locked \u003c0x000000076ad27fc0\u003e (a java.lang.Object) at com.test.Main$$Lambda$1/396873410.run(Unknown Source) at java.lang.Thread.run(Thread.java:748) Found 1 deadlock. jstack自动帮助我们找到了一个死锁，并打印出了相关线程的栈追踪信息。 不推荐使用 suspend() 去挂起线程的原因，是因为suspend()在使线程暂停的同时，并不会去释放任何锁资源。其他线程都无法访问被它占用的锁。直到对应的线程执行resume()方法后，被挂起的线程才能继续，从而其它被阻塞在这个锁的线程才可以继续执行。但是，如果resume()操作出现在suspend()之前执行，那么线程将一直处于挂起状态，同时一直占用锁，这就产生了死锁。 ","date":"2022-01-23","objectID":"/posts/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/:5:3","tags":["Java多线程"],"title":"Java多线程","uri":"/posts/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"categories":["JavaSE笔记"],"content":"wait和notify方法 其实我们之前可能就发现了，Object类还有三个方法我们从来没有使用过，分别是wait()、notify()以及notifyAll()，他们其实是需要配合synchronized来使用的，只有在同步代码块中才能使用这些方法，我们来看看他们的作用是什么： public static void main(String[] args) throws InterruptedException { Object o1 = new Object(); Thread t1 = new Thread(() -\u003e { synchronized (o1){ try { System.out.println(\"开始等待\"); o1.wait(); //进入等待状态并释放锁 System.out.println(\"等待结束！\"); } catch (InterruptedException e) { e.printStackTrace(); } } }); Thread t2 = new Thread(() -\u003e { synchronized (o1){ System.out.println(\"开始唤醒！\"); o1.notify(); //唤醒处于等待状态的线程 for (int i = 0; i \u003c 50; i++) { System.out.println(i); } //唤醒后依然需要等待这里的锁释放之前等待的线程才能继续 } }); t1.start(); Thread.sleep(1000); t2.start(); } 我们可以发现，对象的wait()方法会暂时使得此线程进入等待状态，同时会释放当前代码块持有的锁，这时其他线程可以获取到此对象的锁，当其他线程调用对象的notify()方法后，会唤醒刚才变成等待状态的线程（这时并没有立即释放锁）。注意，必须是在持有锁（同步代码块内部）的情况下使用，否则会抛出异常！ notifyAll其实和notify一样，也是用于唤醒，但是前者是唤醒所有调用wait()后处于等待的线程，而后者是看运气随机选择一个。 ","date":"2022-01-23","objectID":"/posts/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/:5:4","tags":["Java多线程"],"title":"Java多线程","uri":"/posts/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"categories":["JavaSE笔记"],"content":"ThreadLocal的使用 既然每个线程都有一个自己的工作内存，那么能否只在自己的工作内存中创建变量仅供线程自己使用呢？ 我们可以是ThreadLocal类，来创建工作内存中的变量，它将我们的变量值存储在内部（只能存储一个变量），不同的变量访问到ThreadLocal对象时，都只能获取到自己线程所属的变量。 public static void main(String[] args) throws InterruptedException { ThreadLocal\u003cString\u003e local = new ThreadLocal\u003c\u003e(); //注意这是一个泛型类，存储类型为我们要存放的变量类型 Thread t1 = new Thread(() -\u003e { local.set(\"lbwnb\"); //将变量的值给予ThreadLocal System.out.println(\"变量值已设定！\"); System.out.println(local.get()); //尝试获取ThreadLocal中存放的变量 }); Thread t2 = new Thread(() -\u003e { System.out.println(local.get()); //尝试获取ThreadLocal中存放的变量 }); t1.start(); Thread.sleep(3000); //间隔三秒 t2.start(); } 上面的例子中，我们开启两个线程分别去访问ThreadLocal对象，我们发现，第一个线程存放的内容，第一个线程可以获取，但是第二个线程无法获取，我们再来看看第一个线程存入后，第二个线程也存放，是否会覆盖第一个线程存放的内容： public static void main(String[] args) throws InterruptedException { ThreadLocal\u003cString\u003e local = new ThreadLocal\u003c\u003e(); //注意这是一个泛型类，存储类型为我们要存放的变量类型 Thread t1 = new Thread(() -\u003e { local.set(\"lbwnb\"); //将变量的值给予ThreadLocal System.out.println(\"线程1变量值已设定！\"); try { Thread.sleep(2000); //间隔2秒 } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(\"线程1读取变量值：\"); System.out.println(local.get()); //尝试获取ThreadLocal中存放的变量 }); Thread t2 = new Thread(() -\u003e { local.set(\"yyds\"); //将变量的值给予ThreadLocal System.out.println(\"线程2变量值已设定！\"); }); t1.start(); Thread.sleep(1000); //间隔1秒 t2.start(); } 我们发现，即使线程2重新设定了值，也没有影响到线程1存放的值，所以说，不同线程向ThreadLocal存放数据，只会存放在线程自己的工作空间中，而不会直接存放到主内存中，因此各个线程直接存放的内容互不干扰。 我们发现在线程中创建的子线程，无法获得父线程工作内存中的变量： public static void main(String[] args) { ThreadLocal\u003cString\u003e local = new ThreadLocal\u003c\u003e(); Thread t = new Thread(() -\u003e { local.set(\"lbwnb\"); new Thread(() -\u003e { System.out.println(local.get()); }).start(); }); t.start(); } 我们可以使用InheritableThreadLocal来解决： public static void main(String[] args) { ThreadLocal\u003cString\u003e local = new InheritableThreadLocal\u003c\u003e(); Thread t = new Thread(() -\u003e { local.set(\"lbwnb\"); new Thread(() -\u003e { System.out.println(local.get()); }).start(); }); t.start(); } 在InheritableThreadLocal存放的内容，会自动向子线程传递。 ","date":"2022-01-23","objectID":"/posts/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/:5:5","tags":["Java多线程"],"title":"Java多线程","uri":"/posts/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"categories":["JavaSE笔记"],"content":"定时器 我们有时候会有这样的需求，我希望定时执行任务，比如3秒后执行，其实我们可以通过使用Thread.sleep()来实现： public static void main(String[] args) { new TimerTask(() -\u003e System.out.println(\"我是定时任务！\"), 3000).start(); //创建并启动此定时任务 } static class TimerTask{ Runnable task; long time; public TimerTask(Runnable runnable, long time){ this.task = runnable; this.time = time; } public void start(){ new Thread(() -\u003e { try { Thread.sleep(time); task.run(); //休眠后再运行 } catch (InterruptedException e) { e.printStackTrace(); } }).start(); } } 我们通过自行封装一个TimerTask类，并在启动时，先休眠3秒钟，再执行我们传入的内容。那么现在我们希望，能否循环执行一个任务呢？比如我希望每隔1秒钟执行一次代码，这样该怎么做呢？ public static void main(String[] args) { new TimerLoopTask(() -\u003e System.out.println(\"我是定时任务！\"), 3000).start(); //创建并启动此定时任务 } static class TimerLoopTask{ Runnable task; long loopTime; public TimerLoopTask(Runnable runnable, long loopTime){ this.task = runnable; this.loopTime = loopTime; } public void start(){ new Thread(() -\u003e { try { while (true){ //无限循环执行 Thread.sleep(loopTime); task.run(); //休眠后再运行 } } catch (InterruptedException e) { e.printStackTrace(); } }).start(); } } 现在我们将单次执行放入到一个无限循环中，这样就能一直执行了，并且按照我们的间隔时间进行。 但是终究是我们自己实现，可能很多方面还没考虑到，Java也为我们提供了一套自己的框架用于处理定时任务： public static void main(String[] args) { Timer timer = new Timer(); //创建定时器对象 timer.schedule(new TimerTask() { //注意这个是一个抽象类，不是接口，无法使用lambda表达式简化，只能使用匿名内部类 @Override public void run() { System.out.println(Thread.currentThread().getName()); //打印当前线程名称 } }, 1000); //执行一个延时任务 } 我们可以通过创建一个Timer类来让它进行定时任务调度，我们可以通过此对象来创建任意类型的定时任务，包延时任务、循环定时任务等。我们发现，虽然任务执行完成了，但是我们的程序并没有停止，这是因为Timer内存维护了一个任务队列和一个工作线程： public class Timer { /** * The timer task queue. This data structure is shared with the timer * thread. The timer produces tasks, via its various schedule calls, * and the timer thread consumes, executing timer tasks as appropriate, * and removing them from the queue when they're obsolete. */ private final TaskQueue queue = new TaskQueue(); /** * The timer thread. */ private final TimerThread thread = new TimerThread(queue); ... } TimerThread继承自Thread，是一个新创建的线程，在构造时自动启动： public Timer(String name) { thread.setName(name); thread.start(); } 而它的run方法会循环地读取队列中是否还有任务，如果有任务依次执行，没有的话就暂时处于休眠状态： public void run() { try { mainLoop(); } finally { // Someone killed this Thread, behave as if Timer cancelled synchronized(queue) { newTasksMayBeScheduled = false; queue.clear(); // Eliminate obsolete references } } } /** * The main timer loop. (See class comment.) */ private void mainLoop() { try { TimerTask task; boolean taskFired; synchronized(queue) { // Wait for queue to become non-empty while (queue.isEmpty() \u0026\u0026 newTasksMayBeScheduled) //当队列为空同时没有被关闭时，会调用wait()方法暂时处于等待状态，当有新的任务时，会被唤醒。 queue.wait(); if (queue.isEmpty()) break; //当被唤醒后都没有任务时，就会结束循环，也就是结束工作线程 ... } newTasksMayBeScheduled实际上就是标记当前定时器是否关闭，当它为false时，表示已经不会再有新的任务到来，也就是关闭，我们可以通过调用cancel()方法来关闭它的工作线程： public void cancel() { synchronized(queue) { thread.newTasksMayBeScheduled = false; queue.clear(); queue.notify(); //唤醒wait使得工作线程结束 } } 因此，我们可以在使用完成后，调用Timer的cancel()方法以正常退出我们的程序： public static void main(String[] args) { Timer timer = new Timer(); timer.schedule(new TimerTask() { @Override public void run() { System.out.println(Thread.currentThread().getName()); timer.cancel(); //结束 } }, 1000); } ","date":"2022-01-23","objectID":"/posts/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/:6:0","tags":["Java多线程"],"title":"Java多线程","uri":"/posts/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"categories":["JavaSE笔记"],"content":"守护线程 不要把守护进程和守护线程相提并论！守护进程在后台运行运行，不需要和用户交互，本质和普通进程类似。而守护线程就不一样了，当其他所有的非守护线程结束之后，守护线程是自动结束，也就是说，Java中所有的线程都执行完毕后，守护线程自动结束，因此守护线程不适合进行IO操作，只适合打打杂： public static void main(String[] args) throws InterruptedException{ Thread t = new Thread(() -\u003e { while (true){ try { System.out.println(\"程序正常运行中...\"); Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } } }); t.setDaemon(true); //设置为守护线程（必须在开始之前，中途是不允许转换的） t.start(); for (int i = 0; i \u003c 5; i++) { Thread.sleep(1000); } } 在守护线程中产生的新线程也是守护的： public static void main(String[] args) throws InterruptedException{ Thread t = new Thread(() -\u003e { Thread it = new Thread(() -\u003e { while (true){ try { System.out.println(\"程序正常运行中...\"); Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } } }); it.start(); }); t.setDaemon(true); //设置为守护线程（必须在开始之前，中途是不允许转换的） t.start(); for (int i = 0; i \u003c 5; i++) { Thread.sleep(1000); } } ","date":"2022-01-23","objectID":"/posts/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/:7:0","tags":["Java多线程"],"title":"Java多线程","uri":"/posts/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"categories":["JavaSE笔记"],"content":"再谈集合类并行方法 其实我们之前在讲解集合类的根接口时，就发现有这样一个方法： default Stream\u003cE\u003e parallelStream() { return StreamSupport.stream(spliterator(), true); } 并行流，其实就是一个多线程执行的流，它通过默认的ForkJoinPool实现（这里不讲解原理），它可以提高你的多线程任务的速度。 public static void main(String[] args) { List\u003cInteger\u003e list = new ArrayList\u003c\u003e(Arrays.asList(1, 4, 5, 2, 9, 3, 6, 0)); list .parallelStream() //获得并行流 .forEach(i -\u003e System.out.println(Thread.currentThread().getName()+\" -\u003e \"+i)); } 我们发现，forEach操作的顺序，并不是我们实际List中的顺序，同时每次打印也是不同的线程在执行！我们可以通过调用forEachOrdered()方法来使用单线程维持原本的顺序： public static void main(String[] args) { List\u003cInteger\u003e list = new ArrayList\u003c\u003e(Arrays.asList(1, 4, 5, 2, 9, 3, 6, 0)); list .parallelStream() //获得并行流 .forEachOrdered(System.out::println); } 我们之前还发现，在Arrays数组工具类中，也包含大量的并行方法： public static void main(String[] args) { int[] arr = new int[]{1, 4, 5, 2, 9, 3, 6, 0}; Arrays.parallelSort(arr); //使用多线程进行并行排序，效率更高 System.out.println(Arrays.toString(arr)); } 更多地使用并行方法，可以更加充分地发挥现代计算机多核心的优势，但是同时需要注意多线程产生的异步问题！ public static void main(String[] args) { int[] arr = new int[]{1, 4, 5, 2, 9, 3, 6, 0}; Arrays.parallelSetAll(arr, i -\u003e { System.out.println(Thread.currentThread().getName()); return arr[i]; }); System.out.println(Arrays.toString(arr)); } 通过对Java多线程的了解，我们就具备了利用多线程解决问题的思维！ ","date":"2022-01-23","objectID":"/posts/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/:8:0","tags":["Java多线程"],"title":"Java多线程","uri":"/posts/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"categories":["JavaSE笔记"],"content":"Java多线程编程实战 这是整个教程最后一个编程实战内容了，下一章节为反射一般开发者使用比较少，属于选学内容，不编排编程实战课程。 ","date":"2022-01-23","objectID":"/posts/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/:9:0","tags":["Java多线程"],"title":"Java多线程","uri":"/posts/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"categories":["JavaSE笔记"],"content":"生产者与消费者 所谓的生产者消费者模型，是通过一个容器来解决生产者和消费者的强耦合问题。通俗的讲，就是生产者在不断的生产，消费者也在不断的消费，可是消费者消费的产品是生产者生产的，这就必然存在一个中间容器，我们可以把这个容器想象成是一个货架，当货架空的时候，生产者要生产产品，此时消费者在等待生产者往货架上生产产品，而当货架有货物的时候，消费者可以从货架上拿走商品，生产者此时等待货架出现空位，进而补货，这样不断的循环。 通过多线程编程，来模拟一个餐厅的2个厨师和3个顾客，假设厨师炒出一个菜的时间为3秒，顾客吃掉菜品的时间为4秒。 ","date":"2022-01-23","objectID":"/posts/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/:9:1","tags":["Java多线程"],"title":"Java多线程","uri":"/posts/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"categories":["JavaSE笔记"],"content":"java面向对象","date":"2022-01-23","objectID":"/posts/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/","tags":["Java对象和多态"],"title":"Java对象和多态","uri":"/posts/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"categories":["JavaSE笔记"],"content":"Java对象和多态 （面向对象） 配套视频 ","date":"2022-01-23","objectID":"/posts/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/:0:0","tags":["Java对象和多态"],"title":"Java对象和多态","uri":"/posts/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"categories":["JavaSE笔记"],"content":"面向对象基础 面向对象程序设计(Object Oriented Programming) 对象基于类创建，类相当于一个模板，对象就是根据模板创建出来的实体（就像做月饼，我们要做一个月饼首先需要一个模具，模具就是我们的类，而做出来的月饼，就是类的实现，也叫做对象），类是抽象的数据类型，并不能代表某一个具体的事物，类是对象的一个模板。类具有自己的属性，包括成员变量、成员方法等，我们可以调用类的成员方法来让类进行一些操作。 Scanner sc = new Scanner(System.in); String str = sc.nextLine(); System.out.println(\"你输入了：\"+str); sc.close(); 所有的对象，都需要通过new关键字创建，基本数据类型不是对象！Java不是纯面对对象语言！ 不是基本类型的变量，都是引用类型，引用类型变量代表一个对象，而基本数据类型变量，保存的是基本数据类型的值，我们可以通过引用来对对象进行操作。（最好不要理解为引用指向对象的地址，初学者不要谈内存，学到JVM时再来讨论） 对象占用的内存由JVM统一管理，不需要手动释放内存，当一个对象不再使用时（比如失去引用或是离开了作用域）会被JVM自动清理，内存管理更方便！ ","date":"2022-01-23","objectID":"/posts/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/:1:0","tags":["Java对象和多态"],"title":"Java对象和多态","uri":"/posts/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"categories":["JavaSE笔记"],"content":"类的基本结构 为了快速掌握，我们自己创建一个自己的类，创建的类文件名称应该和类名一致。 ","date":"2022-01-23","objectID":"/posts/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/:2:0","tags":["Java对象和多态"],"title":"Java对象和多态","uri":"/posts/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"categories":["JavaSE笔记"],"content":"成员变量 在类中，可以包含许多的成员变量，也叫成员属性，成员字段(field)通过.来访问我们类中的成员变量，我们可以通过类创建的对象来访问和修改这些变量。成员变量是属于对象的！ public class Test { int age; String name; } public static void main(String[] args) { Test test = new Test(); test.name = \"奥利给\"; System.out.println(test.name); } 成员变量默认带有初始值，也可以自己定义初始值。 ","date":"2022-01-23","objectID":"/posts/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/:2:1","tags":["Java对象和多态"],"title":"Java对象和多态","uri":"/posts/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"categories":["JavaSE笔记"],"content":"成员方法 我们之前的学习中接触过方法(Method)吗？主方法！ public static void main(String[] args) { //Body } 方法是语句的集合，是为了完成某件事情而存在的。完成某件事情，可以有结果，也可以做了就做了，不返回结果。比如计算两个数字的和，我们需要得到计算后的结果，所以说方法需要有返回值；又比如，我们只想吧数字打印在控制台，只需要打印就行，不用给我结果，所以说方法不需要有返回值。 方法的定义和使用 在类中，我们可以定义自己的方法，格式如下： [返回值类型] 方法名称([参数]){ //方法体 return 结果; } 返回值类型：可以是引用类型和基本类型，还可以是void，表示没有返回值 方法名称：和标识符的规则一致，和变量一样，规范小写字母开头！ 参数：例如方法需要计算两个数的和，那么我们就要把两个数到底是什么告诉方法，那么它们就可以作为参数传入方法 方法体：方法具体要干的事情 结果：方法执行的结果通过return返回（如果返回类型为void，可以省略return） 非void方法中，return关键字不一定需要放在最后，但是一定要保证方法在任何情况下都具有返回值！ int test(int a){ if(a \u003e 0){ //缺少retrun语句！ }else{ return 0; } } return也能用来提前结束整个方法，无论此时程序执行到何处，无论return位于哪里，都会立即结束个方法！ void main(String[] args) { for (int i = 0; i \u003c 10; i++) { if(i == 1) return; //在循环内返回了！和break区别？ } System.out.println(\"淦\"); //还会到这里吗？ } 传入方法的参数，如果是基本类型，会在调用方法的时候，对参数的值进行复制，方法中的参数变量，不是我们传入的变量本身！ public static void main(String[] args) { int a = 10, b = 20; new Test().swap(a, b); System.out.println(\"a=\"+a+\", b=\"+b); } public class Test{ void swap(int a, int b){ //传递的仅仅是值而已！ int temp = a; a = b; b = temp; } } 传入方法的参数，如果是引用类型，那么传入的依然是该对象的引用！（类似于C语言的指针） public class B{ String name; } public class A{ void test(B b){ //传递的是对象的引用，而不是值 System.out.println(b.name); } } public static void main(String[] args) { int a = 10, b = 20; B b = new B(); b.name = \"lbw\"; new A().test(b); System.out.println(\"a=\"+a+\", b=\"+b); } 方法之间可以相互调用 void a(){ //xxxx } void b(){ a(); } 当方法在自己内部调用自己时，称为递归调用（递归很危险，慎重！） int a(){ return a(); } 成员方法和成员变量一样，是属于对象的，只能通过对象去调用！ ","date":"2022-01-23","objectID":"/posts/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/:2:2","tags":["Java对象和多态"],"title":"Java对象和多态","uri":"/posts/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"categories":["JavaSE笔记"],"content":"对象设计练习 学生应该具有以下属性：名字、年龄 学生应该具有以下行为：学习、运动、说话 ","date":"2022-01-23","objectID":"/posts/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/:2:3","tags":["Java对象和多态"],"title":"Java对象和多态","uri":"/posts/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"categories":["JavaSE笔记"],"content":"方法的重载 一个类中可以包含多个同名的方法，但是需要的形式参数不一样。（补充：形式参数就是定义方法需要的参数，实际参数就传入的参数）方法的返回类型，可以相同，也可以不同，但是仅返回类型不同，是不允许的！ public class Test { int a(){ //原本的方法 return 1; } int a(int i){ //ok，形参不同 return i; } void a(byte i){ //ok，返回类型和形参都不同 } void a(){ //错误，仅返回值类型名称不同不能重载 } } 现在我们就可以使用不同的参数，但是支持调用同样的方法，执行一样的逻辑： public class Test { int sum(int a, int b){ //只有int支持，不灵活！ return a+b; } double sum(double a, double b){ //重写一个double类型的，就支持小数计算了 return a+b; } } 现在我们有很多种重写的方法，那么传入实参后，到底进了哪个方法呢？ public class Test { void a(int i){ System.out.println(\"调用了int\"); } void a(short i){ System.out.println(\"调用了short\"); } void a(long i){ System.out.println(\"调用了long\"); } void a(char i){ System.out.println(\"调用了char\"); } void a(double i){ System.out.println(\"调用了double\"); } void a(float i){ System.out.println(\"调用了float\"); } public static void main(String[] args) { Test test = new Test(); test.a(1); //直接输入整数 test.a(1.0); //直接输入小数 short s = 2; test.a(s); //会对号入座吗？ test.a(1.0F); } } ","date":"2022-01-23","objectID":"/posts/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/:2:4","tags":["Java对象和多态"],"title":"Java对象和多态","uri":"/posts/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"categories":["JavaSE笔记"],"content":"构造方法 构造方法（构造器）没有返回值，也可以理解为，返回的是当前对象的引用！每一个类都默认自带一个无参构造方法。 //反编译结果 package com.test; public class Test { public Test() { //即使你什么都不编写，也自带一个无参构造方法，只是默认是隐藏的 } } 反编译其实就是把我们编译好的class文件变回Java源代码。 Test test = new Test(); //实际上存在Test()这个的方法，new关键字就是用来创建并得到引用的 // new + 你想要使用的构造方法 这种方法没有写明返回值，但是每个类都必须具有这个方法！只有调用类的构造方法，才能创建类的对象！ 类要在一开始准备的所有东西，都会在构造方法里面执行，完成构造方法的内容后，才能创建出对象！ 一般最常用的就是给成员属性赋初始值： public class Student { String name; Student(){ name = \"伞兵一号\"; } } 我们可以手动指定有参构造，当遇到名称冲突时，需要用到this关键字 public class Student { String name; Student(String name){ //形参和类成员变量冲突了，Java会优先使用形式参数定义的变量！ this.name = name; //通过this指代当前的对象属性，this就代表当前对象 } } //idea 右键快速生成！ 注意，this只能用于指代当前对象的内容，因此，只有属于对象拥有的部分才可以使用this，也就是说，只能在类的成员方法中使用this，不能在静态方法中使用this关键字。 在我们定义了新的有参构造之后，默认的无参构造会被覆盖！ //反编译后依然只有我们定义的有参构造！ 如果同时需要有参和无参构造，那么就需要用到方法的重载！手动再去定义一个无参构造。 public class Student { String name; Student(){ } Student(String name){ this.name = name; } } 成员变量的初始化始终在构造方法执行之前 public class Student { String a = \"sadasa\"; Student(){ System.out.println(a); } public static void main(String[] args) { Student s = new Student(); } } ","date":"2022-01-23","objectID":"/posts/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/:2:5","tags":["Java对象和多态"],"title":"Java对象和多态","uri":"/posts/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"categories":["JavaSE笔记"],"content":"静态变量和静态方法 静态变量和静态方法是类具有的属性（后面还会提到静态类、静态代码块），也可以理解为是所有对象共享的内容。我们通过使用static关键字来声明一个变量或一个方法为静态的，一旦被声明为静态，那么通过这个类创建的所有对象，操作的都是同一个目标，也就是说，对象再多，也只有这一个静态的变量或方法。那么，一个对象改变了静态变量的值，那么其他的对象读取的就是被改变的值。 public class Student { static int a; } public static void main(String[] args) { Student s1 = new Student(); s1.a = 10; Student s2 = new Student(); System.out.println(s2.a); } 不推荐使用对象来调用，被标记为静态的内容，可以直接通过类名.xxx的形式访问 public static void main(String[] args) { Student.a = 10; System.out.println(Student.a); } 简述类加载机制 类并不是在一开始就全部加载好，而是在需要时才会去加载（提升速度）以下情况会加载类： 访问类的静态变量，或者为静态变量赋值 new 创建类的实例（隐式加载） 调用类的静态方法 子类初始化时 其他的情况会在讲到反射时介绍 所有被标记为静态的内容，会在类刚加载的时候就分配，而不是在对象创建的时候分配，所以说静态内容一定会在第一个对象初始化之前完成加载。 public class Student { static int a = test(); //直接调用静态方法，只能调用静态方法 Student(){ System.out.println(\"构造类对象\"); } static int test(){ //静态方法刚加载时就有了 System.out.println(\"初始化变量a\"); return 1; } } 思考：下面这种情况下，程序能正常运行吗？如果能，会输出什么内容？ public class Student { static int a = test(); static int test(){ return a; } public static void main(String[] args) { System.out.println(Student.a); } } 定义和赋值是两个阶段，在定义时会使用默认值（上面讲的，类的成员变量会有默认值）定义出来之后，如果发现有赋值语句，再进行赋值，而这时，调用了静态方法，所以说会先去加载静态方法，静态方法调用时拿到a，而a这时仅仅是刚定义，所以说还是初始值，最后得到0 ","date":"2022-01-23","objectID":"/posts/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/:2:6","tags":["Java对象和多态"],"title":"Java对象和多态","uri":"/posts/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"categories":["JavaSE笔记"],"content":"代码块和静态代码块 代码块在对象创建时执行，也是属于类的内容，但是它在构造方法执行之前执行（和成员变量初始值一样），且每创建一个对象时，只执行一次！（相当于构造之前的准备工作） public class Student { { System.out.println(\"我是代码块\"); } Student(){ System.out.println(\"我是构造方法\"); } } 静态代码块和上面的静态方法和静态变量一样，在类刚加载时就会调用； public class Student { static int a; static { a = 10; } public static void main(String[] args) { System.out.println(Student.a); } } ","date":"2022-01-23","objectID":"/posts/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/:2:7","tags":["Java对象和多态"],"title":"Java对象和多态","uri":"/posts/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"categories":["JavaSE笔记"],"content":"String和StringBuilder类 字符串类是一个比较特殊的类，他是Java中唯一重载运算符的类！(Java不支持运算符重载，String是特例) String的对象直接支持使用+或+=运算符来进行拼接，并形成新的String对象！（String的字符串是不可变的！） String a = \"dasdsa\", b = \"dasdasdsa\"; String l = a+b; System.out.println(l); 大量进行字符串的拼接似乎不太好，编译器是很聪明的，String的拼接有可能会被编译器优化为StringBuilder来减少对象创建（对象频繁创建时很费时间同时占内存的！） String result=\"String\"+\"and\"; //会被优化成一句！ String str1=\"String\"; String str2=\"and\"; String result=str1+str2; //变量随时可变，在编译时无法确定result的值，那么只能在运行时再去确定 String str1=\"String\"; String str2=\"and\"; String result=(new StringBuilder(String.valueOf(str1))).append(str2).toString(); //使用StringBuilder，会采用类似于第一种实现，显然会更快！ StringBuilder也是一个类，但是它能够存储可变长度的字符串！ StringBuilder builder = new StringBuilder(); builder .append(\"a\") .append(\"bc\") .append(\"d\"); //链式调用 String str = builder.toString(); System.out.println(str); ","date":"2022-01-23","objectID":"/posts/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/:2:8","tags":["Java对象和多态"],"title":"Java对象和多态","uri":"/posts/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"categories":["JavaSE笔记"],"content":"包和访问控制 ","date":"2022-01-23","objectID":"/posts/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/:3:0","tags":["Java对象和多态"],"title":"Java对象和多态","uri":"/posts/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"categories":["JavaSE笔记"],"content":"包声明和导入 包其实就是用来区分类位置的东西，也可以用来将我们的类进行分类，类似于C++中的namespace！ package com.test; public class Test{ } 包其实是文件夹，比如com.test就是一个com文件夹中包含一个test文件夹，再包含我们Test类。 一般包按照个人或是公司域名的规则倒过来写 顶级域名.一级域名.二级域名 com.java.xxxx 如果需要使用其他包里面的类，那么我们需要import（类似于C/C++中的include） import com.test.Student; 也可以导入包下的全部（一般导入会由编译器自带帮我们补全，但是一定要记得我们需要导包！） import com.test.* Java默认为我们导入了以下的包，不需要去声明 import java.lang.* ","date":"2022-01-23","objectID":"/posts/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/:3:1","tags":["Java对象和多态"],"title":"Java对象和多态","uri":"/posts/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"categories":["JavaSE笔记"],"content":"静态导入 静态导入可以直接导入某个类的静态方法或者是静态变量，导入后，相当于这个方法或是类在定义在当前类中，可以直接调用该方法。 import static com.test.ui.Student.test; public class Main { public static void main(String[] args) { test(); } } 静态导入不会进行类的初始化！ ","date":"2022-01-23","objectID":"/posts/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/:3:2","tags":["Java对象和多态"],"title":"Java对象和多态","uri":"/posts/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"categories":["JavaSE笔记"],"content":"访问控制 Java支持对类属性访问的保护，也就是说，不希望外部类访问类中的属性或是方法，只允许内部调用，这种情况下我们就需要用到权限控制符。 ![image-20210819160939950](C:/Users/Alone/Users/nagocoler/Library/Application Support/typora-user-images/image-20210819160939950.png) 权限控制符可以声明在方法、成员变量、类前面，一旦声明private，只能类内部访问！ public class Student { private int a = 10; //具有私有访问权限，只能类内部访问 } public static void main(String[] args) { Student s = new Student(); System.out.println(s.a); //还可以访问吗？ } 和文件名称相同的类，只能是public，并且一个java文件中只能有一个public class！ // Student.java public class Student { } class Test{ //不能添加权限修饰符！只能是default } ","date":"2022-01-23","objectID":"/posts/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/:3:3","tags":["Java对象和多态"],"title":"Java对象和多态","uri":"/posts/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"categories":["JavaSE笔记"],"content":"数组类型 假设出现一种情况，我想记录100个数字，定义100个变量还可行吗？ 我们可以使用到数组，数组是相同类型数据的有序集合。数组可以代表任何相同类型的一组内容（包括引用类型和基本类型）其中存放的每一个数据称为数组的一个元素，数组的下标是从0开始，也就是第一个元素的索引是0！ int[] arr = new int[10]; //需要new关键字来创建！ String[] arr2 = new String[10]; 数组本身也是类（编程不可见，C++写的），不是基本数据类型！ int[] arr = new int[10]; System.out.println(arr.length); //数组有成员变量！ System.out.println(arr.toString()); //数组有成员方法！ ","date":"2022-01-23","objectID":"/posts/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/:4:0","tags":["Java对象和多态"],"title":"Java对象和多态","uri":"/posts/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"categories":["JavaSE笔记"],"content":"一维数组 一维数组中，元素是依次排列的（线性），每个数组元素可以通过下标来访问！声明格式如下： 类型[] 变量名称 = new 类型[数组大小]; 类型 变量名称n = new 类型[数组大小]; //支持C语言样式，但不推荐！ 类型[] 变量名称 = new 类型[]{...}; //静态初始化（直接指定值和大小） 类型[] 变量名称 = {...}; //同上，但是只能在定义时赋值 创建出来的数组每个元素都有默认值（规则和类的成员变量一样，C语言创建的数组需要手动设置默认值），我们可以通过下标去访问： int[] arr = new int[10]; arr[0] = 626; System.out.println(arr[0]); System.out.println(arr[1]); 我们可以通过数组变量名称.length来获取当前数组长度： int[] arr = new int[]{1, 2, 3}; System.out.println(arr.length); //打印length成员变量的值 数组在创建时，就固定长度，不可更改！访问超出数组长度的内容，会出现错误！ String[] arr = new String[10]; System.out.println(arr[10]); //出现异常！ //Exception in thread \"main\" java.lang.ArrayIndexOutOfBoundsException: 11 // at com.test.Application.main(Application.java:7) 思考：能不能直接修改length的值来实现动态扩容呢？ int[] arr = new int[]{1, 2, 3}; arr.length = 10; 数组做实参，因为数组也是类，所以形参得到的是数组的引用而不是复制的数组，操作的依然是数组对象本身 public static void main(String[] args) { int[] arr = new int[]{1, 2, 3}; test(arr); System.out.println(arr[0]); } private static void test(int[] arr){ arr[0] = 2934; } ","date":"2022-01-23","objectID":"/posts/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/:4:1","tags":["Java对象和多态"],"title":"Java对象和多态","uri":"/posts/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"categories":["JavaSE笔记"],"content":"数组的遍历 如果我们想要快速打印数组中的每一个元素，又怎么办呢？ 传统for循环 我们很容易就联想到for循环 int[] arr = new int[]{1, 2, 3}; for (int i = 0; i \u003c arr.length; i++) { System.out.println(arr[i]); } foreach 传统for循环虽然可控性高，但是不够省事，要写一大堆东西，有没有一种省事的写法呢？ int[] arr = new int[]{1, 2, 3}; for (int i : arr) { System.out.println(i); } foreach属于增强型的for循环，它使得代码更简洁，同时我们能直接拿到数组中的每一个数字。 ","date":"2022-01-23","objectID":"/posts/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/:4:2","tags":["Java对象和多态"],"title":"Java对象和多态","uri":"/posts/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"categories":["JavaSE笔记"],"content":"二维数组 二维数组其实就是存放数组的数组，每一个元素都存放一个数组的引用，也就相当于变成了一个平面。 //三行两列 int[][] arr = { {1, 2}, {3, 4}, {5, 6}}; System.out.println(arr[2][1]); 二维数组的遍历同一维数组一样，只不过需要嵌套循环！ int[][] arr = new int[][]{ {1, 2}, {3, 4}, {5, 6}}; for (int i = 0; i \u003c 3; i++) { for (int j = 0; j \u003c 2; j++) { System.out.println(arr[i][j]); } } ","date":"2022-01-23","objectID":"/posts/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/:4:3","tags":["Java对象和多态"],"title":"Java对象和多态","uri":"/posts/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"categories":["JavaSE笔记"],"content":"多维数组 不止二维数组，还存在三维数组，也就是存放数组的数组的数组，原理同二维数组一样，逐级访问即可。 ","date":"2022-01-23","objectID":"/posts/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/:4:4","tags":["Java对象和多态"],"title":"Java对象和多态","uri":"/posts/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"categories":["JavaSE笔记"],"content":"可变长参数 可变长参数其实就是数组的一种应用，我们可以指定方法的形参为一个可变长参数，要求实参可以根据情况动态填入0个或多个，而不是固定的数量 public static void main(String[] args) { test(\"AAA\", \"BBB\", \"CCC\"); //可变长，最后都会被自动封装成一个数组 } private static void test(String... test){ System.out.println(test[0]); //其实参数就是一个数组 } 由于是数组，所以说只能使用一种类型的可变长参数，并且可变长参数只能放在最后一位！ ","date":"2022-01-23","objectID":"/posts/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/:4:5","tags":["Java对象和多态"],"title":"Java对象和多态","uri":"/posts/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"categories":["JavaSE笔记"],"content":"实战：三大基本排序算法 现在我们有一个数组，但是数组里面的数据是乱序排列的，如何使它变得有序？ int[] arr = {8, 5, 0, 1, 4, 9, 2, 3, 6, 7}; 排序是编程的一个重要技能，掌握排序算法，你的技术才能更上一层楼，很多的项目都需要用到排序！三大排序算法： 冒泡排序 冒泡排序就是冒泡，其实就是不断使得我们无序数组中的最大数向前移动，经历n轮循环逐渐将每一个数推向最前。 插入排序 插入排序其实就跟我们打牌是一样的，我们在摸牌的时候，牌堆是乱序的，但是我们一张一张摸到手中进行排序，使得它变成了有序的！ 选择排序 选择排序其实就是每次都选择当前数组中最大的数排到最前面！ ","date":"2022-01-23","objectID":"/posts/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/:4:6","tags":["Java对象和多态"],"title":"Java对象和多态","uri":"/posts/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"categories":["JavaSE笔记"],"content":"封装、继承和多态 封装、继承和多态是面向对象编程的三大特性。 ","date":"2022-01-23","objectID":"/posts/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/:5:0","tags":["Java对象和多态"],"title":"Java对象和多态","uri":"/posts/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"categories":["JavaSE笔记"],"content":"封装 封装的目的是为了保证变量的安全性，使用者不必在意具体实现细节，而只是通过外部接口即可访问类的成员，如果不进行封装，类中的实例变量可以直接查看和修改，可能给整个代码带来不好的影响，因此在编写类时一般将成员变量私有化，外部类需要同getter和setter方法来查看和设置变量。 设想：学生小明已经创建成功，正常情况下能随便改他的名字和年龄吗？ public class Student { private String name; private int age; public Student(String name, int age) { this.name = name; this.age = age; } public int getAge() { return age; } public String getName() { return name; } } 也就是说，外部现在只能通过调用我定义的方法来获取成员属性，而我们可以在这个方法中进行一些额外的操作，比如小明可以修改名字，但是名字中不能包含\"小\"这个字。 public void setName(String name) { if(name.contains(\"小\")) return; this.name = name; } 单独给外部开放设置名称的方法，因为我还需要做一些额外的处理，所以说不能给外部直接操作成员变量的权限！ 封装思想其实就是把实现细节给隐藏了，外部只需知道这个方法是什么作用，而无需关心实现。 封装就是通过访问权限控制来实现的。 ","date":"2022-01-23","objectID":"/posts/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/:5:1","tags":["Java对象和多态"],"title":"Java对象和多态","uri":"/posts/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"categories":["JavaSE笔记"],"content":"继承 继承属于非常重要的内容，在定义不同类的时候存在一些相同属性，为了方便使用可以将这些共同属性抽象成一个父类，在定义其他子类时可以继承自该父类，减少代码的重复定义，子类可以使用父类中非私有的成员。 现在学生分为两种，艺术生和体育生，他们都是学生的分支，但是他们都有自己的方法： public class SportsStudent extends Student{ //通过extends关键字来继承父类 public SportsStudent(String name, int age) { super(name, age); //必须先通过super关键字（指代父类），实现父类的构造方法！ } public void exercise(){ System.out.println(\"我超勇的！\"); } } public class ArtStudent extends Student{ public ArtStudent(String name, int age) { super(name, age); } public void art(){ System.out.println(\"随手画个毕加索！\"); } } 子类具有父类的全部属性，protected可见但外部无法使用（包括private属性，不可见，无法使用），同时子类还能有自己的方法。继承只能继承一个父类，不支持多继承！ 每一个子类必须定义一个实现父类构造方法的构造方法，也就是需要在构造方法开始使用super()，如果父类使用的是默认构造方法，那么子类不用手动指明。 所有类都默认继承自Object类，除非手动指定类型，但是依然改变不了最顶层的父类是Object类。所有类都包含Object类中的方法，比如： public static void main(String[] args) { Object obj = new Object; System.out.println(obj.hashCode()); //求对象的hashcode，默认是对象的内存地址 System.out.println(obj.equals(obj)); //比较对象是否相同，默认比较的是对象的内存地址，也就是等同于 == System.out.println(obj.toString()); //将对象转换为字符串，默认生成对象的类名称+hashcode } 关于Object类的其他方法，我们会在Java多线程中再来提及。 ","date":"2022-01-23","objectID":"/posts/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/:5:2","tags":["Java对象和多态"],"title":"Java对象和多态","uri":"/posts/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"categories":["JavaSE笔记"],"content":"多态 多态是同一个行为具有多个不同表现形式或形态的能力。也就是同样的方法，由于实现类不同，执行的结果也不同！ 方法的重写 我们之前学习了方法的重载，方法的重写和重载是不一样的，重载是原有的方法逻辑不变的情况下，支持更多参数的实现，而重写是直接覆盖原有方法！ //父类中的study public void study(){ System.out.println(\"学习\"); } //子类中的study @Override //声明这个方法是重写的，但是可以不要，我们现阶段不接触 public void study(){ System.out.println(\"给你看点好康的\"); } 再次定义同样的方法后，父类的方法就被覆盖！子类还可以给父类方法提升访问权限！ public static void main(String[] args) { SportsStudent student = new SportsStudent(\"lbw\", 20); student.study(); //输出子类定义的内容 } 思考：静态方法能被重写吗？ 当我们在重写方法时，不仅想使用我们自己的逻辑，同时还希望执行父类的逻辑（也就是调用父类的方法）怎么办呢？ public void study(){ super.study(); System.out.println(\"给你看点好康的\"); } 同理，如果想访问父类的成员变量，也可以使用super关键字来访问，注意，子类可以具有和父类相同的成员变量！而在方法中访问的默认是 形参列表中 \u003e 当前类的成员变量 \u003e 父类成员变量 public void setTest(int test){ test = 1; this.test = 1; super.test = 1; } 再谈类型转换 我们曾经学习过基本数据类型的类型转换，支持一种数据类型转换为另一种数据类型，而我们的类也是支持类型转换的（仅限于存在亲缘关系的类之间进行转换）比如子类可以直接向上转型： Student student = new SportsStudent(\"lbw\", 20); //父类变量引用子类实例 student.study(); //得到依然是具体实现的结果，而不是当前类型的结果 我们也可以把已经明确是由哪个类实现的父类引用，强制转换为对应的类型： Student student = new SportsStudent(\"lbw\", 20); //是由SportsStudent进行实现的 //... do something... SportsStudent ps = (SportsStudent)student; //让它变成一个具体的子类 ps.sport(); //调用具体实现类的方法 这样的类型转换称为向下转型。 instanceof关键字 那么我们如果只是得到一个父类引用，但是不知道它到底是哪一个子类的实现怎么办？我们可以使用instanceof关键字来实现，它能够进行类型判断！ private static void test(Student student){ if (student instanceof SportsStudent){ SportsStudent sportsStudent = (SportsStudent) student; sportsStudent.sport(); }else if (student instanceof ArtStudent){ ArtStudent artStudent = (ArtStudent) student; artStudent.art(); } } 通过进行类型判断，我们就可以明确类的具体实现到底是哪个类！ 思考：student instanceof Student的结果是什么？ 再谈final关键字 我们目前只知道final关键字能够使得一个变量的值不可更改，那么如果在类前面声明final，会发生什么？ public final class Student { //类被声明为终态，那么它还能被继承吗 } 类一旦被声明为终态，将无法再被继承，不允许子类的存在！而方法被声明为final呢？ public final void study(){ //还能重写吗 System.out.println(\"学习\"); } 如果类的成员属性被声明为final，那么必须在构造方法中或是在定义时赋初始值！ private final String name; //引用类型不允许再指向其他对象 private final int age; //基本类型值不允许发生改变 public Student(String name, int age) { this.name = name; this.age = age; } 学习完封装继承和多态之后，我们推荐在不会再发生改变的成员属性上添加final关键字，JVM会对添加了final关键字的属性进行优化！ 抽象类 类本身就是一种抽象，而抽象类，把类还要抽象，也就是说，抽象类可以只保留特征，而不保留具体呈现形态，比如方法可以定义好，但是我可以不去实现它，而是交由子类来进行实现！ public abstract class Student { //抽象类 public abstract void test(); //抽象方法 } 通过使用abstract关键字来表明一个类是一个抽象类，抽象类可以使用abstract关键字来表明一个方法为抽象方法，也可以定义普通方法，抽象方法不需要编写具体实现（无方法体）但是必须由子类实现（除非子类也是一个抽象类）！ 抽象类由于不是具体的类定义，因此无法直接通过new关键字来创建对象！ Student s = new Student(){ //只能直接创建带实现的匿名内部类！ public void test(){ } } 因此，抽象类一般只用作继承使用！抽象类使得继承关系之间更加明确： public void study(){ //现在只能由子类编写，父类没有定义，更加明确了多态的定义！同一个方法多种实现！ System.out.println(\"给你看点好康的\"); } 接口 接口甚至比抽象类还抽象，他只代表某个确切的功能！也就是只包含方法的定义，甚至都不是一个类！接口包含了一些列方法的具体定义，类可以实现这个接口，表示类支持接口代表的功能（类似于一个插件，只能作为一个附属功能加在主体上，同时具体实现还需要由主体来实现） public interface Eat { void eat(); } 通过使用interface关键字来表明是一个接口（注意，这里class关键字被替换为了interface）接口只能包含public权限的抽象方法！（Java8以后可以有默认实现）我们可以通过声明default关键字来给抽象方法一个默认实现： public interface Eat { default void eat(){ //do something... } } 接口中定义的变量，默认为public static final public interface Eat { int a = 1; void eat(); } 一个类可以实现很多个接口，但是不能理解为多继承！（实际上实现接口是附加功能，和继承的概念有一定出入，顶多说是多继承的一种替代方案）一个类可以附加很多个功能！ public class SportsStudent extends Student implements Eat, ...{ @Override public void eat() { } } 类通过implements关键字来声明实现的接口！每个接口之间用逗号隔开！ 实现接口的类也能通过instanceof关键字判断，也支持向上和向下转型！ ","date":"2022-01-23","objectID":"/posts/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/:5:3","tags":["Java对象和多态"],"title":"Java对象和多态","uri":"/posts/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"categories":["JavaSE笔记"],"content":"内部类 类中可以存在一个类！各种各样的长相怪异的代码就是从这里开始出现的！ ","date":"2022-01-23","objectID":"/posts/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/:6:0","tags":["Java对象和多态"],"title":"Java对象和多态","uri":"/posts/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"categories":["JavaSE笔记"],"content":"成员内部类 我们的类中可以在嵌套一个类： public class Test { class Inner{ //类中定义的一个内部类 } } 成员内部类和成员变量和成员方法一样，都是属于对象的，也就是说，必须存在外部对象，才能创建内部类的对象！ public static void main(String[] args) { Test test = new Test(); Test.Inner inner = test.new Inner(); //写法有那么一丝怪异，但是没毛病！ } ","date":"2022-01-23","objectID":"/posts/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/:6:1","tags":["Java对象和多态"],"title":"Java对象和多态","uri":"/posts/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"categories":["JavaSE笔记"],"content":"静态内部类 静态内部类其实就和类中的静态变量和静态方法一样，是属于类拥有的，我们可以直接通过类名.去访问: public class Test { static class Inner{ } } public static void main(String[] args) { Test.Inner inner = new Test.Inner(); //不用再创建外部类对象了！ } ","date":"2022-01-23","objectID":"/posts/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/:6:2","tags":["Java对象和多态"],"title":"Java对象和多态","uri":"/posts/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"categories":["JavaSE笔记"],"content":"局部内部类 对，你没猜错，就是和局部变量一样哒~ public class Test { public void test(){ class Inner{ } Inner inner = new Inner(); } } 反正我是没用过！内部类 -\u003e 累不累 -\u003e 反正我累了！ ","date":"2022-01-23","objectID":"/posts/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/:6:3","tags":["Java对象和多态"],"title":"Java对象和多态","uri":"/posts/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"categories":["JavaSE笔记"],"content":"匿名内部类 匿名内部类才是我们的重点，也是实现lambda表达式的原理！匿名内部类其实就是在new的时候，直接对接口或是抽象类的实现： public static void main(String[] args) { Eat eat = new Eat() { @Override public void eat() { //DO something... } }; } 我们不用单独去创建一个类来实现，而是可以直接在new的时候写对应的实现！但是，这样写，无法实现复用，只能在这里使用！ lambda表达式 读作λ表达式，它其实就是我们接口匿名实现的简化，比如说： public static void main(String[] args) { Eat eat = new Eat() { @Override public void eat() { //DO something... } }; } public static void main(String[] args) { Eat eat = () -\u003e {}; //等价于上述内容 } lambda表达式（匿名内部类）只能访问外部的final类型或是隐式final类型的局部变量！ 为了方便，JDK默认就为我们提供了专门写函数式的接口，这里只介绍Consumer ","date":"2022-01-23","objectID":"/posts/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/:6:4","tags":["Java对象和多态"],"title":"Java对象和多态","uri":"/posts/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"categories":["JavaSE笔记"],"content":"枚举类 假设现在我们想给小明添加一个状态（跑步、学习、睡觉），外部可以实时获取小明的状态： public class Student { private final String name; private final int age; private String status; //... public void setStatus(String status) { this.status = status; } public String getStatus() { return status; } } 但是这样会出现一个问题，如果我们仅仅是存储字符串，似乎外部可以不按照我们规则，传入一些其他的字符串。这显然是不够严谨的！ 有没有一种办法，能够更好地去实现这样的状态标记呢？我们希望开发者拿到使用的就是我们定义好的状态，我们可以使用枚举类！ public enum Status { RUNNING, STUDY, SLEEP //直接写每个状态的名字即可，分号可以不打，但是推荐打上 } 使用枚举类也非常方便，我们只需要直接访问即可 public class Student { private final String name; private final int age; private Status status; //... public void setStatus(Status status) { //不再是String，而是我们指定的枚举类型 this.status = status; } public Status getStatus() { return status; } } public static void main(String[] args) { Student student = new Student(\"小明\", 18); student.setStatus(Status.RUNNING); System.out.println(student.getStatus()); } 枚举类型使用起来就非常方便了，其实枚举类型的本质就是一个普通的类，但是它继承自Enum类，我们定义的每一个状态其实就是一个public static final的Status类型成员变量！ // Compiled from \"Status.java\" public final class com.test.Status extends java.lang.Enum\u003ccom.test.Status\u003e { public static final com.test.Status RUNNING; public static final com.test.Status STUDY; public static final com.test.Status SLEEP; public static com.test.Status[] values(); public static com.test.Status valueOf(java.lang.String); static {}; } 既然枚举类型是普通的类，那么我们也可以给枚举类型添加独有的成员方法 public enum Status { RUNNING(\"睡觉\"), STUDY(\"学习\"), SLEEP(\"睡觉\"); //无参构造方法被覆盖，创建枚举需要添加参数（本质就是调用的构造方法！） private final String name; //枚举的成员变量 Status(String name){ //覆盖原有构造方法（默认private，只能内部使用！） this.name = name; } public String getName() { //获取封装的成员变量 return name; } } public static void main(String[] args) { Student student = new Student(\"小明\", 18); student.setStatus(Status.RUNNING); System.out.println(student.getStatus().getName()); } 枚举类还自带一些继承下来的实用方法 Status.valueOf(\"\") //将名称相同的字符串转换为枚举 Status.values() //快速获取所有的枚举 ","date":"2022-01-23","objectID":"/posts/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/:7:0","tags":["Java对象和多态"],"title":"Java对象和多态","uri":"/posts/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"categories":["JavaSE笔记"],"content":"基本类型包装类 Java并不是纯面向对象的语言，虽然Java语言是一个面向对象的语言，但是Java中的基本数据类型却不是面向对象的。在学习泛型和集合之前，基本类型的包装类是一定要讲解的内容！ 我们的基本类型，如果想通过对象的形式去使用他们，Java提供的基本类型包装类，使得Java能够更好的体现面向对象的思想，同时也使得基本类型能够支持对象操作！ byte -\u003e Byte boolean -\u003e Boolean short -\u003e Short char -\u003e Character int -\u003e Integer long -\u003e Long float -\u003e Float double -\u003e Double 包装类实际上就行将我们的基本数据类型，封装成一个类（运用了封装的思想） private final int value; //Integer内部其实本质还是存了一个基本类型的数据，但是我们不能直接操作 public Integer(int value) { this.value = value; } 现在我们操作的就是Integer对象而不是一个int基本类型了！ public static void main(String[] args) { Integer i = 1; //包装类型可以直接接收对应类型的数据，并变为一个对象！ System.out.println(i + i); //包装类型可以直接被当做一个基本类型进行操作！ } 自动装箱和拆箱 那么为什么包装类型能直接使用一个具体值来赋值呢？其实依靠的是自动装箱和拆箱机制 Integer i = 1; //其实这里只是简写了而已 Integer i = Integer.valueOf(1); //编译后真正的样子 调用valueOf来生成一个Integer对象！ public static Integer valueOf(int i) { if (i \u003e= IntegerCache.low \u0026\u0026 i \u003c= IntegerCache.high) //注意，Java为了优化，有一个缓存机制，如果是在-128~127之间的数，会直接使用已经缓存好的对象，而不是再去创建新的！（面试常考） return IntegerCache.cache[i + (-IntegerCache.low)]; return new Integer(i); //返回一个新创建好的对象 } 而如果使用包装类来进行运算，或是赋值给一个基本类型变量，会进行自动拆箱： public static void main(String[] args) { Integer i = Integer.valueOf(1); int a = i; //简写 int a = i.intValue(); //编译后实际的代码 long c = i.longValue(); //其他类型也有！ } 既然现在是包装类型了，那么我们还能使用==来判断两个数是否相等吗？ public static void main(String[] args) { Integer i1 = 28914; Integer i2 = 28914; System.out.println(i1 == i2); //实际上判断是两个对象是否为同一个对象（内存地址是否相同） System.out.println(i1.equals(i2)); //这个才是真正的值判断！ } 注意IntegerCache带来的影响！ 思考：下面这种情况结果会是什么？ public static void main(String[] args) { Integer i1 = 28914; Integer i2 = 28914; System.out.println(i1+1 == i2+1); } 在集合类的学习中，我们还会继续用到我们的包装类型！ ","date":"2022-01-23","objectID":"/posts/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/:8:0","tags":["Java对象和多态"],"title":"Java对象和多态","uri":"/posts/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"categories":["JavaSE笔记"],"content":"面向对象编程实战 虽然我们学习了编程，但是我们不能一股脑的所有问题都照着编程的思维去解决，编程只是解决问题的一种手段，灵活的运用我们所学的知识，才是解决问题的最好办法！比如，求1到100所有数的和： public static void main(String[] args) { int sum = 0; for (int i = 1; i \u003c= 100; i++) { //for循环暴力求解，简单，但是效率似乎低了一些 sum += i; } System.out.println(sum); } public static void main(String[] args) { System.out.println((1 + 100) * 50); //高斯求和公式，利用数学，瞬间计算结果！ } 说到最后，其实数学和逻辑思维才是解决问题的最终办法！ ","date":"2022-01-23","objectID":"/posts/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/:9:0","tags":["Java对象和多态"],"title":"Java对象和多态","uri":"/posts/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"categories":["JavaSE笔记"],"content":"对象设计（面向对象、多态运用） 设计一个Person抽象类，包含吃饭运动学习三种行为，分为工人、学生、老师三种职业。 设计设计一个接口考试，只有老师和学生会考试。 设计一个方法，模拟让人类进入考场，要求只有会考试的人才能进入，并且考试。 ","date":"2022-01-23","objectID":"/posts/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/:9:1","tags":["Java对象和多态"],"title":"Java对象和多态","uri":"/posts/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"categories":["JavaSE笔记"],"content":"二分搜索（搜索算法） 现在有一个有序数组（从小到大，数组长度 0 \u003c n \u003c 1000000）如何快速寻找我们想要的数在哪个位置，如果存在请返回下标，不存在返回-1即可。 int[] arr = new int[]{1, 4, 5, 6, 7, 10, 12, 14, 20, 22, 26}; //测试用例 private static int test(int[] arr, int target){ //请在这里实现搜索算法 } ","date":"2022-01-23","objectID":"/posts/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/:9:2","tags":["Java对象和多态"],"title":"Java对象和多态","uri":"/posts/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"categories":["JavaSE笔记"],"content":"快速排序（排序算法、递归分治） （开始之前先介绍一下递归！）快速排序其实是一种排序执行效率很高的排序算法，它利用分治法来对待排序序列进行分治排序，它的思想主要是通过一趟排序将待排记录分隔成独立的两部分，其中的一部分比关键字小，后面一部分比关键字大，然后再对这前后的两部分分别采用这种方式进行排序，通过递归的运算最终达到整个序列有序。 快速排序就像它的名字一样，快速！在极端情况下，会退化成冒泡排序！ ","date":"2022-01-23","objectID":"/posts/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/:9:3","tags":["Java对象和多态"],"title":"Java对象和多态","uri":"/posts/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"categories":["JavaSE笔记"],"content":"0/1背包问题（回溯法、剪枝/动态规划优化） 给定 n 件物品，每一个物品的重量为 w[n]，每个物品的价值为 v[n]。现挑选物品放入背包中，假定背包能承受的最大重量为 capacity，求装入物品的最大价值是多少? int[] w = {2, 3, 4, 5}; int[] v = {3, 4, 5, 6}; int capacity = 8; ","date":"2022-01-23","objectID":"/posts/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/:9:4","tags":["Java对象和多态"],"title":"Java对象和多态","uri":"/posts/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"categories":["JavaSE笔记"],"content":"Java异常处理机制","date":"2022-01-23","objectID":"/posts/java%E5%BC%82%E5%B8%B8/","tags":["Java异常处理"],"title":"Java异常处理机制","uri":"/posts/java%E5%BC%82%E5%B8%B8/"},{"categories":["JavaSE笔记"],"content":"Java异常机制 配套视频 在理想的情况下，我们的程序会按照我们的思路去运行，按理说是不会出现问题的，但是，代码实际编写后并不一定是完美的，可能会有我们没有考虑到的情况，如果这些情况能够正常得到一个错误的结果还好，但是如果直接导致程序运行出现问题了呢？ public static void main(String[] args) { test(1, 0); //当b为0的时候，还能正常运行吗？ } private static int test(int a, int b){ return a/b; //没有任何的判断而是直接做计算 } Exception in thread \"main\" java.lang.ArithmeticException: / by zero at com.test.Application.test(Application.java:9) at com.test.Application.main(Application.java:5) 当程序运行出现我们没有考虑到的情况时，就有可能出现异常或是错误！ ","date":"2022-01-23","objectID":"/posts/java%E5%BC%82%E5%B8%B8/:0:0","tags":["Java异常处理"],"title":"Java异常处理机制","uri":"/posts/java%E5%BC%82%E5%B8%B8/"},{"categories":["JavaSE笔记"],"content":"异常 我们在之前其实已经接触过一些异常了，比如数组越界异常，空指针异常，算术异常等，他们其实都是异常类型，我们的每一个异常也是一个类，他们都继承自Exception类！异常类型本质依然类的对象，但是异常类型支持在程序运行出现问题时抛出（也就是上面出现的红色报错）也可以提前声明，告知使用者需要处理可能会出现的异常！ ","date":"2022-01-23","objectID":"/posts/java%E5%BC%82%E5%B8%B8/:1:0","tags":["Java异常处理"],"title":"Java异常处理机制","uri":"/posts/java%E5%BC%82%E5%B8%B8/"},{"categories":["JavaSE笔记"],"content":"运行时异常 异常的第一种类型是运行时异常，如上述的列子，在编译阶段无法感知代码是否会出现问题，只有在运行的时候才知道会不会出错（正常情况下是不会出错的），这样的异常称为运行时异常。所有的运行时异常都继承自RuntimeException。 ","date":"2022-01-23","objectID":"/posts/java%E5%BC%82%E5%B8%B8/:1:1","tags":["Java异常处理"],"title":"Java异常处理机制","uri":"/posts/java%E5%BC%82%E5%B8%B8/"},{"categories":["JavaSE笔记"],"content":"编译时异常 异常的另一种类型是编译时异常，编译时异常是明确会出现的异常，在编译阶段就需要进行处理的异常（捕获异常）如果不进行处理，将无法通过编译！默认继承自Exception类的异常都是编译时异常。 File file = new File(\"my.txt\"); file.createNewFile(); //要调用此方法，首先需要处理异常 ","date":"2022-01-23","objectID":"/posts/java%E5%BC%82%E5%B8%B8/:1:2","tags":["Java异常处理"],"title":"Java异常处理机制","uri":"/posts/java%E5%BC%82%E5%B8%B8/"},{"categories":["JavaSE笔记"],"content":"错误 错误比异常更严重，异常就是不同寻常，但不一定会导致致命的问题，而错误是致命问题，一般出现错误可能JVM就无法继续正常运行了，比如OutOfMemoryError就是内存溢出错误（内存占用已经超出限制，无法继续申请内存了） int[] arr = new int[Integer.MAX_VALUE]; //能创建如此之大的数组吗？ 运行后得到以下内容： Exception in thread \"main\" java.lang.OutOfMemoryError: Requested array size exceeds VM limit at com.test.Main.main(Main.java:14) 错误都继承自Error类，一般情况下，程序中只能处理异常，错误是很难进行处理的，Error和Execption都继承自Throwable类。当程序中出现错误或异常时又没有进行处理时，程序（当前线程）将终止运行： int[] arr = new int[Integer.MAX_VALUE]; System.out.println(\"lbwnb\"); //还能正常打印吗？ ","date":"2022-01-23","objectID":"/posts/java%E5%BC%82%E5%B8%B8/:2:0","tags":["Java异常处理"],"title":"Java异常处理机制","uri":"/posts/java%E5%BC%82%E5%B8%B8/"},{"categories":["JavaSE笔记"],"content":"异常的处理 当程序没有按照我们想要的样子运行而出现异常时（默认会交给JVM来处理，JVM发现任何异常都会立即终止程序运行，并在控制台打印栈追踪信息），我们希望能够自己处理出现的问题，让程序继续运行下去，就需要对异常进行捕获，比如： int[] arr = new int[5]; arr[5] = 1; //我们需要处理这种情况，保证后面的代码正常运行！ System.out.println(\"lbwnb\"); 我们可以使用try和catch语句块来处理： int[] arr = new int[5]; try{ //在try块中运行代码 arr[5] = 1; //当代码出现异常时，异常会被捕获，并在catch块中得到异常类型的对象 }catch (ArrayIndexOutOfBoundsException e){ //捕获的异常类型 System.out.println(\"程序运行出现异常！\"); //出现异常时执行 } //后面的代码会正常运行 System.out.println(\"lbwnb\"); 当异常被捕获后，就由我们自己进行处理（不再交给JVM处理），因此就不会导致程序终止运行。 我们可以通过使用e.printStackTrace()来打印栈追踪信息，定位我们的异常出现位置： java.lang.ArrayIndexOutOfBoundsException: 5 at com.test.Main.main(Main.java:7) //Main类的第7行出现问题 程序运行出现异常！ lbwnb 运行时异常在编译时可以不用捕获，但是编译时异常必须进行处理： File file = new File(\"my.txt\"); try { file.createNewFile(); } catch (IOException e) { //捕获声明的异常类型 e.printStackTrace(); } 可以捕获到类型不止是Exception的子类，只要是继承自Throwalbe的类，都能被捕获，也就是说，Error也能被捕获，但是不建议这样做，因为错误一般是虚拟机相关的问题，出现Error应该从问题的根源去解决。 ","date":"2022-01-23","objectID":"/posts/java%E5%BC%82%E5%B8%B8/:3:0","tags":["Java异常处理"],"title":"Java异常处理机制","uri":"/posts/java%E5%BC%82%E5%B8%B8/"},{"categories":["JavaSE笔记"],"content":"异常的抛出 当别人调用我们的方法时，如果传入了错误的参数导致程序无法正常运行，这时我们就需要手动抛出一个异常来终止程序继续运行下去，同时告知上一级方法执行出现了问题： public static void main(String[] args) { try { test(1, 0); } catch (Exception e) { //捕获方法中会出现的异常 e.printStackTrace(); } } private static int test(int a, int b) throws Exception { //声明抛出的异常类型 if(b == 0) throw new Exception(\"0不能做除数！\"); //创建异常对象并抛出异常 return a/b; //抛出异常会终止代码运行 } 通过throw关键字抛出异常（抛出异常后，后面的代码不再执行）当程序运行到这一行时，就会终止执行，并出现一个异常。 如果方法中抛出了非运行时异常，但是不希望在此方法内处理，而是交给调用者来处理异常，就需要在方法定义后面显式声明抛出的异常类型！如果抛出的是运行时异常，则不需要在方法后面声明异常类型，调用时也无需捕获，但是出现异常时同样会导致程序终止（出现运行时异常同时未被捕获会默认交给JVM处理，也就是直接中止程序并在控制台打印栈追踪信息） 如果想要调用声明编译时异常的方法，但是依然不想去处理，可以同样的在方法上声明throws来继续交给上一级处理。 public static void main(String[] args) throws Exception { //出现异常就再往上抛，而不是在此方法内处理 test(1, 0); } private static int test(int a, int b) throws Exception { //声明抛出的异常类型 if(b == 0) throw new Exception(\"0不能做除数！\"); //创建异常对象并抛出异常 return a/b; } 当main方法都声明抛出异常时，出现异常就由JVM进行处理，也就是默认的处理方式（直接中止程序并在控制台打印栈追踪信息） 异常只能被捕获一次，当异常捕获出现嵌套时，只会在最内层被捕获： public static void main(String[] args) throws Exception { try{ test(1, 0); }catch (Exception e){ System.out.println(\"外层\"); } } private static int test(int a, int b){ try{ if(b == 0) throw new Exception(\"0不能做除数！\"); }catch (Exception e){ System.out.println(\"内层\"); return 0; } return a/b; } ","date":"2022-01-23","objectID":"/posts/java%E5%BC%82%E5%B8%B8/:4:0","tags":["Java异常处理"],"title":"Java异常处理机制","uri":"/posts/java%E5%BC%82%E5%B8%B8/"},{"categories":["JavaSE笔记"],"content":"自定义异常 JDK为我们已经提前定义了一些异常了，但是可能对我们来说不够，那么就需要自定义异常： public class MyException extends Exception { //直接继承即可 } public static void main(String[] args) throws MyException { throw new MyException(); //直接使用 } 也可以使用父类的带描述的构造方法： public class MyException extends Exception { public MyException(String message){ super(message); } } public static void main(String[] args) throws MyException { throw new MyException(\"出现了自定义的错误\"); } 捕获异常指定的类型，会捕获其所有子异常类型： try { throw new MyException(\"出现了自定义的错误\"); } catch (Exception e) { //捕获父异常类型 System.out.println(\"捕获到异常\"); } ","date":"2022-01-23","objectID":"/posts/java%E5%BC%82%E5%B8%B8/:5:0","tags":["Java异常处理"],"title":"Java异常处理机制","uri":"/posts/java%E5%BC%82%E5%B8%B8/"},{"categories":["JavaSE笔记"],"content":"多重异常捕获和finally关键字 当代码可能出现多种类型的异常时，我们希望能够分不同情况处理不同类型的异常，就可以使用多重异常捕获： try { //.... } catch (NullPointerException e) { } catch (IndexOutOfBoundsException e){ } catch (RuntimeException e){ } 注意，类似于if-else if的结构，父异常类型只能放在最后！ try { //.... } catch (RuntimeException e){ //父类型在前，会将子类的也捕获 } catch (NullPointerException e) { //永远都不会被捕获 } catch (IndexOutOfBoundsException e){ //永远都不会被捕获 } 如果希望把这些异常放在一起进行处理： try { //.... } catch (NullPointerException | IndexOutOfBoundsException e) { //用|隔开每种类型即可 } 当我们希望，程序运行时，无论是否出现异常，都会在最后执行的任务，可以交给finally语句块来处理： try { //.... }catch (Exception e){ }finally { System.out.println(\"lbwnb\"); //无论是否出现异常，都会在最后执行 } try语句块至少要配合catch或finally中的一个： try { int a = 10; a /= 0; }finally { //不捕获异常，程序会终止，但在最后依然会执行下面的内容 System.out.println(\"lbwnb\"); } 思考：try、catch和finally执行顺序： private static int test(int a){ try{ return a; }catch (Exception e){ return 0; }finally { a = a + 1; } } ","date":"2022-01-23","objectID":"/posts/java%E5%BC%82%E5%B8%B8/:6:0","tags":["Java异常处理"],"title":"Java异常处理机制","uri":"/posts/java%E5%BC%82%E5%B8%B8/"},{"categories":["JavaSE笔记"],"content":"Java泛型与集合类","date":"2022-01-23","objectID":"/posts/java%E6%B3%9B%E5%9E%8B%E4%B8%8E%E9%9B%86%E5%90%88%E7%B1%BB/","tags":["Java泛型与集合类"],"title":"Java泛型与集合类","uri":"/posts/java%E6%B3%9B%E5%9E%8B%E4%B8%8E%E9%9B%86%E5%90%88%E7%B1%BB/"},{"categories":["JavaSE笔记"],"content":"Java泛型与集合类 配套视频 在前面我们学习了最重要的类和对象，了解了面向对象编程的思想，注意，非常重要，面向对象是必须要深入理解和掌握的内容，不能草草结束。在本章节，我们会继续深入了解，从我们的泛型开始，再到我们的数据结构，最后再开始我们的集合类学习。 ","date":"2022-01-23","objectID":"/posts/java%E6%B3%9B%E5%9E%8B%E4%B8%8E%E9%9B%86%E5%90%88%E7%B1%BB/:0:0","tags":["Java泛型与集合类"],"title":"Java泛型与集合类","uri":"/posts/java%E6%B3%9B%E5%9E%8B%E4%B8%8E%E9%9B%86%E5%90%88%E7%B1%BB/"},{"categories":["JavaSE笔记"],"content":"走进泛型 为了统计学生成绩，要求设计一个Score对象，包括课程名称、课程号、课程成绩，但是成绩分为两种，一种是以优秀、良好、合格 来作为结果，还有一种就是 60.0、75.5、92.5 这样的数字分数，那么现在该如何去设计这样的一个Score类呢？现在的问题就是，成绩可能是String类型，也可能是Integer类型，如何才能很好的去存可能出现的两种类型呢？ public class Score { String name; String id; Object score; //因为Object是所有类型的父类，因此既可以存放Integer也能存放String public Score(String name, String id, Object score) { this.name = name; this.id = id; this.score = score; } } 以上的方法虽然很好地解决了多种类型存储问题，但是Object类型在编译阶段并不具有良好的类型判断能力，很容易出现以下的情况： public static void main(String[] args) { Score score = new Score(\"数据结构与算法基础\", \"EP074512\", \"优秀\"); //是String类型的 //.... Integer number = (Integer) score.score; //获取成绩需要进行强制类型转换，虽然并不是一开始的类型，但是编译不会报错 } //运行时出现异常！ Exception in thread \"main\" java.lang.ClassCastException: java.lang.String cannot be cast to java.lang.Integer at com.test.Main.main(Main.java:14) 使用Object类型作为引用，取值只能进行强制类型转换，显然无法在编译期确定类型是否安全，项目中代码量非常之大，进行类型比较又会导致额外的开销和增加代码量，如果不经比较就很容易出现类型转换异常，代码的健壮性有所欠缺！（此方法虽然可行，但并不是最好的方法） 为了解决以上问题，JDK1.5新增了泛型，它能够在编译阶段就检查类型安全，大大提升开发效率。 public class Score\u003cT\u003e { //将Score转变为泛型类\u003cT\u003e String name; String id; T score; //T为泛型，根据用户提供的类型自动变成对应类型 public Score(String name, String id, T score) { //提供的score类型即为T代表的类型 this.name = name; this.id = id; this.score = score; } } public static void main(String[] args) { //直接确定Score的类型是字符串类型的成绩 Score\u003cString\u003e score = new Score\u003cString\u003e(\"数据结构与算法基础\", \"EP074512\", \"优秀\"); Integer i = score.score; //编译不通过，因为成员变量score类型被定为String！ } 泛型将数据类型的确定控制在了编译阶段，在编写代码的时候就能明确泛型的类型！如果类型不符合，将无法通过编译！ 泛型本质上也是一个语法糖（并不是JVM所支持的语法，编译后会转成编译器支持的语法，比如之前的foreach就是），在编译后会被擦除，变回上面的Object类型调用，但是类型转换由编译器帮我们完成，而不是我们自己进行转换（安全） //反编译后的代码 public static void main(String[] args) { Score score = new Score(\"数据结构与算法基础\", \"EP074512\", \"优秀\"); String i = (String)score.score; //其实依然会变为强制类型转换，但是这是由编译器帮我们完成的 } 像这样在编译后泛型的内容消失转变为Object的情况称为类型擦除（重要，需要完全理解），所以泛型只是为了方便我们在编译阶段确定类型的一种语法而已，并不是JVM所支持的。 综上，泛型其实就是一种类型参数，用于指定类型。 ","date":"2022-01-23","objectID":"/posts/java%E6%B3%9B%E5%9E%8B%E4%B8%8E%E9%9B%86%E5%90%88%E7%B1%BB/:1:0","tags":["Java泛型与集合类"],"title":"Java泛型与集合类","uri":"/posts/java%E6%B3%9B%E5%9E%8B%E4%B8%8E%E9%9B%86%E5%90%88%E7%B1%BB/"},{"categories":["JavaSE笔记"],"content":"泛型的使用 ","date":"2022-01-23","objectID":"/posts/java%E6%B3%9B%E5%9E%8B%E4%B8%8E%E9%9B%86%E5%90%88%E7%B1%BB/:2:0","tags":["Java泛型与集合类"],"title":"Java泛型与集合类","uri":"/posts/java%E6%B3%9B%E5%9E%8B%E4%B8%8E%E9%9B%86%E5%90%88%E7%B1%BB/"},{"categories":["JavaSE笔记"],"content":"泛型类 上一节我们已经提到泛型类的定义，实际上就是普通的类多了一个类型参数，也就是在使用时需要指定具体的泛型类型。泛型的名称一般取单个大写字母，比如T代表Type，也就是类型的英文单词首字母，当然也可以添加数字和其他的字符。 public class Score\u003cT\u003e { //将Score转变为泛型类\u003cT\u003e String name; String id; T score; //T为泛型，根据用户提供的类型自动变成对应类型 public Score(String name, String id, T score) { //提供的score类型即为T代表的类型 this.name = name; this.id = id; this.score = score; } } 在一个普通类型中定义泛型，泛型T称为参数化类型，在定义泛型类的引用时，需要明确指出类型： Score\u003cString\u003e score = new Score\u003cString\u003e(\"数据结构与算法基础\", \"EP074512\", \"优秀\"); 此时类中的泛型T已经被替换为String了，在我们获取此对象的泛型属性时，编译器会直接告诉我们类型： Integer i = score.score; //编译不通过，因为成员变量score明确为String类型 注意，泛型只能用于对象属性，也就是非静态的成员变量才能使用： static T score; //错误，不能在静态成员上定义 由此可见，泛型是只有在创建对象后编译器才能明确泛型类型，而静态类型是类所具有的属性，不足以使得编译器完成类型推断。 泛型无法使用基本类型，如果需要基本类型，只能使用基本类型的包装类进行替换！ Score\u003cdouble\u003e score = new Score\u003cdouble\u003e(\"数据结构与算法基础\", \"EP074512\", 90.5); //编译不通过 那么为什么泛型无法使用基本类型呢？回想上一节提到的类型擦除，其实就很好理解了。由于JVM没有泛型概念，因此泛型最后还是会被编译器编译为Object，并采用强制类型转换的形式进行类型匹配，而我们的基本数据类型和引用类型之间无法进行类型转换，所以只能使用基本类型的包装类来处理。 ","date":"2022-01-23","objectID":"/posts/java%E6%B3%9B%E5%9E%8B%E4%B8%8E%E9%9B%86%E5%90%88%E7%B1%BB/:2:1","tags":["Java泛型与集合类"],"title":"Java泛型与集合类","uri":"/posts/java%E6%B3%9B%E5%9E%8B%E4%B8%8E%E9%9B%86%E5%90%88%E7%B1%BB/"},{"categories":["JavaSE笔记"],"content":"类的泛型方法 泛型方法的使用也很简单，我们只需要把它当做一个未知的类型来使用即可： public T getScore() { //若方法的返回值类型为泛型，那么编译器会自动进行推断 return score; } public void setScore(T score) { //若方法的形式参数为泛型，那么实参只能是定义时的类型 this.score = score; } Score\u003cString\u003e score = new Score\u003cString\u003e(\"数据结构与算法基础\", \"EP074512\", \"优秀\"); score.setScore(10); //编译不通过，因为只接受String类型 同样地，静态方法无法直接使用类定义的泛型（注意是无法直接使用，静态方法可以使用泛型） ","date":"2022-01-23","objectID":"/posts/java%E6%B3%9B%E5%9E%8B%E4%B8%8E%E9%9B%86%E5%90%88%E7%B1%BB/:2:2","tags":["Java泛型与集合类"],"title":"Java泛型与集合类","uri":"/posts/java%E6%B3%9B%E5%9E%8B%E4%B8%8E%E9%9B%86%E5%90%88%E7%B1%BB/"},{"categories":["JavaSE笔记"],"content":"自定义泛型方法 那么如果我想在静态方法中使用泛型呢？首先我们要明确之前为什么无法使用泛型，因为之前我们的泛型定义是在类上的，只有明确具体的类型才能开始使用，也就是创建对象时完成类型确定，但是静态方法不需要依附于对象，那么只能在使用时再来确定了，所以静态方法可以使用泛型，但是需要单独定义： public static \u003cE\u003e void test(E e){ //在方法定义前声明泛型 System.out.println(e); } 同理，成员方法也能自行定义泛型，在实际使用时再进行类型确定： public \u003cE\u003e void test(E e){ System.out.println(e); } 其实，无论是泛型类还是泛型方法，再使用时一定要能够进行类型推断，明确类型才行。 注意一定要区分类定义的泛型和方法前定义的泛型！ ","date":"2022-01-23","objectID":"/posts/java%E6%B3%9B%E5%9E%8B%E4%B8%8E%E9%9B%86%E5%90%88%E7%B1%BB/:2:3","tags":["Java泛型与集合类"],"title":"Java泛型与集合类","uri":"/posts/java%E6%B3%9B%E5%9E%8B%E4%B8%8E%E9%9B%86%E5%90%88%E7%B1%BB/"},{"categories":["JavaSE笔记"],"content":"泛型引用 可以看到我们在定义一个泛型类的引用时，需要在后面指出此类型： Score\u003cInteger\u003e score; //声明泛型为Integer类型 如果不希望指定类型，或是希望此引用类型可以引用任意泛型的Score类对象，可以使用?通配符，来表示自动匹配任意的可用类型： Score\u003c?\u003e score; //score可以引用任意的Score类型对象了！ 那么使用通配符之后，得到的泛型成员变量会是什么类型呢？ Object o = score.getScore(); //只能变为Object 因为使用了通配符，编译器就无法进行类型推断，所以只能使用原始类型。 在学习了泛型的界限后，我们还会继续了解通配符的使用。 ","date":"2022-01-23","objectID":"/posts/java%E6%B3%9B%E5%9E%8B%E4%B8%8E%E9%9B%86%E5%90%88%E7%B1%BB/:2:4","tags":["Java泛型与集合类"],"title":"Java泛型与集合类","uri":"/posts/java%E6%B3%9B%E5%9E%8B%E4%B8%8E%E9%9B%86%E5%90%88%E7%B1%BB/"},{"categories":["JavaSE笔记"],"content":"泛型的界限 现在有一个新的需求，现在没有String类型的成绩了，但是成绩依然可能是整数，也可能是小数，这时我们不希望用户将泛型指定为除数字类型外的其他类型，我们就需要使用到泛型的上界定义： public class Score\u003cT extends Number\u003e { //设定泛型上界，必须是Number的子类 private final String name; private final String id; private T score; public Score(String name, String id, T score) { this.name = name; this.id = id; this.score = score; } public T getScore() { return score; } } 通过extends关键字进行上界限定，只有指定类型或指定类型的子类才能作为类型参数。 同样的，泛型通配符也支持泛型的界限： Score\u003c? extends Number\u003e score; //限定为匹配Number及其子类的类型 同理，既然泛型有上限，那么也有下限： Score\u003c? super Integer\u003e score; //限定为匹配Integer及其父类 通过super关键字进行下界限定，只有指定类型或指定类型的父类才能作为类型参数。 图解如下： 那么限定了上界后，我们再来使用这个对象的泛型成员，会变成什么类型呢？ Score\u003c? extends Number\u003e score = new Score\u003c\u003e(\"数据结构与算法基础\", \"EP074512\", 10); Number o = score.getScore(); //得到的结果为上界类型 也就是说，一旦我们指定了上界后，编译器就将范围从原始类型Object提升到我们指定的上界Number，但是依然无法明确具体类型。思考：那如果定义下限呢？ 那么既然我们可以给泛型类限定上界，现在我们来看编译后结果呢： //使用javap -l 进行反编译 public class com.test.Score\u003cT extends java.lang.Number\u003e { public com.test.Score(java.lang.String, java.lang.String, T); LineNumberTable: line 8: 0 line 9: 4 line 10: 9 line 11: 14 line 12: 19 LocalVariableTable: Start Length Slot Name Signature 0 20 0 this Lcom/test/Score; 0 20 1 name Ljava/lang/String; 0 20 2 id Ljava/lang/String; 0 20 3 score Ljava/lang/Number; //可以看到score的类型直接被编译为Number类 public T getScore(); LineNumberTable: line 15: 0 LocalVariableTable: Start Length Slot Name Signature 0 5 0 this Lcom/test/Score; } 因此，一旦确立上限后，编译器会自动将类型提升到上限类型。 ","date":"2022-01-23","objectID":"/posts/java%E6%B3%9B%E5%9E%8B%E4%B8%8E%E9%9B%86%E5%90%88%E7%B1%BB/:2:5","tags":["Java泛型与集合类"],"title":"Java泛型与集合类","uri":"/posts/java%E6%B3%9B%E5%9E%8B%E4%B8%8E%E9%9B%86%E5%90%88%E7%B1%BB/"},{"categories":["JavaSE笔记"],"content":"钻石运算符 我们发现，每次创建泛型对象都需要在前后都标明类型，但是实际上后面的类型声明是可以去掉的，因为我们在传入参数时或定义泛型类的引用时，就已经明确了类型，因此JDK1.7提供了钻石运算符来简化代码： Score\u003cInteger\u003e score = new Score\u003cInteger\u003e(\"数据结构与算法基础\", \"EP074512\", 10); //1.7之前 Score\u003cInteger\u003e score = new Score\u003c\u003e(\"数据结构与算法基础\", \"EP074512\", 10); //1.7之后 ","date":"2022-01-23","objectID":"/posts/java%E6%B3%9B%E5%9E%8B%E4%B8%8E%E9%9B%86%E5%90%88%E7%B1%BB/:2:6","tags":["Java泛型与集合类"],"title":"Java泛型与集合类","uri":"/posts/java%E6%B3%9B%E5%9E%8B%E4%B8%8E%E9%9B%86%E5%90%88%E7%B1%BB/"},{"categories":["JavaSE笔记"],"content":"泛型与多态 泛型不仅仅可以可以定义在类上，同时也能定义在接口上： public interface ScoreInterface\u003cT\u003e { T getScore(); void setScore(T t); } 当实现此接口时，我们可以选择在实现类明确泛型类型或是继续使用此泛型，让具体创建的对象来确定类型。 public class Score\u003cT\u003e implements ScoreInterface\u003cT\u003e{ //将Score转变为泛型类\u003cT\u003e private final String name; private final String id; private T score; public Score(String name, String id, T score) { this.name = name; this.id = id; this.score = score; } public T getScore() { return score; } @Override public void setScore(T score) { this.score = score; } } public class StringScore implements ScoreInterface\u003cString\u003e{ //在实现时明确类型 @Override public String getScore() { return null; } @Override public void setScore(String s) { } } 抽象类同理，这里就不多做演示了。 ","date":"2022-01-23","objectID":"/posts/java%E6%B3%9B%E5%9E%8B%E4%B8%8E%E9%9B%86%E5%90%88%E7%B1%BB/:2:7","tags":["Java泛型与集合类"],"title":"Java泛型与集合类","uri":"/posts/java%E6%B3%9B%E5%9E%8B%E4%B8%8E%E9%9B%86%E5%90%88%E7%B1%BB/"},{"categories":["JavaSE笔记"],"content":"多态类型擦除 思考一个问题，既然继承后明确了泛型类型，那么为什么@Override不会出现错误呢，重写的条件是需要和父类的返回值类型、形式参数一致，而泛型默认的原始类型是Object类型，子类明确后变为Number类型，这显然不满足重写的条件，但是为什么依然能编译通过呢？ class A\u003cT\u003e{ private T t; public T get(){ return t; } public void set(T t){ this.t=t; } } class B extends A\u003cNumber\u003e{ private Number n; @Override public Number get(){ //这并不满足重写的要求，因为只能重写父类同样返回值和参数的方法，但是这样却能够通过编译！ return t; } @Override public void set(Number t){ this.t=t; } } 通过反编译进行观察，实际上是编译器帮助我们生成了两个桥接方法用于支持重写： @Override public Object get(){ return this.get();//调用返回Number的那个方法 } @Override public void set(Object t ){ this.set((Number)t ); //调用参数是Number的那个方法 } ","date":"2022-01-23","objectID":"/posts/java%E6%B3%9B%E5%9E%8B%E4%B8%8E%E9%9B%86%E5%90%88%E7%B1%BB/:2:8","tags":["Java泛型与集合类"],"title":"Java泛型与集合类","uri":"/posts/java%E6%B3%9B%E5%9E%8B%E4%B8%8E%E9%9B%86%E5%90%88%E7%B1%BB/"},{"categories":["JavaSE笔记"],"content":"数据结构基础 警告！本章最难的部分！ 学习集合类之前，我们还有最关键的内容需要学习，同第一章一样，自底向上才是最佳的学习方向，比起直接带大家认识集合类，不如先了解一下数据结构，只有了解了数据结构基础，才能更好地学习集合类，同时，数据结构也是你以后深入学习JDK源码的必备条件！（学习不要快餐式！）当然，我们主要是讲解Java，数据结构作为铺垫作用，所以我们只会讲解关键的部分，其他部分可以下去自行了解。 在计算机科学中，数据结构是一种数据组织、管理和存储的格式,它可以帮助我们实现对数据高效的访问和修改。更准确地说,数据结构是数据值的集合，可以体现数据值之间的关系，以及可以对数据进行应用的函数或操作。 通俗地说，我们需要去学习在计算机中如何去更好地管理我们的数据，才能让我们对我们的数据控制更加灵活！ ","date":"2022-01-23","objectID":"/posts/java%E6%B3%9B%E5%9E%8B%E4%B8%8E%E9%9B%86%E5%90%88%E7%B1%BB/:3:0","tags":["Java泛型与集合类"],"title":"Java泛型与集合类","uri":"/posts/java%E6%B3%9B%E5%9E%8B%E4%B8%8E%E9%9B%86%E5%90%88%E7%B1%BB/"},{"categories":["JavaSE笔记"],"content":"线性表 线性表是最基本的一种数据结构，它是表示一组相同类型数据的有限序列，你可以把它与数组进行参考，但是它并不是数组，线性表是一种表结构，它能够支持数据的插入、删除、更新、查询等，同时数组可以随意存放在数组中任意位置，而线性表只能依次有序排列，不能出现空隙，因此，我们需要进一步的设计。 顺序表 将数据依次存储在连续的整块物理空间中，这种存储结构称为顺序存储结构，而以这种方式实现的线性表，我们称为顺序表。 同样的，表中的每一个个体都被称为元素，元素左边的元素（上一个元素），称为前驱，同理，右边的元素（后一个元素）称为后驱。 我们设计线性表的目标就是为了去更好地管理我们的数据，也就是说，我们可以基于数组，来进行封装，实现增删改查！既然要存储一组数据，那么很容易联想到我们之前学过的数组，数组就能够容纳一组同类型的数据。 目标：以数组为底层，编写以下抽象类的具体实现 /** * 线性表抽象类 * @param \u003cE\u003e 存储的元素(Element)类型 */ public abstract class AbstractList\u003cE\u003e { /** * 获取表的长度 * @return 顺序表的长度 */ public abstract int size(); /** * 添加一个元素 * @param e 元素 * @param index 要添加的位置(索引) */ public abstract void add(E e, int index); /** * 移除指定位置的元素 * @param index 位置 * @return 移除的元素 */ public abstract E remove(int index); /** * 获取指定位置的元素 * @param index 位置 * @return 元素 */ public abstract E get(int index); } 链表 数据分散的存储在物理空间中，通过一根线保存着它们之间的逻辑关系，这种存储结构称为链式存储结构 实际上，就是每一个结点存放一个元素和一个指向下一个结点的引用（C语言里面是指针，Java中就是对象的引用，代表下一个结点对象） 利用这种思想，我们再来尝试实现上面的抽象类，从实际的代码中感受！ 比较：顺序表和链表的优异？ 顺序表优缺点： 访问速度快，随机访问性能高 插入和删除的效率低下，极端情况下需要变更整个表 不易扩充，需要复制并重新创建数组 链表优缺点： 插入和删除效率高，只需要改变连接点的指向即可 动态扩充容量，无需担心容量问题 访问元素需要依次寻找，随机访问元素效率低下 链表只能指向后面，能不能指向前面呢？双向链表！ 栈和队列实际上就是对线性表加以约束的一种数据结构，如果前面的线性表的掌握已经ok，那么栈和队列就非常轻松了！ 栈 栈遵循先入后出原则，只能在线性表的一端添加和删除元素。我们可以把栈看做一个杯子，杯子只有一个口进出，最低处的元素只能等到上面的元素离开杯子后，才能离开。 向栈中插入一个元素时，称为入栈（压栈），移除栈顶元素称为出栈，我们需要尝试实现以下抽象类型： /** * 抽象类型栈，待实现 * @param \u003cE\u003e 元素类型 */ public abstract class AbstractStack\u003cE\u003e { /** * 出栈操作 * @return 栈顶元素 */ public abstract E pop(); /** * 入栈操作 * @param e 元素 */ public abstract void push(E e); } 其实，我们的JVM在处理方法调用时，也是一个栈操作： 所以说，如果玩不好递归，就会像这样： public class Main { public static void main(String[] args) { go(); } private static void go(){ go(); } } Exception in thread \"main\" java.lang.StackOverflowError at com.test.Main.go(Main.java:13) at com.test.Main.go(Main.java:13) at com.test.Main.go(Main.java:13) at com.test.Main.go(Main.java:13) at com.test.Main.go(Main.java:13) at com.test.Main.go(Main.java:13) at com.test.Main.go(Main.java:13) at com.test.Main.go(Main.java:13) ... 栈的深度是有限制的，如果达到限制，将会出现StackOverflowError错误（注意是错误！说明是JVM出现了问题） 队列 队列同样也是受限制的线性表，不过队列就像我们排队一样，只能从队尾开始排，从队首出。 所以我们要实现以下内容： /** * * @param \u003cE\u003e */ public abstract class AbstractQueue\u003cE\u003e { /** * 进队操作 * @param e 元素 */ public abstract void offer(E e); /** * 出队操作 * @return 元素 */ public abstract E poll(); } ","date":"2022-01-23","objectID":"/posts/java%E6%B3%9B%E5%9E%8B%E4%B8%8E%E9%9B%86%E5%90%88%E7%B1%BB/:3:1","tags":["Java泛型与集合类"],"title":"Java泛型与集合类","uri":"/posts/java%E6%B3%9B%E5%9E%8B%E4%B8%8E%E9%9B%86%E5%90%88%E7%B1%BB/"},{"categories":["JavaSE笔记"],"content":"二叉树 本版块主要学习的是二叉树，树也是一种数据结构，但是它使用起来更加的复杂。 树 我们前面已经学习过链表了，我们知道链表是单个结点之间相连，也就是一种一对一的关系，而树则是一个结点连接多个结点，也就是一对多的关系。 一个结点可以有N个子结点，就像上图一样，看起来就像是一棵树。而位于最顶端的结点（没有父结点）我们称为根结点，而结点拥有的子节点数量称为度，每向下一级称为一个层次，树中出现的最大层次称为树的深度(高度)。 二叉树 二叉树是一种特殊的树，每个结点最多有两颗子树，所以二叉树中不存在度大于2的结点，位于两边的子结点称为左右子树（注意，左右子树是明确区分的，是左就是左，是右就是右） 数学性质： 在二叉树的第i层上最多有2^(i-1) 个节点。 二叉树中如果深度为k，那么最多有2^k-1个节点。 设计一个二叉树结点类： public class TreeNode\u003cE\u003e { public E e; //当前结点数据 public TreeNode\u003cE\u003e left; //左子树 public TreeNode\u003cE\u003e right; //右子树 } 二叉树的遍历 顺序表的遍历其实就是依次有序去访问表中每一个元素，而像二叉树这样的复杂结构，我们有四种遍历方式，他们是：前序遍历、中序遍历、后序遍历以及层序遍历，本版块我们主要讨论前三种遍历方式： 前序遍历：从二叉树的根结点出发，到达结点时就直接输出结点数据，按照先向左在向右的方向访问。ABCDEF 中序遍历：从二叉树的根结点出发，优先输出左子树的节点的数据，再输出当前节点本身，最后才是右子树。CBDAEF 后序遍历：从二叉树的根结点出发，优先遍历其左子树，再遍历右子树，最后在输出当前节点本身。CDBFEA 满二叉树和完全二叉树 满二叉树和完全二叉树其实就是特殊情况下的二叉树，满二叉树左右的所有叶子节点都在同一层，也就是说，完全把每一个层级都给加满了结点。完全二叉树与满二叉树不同的地方在于，它的最下层叶子节点可以不满，但是最下层的叶子节点必须靠左排布。 其实满二叉树和完全二叉树就是有一定规律的二叉树，很容易理解。 ","date":"2022-01-23","objectID":"/posts/java%E6%B3%9B%E5%9E%8B%E4%B8%8E%E9%9B%86%E5%90%88%E7%B1%BB/:3:2","tags":["Java泛型与集合类"],"title":"Java泛型与集合类","uri":"/posts/java%E6%B3%9B%E5%9E%8B%E4%B8%8E%E9%9B%86%E5%90%88%E7%B1%BB/"},{"categories":["JavaSE笔记"],"content":"快速查找 我们之前提到的这些数据结构，很好地帮我们管理了数据，但是，如果需要查找某一个元素是否存在于数据结构中，如何才能更加高效的去完成呢？ 哈希表 通过前面的学习，我们发现，顺序表虽然查询效率高，但是插入删除有严重表更新的问题，而链表虽然弥补了更新问题，但是查询效率实在是太低了，能否有一种折中方案？哈希表！ 不知大家在之前的学习中是否发现，我们的Object类中，定义了一个叫做hashcode()的方法？而这个方法呢，就是为了更好地支持哈希表的实现。hashcode()默认得到的是对象的内存地址，也就是说，每个对象的hashCode都不一样。 哈希表，其实本质上就是一个存放链表的数组，那么它是如何去存储数据的呢？我们先来看看长啥样： 数组中每一个元素都是一个头结点，用于保存数据，那我们怎么确定数据应该放在哪一个位置呢？通过hash算法，我们能够瞬间得到元素应该放置的位置。 //假设hash表长度为16，hash算法为： private int hash(int hashcode){ return hashcode % 16; } 设想这样一个问题，如果计算出来的hash值和之前已经存在的元素相同了呢？这种情况我们称为hash碰撞，这也是为什么要将每一个表元素设置为一个链表的头结点的原因，一旦发现重复，我们可以往后继续添加节点。 当然，以上的hash表结构只是一种设计方案，在面对大额数据时，是不够用的，在JDK1.8中，集合类使用的是数组+二叉树的形式解决的（这里的二叉树是经过加强的二叉树，不是前面讲得简单二叉树，我们下一节就会开始讲） 二叉排序树 我们前面学习的二叉树效率是不够的，我们需要的是一种效率更高的二叉树，因此，基于二叉树的改进，提出了二叉查找树，可以看到结构像下面这样： 不难发现，每个节点的左子树，一定小于当前节点的值，每个节点的右子树，一定大于当前节点的值，这样的二叉树称为二叉排序树。利用二分搜索的思想，我们就可以快速查找某个节点！ 平衡二叉树 在了解了二叉查找树之后，我们发现，如果根节点为10，现在加入到结点的值从9开始，依次减小到1，那么这个表就会很奇怪，就像下面这样： 显然，当所有的结点都排列到一边，这种情况下，查找效率会直接退化为最原始的二叉树！因此我们需要维持二叉树的平衡，才能维持原有的查找效率。 现在我们对二叉排序树加以约束，要求每个结点的左右两个子树的高度差的绝对值不超过1，这样的二叉树称为平衡二叉树，同时要求每个结点的左右子树都是平衡二叉树，这样，就不会因为一边的疯狂增加导致失衡。我们来看看以下几种情况： 左左失衡 右右失衡 左右失衡 右左失衡 通过以上四种情况的处理，最终得到维护平衡二叉树的算法。 红黑树 红黑树也是二叉排序树的一种改进，同平衡二叉树一样，红黑树也是一种维护平衡的二叉排序树，但是没有平衡二叉树那样严格（平衡二叉树每次插入新结点时，可能会出现大量的旋转，而红黑树保证不超过三次），红黑树降低了对于旋转的要求，因此效率有一定的提升同时实现起来也更加简单。但是红黑树的效率却高于平衡二叉树，红黑树也是JDK1.8中使用的数据结构！ 红黑树的特性: （1）每个节点或者是黑色，或者是红色。 （2）根节点是黑色。 （3）每个叶子节点的两边也需要表示（虽然没有，但是null也需要表示出来）是黑色。 （4）如果一个节点是红色的，则它的子节点必须是黑色的。 （5）从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点。 我们来看看一个节点，是如何插入到红黑树中的： 基本的 插入规则和平衡二叉树一样，但是在插入后： 将新插入的节点标记为红色 如果 X 是根结点(root)，则标记为黑色 如果 X 的 parent 不是黑色，同时 X 也不是 root: 3.1 如果 X 的 uncle (叔叔) 是红色 3.1.1 将 parent 和 uncle 标记为黑色 3.1.2 将 grand parent (祖父) 标记为红色 3.1.3 让 X 节点的颜色与 X 祖父的颜色相同，然后重复步骤 2、3 3.2 如果 X 的 uncle (叔叔) 是黑色，我们要分四种情况处理 3.2.1 左左 (P 是 G 的左孩子，并且 X 是 P 的左孩子) 3.2.2 左右 (P 是 G 的左孩子，并且 X 是 P 的右孩子) 3.2.3 右右 (P 是 G 的右孩子，并且 X 是 P 的右孩子) 3.2.4 右左 (P 是 G 的右孩子，并且 X 是 P 的左孩子) 其实这种情况下处理就和我们的平衡二叉树一样了 ","date":"2022-01-23","objectID":"/posts/java%E6%B3%9B%E5%9E%8B%E4%B8%8E%E9%9B%86%E5%90%88%E7%B1%BB/:3:3","tags":["Java泛型与集合类"],"title":"Java泛型与集合类","uri":"/posts/java%E6%B3%9B%E5%9E%8B%E4%B8%8E%E9%9B%86%E5%90%88%E7%B1%BB/"},{"categories":["JavaSE笔记"],"content":"认识集合类 集合表示一组对象，称为其元素。一些集合允许重复的元素，而另一些则不允许。一些集合是有序的，而其他则是无序的。 集合类其实就是为了更好地组织、管理和操作我们的数据而存在的，包括列表、集合、队列、映射等数据结构。从这一块开始，我们会从源码角度给大家讲解（数据结构很重要！），不仅仅是教会大家如何去使用。 集合类最顶层不是抽象类而是接口，因为接口代表的是某个功能，而抽象类是已经快要成形的类型，不同的集合类的底层实现是不相同的，同时一个集合类可能会同时具有两种及以上功能（既能做队列也能做列表），所以采用接口会更加合适，接口只需定义支持的功能即可。 ","date":"2022-01-23","objectID":"/posts/java%E6%B3%9B%E5%9E%8B%E4%B8%8E%E9%9B%86%E5%90%88%E7%B1%BB/:4:0","tags":["Java泛型与集合类"],"title":"Java泛型与集合类","uri":"/posts/java%E6%B3%9B%E5%9E%8B%E4%B8%8E%E9%9B%86%E5%90%88%E7%B1%BB/"},{"categories":["JavaSE笔记"],"content":"数组与集合 相同之处： 它们都是容器，都能够容纳一组元素。 不同之处： 数组的大小是固定的，集合的大小是可变的。 数组可以存放基本数据类型，但集合只能存放对象。 数组存放的类型只能是一种，但集合可以有不同种类的元素。 ","date":"2022-01-23","objectID":"/posts/java%E6%B3%9B%E5%9E%8B%E4%B8%8E%E9%9B%86%E5%90%88%E7%B1%BB/:4:1","tags":["Java泛型与集合类"],"title":"Java泛型与集合类","uri":"/posts/java%E6%B3%9B%E5%9E%8B%E4%B8%8E%E9%9B%86%E5%90%88%E7%B1%BB/"},{"categories":["JavaSE笔记"],"content":"集合根接口Collection 本接口中定义了全部的集合基本操作，我们可以在源码中看看。 我们再来看看List和Set以及Queue接口。 ","date":"2022-01-23","objectID":"/posts/java%E6%B3%9B%E5%9E%8B%E4%B8%8E%E9%9B%86%E5%90%88%E7%B1%BB/:4:2","tags":["Java泛型与集合类"],"title":"Java泛型与集合类","uri":"/posts/java%E6%B3%9B%E5%9E%8B%E4%B8%8E%E9%9B%86%E5%90%88%E7%B1%BB/"},{"categories":["JavaSE笔记"],"content":"集合类的使用 ","date":"2022-01-23","objectID":"/posts/java%E6%B3%9B%E5%9E%8B%E4%B8%8E%E9%9B%86%E5%90%88%E7%B1%BB/:5:0","tags":["Java泛型与集合类"],"title":"Java泛型与集合类","uri":"/posts/java%E6%B3%9B%E5%9E%8B%E4%B8%8E%E9%9B%86%E5%90%88%E7%B1%BB/"},{"categories":["JavaSE笔记"],"content":"List列表 首先介绍ArrayList，它的底层是用数组实现的，内部维护的是一个可改变大小的数组，也就是我们之前所说的线性表！跟我们之前自己写的ArrayList相比，它更加的规范，同时继承自List接口。 先看看ArrayList的源码！ 基本操作 List\u003cString\u003e list = new ArrayList\u003c\u003e(); //默认长度的列表 List\u003cString\u003e listInit = new ArrayList\u003c\u003e(100); //初始长度为100的列表 向列表中添加元素： List\u003cString\u003e list = new ArrayList\u003c\u003e(); list.add(\"lbwnb\"); list.add(\"yyds\"); list.contains(\"yyds\"); //是否包含某个元素 System.out.println(list); 移除元素： public static void main(String[] args) { List\u003cString\u003e list = new ArrayList\u003c\u003e(); list.add(\"lbwnb\"); list.add(\"yyds\"); list.remove(0); //按下标移除元素 list.remove(\"yyds\"); //移除指定元素 System.out.println(list); } 也支持批量操作： public static void main(String[] args) { ArrayList\u003cString\u003e list = new ArrayList\u003c\u003e(); list.addAll(new ArrayList\u003c\u003e()); //在尾部批量添加元素 list.removeAll(new ArrayList\u003c\u003e()); //批量移除元素（只有给定集合中存在的元素才会被移除） list.retainAll(new ArrayList\u003c\u003e()); //只保留某些元素 System.out.println(list); } 我们再来看LinkedList，其实本质就是一个链表！我们来看看源码。 其实与我们之前编写的LinkedList不同之处在于，它内部使用的是一个双向链表： private static class Node\u003cE\u003e { E item; Node\u003cE\u003e next; Node\u003cE\u003e prev; Node(Node\u003cE\u003e prev, E element, Node\u003cE\u003e next) { this.item = element; this.next = next; this.prev = prev; } } 当然，我们发现它还实现了Queue接口，所以LinkedList也能被当做一个队列或是栈来使用。 public static void main(String[] args) { LinkedList\u003cString\u003e list = new LinkedList\u003c\u003e(); list.offer(\"A\"); //入队 System.out.println(list.poll()); //出队 list.push(\"A\"); list.push(\"B\"); //进栈 list.push(\"C\"); System.out.println(list.pop()); System.out.println(list.pop()); //出栈 System.out.println(list.pop()); } 利用代码块来快速添加内容 前面我们学习了匿名内部类，我们就可以利用代码块，来快速生成一个自带元素的List List\u003cString\u003e list = new LinkedList\u003cString\u003e(){{ //初始化时添加 this.add(\"A\"); this.add(\"B\"); }}; 如果是需要快速生成一个只读的List，后面我们会讲解Arrays工具类。 集合的排序 List\u003cInteger\u003e list = new LinkedList\u003cInteger\u003e(){ //Java9才支持匿名内部类使用钻石运算符 { this.add(10); this.add(2); this.add(5); this.add(8); } }; list.sort((a, b) -\u003e { //排序已经由JDK实现，现在只需要填入自定义规则，完成Comparator接口实现 return a - b; //返回值小于0，表示a应该在b前面，返回值大于0，表示b应该在a后面，等于0则不进行交换 }); System.out.println(list); ","date":"2022-01-23","objectID":"/posts/java%E6%B3%9B%E5%9E%8B%E4%B8%8E%E9%9B%86%E5%90%88%E7%B1%BB/:5:1","tags":["Java泛型与集合类"],"title":"Java泛型与集合类","uri":"/posts/java%E6%B3%9B%E5%9E%8B%E4%B8%8E%E9%9B%86%E5%90%88%E7%B1%BB/"},{"categories":["JavaSE笔记"],"content":"迭代器 集合的遍历 所有的集合类，都支持foreach循环！ public static void main(String[] args) { List\u003cInteger\u003e list = new LinkedList\u003cInteger\u003e(){ //Java9才支持匿名内部类使用钻石运算符 { this.add(10); this.add(2); this.add(5); this.add(8); } }; for (Integer integer : list) { System.out.println(integer); } } 当然，也可以使用JDK1.8新增的forEach方法，它接受一个Consumer接口实现： list.forEach(i -\u003e { System.out.println(i); }); 从JDK1.8开始，lambda表达式开始逐渐成为主流，我们需要去适应函数式编程的这种语法，包括批量替换，也是用到了函数式接口来完成的。 list.replaceAll((i) -\u003e { if(i == 2) return 3; //将所有的2替换为3 else return i; //不是2就不变 }); System.out.println(list); Iterable和Iterator接口 我们之前学习数据结构时，已经得知，不同的线性表实现，在获取元素时的效率也不同，因此我们需要一种更好地方式来统一不同数据结构的遍历。 由于ArrayList对于随机访问的速度更快，而LinkedList对于顺序访问的速度更快，因此在上述的传统for循环遍历操作中，ArrayList的效率更胜一筹，因此我们要使得LinkedList遍历效率提升，就需要采用顺序访问的方式进行遍历，如果没有迭代器帮助我们统一标准，那么我们在应对多种集合类型的时候，就需要对应编写不同的遍历算法，很显然这样会降低我们的开发效率，而迭代器的出现就帮助我们解决了这个问题。 我们先来看看迭代器里面方法： public interface Iterator\u003cE\u003e { //... } 每个集合类都有自己的迭代器，通过iterator()方法来获取： Iterator\u003cInteger\u003e iterator = list.iterator(); //生成一个新的迭代器 while (iterator.hasNext()){ //判断是否还有下一个元素 Integer i = iterator.next(); //获取下一个元素（获取一个少一个） System.out.println(i); } 迭代器生成后，默认指向第一个元素，每次调用next()方法，都会将指针后移，当指针移动到最后一个元素之后，调用hasNext()将会返回false，迭代器是一次性的，用完即止，如果需要再次使用，需要调用iterator()方法。 ListIterator\u003cInteger\u003e iterator = list.listIterator(); //List还有一个更好地迭代器实现ListIterator ListIterator是List中独有的迭代器，在原有迭代器基础上新增了一些额外的操作。 ","date":"2022-01-23","objectID":"/posts/java%E6%B3%9B%E5%9E%8B%E4%B8%8E%E9%9B%86%E5%90%88%E7%B1%BB/:5:2","tags":["Java泛型与集合类"],"title":"Java泛型与集合类","uri":"/posts/java%E6%B3%9B%E5%9E%8B%E4%B8%8E%E9%9B%86%E5%90%88%E7%B1%BB/"},{"categories":["JavaSE笔记"],"content":"Set集合 我们之前已经看过Set接口的定义了，我们发现接口中定义的方法都是Collection中直接继承的，因此，Set支持的功能其实也就和Collection中定义的差不多，只不过使用方法上稍有不同。 Set集合特点： 不允许出现重复元素 不支持随机访问（不允许通过下标访问） 首先认识一下HashSet，它的底层就是采用哈希表实现的（我们在这里先不去探讨实现原理，因为底层实质上维护的是一个HashMap，我们学习了Map之后再来讨论） public static void main(String[] args) { HashSet\u003cInteger\u003e set = new HashSet\u003c\u003e(); set.add(120); //支持插入元素，但是不支持指定位置插入 set.add(13); set.add(11); for (Integer integer : set) { System.out.println(integer); } } 运行上面代码发现，最后Set集合中存在的元素顺序，并不是我们的插入顺序，这是因为HashSet底层是采用哈希表来实现的，实际的存放顺序是由Hash算法决定的。 那么我们希望数据按照我们插入的顺序进行保存该怎么办呢？我们可以使用LinkedHashSet： public static void main(String[] args) { LinkedHashSet\u003cInteger\u003e set = new LinkedHashSet\u003c\u003e(); //会自动保存我们的插入顺序 set.add(120); set.add(13); set.add(11); for (Integer integer : set) { System.out.println(integer); } } LinkedHashSet底层维护的不再是一个HashMap，而是LinkedHashMap，它能够在插入数据时利用链表自动维护顺序，因此这样就能够保证我们插入顺序和最后的迭代顺序一致了。 还有一种Set叫做TreeSet，它会在元素插入时进行排序： public static void main(String[] args) { TreeSet\u003cInteger\u003e set = new TreeSet\u003c\u003e(); set.add(1); set.add(3); set.add(2); System.out.println(set); } 可以看到最后得到的结果并不是我们插入顺序，而是按照数字的大小进行排列。当然，我们也可以自定义排序规则： public static void main(String[] args) { TreeSet\u003cInteger\u003e set = new TreeSet\u003c\u003e((a, b) -\u003e b - a); //在创建对象时指定规则即可 set.add(1); set.add(3); set.add(2); System.out.println(set); } 现在的结果就是我们自定义的排序规则了。 虽然Set集合只是粗略的进行了讲解，但是学习Map之后，我们还会回来看我们Set的底层实现，所以说最重要的还是Map。本节只需要记住Set的性质、使用即可。 ","date":"2022-01-23","objectID":"/posts/java%E6%B3%9B%E5%9E%8B%E4%B8%8E%E9%9B%86%E5%90%88%E7%B1%BB/:5:3","tags":["Java泛型与集合类"],"title":"Java泛型与集合类","uri":"/posts/java%E6%B3%9B%E5%9E%8B%E4%B8%8E%E9%9B%86%E5%90%88%E7%B1%BB/"},{"categories":["JavaSE笔记"],"content":"Map映射 什么是映射 我们在高中阶段其实已经学习过映射了，映射指两个元素的之间相互“对应”的关系，也就是说，我们的元素之间是两两对应的，是以键值对的形式存在。 Map接口 Map就是为了实现这种数据结构而存在的，我们通过保存键值对的形式来存储映射关系。 我们先来看看Map接口中定义了哪些操作。 HashMap和LinkedHashMap HashMap的实现过程，相比List，就非常地复杂了，它并不是简简单单的表结构，而是利用哈希表存放映射关系，我们来看看HashMap是如何实现的，首先回顾我们之前学习的哈希表，它长这样： 哈希表的本质其实就是一个用于存放后续节点的头结点的数组，数组里面的每一个元素都是一个头结点（也可以说就是一个链表），当要新插入一个数据时，会先计算该数据的哈希值，找到数组下标，然后创建一个新的节点，添加到对应的链表后面。 而HashMap就是采用的这种方式，我们可以看到源码中同样定义了这样的一个结构： /** * The table, initialized on first use, and resized as * necessary. When allocated, length is always a power of two. * (We also tolerate length zero in some operations to allow * bootstrapping mechanics that are currently not needed.) */ transient Node\u003cK,V\u003e[] table; 这个表会在第一次使用时初始化，同时在必要时进行扩容，并且它的大小永远是2的倍数！ /** * The default initial capacity - MUST be a power of two. */ static final int DEFAULT_INITIAL_CAPACITY = 1 \u003c\u003c 4; // aka 16 我们可以看到默认的大小为2的4次方，每次都需要是2的倍数，也就是说，下一次增长之后，大小会变成2的5次方。 我们现在需要思考一个问题，当我们表中的数据不断增加之后，链表会变得越来越长，这样会严重导致查询速度变慢，首先想到办法就是，我们可以对数组的长度进行扩容，来存放更多的链表，那么什么情况下会进行扩容呢？ /** * The load factor for the hash table. * * @serial */ final float loadFactor; 我们还发现HashMap源码中有这样一个变量，也就是负载因子，那么它是干嘛的呢？ 负载因子其实就是用来衡量当前情况是否需要进行扩容的标准。我们可以看到默认的负载因子是0.75 /** * The load factor used when none specified in constructor. */ static final float DEFAULT_LOAD_FACTOR = 0.75f; 那么负载因子是怎么控制扩容的呢？0.75的意思是，在插入新的结点后，如果当前数组的占用率达到75%则进行扩容。在扩容时，会将所有的数据，重新计算哈希值，得到一个新的下标，组成新的哈希表。 但是这样依然有一个问题，链表过长的情况还是有可能发生，所以，为了从根源上解决这个问题，在JDK1.8时，引入了红黑树这个数据结构。 当链表的长度达到8时，会自动将链表转换为红黑树，这样能使得原有的查询效率大幅度降低！当使用红黑树之后，我们就可以利用二分搜索的思想，快速地去寻找我们想要的结果，而不是像链表一样挨个去看。 /** * Entry for Tree bins. Extends LinkedHashMap.Entry (which in turn * extends Node) so can be used as extension of either regular or * linked node. */ static final class TreeNode\u003cK,V\u003e extends LinkedHashMap.Entry\u003cK,V\u003e { 除了Node以外，HashMap还有TreeNode，很明显这就是为了实现红黑树而设计的内部类。不过我们发现，TreeNode并不是直接继承Node，而是使用了LinkedHashMap中的Entry实现，它保存了前后节点的顺序（也就是我们的插入顺序）。 /** * HashMap.Node subclass for normal LinkedHashMap entries. */ static class Entry\u003cK,V\u003e extends HashMap.Node\u003cK,V\u003e { Entry\u003cK,V\u003e before, after; Entry(int hash, K key, V value, Node\u003cK,V\u003e next) { super(hash, key, value, next); } } LinkedHashMap是直接继承自HashMap，具有HashMap的全部性质，同时得益于每一个节点都是一个双向链表，保存了插入顺序，这样我们在遍历LinkedHashMap时，顺序就同我们的插入顺序一致。当然，也可以使用访问顺序，也就是说对于刚访问过的元素，会被排到最后一位。 public static void main(String[] args) { LinkedHashMap\u003cInteger, String\u003e map = new LinkedHashMap\u003c\u003e(16, 0.75f, true); //以访问顺序 map.put(1, \"A\"); map.put(2, \"B\"); map.put(3, \"C\"); map.get(2); System.out.println(map); } 观察结果，我们发现，刚访问的结果被排到了最后一位。 TreeMap TreeMap其实就是自动维护顺序的一种Map，就和我们前面提到的TreeSet一样： /** * The comparator used to maintain order in this tree map, or * null if it uses the natural ordering of its keys. * * @serial */ private final Comparator\u003c? super K\u003e comparator; private transient Entry\u003cK,V\u003e root; /** * Node in the Tree. Doubles as a means to pass key-value pairs back to * user (see Map.Entry). */ static final class Entry\u003cK,V\u003e implements Map.Entry\u003cK,V\u003e { 我们发现它的内部直接维护了一个红黑树，就像它的名字一样，就是一个Tree，因为它默认就是有序的，所以说直接采用红黑树会更好。我们在创建时，直接给予一个比较规则即可。 Map的使用 我们首先来看看Map的一些基本操作： public static void main(String[] args) { Map\u003cInteger, String\u003e map = new HashMap\u003c\u003e(); map.put(1, \"A\"); map.put(2, \"B\"); map.put(3, \"C\"); System.out.println(map.get(1)); //获取Key为1的值 System.out.println(map.getOrDefault(0, \"K\")); //不存在就返回K map.remove(1); //移除这个Key的键值对 } 由于Map并未实现迭代器接口，因此不支持foreach，但是JDK1.8为我们提供了forEach方法使用： public static void main(String[] args) { Map\u003cInteger, String\u003e map = new HashMap\u003c\u003e(); map.put(1, \"A\"); map.put(2, \"B\"); map.put(3, \"C\"); map.forEach((k, v) -\u003e System.out.println(k+\"-\u003e\"+v)); for (Map.Entry\u003cInteger, String\u003e entry : map.entrySet()) { //也可以获取所有的Entry来foreach int key = entry.getKey(); String value = entry.getValue(); System.out.println(key+\" -\u003e \"+value); } } 我们也可以单独获取所有的值或者是键： public static void main(String[] args) { Map\u003cInteger, String\u003e map = new HashMap\u003c\u003e(); map.put(1, \"A\"); map.put(2, \"B\"); map.put(3, \"C\"); System.out.println(map.keySet()); //直接获取所有的key System.out.println(map.values()); //直接获取所有的值 } 再谈Set原理 通过观察Hash","date":"2022-01-23","objectID":"/posts/java%E6%B3%9B%E5%9E%8B%E4%B8%8E%E9%9B%86%E5%90%88%E7%B1%BB/:5:4","tags":["Java泛型与集合类"],"title":"Java泛型与集合类","uri":"/posts/java%E6%B3%9B%E5%9E%8B%E4%B8%8E%E9%9B%86%E5%90%88%E7%B1%BB/"},{"categories":["JavaSE笔记"],"content":"集合的嵌套 既然集合类型中的元素类型是泛型，那么能否嵌套存储呢？ public static void main(String[] args) { Map\u003cString, List\u003cInteger\u003e\u003e map = new HashMap\u003c\u003e(); //每一个映射都是 字符串\u003c-\u003e列表 map.put(\"卡布奇诺今犹在\", new LinkedList\u003c\u003e()); map.put(\"不见当年倒茶人\", new LinkedList\u003c\u003e()); System.out.println(map.keySet()); System.out.println(map.values()); } 通过Key获取到对应的值后，就是一个列表： map.get(\"卡布奇诺今犹在\").add(10); System.out.println(map.get(\"卡布奇诺今犹在\").get(0)); 让套娃继续下去： public static void main(String[] args) { Map\u003cInteger, Map\u003cInteger, Map\u003cInteger, String\u003e\u003e\u003e map = new HashMap\u003c\u003e(); } 你也可以使用List来套娃别的： public static void main(String[] args) { List\u003cMap\u003cString, Set\u003cString\u003e\u003e\u003e list = new LinkedList\u003c\u003e(); } ","date":"2022-01-23","objectID":"/posts/java%E6%B3%9B%E5%9E%8B%E4%B8%8E%E9%9B%86%E5%90%88%E7%B1%BB/:5:5","tags":["Java泛型与集合类"],"title":"Java泛型与集合类","uri":"/posts/java%E6%B3%9B%E5%9E%8B%E4%B8%8E%E9%9B%86%E5%90%88%E7%B1%BB/"},{"categories":["JavaSE笔记"],"content":"流Stream和Optional的使用 Java 8 API添加了一个新的抽象称为流Stream，可以让你以一种声明的方式处理数据。Stream 使用一种类似用 SQL 语句从数据库查询数据的直观方式来提供一种对 Java 集合运算和表达的高阶抽象。Stream API可以极大提高Java程序员的生产力，让程序员写出高效率、干净、简洁的代码。这种风格将要处理的元素集合看作一种流， 流在管道中传输， 并且可以在管道的节点上进行处理， 比如筛选， 排序，聚合等。元素流在管道中经过中间操作（intermediate operation）的处理，最后由最终操作(terminal operation)得到前面处理的结果。 它看起来就像一个工厂的流水线一样！我们就可以把一个Stream当做流水线处理： public static void main(String[] args) { List\u003cString\u003e list = new ArrayList\u003c\u003e(); list.add(\"A\"); list.add(\"B\"); list.add(\"C\"); //移除为B的元素 Iterator\u003cString\u003e iterator = list.iterator(); while (iterator.hasNext()){ if(iterator.next().equals(\"B\")) iterator.remove(); } //Stream操作 list = list //链式调用 .stream() //获取流 .filter(e -\u003e !e.equals(\"B\")) //只允许所有不是B的元素通过流水线 .collect(Collectors.toList()); //将流水线中的元素重新收集起来，变回List System.out.println(list); } 可能从上述例子中还不能感受到流处理带来的便捷，我们通过下面这个例子来感受一下： public static void main(String[] args) { List\u003cInteger\u003e list = new ArrayList\u003c\u003e(); list.add(1); list.add(2); list.add(3); list.add(3); list = list .stream() .distinct() //去重（使用equals判断） .sorted((a, b) -\u003e b - a) //进行倒序排列 .map(e -\u003e e+1) //每个元素都要执行+1操作 .limit(2) //只放行前两个元素 .collect(Collectors.toList()); System.out.println(list); } 当遇到大量的复杂操作时，我们就可以使用Stream来快速编写代码，这样不仅代码量大幅度减少，而且逻辑也更加清晰明了（如果你学习过SQL的话，你会发现它更像一个Sql语句） 注意：不能认为每一步是直接依次执行的！ List\u003cInteger\u003e list = new ArrayList\u003c\u003e(); list.add(1); list.add(2); list.add(3); list.add(3); list = list .stream() .distinct() //断点 .sorted((a, b) -\u003e b - a) .map(e -\u003e { System.out.println(\"\u003e\u003e\u003e \"+e); //断点 return e+1; }) .limit(2) //断点 .collect(Collectors.toList()); //实际上，stream会先记录每一步操作，而不是直接开始执行内容，当整个链式调用完成后，才会依次进行！ 接下来，我们用一堆随机数来进行更多流操作的演示： public static void main(String[] args) { Random random = new Random(); //Random是一个随机数工具类 random .ints(-100, 100) //生成-100~100之间的，随机int型数字（本质上是一个IntStream） .limit(10) //只获取前10个数字（这是一个无限制的流，如果不加以限制，将会无限进行下去！） .filter(i -\u003e i \u003c 0) //只保留小于0的数字 .sorted() //默认从小到大排序 .forEach(System.out::println); //依次打印 } 我们可以生成一个统计实例来帮助我们快速进行统计： public static void main(String[] args) { Random random = new Random(); //Random是一个随机数工具类 IntSummaryStatistics statistics = random .ints(0, 100) .limit(100) .summaryStatistics(); //获取语法统计实例 System.out.println(statistics.getMax()); //快速获取最大值 System.out.println(statistics.getCount()); //获取数量 System.out.println(statistics.getAverage()); //获取平均值 } 普通的List只需要一个方法就可以直接转换到方便好用的IntStream了： public static void main(String[] args) { List\u003cInteger\u003e list = new ArrayList\u003c\u003e(); list.add(1); list.add(1); list.add(2); list.add(3); list.add(4); list.stream() .mapToInt(i -\u003e i) //将每一个元素映射为Integer类型（这里因为本来就是Integer） .summaryStatistics(); } 我们还可以通过flat来对整个流进行进一步细分： public static void main(String[] args) { List\u003cString\u003e list = new ArrayList\u003c\u003e(); list.add(\"A,B\"); list.add(\"C,D\"); list.add(\"E,F\"); //我们想让每一个元素通过,进行分割，变成独立的6个元素 list = list .stream() //生成流 .flatMap(e -\u003e Arrays.stream(e.split(\",\"))) //分割字符串并生成新的流 .collect(Collectors.toList()); //汇成新的List System.out.println(list); //得到结果 } 我们也可以只通过Stream来完成所有数字的和，使用reduce方法： public static void main(String[] args) { List\u003cInteger\u003e list = new ArrayList\u003c\u003e(); list.add(1); list.add(2); list.add(3); int sum = list .stream() .reduce((a, b) -\u003e a + b) //计算规则为：a是上一次计算的值，b是当前要计算的参数，这里是求和 .get(); //我们发现得到的是一个Optional类实例，不是我们返回的类型，通过get方法返回得到的值 System.out.println(sum); } 通过上面的例子，我们发现，Stream不喜欢直接给我们返回一个结果，而是通过Optinal的方式，那么什么是Optional呢？ Optional类是Java8为了解决null值判断问题，使用Optional类可以避免显式的null值判断（null的防御性检查），避免null导致的NPE（NullPointerException）。总而言之，就是对控制的一个判断，为了避免空指针异常。 public static void main(String[] args) { String str = null; if(str != null){ //当str不为空时添加元素到List中 list.add(str); } } 有了Optional之后，我们就可以这样写： public static void main(String[] args) { String str = null; Optional\u003cString\u003e optional = Optional.ofNullable(str); //转换为Optional optional.ifPresent(System.out::println); //当存在时再执行方法 } 就类似于Kotlin中的： var str : String? = null str?.upperCase() 我们可以选择直接get或是当值为null时，获取备选值： public static void main(String[] args) { String str = null; Optional optional = Optional.ofNullable(str); //转换为Optional（可空） System.out.println(optional.orElse(\"lbwnb\")); // S","date":"2022-01-23","objectID":"/posts/java%E6%B3%9B%E5%9E%8B%E4%B8%8E%E9%9B%86%E5%90%88%E7%B1%BB/:5:6","tags":["Java泛型与集合类"],"title":"Java泛型与集合类","uri":"/posts/java%E6%B3%9B%E5%9E%8B%E4%B8%8E%E9%9B%86%E5%90%88%E7%B1%BB/"},{"categories":["JavaSE笔记"],"content":"Arrays和Collections的使用 Arrays是一个用于操作数组的工具类，它给我们提供了大量的工具方法： /** * This class contains various methods for manipulating arrays (such as * sorting and searching). This class also contains a static factory * that allows arrays to be viewed as lists. \u003c- 注意，这句话很关键 * * @author Josh Bloch * @author Neal Gafter * @author John Rose * @since 1.2 */ public class Arrays { 由于操作数组并不像集合那样方便，因此JDK提供了Arrays类来增强对数组操作，比如： public static void main(String[] args) { int[] array = {1, 5, 2, 4, 7, 3, 6}; Arrays.sort(array); //直接进行排序（底层原理：进行判断，元素少使用插入排序，大量元素使用双轴快速/归并排序） System.out.println(array); //由于int[]是一个对象类型，而数组默认是没有重写toString()方法，因此无法打印到想要的结果 System.out.println(Arrays.toString(array)); //我们可以使用Arrays.toString()来像集合一样直接打印每一个元素出来 } public static void main(String[] args) { int[] array = {1, 5, 2, 4, 7, 3, 6}; Arrays.sort(array); System.out.println(\"排序后的结果：\"+Arrays.toString(array)); System.out.println(\"目标元素3位置为：\"+Arrays.binarySearch(array, 3)); //二分搜素，必须是已经排序好的数组！ } public static void main(String[] args) { int[] array = {1, 5, 2, 4, 7, 3, 6}; Arrays .stream(array) //将数组转换为流进行操作 .sorted() .forEach(System.out::println); } public static void main(String[] args) { int[] array = {1, 5, 2, 4, 7, 3, 6}; int[] array2 = Arrays.copyOf(array, array.length); //复制一个一模一样的数组 System.out.println(Arrays.toString(array2)); System.out.println(Arrays.equals(array, array2)); //比较两个数组是否值相同 Arrays.fill(array, 0); //将数组的所有值全部填充为指定值 System.out.println(Arrays.toString(array)); Arrays.setAll(array2, i -\u003e array2[i] + 2); //依次计算每一个元素（注意i是下标位置） System.out.println(Arrays.toString(array2)); //这里计算让每个元素值+2 } 思考：当二维数组使用Arrays.equals()进行比较以及Arrays.toString()进行打印时，还会得到我们想要的结果吗？ public static void main(String[] args) { Integer[][] array = {{1, 5}, {2, 4}, {7, 3}, {6}}; Integer[][] array2 = {{1, 5}, {2, 4}, {7, 3}, {6}}; System.out.println(Arrays.toString(array)); //这样还会得到我们想要的结果吗？ System.out.println(Arrays.equals(array2, array)); //这样还会得到true吗？ System.out.println(Arrays.deepToString(array)); //使用deepToString就能到打印多维数组 System.out.println(Arrays.deepEquals(array2, array)); //使用deepEquals就能比较多维数组 } 那么，一开始提到的当做List进行操作呢？我们可以使用Arrays.asList()来将数组转换为一个 固定长度的List public static void main(String[] args) { Integer[] array = {1, 5, 2, 4, 7, 3, 6}; List\u003cInteger\u003e list = Arrays.asList(array); //不支持基本类型数组，必须是对象类型数组 Arrays.asList(\"A\", \"B\", \"C\"); //也可以逐个添加，因为是可变参数 list.add(1); //此List实现是长度固定的，是Arrays内部单独实现的一个类型，因此不支持添加操作 list.remove(0); //同理，也不支持移除 list.set(0, 8); //直接设置指定下标的值就可以 list.sort(Comparator.reverseOrder()); //也可以执行排序操作 System.out.println(list); //也可以像List那样直接打印 } 文字游戏：allows arrays to be viewed as lists，实际上只是当做List使用，本质还是数组，因此数组的属性依然存在！因此如果要将数组快速转换为实际的List，可以像这样： public static void main(String[] args) { Integer[] array = {1, 5, 2, 4, 7, 3, 6}; List\u003cInteger\u003e list = new ArrayList\u003c\u003e(Arrays.asList(array)); } 通过自行创建一个真正的ArrayList并在构造时将Arrays的List值传递。 既然数组操作都这么方便了，集合操作能不能也安排点高级的玩法呢？那必须的，JDK为我们准备的Collocations类就是专用于集合的工具类： public static void main(String[] args) { List\u003cInteger\u003e list = new ArrayList\u003c\u003e(); Collections.max(list); Collections.min(list); } 当然，Collections提供的内容相比Arrays会更多，希望大家下去自行了解，这里就不多做介绍了。 ","date":"2022-01-23","objectID":"/posts/java%E6%B3%9B%E5%9E%8B%E4%B8%8E%E9%9B%86%E5%90%88%E7%B1%BB/:5:7","tags":["Java泛型与集合类"],"title":"Java泛型与集合类","uri":"/posts/java%E6%B3%9B%E5%9E%8B%E4%B8%8E%E9%9B%86%E5%90%88%E7%B1%BB/"},{"categories":["JavaSE笔记"],"content":"集合类编程实战 ","date":"2022-01-23","objectID":"/posts/java%E6%B3%9B%E5%9E%8B%E4%B8%8E%E9%9B%86%E5%90%88%E7%B1%BB/:6:0","tags":["Java泛型与集合类"],"title":"Java泛型与集合类","uri":"/posts/java%E6%B3%9B%E5%9E%8B%E4%B8%8E%E9%9B%86%E5%90%88%E7%B1%BB/"},{"categories":["JavaSE笔记"],"content":"反转链表 1 \u003c- 3 \u003c- 5 \u003c- 7 \u003c- 9 转换为 1 \u003c- 3 \u003c- 5 \u003c- 7 \u003c- 9 现在有一个单链表，尝试将其所有节点倒序排列 public class Main { public static void main(String[] args) { Node head = new Node(1); head.next = new Node(3); head.next.next = new Node(5); head.next.next.next = new Node(7); head.next.next.next.next = new Node(9); head = reverse(head); while (head != null){ System.out.println(head.value+\" \"); head = head.next; } } public static class Node { public int value; public Node next; public Node(int data) { this.value = data; } } public static Node reverse(Node head) { //在这里实现 } } ","date":"2022-01-23","objectID":"/posts/java%E6%B3%9B%E5%9E%8B%E4%B8%8E%E9%9B%86%E5%90%88%E7%B1%BB/:6:1","tags":["Java泛型与集合类"],"title":"Java泛型与集合类","uri":"/posts/java%E6%B3%9B%E5%9E%8B%E4%B8%8E%E9%9B%86%E5%90%88%E7%B1%BB/"},{"categories":["JavaSE笔记"],"content":"重建二叉树 现在知道二叉树的前序: GDAFEMHZ，以及中序: ADEFGHMZ，请根据已知信息还原这颗二叉树。 ","date":"2022-01-23","objectID":"/posts/java%E6%B3%9B%E5%9E%8B%E4%B8%8E%E9%9B%86%E5%90%88%E7%B1%BB/:6:2","tags":["Java泛型与集合类"],"title":"Java泛型与集合类","uri":"/posts/java%E6%B3%9B%E5%9E%8B%E4%B8%8E%E9%9B%86%E5%90%88%E7%B1%BB/"},{"categories":["JavaSE笔记"],"content":"实现计算器 实现一个计算器，要求输入一个计算公式（含加减乘除运算符，没有负数但是有小数），得到结果，比如输入：1+4*3/1.321，得到结果为：2.2 ","date":"2022-01-23","objectID":"/posts/java%E6%B3%9B%E5%9E%8B%E4%B8%8E%E9%9B%86%E5%90%88%E7%B1%BB/:6:3","tags":["Java泛型与集合类"],"title":"Java泛型与集合类","uri":"/posts/java%E6%B3%9B%E5%9E%8B%E4%B8%8E%E9%9B%86%E5%90%88%E7%B1%BB/"},{"categories":["JavaSE笔记"],"content":"字符串匹配（KMP算法） 现在给定一个主字符串和一个子字符串，请判断主字符串是否包含子字符串，例如主字符串：ABCABCDHI，子字符串：ABCD，因此主字符串包含此子字符串；主字符串：ABCABCUISA，子字符串：ABCD，则不包含。 ","date":"2022-01-23","objectID":"/posts/java%E6%B3%9B%E5%9E%8B%E4%B8%8E%E9%9B%86%E5%90%88%E7%B1%BB/:6:4","tags":["Java泛型与集合类"],"title":"Java泛型与集合类","uri":"/posts/java%E6%B3%9B%E5%9E%8B%E4%B8%8E%E9%9B%86%E5%90%88%E7%B1%BB/"},{"categories":["C++实战"],"content":"”一起来领略C++模板的奥义“","date":"2022-01-20","objectID":"/posts/c++%E7%9A%84%E6%A8%A1%E6%9D%BF%E5%86%99println/","tags":["C++模板"],"title":"C++变参模板运用实战——实现PrintLn","uri":"/posts/c++%E7%9A%84%E6%A8%A1%E6%9D%BF%E5%86%99println/"},{"categories":["C++实战"],"content":"想要实现PrintLn，关键在于支持无限个参数的打印函数，所以我大致总结下C++能够如何去实现它！ ","date":"2022-01-20","objectID":"/posts/c++%E7%9A%84%E6%A8%A1%E6%9D%BF%E5%86%99println/:0:0","tags":["C++模板"],"title":"C++变参模板运用实战——实现PrintLn","uri":"/posts/c++%E7%9A%84%E6%A8%A1%E6%9D%BF%E5%86%99println/"},{"categories":["C++实战"],"content":"方式一：用初始化列表实现PrintLn() 【C++11】 ","date":"2022-01-20","objectID":"/posts/c++%E7%9A%84%E6%A8%A1%E6%9D%BF%E5%86%99println/:1:0","tags":["C++模板"],"title":"C++变参模板运用实战——实现PrintLn","uri":"/posts/c++%E7%9A%84%E6%A8%A1%E6%9D%BF%E5%86%99println/"},{"categories":["C++实战"],"content":"版本一：朴素初始化列表版本版本 函数版本： #include\u003ciostream\u003eusing namespace std; void PrintLn(std::initializer_list\u003cint\u003e args){ for(auto arg:args){ cout\u003c\u003carg\u003c\u003c\", \"; } cout\u003c\u003cstd::endl; } int main() { PrintLn({3,23,2,12}); return 0; } 类的构造器版本(可去掉小括号)： #include\u003ciostream\u003eusing namespace std; class PrintLn { public: PrintLn(std::initializer_list\u003cint\u003e args) { for (auto arg:args) { cout \u003c\u003c arg \u003c\u003c \", \"; } cout \u003c\u003c std::endl; } }; int main() { auto t = PrintLn{3, 23, 2, 12}; return 0; } ","date":"2022-01-20","objectID":"/posts/c++%E7%9A%84%E6%A8%A1%E6%9D%BF%E5%86%99println/:1:1","tags":["C++模板"],"title":"C++变参模板运用实战——实现PrintLn","uri":"/posts/c++%E7%9A%84%E6%A8%A1%E6%9D%BF%E5%86%99println/"},{"categories":["C++实战"],"content":"版本二：加模板参数版本 实际上和上面的基本没太大区别，除了上面确定为了int类型，二加了模板后，可以为任意类型，但是实际上传入的还是只能是同一个类型。所以初始化列表实现是非常的不好用的。 #incldue\u003ciostream\u003e using namespace std; template\u003ctypename T\u003e class PrintLn { public: PrintLn(std::initializer_list\u003cT\u003e args) { for (auto arg:args) { cout \u003c\u003c arg \u003c\u003c \", \"; }# PrintLn函数实现 想要实现PrintLn，关键在于支持无限个参数的打印函数，所以我大致总结下C++能够如何去实现它！ ## 方式一：用初始化列表实现PrintLn() 【C++11】 ### 版本一：朴素初始化列表版本版本 \u003e 函数版本： ```cpp #include\u003ciostream\u003eusing namespace std; void PrintLn(std::initializer_list\u003cint\u003e args){ for(auto arg:args){ cout\u003c\u003carg\u003c\u003c\", \"; } cout\u003c\u003cstd::endl; } int main() { PrintLn({3,23,2,12}); return 0; } 类的构造器版本(可去掉小括号)： #include\u003ciostream\u003eusing namespace std; class PrintLn { public: PrintLn(std::initializer_list\u003cint\u003e args) { for (auto arg:args) { cout \u003c\u003c arg \u003c\u003c \", \"; } cout \u003c\u003c std::endl; } }; int main() { auto t = PrintLn{3, 23, 2, 12}; return 0; } ","date":"2022-01-20","objectID":"/posts/c++%E7%9A%84%E6%A8%A1%E6%9D%BF%E5%86%99println/:1:2","tags":["C++模板"],"title":"C++变参模板运用实战——实现PrintLn","uri":"/posts/c++%E7%9A%84%E6%A8%A1%E6%9D%BF%E5%86%99println/"},{"categories":["C++实战"],"content":"版本二：加模板参数版本 实际上和上面的基本没太大区别，除了上面确定为了int类型，而加了模板后，可以为任意类型，但是实际上传入的还是只能是同一个类型。所以初始化列表的方式实现Println只能说形似而神不似。 #incldue\u003ciostream\u003e using namespace std; template\u003ctypename T\u003e class PrintLn { public: PrintLn(std::initializer_list\u003cT\u003e args) { for (auto arg:args) { cout \u003c\u003c arg \u003c\u003c \", \"; } cout \u003c\u003c std::endl; } }; int main() { auto t = PrintLn\u003cint\u003e{3, 23, 2, 12}; return 0; } ","date":"2022-01-20","objectID":"/posts/c++%E7%9A%84%E6%A8%A1%E6%9D%BF%E5%86%99println/:1:3","tags":["C++模板"],"title":"C++变参模板运用实战——实现PrintLn","uri":"/posts/c++%E7%9A%84%E6%A8%A1%E6%9D%BF%E5%86%99println/"},{"categories":["C++实战"],"content":"方式二：用可变参模板实现 【C++11/17】 如果有了解过C的可变参函数和可变参的宏，那么这个可变参模板与它有些类型，只不过C里面的va_start,va_list,va_arg,va_end这一系列实现可变参数的宏用起来非常麻烦，而且无法确定每个参数的类型，而可变参的模板则带有模板的泛型性质，所以是能确定类型的，甚至由于模板可以传值，后面还可直接传值使用。 以下简单描述可变参模板的使用方式： typenam... 算C++的一个新的关键字，它可以用来定义一个可变参的模板类型，而这个类型在其他地方定义使用的时候也要在后面带上 ... 表示拆包，否则会报错。 例如： template\u003ctypename... T\u003e void f(T... t){//TODO 这种类型或变量在任何地方作为参数定义或者传递的时候都需要加上...表示拆包 f(t...) } 在C++17出现fold expression之前，这个拆包过程只能借助另一个模板参数来得到模板参数包里面的内容。 注意以上两点，那么可以开始编写泛型模板，实现可变参数的完全打印过程了。 ","date":"2022-01-20","objectID":"/posts/c++%E7%9A%84%E6%A8%A1%E6%9D%BF%E5%86%99println/:2:0","tags":["C++模板"],"title":"C++变参模板运用实战——实现PrintLn","uri":"/posts/c++%E7%9A%84%E6%A8%A1%E6%9D%BF%E5%86%99println/"},{"categories":["C++实战"],"content":"C++11版本实现 错误实现版本：如果你直接像下面这样进行拆包，那么编译是会报错的，因为拆包过程相当于一个递归的过程，而你这个递归的过程没有一个跳出的条件，比如args如果为0个参数时，继续在往下就无法展开了，所以需要实现一个没有参数的版本让拆包过程停止。 template\u003ctypename T,typename... Args\u003e void PrintLn(T firstArg,Args... args){ cout\u003c\u003cfirstArg\u003c\u003c\", \"; PrintLn(args...); } //拆包过程：PrintLn(3,1,3,4)-\u003e // PrintLn(firstArg:3,args(1,3,4)); // PrintLn(firstArg:1,args(3,4)); // PrintLn(firstArg:3,args(4)); // PrintLn(firstArg:4,args(null)) // 由于到了上面的第四行还要继续往下拆包 // 而此时只有0个参数，没有对应的PrintLn版本可以调用，故报错！ 以下为正确修改版本： #include\u003ciostream\u003eusing namespace std; void PrintLn(){ } template\u003ctypename T,typename... Args\u003e void PrintLn(T firstArg,Args... args){ cout\u003c\u003cfirstArg\u003c\u003c\", \"; PrintLn(args...); } int main() { PrintLn(3, 23, 2, 12); return 0; 当然也可以控制只剩一个参数时就停止拆包。 #include\u003ciostream\u003eusing namespace std; template\u003ctypename T\u003e void PrintLn(T arg){ cout\u003c\u003carg\u003c\u003cendl; } template\u003ctypename T,typename... Args\u003e void PrintLn(T firstArg,Args... args){ cout\u003c\u003cfirstArg\u003c\u003c\", \"; PrintLn(args...); } int main() { PrintLn(3, 23, 2, 12); return 0; } ","date":"2022-01-20","objectID":"/posts/c++%E7%9A%84%E6%A8%A1%E6%9D%BF%E5%86%99println/:2:1","tags":["C++模板"],"title":"C++变参模板运用实战——实现PrintLn","uri":"/posts/c++%E7%9A%84%E6%A8%A1%E6%9D%BF%E5%86%99println/"},{"categories":["C++实战"],"content":"C++17版本实现 上面的实现流程实际上在C++17中可以用 if constexpr()+sizeof… 在编译期间来进行流程控制。 首先来讲一讲为什么普通的 if + sizeof… 来实现可变参数的长度控制流程会报错呢？ 因为整个模板推断和拆包解包过程是在编译期完成的，而if的控制流程在编译期是完全不清楚的，所以会报错，但是有了if constexpr之后，就能控制编译期的模板拆包过程了！ 如上面实现PrintLn，可以直接简化成下面这样： #include\u003ciostream\u003eusing namespace std; template\u003ctypename T,typename... Args\u003e void PrintLn(T firstArg,Args... args){ if constexpr(sizeof...(args)==0){//当参数个数为0个的时候就不继续拆包了 cout\u003c\u003cfirstArg\u003c\u003cendl; }else{ cout\u003c\u003cfirstArg\u003c\u003c\", \"; PrintLn(args...);//往下继续拆包 } } int main() { PrintLn(3, 23, 2, 12); return 0; } ","date":"2022-01-20","objectID":"/posts/c++%E7%9A%84%E6%A8%A1%E6%9D%BF%E5%86%99println/:2:2","tags":["C++模板"],"title":"C++变参模板运用实战——实现PrintLn","uri":"/posts/c++%E7%9A%84%E6%A8%A1%E6%9D%BF%E5%86%99println/"},{"categories":["C++实战"],"content":"方式三：可变参模板的fold expression展开 【C++17】 在C++17中，加入了一个fold expression的语法，让可变参数模板可以不通过递归的方式来解包，直接把每个包解开放入一个表达式，然后剩余的包都以该表达式解开，基本的语法如下： ((expression)op...); expression : 表示希望每个解开的参数所执行的表达式。 op : 你指定的操作符。 ... : 一直不断的解包，由于此处放的位置是右边，所以往右边解包，如果放左边则往左边解包。 示例代码： #include \u003cbits/stdc++.h\u003eusing namespace std; template\u003ctypename... Args\u003e double sum(Args... args){ return (args+...);//等价于3+23+1+3.32 } template\u003cauto... val\u003e//可变的传值的模板参数 constexpr int sum(){ return (val+...); } int main() { cout\u003c\u003csum\u003c3,23,1,32\u003e()\u003c\u003cendl;//传值模板参数不支持浮点类型，所以全用的int类型 cout\u003c\u003csum(3,23,1,3.32); return 0; } ","date":"2022-01-20","objectID":"/posts/c++%E7%9A%84%E6%A8%A1%E6%9D%BF%E5%86%99println/:3:0","tags":["C++模板"],"title":"C++变参模板运用实战——实现PrintLn","uri":"/posts/c++%E7%9A%84%E6%A8%A1%E6%9D%BF%E5%86%99println/"},{"categories":["C++实战"],"content":"简单的利用fold expr实现 基于以上对fold expr的使用，我们来正式实现PrintLn，值得一提的是，这个fold expr的性能肯定是比之前递归解包的性能要好的，因为只是迭代的拓宽而已。 我们可以将拆开的包用 ',' 展开 #include\u003ciostream\u003eusing namespace std; template\u003ctypename... Args\u003e void PrintLn(Args... args){ ((cout\u003c\u003cargs\u003c\u003c\", \"),...)\u003c\u003cendl; } int main() { PrintLn(1,2.3,\"LB\",\"hhh\"); return 0; } ","date":"2022-01-20","objectID":"/posts/c++%E7%9A%84%E6%A8%A1%E6%9D%BF%E5%86%99println/:3:1","tags":["C++模板"],"title":"C++变参模板运用实战——实现PrintLn","uri":"/posts/c++%E7%9A%84%E6%A8%A1%E6%9D%BF%E5%86%99println/"},{"categories":["C++实战"],"content":"加上流程控制实现 通过更复杂的流程控制把最后一个打印出来的逗号去掉。 通过延申三元运算符，使得运行时能够正确的打印最后一次。 反正我这里编译期只负责文本替换，所以被fold expr展开的表达式并不会有什么要是编译期常量的要求。 这一切都看作简单宏替换即可。 #include\u003ciostream\u003eusing namespace std; template\u003ctypename... Args\u003e void PrintLn(Args... args){ int lastIndex = sizeof...(args)-1;//得到传入的参数长度 int i = 0; ((i++==lastIndex?cout\u003c\u003cargs\u003c\u003cendl:cout\u003c\u003cargs\u003c\u003c\", \"),...); } int main() { PrintLn(1,2.3,\"LB\",\"hhh\"); return 0; } ","date":"2022-01-20","objectID":"/posts/c++%E7%9A%84%E6%A8%A1%E6%9D%BF%E5%86%99println/:3:2","tags":["C++模板"],"title":"C++变参模板运用实战——实现PrintLn","uri":"/posts/c++%E7%9A%84%E6%A8%A1%E6%9D%BF%E5%86%99println/"},{"categories":["C++实战"],"content":"更多fold expr运用… 利用与或表达式展开，然后利用它们的短路性质，实现得到拆包元素的精准打击（获得包里的第几个元素）。 #include\u003ciostream\u003eusing namespace std; template\u003ctypename... Args\u003e auto GetNth(int n, Args... args) { int i = 0; using CommonType = common_type_t\u003cArgs...\u003e; CommonType ret; ((i++ == n \u0026\u0026 (ret = args, true))||...); return ret; } int main() { cout \u003c\u003c GetNth(3, 2, 1, 2.3, 32.2); return 0; } 上面为了存储不确定的类型用了common_type_t，这个可以帮助你得到一个公共可用的类型，而这个类型必须是公共可用，比如int了float型可以进行相互转化所以有公共类型，而 char* 和int类型则没有，所以这个GetNth中的元素不能传递 char* 类型的同时传递int类型。 ","date":"2022-01-20","objectID":"/posts/c++%E7%9A%84%E6%A8%A1%E6%9D%BF%E5%86%99println/:3:3","tags":["C++模板"],"title":"C++变参模板运用实战——实现PrintLn","uri":"/posts/c++%E7%9A%84%E6%A8%A1%E6%9D%BF%E5%86%99println/"},{"categories":["C++实战"],"content":"”Socket基本操作的C++封装“","date":"2022-01-20","objectID":"/posts/socket%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9Cc++%E5%B0%81%E8%A3%85/","tags":["socket通信"],"title":"Socket基本操作的C++封装","uri":"/posts/socket%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9Cc++%E5%B0%81%E8%A3%85/"},{"categories":["C++实战"],"content":"封装过程 ","date":"2022-01-20","objectID":"/posts/socket%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9Cc++%E5%B0%81%E8%A3%85/:1:0","tags":["socket通信"],"title":"Socket基本操作的C++封装","uri":"/posts/socket%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9Cc++%E5%B0%81%E8%A3%85/"},{"categories":["C++实战"],"content":"接口类的实现(抽象类) _public_socket.h 该头文件用于包含所有该系统平台socket所需要依赖的库。 windows平台 #ifndef MY_TINY_STL__PUBLIC_SOCKET_H #define MY_TINY_STL__PUBLIC_SOCKET_H #include \u003cwinsock2.h\u003e#pragma comment (lib, \"ws2_32.lib\") //加载 ws2_32.dll #endif //MY_TINY_STL__PUBLIC_SOCKET_H Linux平台 #include \u003cunistd.h\u003e#include \u003carpa/inet.h\u003e#include \u003csys/socket.h\u003e#include \u003cnetinet/in.h\u003eTCP_INTERFACE.h(作用于win平台) 由于该接口由服务器端和客户端继承，而两者同样的函数成员也就是这些了，设计客户端和服务器端时就只需要考虑各自的套接字以及其余操作的成员函数，也不需要管理DLL的开关。 还有一个erro_die()成员函数用于阻断错误并打印对应情况。 // // Created by Alone on 2021/8/17. // #ifndef MY_TINY_STL_TCP_INTERFACE_H #define MY_TINY_STL_TCP_INTERFACE_H #include \u003ccstdio\u003e#include \"_public_socket.h\" class TCP_INTERFACE { public: TCP_INTERFACE() { //初始化 DLL WSADATA wsaData; WSAStartup(MAKEWORD(2, 2), \u0026wsaData); } //返回值小于等于0时发生错误 virtual int Send(SOCKET clnt, const void *buf, const int buflen) = 0; virtual int Recv(SOCKET clnt, void *buf, const int buflen) = 0; //closesocket返回值不为0则发生错误 virtual void Close(SOCKET clnt) = 0; virtual void error_die(const char *str) = 0; ~TCP_INTERFACE() { WSACleanup(); } }; #endif //MY_TINY_STL_TCP_INTERFACE_H ","date":"2022-01-20","objectID":"/posts/socket%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9Cc++%E5%B0%81%E8%A3%85/:1:1","tags":["socket通信"],"title":"Socket基本操作的C++封装","uri":"/posts/socket%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9Cc++%E5%B0%81%E8%A3%85/"},{"categories":["C++实战"],"content":"服务器端封装 这次修改了下逻辑，还是用accept返回一个套接字进行发送和接收操作比较好。类的底层没有再保留用于和某个客户端通信的套接字了，自己控制各个客户端套接字的关闭和使用。 TCP_SOCKET_SERVER.h // // Created by Alone on 2021/8/16. // #ifndef MY_TINY_STL_TCP_SOCKET_SERVER_H #define MY_TINY_STL_TCP_SOCKET_SERVER_H #include \"TCP_INTERFACE.h\" class TCP_SOCKET_SERVER : public TCP_INTERFACE { public: TCP_SOCKET_SERVER(); ~TCP_SOCKET_SERVER(); void Bind(int port); void Listen(); SOCKET Accept(); int Send(SOCKET clnt, const void *buf, const int buflen); int Recv(SOCKET clnt, void *buf, const int buflen); void Close(SOCKET clnt); void error_die(const char *str); private: SOCKET servSock; sockaddr_in sockAddr; }; #endif //MY_TINY_STL_TCP_SOCKET_SERVER_H TCP_SOCKET_SERVER.cpp // // Created by Alone on 2021/8/16. // #include \"TCP_SOCKET_SERVER.h\" //初始化操作 TCP_SOCKET_SERVER::TCP_SOCKET_SERVER() : servSock(0) { memset(\u0026sockAddr, 0, sizeof(sockAddr)); //每个字节都用0填充 } //绑定操作 void TCP_SOCKET_SERVER::Bind(int port) { servSock = socket(PF_INET, SOCK_STREAM, IPPROTO_TCP); sockAddr.sin_family = PF_INET; //使用IPv4地址 sockAddr.sin_addr.s_addr = htonl(INADDR_ANY); //具体的IP地址 sockAddr.sin_port = htons(port); //端口 if (bind(servSock, (SOCKADDR *) \u0026sockAddr, sizeof(SOCKADDR)) != 0) { error_die(\"bind\"); } } //置于监听状态 void TCP_SOCKET_SERVER::Listen() { if (servSock == 0) error_die(\"listen\"); if (listen(servSock, SOMAXCONN) != 0) { error_die(\"listen\"); } } //利用套接字的监听串口，接收客户端的请求，建立新的套接字进行存储信息 SOCKET TCP_SOCKET_SERVER::Accept() { SOCKADDR t; int nSize = sizeof(SOCKADDR); //后面两个参数为可选 SOCKET clnt = accept(servSock, \u0026t, \u0026nSize); if (clnt \u003c= 0)error_die(\"accept\"); return clnt; } //返回的是发送到缓冲区的字节长度 int TCP_SOCKET_SERVER::Send(SOCKET clnt, const void *buf, const int buflen) { return send(clnt, (const char *) buf, buflen, 0); } //返回已经接收的字节长度 int TCP_SOCKET_SERVER::Recv(SOCKET clnt, void *buf, const int buflen) { return recv(clnt, (char *) buf, buflen, 0); } //析构函数关闭socket TCP_SOCKET_SERVER::~TCP_SOCKET_SERVER() { if (servSock != 0)closesocket(servSock); } void TCP_SOCKET_SERVER::Close(SOCKET clnt) { if (closesocket(clnt) != 0) { error_die(\"closesocket\"); } } void TCP_SOCKET_SERVER::error_die(const char *str) { printf(\"[hint]%s failed:%d\", str, WSAGetLastError()); exit(-1); } ","date":"2022-01-20","objectID":"/posts/socket%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9Cc++%E5%B0%81%E8%A3%85/:1:2","tags":["socket通信"],"title":"Socket基本操作的C++封装","uri":"/posts/socket%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9Cc++%E5%B0%81%E8%A3%85/"},{"categories":["C++实战"],"content":"客户端的封装 TCP_SOCKET_CLIENT.h 增加了利用域名查询ip地址的成员函数gethostbyname(),挺好玩的！此次增加了erro_die函数，且发送和接收都操作套接字。在类的内部还是保留了套接字的备份，用于忘记关闭套接字时，析构函数进行关闭。 // // Created by Alone on 2021/8/18. // #ifndef MY_TINY_STL_TCP_SOCKET_CLIENT_H #define MY_TINY_STL_TCP_SOCKET_CLIENT_H #include \"TCP_INTERFACE.h\"#include \u003ciostream\u003e class TCP_SOCKET_CLIENT : public TCP_INTERFACE { public: TCP_SOCKET_CLIENT(); ~TCP_SOCKET_CLIENT(); SOCKET Connect(const char *IPAdrr, u_short port); //用于利用URL(域名)查询IP地址 void Gethostbyname(const char *URL); //接口必须实现的函数 int Send(SOCKET clnt,const void *buf, const int bufSize); int Recv(SOCKET clnt,void *buf, const int bufSize); void Close(SOCKET clnt); void error_die(const char *str); private: //由于一般客户端只需要一个套接字实现连接,然后还需要一个socketadrr_in用于连接内容的赋值 SOCKET clntSock; sockaddr_in sockAddr; }; #endif //MY_TINY_STL_TCP_SOCKET_CLIENT_H TCP_SOCKET_CLIENT.cpp // // Created by Alone on 2021/8/17. // #include \"TCP_SOCKET_CLIENT.h\" //初始化 TCP_SOCKET_CLIENT::TCP_SOCKET_CLIENT() : clntSock(0) {} //关闭套接字操作 void TCP_SOCKET_CLIENT::Close(SOCKET clnt) { if (closesocket(clnt) != 0) error_die(\"close\"); clntSock = 0; } //连接服务器操作 SOCKET TCP_SOCKET_CLIENT::Connect(const char *IPAdrr, u_short port) { memset(\u0026sockAddr, 0, sizeof sockAddr); clntSock = socket(PF_INET, SOCK_STREAM, IPPROTO_TCP); sockAddr.sin_family = PF_INET; sockAddr.sin_addr.s_addr = inet_addr(IPAdrr); sockAddr.sin_port = htons(port); if (connect(clntSock, (SOCKADDR *) \u0026sockAddr, sizeof(sockAddr)) != 0) { error_die(\"connect\"); } return clntSock; } //发送信息操作 int TCP_SOCKET_CLIENT::Send(SOCKET clnt,const void *buf, const int bufSize) { return send(clnt, (const char *) buf, bufSize, 0); } //接收信息操作 int TCP_SOCKET_CLIENT::Recv(SOCKET clnt,void *buf, const int bufSize) { return recv(clnt, (char *) buf, bufSize, 0); } //根据域名获取ip地址等信息 void TCP_SOCKET_CLIENT::Gethostbyname(const char *URL) { hostent *host = gethostbyname(URL); if (!host) { std::cout \u003c\u003c \"Get IP address error!\\n\"; return; } //打印本命 std::cout \u003c\u003c URL \u003c\u003c std::endl; //别名 for (int i = 0; host-\u003eh_aliases[i]; i++) { printf(\"Aliases %d: %s\\n\", i + 1, host-\u003eh_aliases[i]); } //地址类型 printf(\"Address type: %s\\n\", (host-\u003eh_addrtype == AF_INET) ? \"AF_INET\" : \"AF_INET6\"); //IP地址,其中inet_ntoa()函数是将网络字节序转为本地的字节序，方便打印看懂 for (int i = 0; host-\u003eh_addr_list[i]; i++) { printf(\"IP addr %d: %s\\n\", i + 1, inet_ntoa(*(struct in_addr *) host-\u003eh_addr_list[i])); } } //析构时需要确保所有东西已经关闭 TCP_SOCKET_CLIENT::~TCP_SOCKET_CLIENT() { if (clntSock != 0) closesocket(clntSock); } void TCP_SOCKET_CLIENT::error_die(const char *str) { printf(\"[hint]%s failed:%d\", str, WSAGetLastError()); exit(-1); } ","date":"2022-01-20","objectID":"/posts/socket%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9Cc++%E5%B0%81%E8%A3%85/:1:3","tags":["socket通信"],"title":"Socket基本操作的C++封装","uri":"/posts/socket%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9Cc++%E5%B0%81%E8%A3%85/"},{"categories":["C++实战"],"content":"实例讲解 ","date":"2022-01-20","objectID":"/posts/socket%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9Cc++%E5%B0%81%E8%A3%85/:2:0","tags":["socket通信"],"title":"Socket基本操作的C++封装","uri":"/posts/socket%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9Cc++%E5%B0%81%E8%A3%85/"},{"categories":["C++实战"],"content":"实例一：回声程序通信 服务器回声程序 绑定本地1234端口，进入监听状态等待请求，如果通信对象关闭了通信，也不慌，重新goto到等待请求得到新的通信套接字 #include \u003ciostream\u003e#include \"TCP_SOCKET_SERVER.h\" #define BUF_SIZE 1000 using namespace std; int main() { TCP_SOCKET_SERVER a; a.Bind(1234); a.Listen(); restart: SOCKET clnt = a.Accept(); while (1) { char *x = new char[BUF_SIZE]; memset(x, 0, BUF_SIZE); int size = a.Recv(clnt,x, BUF_SIZE); if (size \u003c= 0) break; if (a.Send(clnt,x, size) \u003c= 0) break; } a.Close(clnt); cout \u003c\u003c \"connect is over.Waiting for a new connection!\\n\"; goto restart; } 客户端通信程序 为保持持续通信，一旦客户端拒绝了请求，那么弹出循环重新连接，并设置连接超时操作。 #include \"TCP_SOCKET_CLIENT.h\"#define BUF_SIZE 100 int main(){ TCP_SOCKET_CLIENT t; const char* to = \"127.0.0.1\"; restart: SOCKET clnt = t.Connect(to,1234); while(1){ std::cout\u003c\u003c\"\\nInput your message:\\n\"; char buf[BUF_SIZE] = {0}; std::cin.getline(buf,99); int size = t.Send(clnt,buf,BUF_SIZE); if(size\u003c=0) break; memset(buf,0,sizeof buf); if(t.Recv(clnt,buf,size)\u003c=0) break; printf(\"received from %s is:\\n\",to); std::cout\u003c\u003cbuf; } t.Close(clnt); std::cout\u003c\u003c\"The Server is disconnected,and socket has been cleaned up,socket connection has been re-established\\n\"; goto restart; return 0; } 回声效果 客户端收到的结果 服务器端一直运行着，只要不关闭，但每次只能和一个客户端进行通信，通信完后重新等待连接。 ","date":"2022-01-20","objectID":"/posts/socket%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9Cc++%E5%B0%81%E8%A3%85/:2:1","tags":["socket通信"],"title":"Socket基本操作的C++封装","uri":"/posts/socket%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9Cc++%E5%B0%81%E8%A3%85/"},{"categories":["C++实战"],"content":"实例二：文件操作，传送图片(掌握重复传包) 分析待传图片 看看这百万大小的字节，一次肯定是传不完的，所以我们需要发送端不断的续传，直到传送完毕。 发送端程序 #include \"TCP_SOCKET_CLIENT.h\"#include \u003cfstream\u003eint main(){ TCP_SOCKET_CLIENT t; const char* to = \"127.0.0.1\"; restart: SOCKET clnt = t.Connect(to,1234); //图片写入buf(这几百万字节大小，得亏是new动态分配 std::ifstream img(\"D:/DesktopBackground/L-69.png\",std::ios::in|std::ios::binary); //设置文件指针用于求文件内容长度 img.seekg(0,std::ios::end); int len = img.tellg(); img.seekg(0,std::ios::beg); if(len\u003e0){printf(\"read OK\\n\");} else {printf(\"file is empty!\");return 0;} //填补buf char * buf = new char[len]; img.read(buf,len); //发送数据到服务器,一次肯定发送不完，所以多次 int sum = 0; while(sum\u003clen){ int sendlen = t.Send(clnt,buf,len); if(sendlen\u003c=0){ printf(\"Send Erro!\"); return 0; } sum += sendlen; } t.Close(clnt); printf(\"Send OK!\"); return 0; } 接收端程序 #include \u003ciostream\u003e#include \"TCP_SOCKET_SERVER.h\"#include \u003cfstream\u003e#define BUF_SIZE 100 using namespace std; int main() { TCP_SOCKET_SERVER a; a.Bind(1234); a.Listen(); //等待连接，连接成功便可建立通讯 SOCKET clnt = a.Accept(); //创建文件用于写入图片数据 ofstream t(\"test.png\",ios::binary|ios::out); //由于要接收的图片文件较大，需要分多次包进行传输数据，所以需要不断循环接收 while(1){ char buf[BUF_SIZE]; int sz = a.Recv(clnt,buf,BUF_SIZE); //直到发送端发送数据完毕断开连接后，便可判断为接收完毕 if(sz\u003c=0){ cout\u003c\u003c\"Finish !\"; return 0; } //每次调整文件指针位置到最后续写 t.seekp(0,ios::end); t.write(buf,sz); } a.Close(clnt); } 接收结果 一模一样毫无偏差 ","date":"2022-01-20","objectID":"/posts/socket%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9Cc++%E5%B0%81%E8%A3%85/:2:2","tags":["socket通信"],"title":"Socket基本操作的C++封装","uri":"/posts/socket%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9Cc++%E5%B0%81%E8%A3%85/"},{"categories":["C++实战"],"content":"实例三：Web通信(浏览器访问服务器) ","date":"2022-01-20","objectID":"/posts/socket%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9Cc++%E5%B0%81%E8%A3%85/:3:0","tags":["socket通信"],"title":"Socket基本操作的C++封装","uri":"/posts/socket%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9Cc++%E5%B0%81%E8%A3%85/"},{"categories":["C++实战"],"content":"Web服务器程序 我这个web服务器也算是及其简单了。。并没有对客户端的http请求进行解析然后发送对应的文件给客户端，而是单纯的我客户端想怎么发就怎么发。。另外这个程序虽然是对图片进行了判断，但并未写出对应的图片发送程序(二进制文件读写是不一样的)，所以实际只能发送文本文件，如html代码。所以后面看到的课程表都无法显示图片的原因是客户端程序压根就没在乎过客户端的请求🤣 #include \u003ciostream\u003e#include \u003cfstream\u003e#include \"TCP_SOCKET_SERVER.h\" void sendfileToWeb(SOCKET clnt, TCP_SOCKET_SERVER \u0026a, const char *filename); int main() { TCP_SOCKET_SERVER a; a.Bind(8086); a.Listen(); SOCKET clnt = a.Accept(); while (1) { sendfileToWeb(clnt, a, \"D:/Html/schedule/schedule.html\"); a.Close(clnt); clnt = a.Accept(); } } //反馈请求，发送文件代码或者图片等二进制信息。 void sendfileToWeb(SOCKET clnt, TCP_SOCKET_SERVER \u0026a, const char *filename) { //写入返回头信息：包括状态和内容类型 char *type = nullptr; if (strstr(filename, \".html\")) type = \"text/html\"; else if (strstr(filename, \".jpg\")) type = \"image/jpg\"; else if (strstr(filename, \".png\")) type = \"image/png\"; char x[100] = {0}; sprintf(x, \"HTTP/1.1 200 ok\\r\\nContent-Type: %s\\r\\n\\r\\n\", type); //发送返回头信息,每次发送间隔需要一定时间，否则浏览器可能接收没这么快 int sz1 = a.Send(clnt, x, strlen(x)); if (sz1 \u003c= 0)return; //发送文件内容到客户端 std::ifstream ss(filename, std::ios::in); char html[1024] = {0}; while (ss.getline(html, 1024)) { int szz = a.Send(clnt, html, strlen(html)); if (szz \u003c= 0) return; Sleep(1); } ss.close(); } ","date":"2022-01-20","objectID":"/posts/socket%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9Cc++%E5%B0%81%E8%A3%85/:3:1","tags":["socket通信"],"title":"Socket基本操作的C++封装","uri":"/posts/socket%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9Cc++%E5%B0%81%E8%A3%85/"},{"categories":["C++实战"],"content":"接收结果 ","date":"2022-01-20","objectID":"/posts/socket%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9Cc++%E5%B0%81%E8%A3%85/:3:2","tags":["socket通信"],"title":"Socket基本操作的C++封装","uri":"/posts/socket%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9Cc++%E5%B0%81%E8%A3%85/"},{"categories":["C++实战"],"content":"总结 收获： 了解到网络通讯过程到底是怎么样的。 了解到底层socket通信是如何进行的。 封装了socket操作，增强了代码的复用性。 对基本的http请求过程有所了解： 基本上就是浏览器(客户端)对相应的IP地址发起请求，其对应的服务器返回给你这个网页的主页，然后根据你鼠标的点击，又会触发http请求，其对应的服务器对你的请求进行解析，得出你想要的文件，然后发送给你，循环往复一直如此。。。 ","date":"2022-01-20","objectID":"/posts/socket%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9Cc++%E5%B0%81%E8%A3%85/:4:0","tags":["socket通信"],"title":"Socket基本操作的C++封装","uri":"/posts/socket%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9Cc++%E5%B0%81%E8%A3%85/"},{"categories":["C++实战"],"content":"”简单学习下基本的类封装“","date":"2022-01-20","objectID":"/posts/%E5%A4%A7%E6%95%B4%E6%95%B0%E5%8A%A0%E5%87%8F/","tags":["C++类的封装"],"title":"大数加减类的实现(C++实现)✨","uri":"/posts/%E5%A4%A7%E6%95%B4%E6%95%B0%E5%8A%A0%E5%87%8F/"},{"categories":["C++实战"],"content":"为什么需要大数加减类？ 对于计算机而言，基本的数据类型一般最多为64位数据表示范围，这个范围是有限的，没法无限的表示所有的数据，那么有没有一种方式能够表示所有的大数，并完成加减乘除呢？ 答案肯定是有的，由于数据都是由一位一位的数字所组成，我们只需要用数组中的每一位表示一位数字，便可完成对大数的模拟了。 那么我们说明时候需要用到大数模拟呢？对竞赛人而言，有很多题目实际上就是高精度大数模拟类型，而对于普通的程序员而言，大数模拟也仅是在做某个逻辑运算而保证不会溢出的最佳策略，那么大家难道不好奇如何实现一个大数模拟类吗？ 现在就从封装一个简单的加减类开始了解这样一个大数模拟是怎么实现的👀 ","date":"2022-01-20","objectID":"/posts/%E5%A4%A7%E6%95%B4%E6%95%B0%E5%8A%A0%E5%87%8F/:1:0","tags":["C++类的封装"],"title":"大数加减类的实现(C++实现)✨","uri":"/posts/%E5%A4%A7%E6%95%B4%E6%95%B0%E5%8A%A0%E5%87%8F/"},{"categories":["C++实战"],"content":"大数加减类实现详解 ","date":"2022-01-20","objectID":"/posts/%E5%A4%A7%E6%95%B4%E6%95%B0%E5%8A%A0%E5%87%8F/:2:0","tags":["C++类的封装"],"title":"大数加减类的实现(C++实现)✨","uri":"/posts/%E5%A4%A7%E6%95%B4%E6%95%B0%E5%8A%A0%E5%87%8F/"},{"categories":["C++实战"],"content":"一、流程图总览 如图总体来说分为五部分： 静态成员函数：属于类的公共接口(核心) 构造和析构函数：构造对象以及析构对象 成员数据：用于运算的数据以及表示对象的数据 运算符重载：用于自定义运算方式(核心) 内部成员函数：属于对象的公共接口 ","date":"2022-01-20","objectID":"/posts/%E5%A4%A7%E6%95%B4%E6%95%B0%E5%8A%A0%E5%87%8F/:2:1","tags":["C++类的封装"],"title":"大数加减类的实现(C++实现)✨","uri":"/posts/%E5%A4%A7%E6%95%B4%E6%95%B0%E5%8A%A0%E5%87%8F/"},{"categories":["C++实战"],"content":"二、成员数据和构造函数详解 成员数据 bool f; //是否是负数的标记 char *nums; //存储非符号的大数各个位 int length; //nums的数据长度 int capacity; //nums的可用容量 构造和析构 //缺省构造函数 BigInteger() : length(0), capacity(1), f(false) { nums = new char[capacity]; } //用于转化普通字符串的构造函数 BigInteger(const char *n) : length(strlen(n)), f(false) { int start = 0; if (n[0] == '-') { f = true; start++; } while (start\u003clength\u0026\u0026n[start] == '0')start++; capacity = length * 10; nums = new char[capacity]; std::copy(n + start, n + length, nums); length = length - start; } //拷贝构造函数 BigInteger(BigInteger \u0026a) { capacity = a.capacity; length = a.length; f = a.f; nums = new char[capacity]; std::copy(a.nums, a.nums + length, nums); } //移动构造函数：这里调用了等于号，根据a的类型来决定用哪个等于号 BigInteger(BigInteger \u0026\u0026a) :length(0){ *this = a; } //析构函数 ~BigInteger() { delete[] nums; } ","date":"2022-01-20","objectID":"/posts/%E5%A4%A7%E6%95%B4%E6%95%B0%E5%8A%A0%E5%87%8F/:2:2","tags":["C++类的封装"],"title":"大数加减类的实现(C++实现)✨","uri":"/posts/%E5%A4%A7%E6%95%B4%E6%95%B0%E5%8A%A0%E5%87%8F/"},{"categories":["C++实战"],"content":"三、(算法核心)静态成员函数和运算符重载详解 static Swap() //调用std的swap实现对基本数据的交换 static void Swap(BigInteger \u0026a, BigInteger \u0026b) { std::swap(a.length, b.length); std::swap(a.capacity, b.capacity); std::swap(a.f, b.f); std::swap(a.nums, b.nums); } static compare() //不看符号比较nums的大小：表示a是否比b大 static bool compare(const BigInteger \u0026a,const BigInteger \u0026b) { //比较纯nums大小(不看符号 int n1 = a.length; int n2 = b.length; if (n1 != n2)return n1 \u003e n2; //返回a和b哪个大，true则位a大 int i = 0; while (i \u003c n1 \u0026\u0026 a.nums[i] == b.nums[i])i++; //a b一样长的情况下，比较两个的值 if (i == n1) return false; return a.nums[i] \u003e b.nums[i]; } static isEqual() //表示a和b是否相等 bool isEqual(BigInteger \u0026a, BigInteger \u0026b) { if (a.f != b.f || (a.length != b.length))return false; int i = 0; while (i \u003c a.length \u0026\u0026 a.nums[i] == b.nums[i])i++; return i == a.length \u0026\u0026 a.f == b.f; } (*核心算法)static add() 不看符号的加法，符号这方面由重载加法运算符控制。 static BigInteger add(BigInteger \u0026a, BigInteger \u0026b) { //不看符号的加法 a.reverse();//尾端对齐 b.reverse(); BigInteger t; int up = 0; int len = a.length \u003e b.length ? a.length : b.length; for (int i = 0; i \u003c len; i++) { int ta = i \u003c a.length ? a[i] - '0' : 0; int tb = i \u003c b.length ? b[i] - '0' : 0; int base = ta + tb + up; t.push_back(base % 10 + '0'); up = base / 10; } if (up) t.push_back(up + '0'); t.reverse();//返回原位 a.reverse(); b.reverse(); return t; } (*核心算法)static minus() 不看符号的减法,默认了a的nums大小(不看符号)是比b大的。 static BigInteger minus(BigInteger \u0026a, BigInteger \u0026b) { a.reverse(); b.reverse(); BigInteger t; int len = a.length \u003e b.length ? a.length : b.length; for (int i = 0; i \u003c len; i++) { int ta = i \u003c a.length ? a[i] - '0' : 0; int tb = i \u003c b.length ? b[i] - '0' : 0; int base = ta - tb; if (base \u003c 0) { base += 10; a[i + 1]--; } t.push_back(base + '0'); } t.reverse(); a.reverse(); b.reverse(); return t; } char \u0026operator[] char \u0026operator[](int i) { return nums[i]; } BigInteger \u0026operator= 用了两个版本–右值引用和左值引用版本 右值引用延长寿命，用交换的方式实现(毕竟是将亡值 BigInteger \u0026operator=(BigInteger\u0026\u0026 a) { //Swap\u0026Copy方式实现右值赋值重载 Swap(*this, a); return *this; } 左值引用深拷贝 BigInteger \u0026operator=(const BigInteger \u0026a) {//深拷贝 if (length != 0)//如果不是初始化调用的 = ，则肯定需要先把原来的内存delete掉 delete[]nums; capacity = a.capacity; length = a.length; f = a.f; nums = new char[capacity]; std::copy(a.nums, a.nums + length, nums); return *this; } bool operator\u003c 重载了小于号，好处在于可以直接利用stl进行各种排序操作了。 注意：一定要写成const版本的成员函数，不然STL库无法调用，因为STL库中的所有比较都是基于const对象。 bool operator\u003c(const BigInteger \u0026a) const { if (f \u0026\u0026 !a.f) { //其中一个为负数，则那个是更小的 return true; } else if (!f \u0026\u0026 a.f) return false; if (f) { //两者都为负数的情况，左边的值要更大则为true return compare(*this, a); }//两者均为正数，则值更小的在左边为true return compare(a, *this); } (*核心算法)BigInteger operator+ 利用静态成员函数完成无符号的加减，然后在这里进行判断各种符号情况，根据不同的符号情况进行不同的加法处理。 注意在调用minus之前需要比较两个数的nums谁更大，更大的放在第一个参数上！ BigInteger operator+(BigInteger \u0026a) { BigInteger res; bool flag; if (a.f \u0026\u0026 f) { //同为负数情况，直接相加，再改符号 res = add(*this, a); flag = true; } else if (a.f \u0026\u0026 !f) {//左正右负 if (compare(a, *this)) { //看负数对应的nums是否比正数大 flag = true; res = minus(a, *this); } else { flag = false; res = minus(*this, a); } } else if (!a.f \u0026\u0026 f) { if (compare(*this, a)) { //与上一个相同 flag = true; res = minus(*this, a); } else { flag = false; res = minus(a, *this); } } else { //同时为正数就是最简单的加法 flag = false; res = add(*this, a); } res.f = flag; return res; } (*核心算法)BigInteger operator- 同样是分类讨论，同样是根据不同的类型调用minus和add函数。 与正数不同的处理在于对符号的处理，如果同为负数，则需要判断两者是否相等，防止两数相等相减后减为 0，而被处理为 -0 。 BigInteger operator-(BigInteger \u0026a) { BigInteger res; bool flag; if (a.f \u0026\u0026 f) { //同为负数情况--左边-右边==(不看符号)右边-(不看符号)左边 if (compare(a, *this)) { flag = false; res = minus(a, *this); } else { if (isEqual(*this, a)) flag = false; else flag = true; res = minus(*this, a); } } else if (a.f \u0026\u0026 !f) { //左边为正，右边为负--左边-右边==左边+右边 flag = false; res = add(a, *this); } else if (!a.f \u0026\u0026 f) { //右边为正，左边为负--左边-右边==两边为负的加法 flag = true; res = add(a, *this); } else { //同时为正数--左边-右边==左边-右边(分类讨论正负 if (compare(a, *this)) { //右边\u003e左边,符号为负 res = minus(a, *this); flag = true; } else { //右边\u003c左边，符号为正 res = minus(*this, a); flag = false; } } res.f = flag; return res; } ","date":"2022-01-20","objectID":"/posts/%E5%A4%A7%E6%95%B4%E6%95%B0%E5%8A%A0%E5%87%8F/:2:3","tags":["C++类的封装"],"title":"大数加减类的实现(C++实现)✨","uri":"/posts/%E5%A4%A7%E6%95%B4%E6%95%B0%E5%8A%A0%E5%87%8F/"},{"categories":["C++实战"],"content":"四、其他内部成员函数详解 向外提供的get接口 int getCap() { return capacity; } int getLength() { return length; } bool isNegative() { return f; } bool isEmpty() { return length == 0; } 进行赋值操作所必备的push_back和reverse函数 void push_back(char x) { if (length \u003e= capacity) {//扩容操作 capacity *= 2; char *t = nums; nums = new char[capacity]; std::copy(t, t + length, nums); delete[]t; } nums[length++] = x; } void reverse() {//反转操作 int l = 0, r = length - 1; while (l \u003c r) { std::swap(nums[l], nums[r]); l++; r--; } } 无关紧要的 read() 输入接口 和 print() 输出测试接口 void print() { if (f) printf(\"-\"); nums[length] = '\\0'; int i = 0; while (nums[i] == '0')i++; printf(\"%s\", nums + i); } void read() {//利用getchar()给对象赋上数据 char c = getchar(); if (c == '-') { f = true; c = getchar(); } while (c == '0') c = getchar();//将前导0消耗掉 while (c != '\\n') { push_back(c);//不断的调用push_back即可 c = getchar(); } } ","date":"2022-01-20","objectID":"/posts/%E5%A4%A7%E6%95%B4%E6%95%B0%E5%8A%A0%E5%87%8F/:2:4","tags":["C++类的封装"],"title":"大数加减类的实现(C++实现)✨","uri":"/posts/%E5%A4%A7%E6%95%B4%E6%95%B0%E5%8A%A0%E5%87%8F/"},{"categories":["C++实战"],"content":"整理代码 ","date":"2022-01-20","objectID":"/posts/%E5%A4%A7%E6%95%B4%E6%95%B0%E5%8A%A0%E5%87%8F/:3:0","tags":["C++类的封装"],"title":"大数加减类的实现(C++实现)✨","uri":"/posts/%E5%A4%A7%E6%95%B4%E6%95%B0%E5%8A%A0%E5%87%8F/"},{"categories":["C++实战"],"content":".h声明文件 如果在声明类的同时进行定义，则内部的成员函数默认就是内联的。所以我们一般把短小的代码进行内联，以下的实现均是以该规律进行。 // // Created by Alone on 2021/10/7. // #ifndef MY_TINY_STL_BIGINTEGER_H #define MY_TINY_STL_BIGINTEGER_H #include \u003calgorithm\u003e#include \u003ciostream\u003e#include \u003ccstring\u003e class BigInteger { bool f; char *nums; int length; int capacity; public: //构造函数 BigInteger() : length(0), capacity(1), f(false) { //缺省构造函数 nums = new char[capacity]; } BigInteger(const char *n); BigInteger(const BigInteger \u0026a); BigInteger(BigInteger \u0026\u0026a); ~BigInteger() { //析构函数 delete[] nums; } public: //静态函数 static void Swap(BigInteger \u0026a, BigInteger \u0026b); static bool compare(const BigInteger \u0026a, const BigInteger \u0026b); bool isEqual(BigInteger \u0026a, BigInteger \u0026b); static BigInteger add(BigInteger \u0026a, BigInteger \u0026b); static BigInteger minus(BigInteger \u0026a, BigInteger \u0026b); public: //运算符重载 char \u0026operator[](int i) { return nums[i]; } BigInteger \u0026operator=(BigInteger \u0026\u0026a) { //Swap\u0026Copy方式实现右值赋值重载 Swap(*this, a); return *this; } BigInteger \u0026operator=(const BigInteger \u0026a); bool operator\u003c(const BigInteger \u0026a) const; BigInteger operator+(BigInteger \u0026a); BigInteger operator-(BigInteger \u0026a); public: //对象的基本成员函数 int getCap() { return capacity; } int getLength() { return length; } bool isNegative() { return f; } bool isEmpty() { return length == 0; } void reverse(); void push_back(char x); void print(); void read(); }; #endif //MY_TINY_STL_BIGINTEGER_H ","date":"2022-01-20","objectID":"/posts/%E5%A4%A7%E6%95%B4%E6%95%B0%E5%8A%A0%E5%87%8F/:3:1","tags":["C++类的封装"],"title":"大数加减类的实现(C++实现)✨","uri":"/posts/%E5%A4%A7%E6%95%B4%E6%95%B0%E5%8A%A0%E5%87%8F/"},{"categories":["C++实战"],"content":".cpp定义并实现 // // Created by Alone on 2021/10/7. // #include \"BigInteger.h\" //@构造函数实现 BigInteger::BigInteger(const char *n) : length(strlen(n)), f(false) { //用于初始值的构造函数 int start = 0; if (n[0] == '-') { f = true; start++; } while (start \u003c length \u0026\u0026 n[start] == '0')start++; capacity = length * 10; nums = new char[capacity]; std::copy(n + start, n + length, nums); length = length - start; } BigInteger::BigInteger(const BigInteger \u0026a) { //拷贝构造函数 capacity = a.capacity; length = a.length; f = a.f; nums = new char[capacity]; std::copy(a.nums, a.nums + length, nums); } BigInteger::BigInteger(BigInteger \u0026\u0026a) : length(0) { //移动构造函数 *this = a; } //@静态函数实现 void BigInteger::Swap(BigInteger \u0026a, BigInteger \u0026b) { std::swap(a.length, b.length); std::swap(a.capacity, b.capacity); std::swap(a.f, b.f); std::swap(a.nums, b.nums); } bool BigInteger::compare(const BigInteger \u0026a, const BigInteger \u0026b) { int n1 = a.length; int n2 = b.length; if (n1 != n2)return n1 \u003e n2; //返回a和b哪个大，true则位a大 int i = 0; while (i \u003c n1 \u0026\u0026 a.nums[i] == b.nums[i])i++; //a b一样长的情况下，比较两个的值 if (i == n1) return false; return a.nums[i] \u003e b.nums[i]; } bool BigInteger::isEqual(BigInteger \u0026a, BigInteger \u0026b) { if (a.f != b.f || (a.length != b.length))return false; int i = 0; while (i \u003c a.length \u0026\u0026 a.nums[i] == b.nums[i])i++; return i == a.length \u0026\u0026 a.f == b.f; } BigInteger BigInteger::add(BigInteger \u0026a, BigInteger \u0026b) { a.reverse();//尾端对齐 b.reverse(); BigInteger t; int up = 0; int len = a.length \u003e b.length ? a.length : b.length; for (int i = 0; i \u003c len; i++) { int ta = i \u003c a.length ? a[i] - '0' : 0; int tb = i \u003c b.length ? b[i] - '0' : 0; int base = ta + tb + up; t.push_back(base % 10 + '0'); up = base / 10; } if (up) t.push_back(up + '0'); t.reverse();//返回原位 a.reverse(); b.reverse(); return t; } BigInteger BigInteger::minus(BigInteger \u0026a, BigInteger \u0026b) { a.reverse(); b.reverse(); BigInteger t; int len = a.length \u003e b.length ? a.length : b.length; for (int i = 0; i \u003c len; i++) { int ta = i \u003c a.length ? a[i] - '0' : 0; int tb = i \u003c b.length ? b[i] - '0' : 0; int base = ta - tb; if (base \u003c 0) { base += 10; a[i + 1]--; } t.push_back(base + '0'); } t.reverse(); a.reverse(); b.reverse(); return t; } //@运算符重载实现 BigInteger \u0026BigInteger::operator=(const BigInteger \u0026a) { if (length != 0)//如果不是初始化调用的 = ，则肯定需要先把原来的内存delete掉 delete[]nums; capacity = a.capacity; length = a.length; f = a.f; nums = new char[capacity]; std::copy(a.nums, a.nums + length, nums); return *this; } BigInteger BigInteger::operator+(BigInteger \u0026a) { BigInteger res; bool flag; if (a.f \u0026\u0026 f) { //同为负数情况，直接相加，再改符号 res = add(*this, a); flag = true; } else if (a.f \u0026\u0026 !f) {//左正右负 if (compare(a, *this)) { //看负数对应的nums是否比正数大 flag = true; res = minus(a, *this); } else { flag = false; res = minus(*this, a); } } else if (!a.f \u0026\u0026 f) { if (compare(*this, a)) { //与上一个相同 flag = true; res = minus(*this, a); } else { flag = false; res = minus(a, *this); } } else { //同时为正数就是最简单的加法 flag = false; res = add(*this, a); } res.f = flag; return res; } BigInteger BigInteger::operator-(BigInteger \u0026a) { BigInteger res; bool flag; if (a.f \u0026\u0026 f) { //同为负数情况--左边-右边==(不看符号)右边-(不看符号)左边 if (compare(a, *this)) { flag = false; res = minus(a, *this); } else { if (isEqual(*this, a)) flag = false; else flag = true; res = minus(*this, a); } } else if (a.f \u0026\u0026 !f) { //左边为正，右边为负--左边-右边==左边+右边 flag = false; res = add(a, *this); } else if (!a.f \u0026\u0026 f) { //右边为正，左边为负--左边-右边==两边为负的加法 flag = true; res = add(a, *this); } else { //同时为正数--左边-右边==左边-右边(分类讨论正负 if (compare(a, *this)) { //右边\u003e左边,符号为负 res = minus(a, *this); flag = true; } else { //右边\u003c左边，符号为正 res = minus(*this, a); flag = false; } } res.f = flag; return res; } bool BigInteger::operator\u003c(const BigInteger \u0026a) const { if (f \u0026\u0026 !a.f) { //其中一个为负数，则那个是更小的 return true; } else if (!f \u0026\u0026 a.f) return false; if (f) { //两者都为负数的情况，左边的值要更大则为true return compare(*this, a); }//两者均为正数，则值更小的在左边为true return compare(a, *this); } //@基本成员函数 void BigInteger::reverse() { int l = 0, r = length - 1; while (l \u003c r) { std::swap(nums[l], nums[r]); l++","date":"2022-01-20","objectID":"/posts/%E5%A4%A7%E6%95%B4%E6%95%B0%E5%8A%A0%E5%87%8F/:3:2","tags":["C++类的封装"],"title":"大数加减类的实现(C++实现)✨","uri":"/posts/%E5%A4%A7%E6%95%B4%E6%95%B0%E5%8A%A0%E5%87%8F/"},{"categories":["C++实战"],"content":"功能测试 ","date":"2022-01-20","objectID":"/posts/%E5%A4%A7%E6%95%B4%E6%95%B0%E5%8A%A0%E5%87%8F/:4:0","tags":["C++类的封装"],"title":"大数加减类的实现(C++实现)✨","uri":"/posts/%E5%A4%A7%E6%95%B4%E6%95%B0%E5%8A%A0%E5%87%8F/"},{"categories":["C++实战"],"content":"一、基本的加减测试 运行的测试代码： 打印输出 python输出 总结 与python输出无异，故通过测试。但碍于测试数据太过少，不是很有说服力，还有后面的解题测试。 ","date":"2022-01-20","objectID":"/posts/%E5%A4%A7%E6%95%B4%E6%95%B0%E5%8A%A0%E5%87%8F/:4:1","tags":["C++类的封装"],"title":"大数加减类的实现(C++实现)✨","uri":"/posts/%E5%A4%A7%E6%95%B4%E6%95%B0%E5%8A%A0%E5%87%8F/"},{"categories":["C++实战"],"content":"二、存储个人输入的数据+排序测试 测试代码(方便测试只输入了10个数据)： 排序输出： ","date":"2022-01-20","objectID":"/posts/%E5%A4%A7%E6%95%B4%E6%95%B0%E5%8A%A0%E5%87%8F/:4:2","tags":["C++类的封装"],"title":"大数加减类的实现(C++实现)✨","uri":"/posts/%E5%A4%A7%E6%95%B4%E6%95%B0%E5%8A%A0%E5%87%8F/"},{"categories":["C++实战"],"content":"三、解题测试 正好最近刷的PAT甲级就涉及到大数的加减hhh！ 题目描述 OJ平台 解题代码 #include \"bits/stdc++.h\" class BigInteger { bool f; char *nums; int length; int capacity; public://构造函数 BigInteger() : length(0), capacity(1), f(false) { //缺省构造函数 nums = new char[capacity]; } BigInteger(const char *n) : length(strlen(n)), f(false) { //用于初始值的构造函数 int start = 0; if (n[0] == '-') { f = true; start++; } while (start \u003c length \u0026\u0026 n[start] == '0')start++; capacity = length * 10; nums = new char[capacity]; std::copy(n + start, n + length, nums); length = length - start; } BigInteger(const BigInteger \u0026a) { //拷贝构造函数 capacity = a.capacity; length = a.length; f = a.f; nums = new char[capacity]; std::copy(a.nums, a.nums + length, nums); } BigInteger(BigInteger \u0026\u0026a) : length(0) { //移动构造函数 *this = a; } ~BigInteger() { //析构函数 delete[] nums; } public://静态成员函数 static void Swap(BigInteger \u0026a, BigInteger \u0026b) { std::swap(a.length, b.length); std::swap(a.capacity, b.capacity); std::swap(a.f, b.f); std::swap(a.nums, b.nums); } static bool compare(const BigInteger \u0026a, const BigInteger \u0026b) { //比较纯nums大小(不看符号 int n1 = a.length; int n2 = b.length; if (n1 != n2)return n1 \u003e n2; //返回a和b哪个大，true则位a大 int i = 0; while (i \u003c n1 \u0026\u0026 a.nums[i] == b.nums[i])i++; //a b一样长的情况下，比较两个的值 if (i == n1) return false; return a.nums[i] \u003e b.nums[i]; } bool isEqual(BigInteger \u0026a, BigInteger \u0026b) { if (a.f != b.f || (a.length != b.length))return false; int i = 0; while (i \u003c a.length \u0026\u0026 a.nums[i] == b.nums[i])i++; return i == a.length \u0026\u0026 a.f == b.f; } static BigInteger add(BigInteger \u0026a, BigInteger \u0026b) { //不看符号的加法 a.reverse();//尾端对齐 b.reverse(); BigInteger t; int up = 0; int len = a.length \u003e b.length ? a.length : b.length; for (int i = 0; i \u003c len; i++) { int ta = i \u003c a.length ? a[i] - '0' : 0; int tb = i \u003c b.length ? b[i] - '0' : 0; int base = ta + tb + up; t.push_back(base % 10 + '0'); up = base / 10; } if (up) t.push_back(up + '0'); t.reverse();//返回原位 a.reverse(); b.reverse(); return t; } static BigInteger minus(BigInteger \u0026a, BigInteger \u0026b) { //不看符号的减法,默认了a的长度或者大小是比b要大的(所以外界不要乱调用 a.reverse(); b.reverse(); BigInteger t; int len = a.length \u003e b.length ? a.length : b.length; for (int i = 0; i \u003c len; i++) { int ta = i \u003c a.length ? a[i] - '0' : 0; int tb = i \u003c b.length ? b[i] - '0' : 0; int base = ta - tb; if (base \u003c 0) { base += 10; a[i + 1]--; } t.push_back(base + '0'); } t.reverse(); a.reverse(); b.reverse(); return t; } public://成员函数和重载运算符 char \u0026operator[](int i) { return nums[i]; } BigInteger \u0026operator=(BigInteger \u0026\u0026a) { //Swap\u0026Copy方式实现右值赋值重载 Swap(*this, a); return *this; } BigInteger \u0026operator=(const BigInteger \u0026a) {//深拷贝 if (length != 0)//如果不是初始化调用的 = ，则肯定需要先把原来的内存delete掉 delete[]nums; capacity = a.capacity; length = a.length; f = a.f; nums = new char[capacity]; std::copy(a.nums, a.nums + length, nums); return *this; } int getCap() { return capacity; } int getLength() { return length; } bool isNegative() { return f; } bool isEmpty() { return length == 0; } void reverse() { int l = 0, r = length - 1; while (l \u003c r) { std::swap(nums[l], nums[r]); l++; r--; } } void push_back(char x) { if (length \u003e= capacity) { capacity *= 2; char *t = nums; nums = new char[capacity]; std::copy(t, t + length, nums); delete[]t; } nums[length++] = x; } bool operator\u003c(const BigInteger \u0026a) const { if (f \u0026\u0026 !a.f) { //其中一个为负数，则那个是更小的 return true; } else if (!f \u0026\u0026 a.f) return false; if (f) { //两者都为负数的情况，左边的值要更大则为true return compare(*this, a); }//两者均为正数，则值更小的在左边为true return compare(a, *this); } BigInteger operator+(BigInteger \u0026a) { BigInteger res; bool flag; if (a.f \u0026\u0026 f) { //同为负数情况，直接相加，再改符号 res = add(*this, a); flag = true; } else if (a.f \u0026\u0026 !f) {//左正右负 if (compare(a, *this)) { //看负数对应的nums是否比正数大 flag = true; res = minus(a, *this); } else { flag = false; res = minus(*this, a); } } else if (!a.f \u0026\u0026 f) { if (compare(*this, a)) { //与上一个相同 flag = true; res = minus(*this, a); } else { flag = false; res = minus(a, *this); } } else { //同时为正数就是最简单的加法 flag = false; res = add(*this, a); } res.f = flag; return res; } BigInteger operator-(BigInteger \u0026a","date":"2022-01-20","objectID":"/posts/%E5%A4%A7%E6%95%B4%E6%95%B0%E5%8A%A0%E5%87%8F/:4:3","tags":["C++类的封装"],"title":"大数加减类的实现(C++实现)✨","uri":"/posts/%E5%A4%A7%E6%95%B4%E6%95%B0%E5%8A%A0%E5%87%8F/"},{"categories":["C++实战"],"content":"总结 很多人，可能觉得做项目一定得是那种高大上，又或者是那种贪吃蛇小游戏、扫雷小游戏类型，实际上只要你有兴趣，任何一个东西都能成为你的练手项目，并且收获收获也许比你跟风去弄几个小游戏更大。 做这个小项目，我的收获是，对C++的语法更加的了解了，关于移动构造器、拷贝构造器、赋值重载这块弄得更清楚了，最大的收获在于强化了一个类的设计思路，这个是最重要的。 多写一些类的实现，不仅有利于对算法和语言语法的理解，更大的收获在于对各个功能的设计思路，作为程序员，我们最需要的就是这样的逻辑思维，从接到需求开始，我们应该能迅速的抽象出各种实现方案，然后进行不断的优化，得出属于自己的代码！ ","date":"2022-01-20","objectID":"/posts/%E5%A4%A7%E6%95%B4%E6%95%B0%E5%8A%A0%E5%87%8F/:5:0","tags":["C++类的封装"],"title":"大数加减类的实现(C++实现)✨","uri":"/posts/%E5%A4%A7%E6%95%B4%E6%95%B0%E5%8A%A0%E5%87%8F/"},{"categories":["C++实战"],"content":"矩阵快速幂的C++封装","date":"2022-01-20","objectID":"/posts/%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82%E7%9A%84c++%E5%B0%81%E8%A3%85/","tags":["矩阵快速幂"],"title":"矩阵快速幂的C++封装","uri":"/posts/%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82%E7%9A%84c++%E5%B0%81%E8%A3%85/"},{"categories":["C++实战"],"content":"实现源码在线查看 如果对于类的设计已经非常清楚，只是进来想看看我的这个泛型模板源代码，那么直接点到下面这个链接进行查看： 源码链接 ","date":"2022-01-20","objectID":"/posts/%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82%E7%9A%84c++%E5%B0%81%E8%A3%85/:0:0","tags":["矩阵快速幂"],"title":"矩阵快速幂的C++封装","uri":"/posts/%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82%E7%9A%84c++%E5%B0%81%E8%A3%85/"},{"categories":["C++实战"],"content":"什么是矩阵快速幂？ 关于快速幂，就是利用二进制进行求解某个数的幂的快速方法。 后面会对快速幂的原理进行简单讲解，如果还是不懂，请自行百度。 相信有很多小伙伴是初入大学的世界，可能还没学过线性代数（比如我），于是乎不知道矩阵是什么，我推荐一个网站去看看矩阵的乘法是怎么运算的，下面是网站链接：（话说how to这个网站还真是牛批，什么东西都有教程，而且质量还贼高！😂） 矩阵乘法的计算方式 那么如何用代码表示矩阵以及他的乘法呢？ 其实很简单，就是三层循环进行控制即可。 如：我这里是C++的重载运算符 Matrix 是我定义的一个类。 Matrix\u0026 operator*(Matrix\u0026 b){ assert(b.date!=NULL \u0026\u0026 date!=NULL \u0026\u0026 m==b.n); ll tmp[n][b.m]; for(int i=0;i\u003cn;i++){ for(int j=0;j\u003cb.m;j++){ ll sum = 0; for(int k=0;k\u003cm;k++){ sum = (sum + date[i][k]*b.date[k][j])%MOD; } tmp[i][j] = sum; } } this-\u003em = b.m; for(int i=0;i\u003cn;i++){ for (int j = 0; j \u003c m; ++j) { date[i][j] = tmp[i][j]; } } return *this; } ","date":"2022-01-20","objectID":"/posts/%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82%E7%9A%84c++%E5%B0%81%E8%A3%85/:1:0","tags":["矩阵快速幂"],"title":"矩阵快速幂的C++封装","uri":"/posts/%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82%E7%9A%84c++%E5%B0%81%E8%A3%85/"},{"categories":["C++实战"],"content":"怎么进行矩阵快速幂的运算？ 关于如何矩阵快速幂，我们先了解一下简单的快速幂。 说是快速幂就是通过位运算实现快速的同数累乘。 简述一下快速幂的原理： 原理就是，如果要求x的3次幂，那么可以转化为求 x*x 的 2 次幂，而求一个数的 2^n 幂是很简单的，比如进行一次 x *= x 便得到 x 的二次方。而再进行一次 x *= x 就得到了 4 次方，继续便可得到 8/16... 总之是 log2N 的时间。 代码如下： int QuickPow(int x,int n){ int c = n; int res = 1; while(c!=0){ if(c\u00261!=0){ res *= x; } c \u003e\u003e= 1; x *= x; } return res; } 那么矩阵的快速幂如何进行？ 把上述的 int 类型换成自己定义的矩阵就是矩阵的快速幂了。 我直接贴上C++实现的重载运算符后的类的快速幂写法： 这里的quickPow表示的是一个类的成员函数，所以可以直接用到这个矩阵里的数据进行运算。this表示指向这个对象的指针。init() 成员函数表示初始化为单位矩阵。 void quickPow(ll c){ if(c==1||c\u003c0)return; if(c==0){ init(); return; } Matrix tmp(*this); init(); while (c){ if(c\u00261){ *this = *this * tmp; } c \u003e\u003e= 1; tmp = tmp*tmp; } } ","date":"2022-01-20","objectID":"/posts/%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82%E7%9A%84c++%E5%B0%81%E8%A3%85/:1:1","tags":["矩阵快速幂"],"title":"矩阵快速幂的C++封装","uri":"/posts/%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82%E7%9A%84c++%E5%B0%81%E8%A3%85/"},{"categories":["C++实战"],"content":"为什么突然想写这个模板？ 主要是因为最近做了几道快速幂的题目，被坑的很惨，然后就突然想设计一个模板了，主要是 my_tiny_stl 这个仓库也好久没更新了😂 ","date":"2022-01-20","objectID":"/posts/%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82%E7%9A%84c++%E5%B0%81%E8%A3%85/:2:0","tags":["矩阵快速幂"],"title":"矩阵快速幂的C++封装","uri":"/posts/%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82%E7%9A%84c++%E5%B0%81%E8%A3%85/"},{"categories":["C++实战"],"content":"题目 OJ网站 ","date":"2022-01-20","objectID":"/posts/%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82%E7%9A%84c++%E5%B0%81%E8%A3%85/:2:1","tags":["矩阵快速幂"],"title":"矩阵快速幂的C++封装","uri":"/posts/%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82%E7%9A%84c++%E5%B0%81%E8%A3%85/"},{"categories":["C++实战"],"content":"我是如何被坑的 首先拿到这道题，我便马上开始简单的O(n)递推法实现，然后提交，然后。。超时。。 定眼一看，数据量原来这么大！ 后面一想，肯定是矩阵快速幂了，先想出以下矩阵的递推式子： 进而题目便可得到求解。 然后我就利用 C++ 的类简单的封装了一个矩阵类，里面重载了乘法和 quickpow 方法，然后比较悠闲的准备提交，还没提交前就遇到C++的语法陷阱、、 语法陷阱（建议非C++党绕道） 由于类用的都是堆内存，所以我写了析构函数，我遇到的问题出在重载乘法时我返回的是左值，而且我也没有对 ‘=’ 进行重载，所以 ‘=’ 就是直接的成员变量拷贝，这导致一个结果就是两个对象的 date 指向同一片内存空间，而之前的那片内存空间泄露了，且最后这两个对象肯定都会调用析构函数，这又导致了析构函数调用了两次！ 如何解决这个问题？如果是 C++98 ，那么这个问题很大，基本上就是两种方法解决： 逃避问题，乘法的左操作数必须是当前赋值对象，这样就避免了最后赋值语句将原本对象内的指针直接改变。 解决问题，解决这类问题无论是 C++11 还是 C++98 最直接的方式就是重载 ‘=’ 号，重载 '=' 号的实现根据具体的情况进行，而具体实现赋值的重载，我们需要考虑两件事：第一，需尽可能的减少内存的申请和使用（具体而言就是判断两个对象的指针所指向的是否为同一片空间，即便不是同一片空间，为了增加空间利用率还可以判断两个空间是否大小一致，然后进行拷贝即可）。第二，如果是临时对象则需要把它的指针置空（防止编译器未优化临时变量的析构函数，从而调用了析构函数多次析构同一内存）。 由于 C++11 开始有了右值引用和它配套的移动赋值构造器，所以可以把临时变量直接调用移动构造器变成具名对象，然后进行操作，一般就是把它的指针所有权进行转移，然后把它的指针置空防止析构错误，在我的理解下，右值引用的出现就是为了捕捉到匿名对象然后给程序员进行适当的性能优化操作，没有右值引用前，匿名对象的内存根本就没法去使用，只能用来简单的赋值拷贝操作后才能使用，这样就很消耗内存了，右值引用出现后，我们可以通过右值引用对匿名对象进行捕捉，然后操作它的底层内存。还有一个很大的内存相关的更新就是有了一个 nullptr 关键字，这个关键字使得空指针不再会有歧义，所以 delete nullptr 是安全的。所以防止多次 delete 同一片空间产生错误可以将它赋值为 nullptr 即可。 那么基于 C++11 这个问题该如何解决呢？解决方法和C++98没差，就是能够更加得心应手的进行内存的管理了，如果等号右边是一个右值，那么它肯定是一个临时对象，所以我们可以在 ‘=’ 号的重载中直接了当的用它的内存，并把它的指针置空。如果没有右值类型进行捕获，编译器默认也是会对临时对象进行优化的，也能防止产生多个对象的赋值拷贝，但只能在对象初始化的时候进行优化！而在其他时候则还是会调用析构函数，这个时候如果还是用编译器默认产生的 ‘=’ 重载，则会发生被析构的空间的指针被赋值的情况，而我们的右值引用版本的赋值重载便是针对此现象的。这样便于内存管理，将右值和左值进行分开处理。右值是临时变量只需要用一会儿，所以可以直接把它的内存拿过来继续用，也不会对程序逻辑造成影响，而左值则不一样，它还需要存活很长一段时间，所以我们需要另创空间进行拷贝。 特别提醒：如果是做算法题，则完全不用去考虑内存的管理，析构函数也不要去写，毕竟只需要单次调用使用，对象最多也就存在一会儿。 做题陷阱 在必要的时候千万不要舍不得开long long！！！！ 这道题的数据量无论是幂的次方还是整个记录过程的数据都要开long long！！！ 我被这个陷阱坑了无数回了，这一次也不另外😅 开始写完这种之后过了前5个，然后后面5个报错，我还以为我设计的这个类有问题，还特意去写了好几个普通C语言版本😂最后发现原来的没开long long。以下为更改long long后的代码通过版本，我用宏定义写了几个版本。。。 这个Matrix类的设计还是很多地方没有考虑到位，比如上一个陷阱的问题只是通过方法一得到解决，并未去重载赋值操作符。。。所以后面痛定思痛，设计一个较为可用的Matrix类！ 效率时快时慢的，这主要取决于编译器是否进行优化。 // // Created by Alone on 2021/11/19. // #include \u003cbits/stdc++.h\u003eusing namespace std; //#define ELSE_MAIN #define MY_MAIN #define MAT #ifdef MAT typedef long long ll; class Matrix{ ll** date; int m; int n; public: static const int MOD; public: Matrix(ll** rec,int n,int m):date(rec),n(n),m(m){}//C风格的初始化 Matrix():date(NULL),m(0),n(0){} //缺省 Matrix(Matrix\u0026 b):n(b.n),m(b.m){//拷贝构造 assert(b.date!=NULL \u0026\u0026 b.n\u003e0 \u0026\u0026 b.m\u003e0); date = new ll*[n]; copy(b.date,b.date+n,date); for(int i=0;i\u003cn;i++){ date[i] = new ll[m]; copy(b.date[i],b.date[i]+m,date[i]); } } ~Matrix(){//析构函数实现 assert(date!=NULL \u0026\u0026 n\u003e0 \u0026\u0026 m\u003e0); for (int i = n-1; i \u003e=0 ; --i) { delete [] date[i]; } delete[] date; } Matrix\u0026 operator*(Matrix\u0026 b){ assert(b.date!=NULL \u0026\u0026 date!=NULL \u0026\u0026 m==b.n); ll tmp[n][b.m]; for(int i=0;i\u003cn;i++){ for(int j=0;j\u003cb.m;j++){ ll sum = 0; for(int k=0;k\u003cm;k++){ sum = (sum + date[i][k]*b.date[k][j])%MOD; } tmp[i][j] = sum; } } this-\u003em = b.m; for(int i=0;i\u003cn;i++){ for (int j = 0; j \u003c m; ++j) { date[i][j] = tmp[i][j]; } } return *this; } void init(){//重新初始化为单位矩阵 assert(date!=NULL \u0026\u0026 n\u003e0 \u0026\u0026 m\u003e0); for (int i = 0; i \u003c n; ++i) { for (int j = 0; j \u003c m; ++j) { if(i==j)date[i][j] = 1; else date[i][j] = 0; } } } void quickPow(ll c){ if(c==1||c\u003c0)return; if(c==0){ init(); return; } Matrix tmp(*this); init(); while (c){ if(c\u00261){ *this = *this * tmp; } c \u003e\u003e= 1; tmp = tmp*tmp; } } void print(){ for(int i=0;i\u003cn;i++){ for(int j=0;j\u003cm;j++){ cout\u003c\u003cdate[i][j]\u003c\u003c' '; } cout\u003c\u003cendl; } } int get(int x,int y){ assert(date!=NULL \u0026\u0026 x\u003cn \u0026\u0026 y\u003cm); return date[x][y]; } }; const int Matrix::MOD = 1e9+7; #endif #ifdef MY_MAIN int main(){ ll c; cin\u003e\u003ec; ll** matrix = new ll*[2]; matrix[0] = new ll[2]{1,1}; matrix[1] = new ll[2]{1,0}; Matrix mat(matrix,2,2); mat.quickPow(c-1); //mat.print(); ll** res = new ll*[2]; res[0] = new ll[1]; res[1] = new ll[1]; res[0][0] = res[1][0] = 1; Matrix fib(res,2,1); //这里有个内存分配错误，mat*fib返回的是左值，而=没有重载默认直接赋值成员变量。 //直接导致了fib失去了之前的变量所有权，和mat共同有一个内存空间，这样导致同一片空间被free两次 //通过重载 = 号解决，防止直接的内存没有被释放就重新绑定同一片内存 Matrix ret(mat*fib); cout\u003c\u003cret.get(0,0); return 0; } #endif #ifdef TEST_MAIN typedef long long ll ; const int MOD = 1e9+7; ll a[2][2]{{1,1},{1,0}};ll b[2]{1,1}; void selfMut(){ ll tmp[2][2]; for(int i=0;i\u003c2;i","date":"2022-01-20","objectID":"/posts/%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82%E7%9A%84c++%E5%B0%81%E8%A3%85/:2:2","tags":["矩阵快速幂"],"title":"矩阵快速幂的C++封装","uri":"/posts/%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82%E7%9A%84c++%E5%B0%81%E8%A3%85/"},{"categories":["C++实战"],"content":"教你设计Matrix类 ","date":"2022-01-20","objectID":"/posts/%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82%E7%9A%84c++%E5%B0%81%E8%A3%85/:3:0","tags":["矩阵快速幂"],"title":"矩阵快速幂的C++封装","uri":"/posts/%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82%E7%9A%84c++%E5%B0%81%E8%A3%85/"},{"categories":["C++实战"],"content":"如何设计一个类？ 结构： 内部数据抽象：对象的运算数据存储 用二级指针 date 进行矩阵的二维空间的内存管理，以及n和m表示矩阵的行高和列宽。 行为抽象：对对象的行为描述 构造函数（缺省、自定义、拷贝、移动） 和 析构函数（调用destory成员函数）。 setter 和 getter。提供函数接口去设置和得到数据。 功能函数：比如重载的乘法运算符和快速幂函数这些都算功能函数。 对象的属性抽象： 数据和行为是否对外，对外封装数据的意义在于防止对对象行为描述的破坏，而对外开放的某个行为通常需要内部多个函数进行重复调用来实现。这个时候需要用到 public 和 private 关键字进行修饰。 数据和行为是否可继承，对于某些行为（函数），我们不想被外部调用，但是对子类又很有用，这个时候我们可以采取 protect 关键字进行修饰。 数据和行为是否能重复利用，为了节省不必要的内存开销，可以设计不需要产生具体对象的通用型函数，可以使用 static 关键字进行修饰，这样可以避免我想使用某个函数前还得去申请一片毫不相关的内存空间，而对于某个对象的数据也可以采用 static 进行修饰，这样一来，这个数据在对象的创建过程中就不需要再进行申请和赋值了。 那么接下来就来确定行为（函数）的属性了，数据肯定是不对外开放的（private），否则面向对象将毫无意义。 构造函数 和 析构函数，这两个是对象的创建和销毁的关键，所以如果不是希望对象不被创建或者是不被销毁，都应该使用 public 修饰。 setter 和 getter。很明显是对外开放的接口函数，所以肯定也是 public 修饰。 功能函数：矩阵快速幂的函数，很明显我们希望设置一个对外通用的情况，那么这个时候就应该不需要创建对象便可进行调用，所以最好用 static 进行修饰（这个一般为外部通用接口，内部还需实现一个方便类调用的版本，这也很简单，直接传参调用该函数即可），重载的乘法肯定也是对外的所以需要 public 修饰，destroy 函数用于处理内存的回收，很明显这是一个内部通用的函数，但是外界完全是不需要它的！所以把它设置为 private 属性即可。 以上便是对整个类的设计思路，当然真正动手设计的时候，还需要具体到函数的参数和返回值类型，因为这牵扯到 C++ 的具体语法了，比如我应该在重载乘法的时候返回一个什么样的类型？最好是返回一个右值！而重载赋值运算符则最好是返回一个左值。一般需要考虑返回值类型的取舍时，最难的就是如果返回一个对象，我该返回左值还是右值。 写了这么久C++，我感觉用C++写的Java屏蔽重载运算符的特性主要就是重载运算符时需要考虑的过程太多了，C++菜鸡（我就是这个菜鸟😂）写出及其低效且不安全的代码，而只有老鸟才能写出优雅高效的代码。 ","date":"2022-01-20","objectID":"/posts/%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82%E7%9A%84c++%E5%B0%81%E8%A3%85/:3:1","tags":["矩阵快速幂"],"title":"矩阵快速幂的C++封装","uri":"/posts/%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82%E7%9A%84c++%E5%B0%81%E8%A3%85/"},{"categories":["C++实战"],"content":"类的具体抽象结构（代码的具体规划图） 按照属性对类的各个部分进行分类的，毕竟属性也基本就代表了这个方法的使用场景了。 最后可以利用基本的断言或者异常，让代码变得更为健壮，使得更容易定位错误发生的位置和原因。 ","date":"2022-01-20","objectID":"/posts/%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82%E7%9A%84c++%E5%B0%81%E8%A3%85/:3:2","tags":["矩阵快速幂"],"title":"矩阵快速幂的C++封装","uri":"/posts/%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82%E7%9A%84c++%E5%B0%81%E8%A3%85/"},{"categories":["C++实战"],"content":"实现矩阵泛型模板类 源代码实现 我先是画出规划图进行实现，然后在实现的过程中，发现可以新增一些特性，比如重载下标运算符，比如用print函数打印出来方便验证。 具体实现过程，为了方便简单的定位可能发生的错误，使用了大量的assert进行断言检查。如果想代码的健壮性更强，可以使用抛出异常的方式。 源代码对应的GitHub仓库地址：仓库链接，还有更多模板的实现，包括少量STL 更好的源码阅读体验：源码在线阅读 直接阅读下面的代码有点不太好查看，推荐去上面的GitHub1s里面查看源码。 // // Created by L_B__ on 2021/11/20. // #ifndef LQTEST_MATRIX_H #define LQTEST_MATRIX_H #include \u003ccassert\u003e#include \u003calgorithm\u003e#include \u003ciostream\u003e #define _MOD template\u003ctypename T\u003e class Matrix { /*Type define*/ typedef T data_t; typedef int ssize_t; /*data source*/ data_t **data; ssize_t n; ssize_t m; public: static const data_t MOD; public: /*default construct*/ Matrix() : m(0), n(0), data(nullptr) {} /*custom construct*/ Matrix(data_t **mat, ssize_t n, ssize_t m) : data(mat), n(n), m(m) {}//外部申请内存传入内部 Matrix(ssize_t n, ssize_t m) : data(nullptr), n(n), m(m) {//外部指定矩阵的行和列即可，内存初始化在内部进行 assert(n \u003e 0 \u0026\u0026 m \u003e 0); data = new data_t *[n]; for (int i = 0; i \u003c n; i++) { data[i] = new data_t[m]; } init(data, n, m); } /*copy construct*/ Matrix(Matrix \u0026src) : data(nullptr), n(src.n), m(src.m)//也可用const \u0026引用类型，但这样很多右值的情况都不会调用移动构造了 { assert(n \u003e 0 \u0026\u0026 m \u003e 0); data = new data_t *[n]; for (int i = 0; i \u003c n; ++i) { data[i] = new data_t[m]; std::copy(src.data[i], src.data[i] + m, data[i]); } } /*move construct*/ Matrix(Matrix\u003cdata_t\u003e \u0026\u0026src) : n(src.n), m(src.m), data(nullptr) { assert(src.data != nullptr \u0026\u0026 n \u003e 0 \u0026\u0026 m \u003e 0); data = src.data; src.data = nullptr; src.n = src.m = 0; } /*destruct*/ ~Matrix() { destroy(); } /*overload*/ //加上MOD的特殊版本 #ifdef _MOD Matrix operator*(const Matrix\u003cdata_t\u003e \u0026src)//建议返回右值，返回左值的后续坑比较多，参数const \u0026既可以接受左值也可接受右值 { assert(data != nullptr \u0026\u0026 src.data != nullptr \u0026\u0026 m == src.n \u0026\u0026 m \u003e 0 \u0026\u0026 n \u003e 0 \u0026\u0026 src.m \u003e 0);//进行矩阵乘法的必要条件 data_t **tmp = new data_t *[n]; //为tmp申请动态内存，因为是传出参数 for (int i = 0; i \u003c n; ++i) { tmp[i] = new data_t[m]; } for (int i = 0; i \u003c n; ++i)//开始更新tmp { for (int j = 0; j \u003c src.m; ++j) { data_t sum = 0; for (int k = 0; k \u003c m; ++k) { sum = (sum + data[i][k] * src.data[k][j]) % MOD; } tmp[i][j] = sum; } } //直接构造匿名对象返回 return Matrix(tmp, n, src.m);; } Matrix \u0026operator*=(const Matrix\u003cdata_t\u003e \u0026src)//*= 想一想我们平时的使用，就是返回一个左值 { assert(data != nullptr \u0026\u0026 src.data != nullptr \u0026\u0026 m == src.n \u0026\u0026 m \u003e 0 \u0026\u0026 n \u003e 0 \u0026\u0026 src.m \u003e 0);//进行矩阵乘法的必要条件 data_t tmp[n][src.m];//静态内存就行，毕竟只是临时存数据的 for (int i = 0; i \u003c n; ++i)//开始更新tmp { for (int j = 0; j \u003c src.m; ++j) { data_t sum = 0; for (int k = 0; k \u003c m; ++k) { sum = (sum + data[i][k] * src.data[k][j]) % MOD; } tmp[i][j] = sum; } } //由于此时的date内存可能不够容下tmp数据，所以可能需要重新进行内存申请 //注意重新申请列内存的时候，需要把之前的内存释放 if (m != src.m) { for (int i = 0; i \u003c n; ++i) { delete[]data[i]; data[i] = nullptr; data[i] = new data_t[src.m]; } } for (int i = 0; i \u003c n; ++i) { assert(data[i] != nullptr); std::copy(tmp[i], tmp[i] + src.m, data[i]); } return *this; } #endif #ifndef _MOD Matrix operator*(const Matrix\u003cdata_t\u003e\u0026src)//建议返回右值，返回左值的后续坑比较多，参数const \u0026既可以接受左值也可接受右值 { assert(data!= nullptr\u0026\u0026src.data!= nullptr\u0026\u0026m==src.n\u0026\u0026m\u003e0\u0026\u0026n\u003e0\u0026\u0026src.m\u003e0);//进行矩阵乘法的必要条件 data_t** tmp = new data_t *[n]; //为tmp申请动态内存，因为是传出参数 for (int i = 0; i \u003c n; ++i) { tmp[i] = new data_t [m]; } for(int i=0;i\u003cn;++i)//开始更新tmp { for (int j = 0; j \u003c src.m; ++j) { data_t sum = 0; for (int k = 0; k \u003c m; ++k) { sum = sum + data[i][k]*src.data[k][j]; } tmp[i][j] = sum; } } //直接构造匿名对象返回 return Matrix (tmp,n,src.m); } /*与乘法的唯一区别在于乘法是构造一个新的对象，而*=返回的是this*/ Matrix \u0026operator*=(const Matrix\u003cdata_t\u003e \u0026src)//*= 想一想我们平时的使用，就是返回一个左值 { assert(data!= nullptr\u0026\u0026src.data!= nullptr\u0026\u0026m==src.n\u0026\u0026m\u003e0\u0026\u0026n\u003e0\u0026\u0026src.m\u003e0);//进行矩阵乘法的必要条件 data_t tmp[n][src.m];//静态内存就行，毕竟只是临时存数据的 for(int i=0;i\u003cn;++i)//开始更新tmp { for (int j = 0; j \u003c src.m; ++j) { data_t sum = 0; for (int k = 0; k \u003c m; ++k) { sum = sum + data[i][k]*src.data[k][j]; } tmp[i][j] = sum; } } //由于此时的date内存可能不够容下tmp数据，所以可能需要重新进行内存申请 //注意重新申请列内存的时候，需要把之前的内存释放 if(m!=src.m){ for (int i = 0; i \u003c n; ++i) { delete []data[i]; data[i] = nullptr; data[i] = new data_t [src.m]; } } for (int i = 0; i \u003c n; ++i) { assert(data[i] != nullptr); std::copy(tmp[i],tmp[i]+src.m,data[i]); } return *this; } #endif //赋值号的重载","date":"2022-01-20","objectID":"/posts/%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82%E7%9A%84c++%E5%B0%81%E8%A3%85/:3:3","tags":["矩阵快速幂"],"title":"矩阵快速幂的C++封装","uri":"/posts/%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82%E7%9A%84c++%E5%B0%81%E8%A3%85/"},{"categories":["C++实战"],"content":"总结 由于用的是 C++11 的语法进行实现的模板类，所以低于这个版本的编译器都无法正常使用。我查阅了相关资料，实际上蓝桥杯比赛的时候可以用 C++11，而acm更是不用说，早就能用C++11了。 简单复盘： 实现一个这样的类，主要能学到以下几点： 类的设计技巧。 对C++的左右值有了更深入的理解。 各种构造器的设计和实现已经达到炉火纯青的地步了。 ","date":"2022-01-20","objectID":"/posts/%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82%E7%9A%84c++%E5%B0%81%E8%A3%85/:4:0","tags":["矩阵快速幂"],"title":"矩阵快速幂的C++封装","uri":"/posts/%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82%E7%9A%84c++%E5%B0%81%E8%A3%85/"}]